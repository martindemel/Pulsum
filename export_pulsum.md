# Xcode iOS App Snapshot
Generated: 2026-01-25T20:34:41.371932-06:00
Repo root: /Users/martin.demel/Desktop/PULSUM/Pulsum
Git: gate6-ml-correctness-personalization @ b9d6a23d3eec5342dd524587c69fa2881fae5063
Git status (git status -sb):
`````text
## gate6-ml-correctness-personalization...origin/gate6-ml-correctness-personalization
 M Packages/PulsumAgents/Sources/PulsumAgents/SentimentAgent.swift
 M Pulsum.xcodeproj/project.pbxproj
 M Pulsum.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved
?? appdesign.md
?? "export 2.md"
?? export.md
`````

## Environment
### sw_vers
- Exit code: 0
`````text
ProductName:		macOS
ProductVersion:		26.2
BuildVersion:		25C56
`````

### xcode-select -p
- Exit code: 0
`````text
/Applications/Xcode.app/Contents/Developer
`````

### xcodebuild -version
- Exit code: 0
`````text
Xcode 26.1.1
Build version 17B100
`````

### swift --version
- Exit code: 0
`````text
Apple Swift version 6.2.1 (swiftlang-6.2.1.4.8 clang-1700.4.4.1)
Target: arm64-apple-macosx26.0
swift-driver version: 1.127.14.1 
`````

## Xcode Projects & Workspaces
### Pulsum.xcodeproj
- Type: project
- Schemes: Pulsum, PulsumAgents, PulsumData, PulsumML, PulsumServices, PulsumTypes, PulsumUI
- Command: `xcodebuild -list -json -project Pulsum.xcodeproj` (exit 0)
`````json
{
  "project" : {
    "configurations" : [
      "Debug",
      "Release"
    ],
    "name" : "Pulsum",
    "schemes" : [
      "Pulsum",
      "PulsumAgents",
      "PulsumData",
      "PulsumML",
      "PulsumServices",
      "PulsumTypes",
      "PulsumUI",
      "PulsumUI"
    ],
    "targets" : [
      "Pulsum",
      "PulsumTests",
      "PulsumUITests"
    ]
  }
}
`````

### Pulsum.xcodeproj/project.xcworkspace
- Type: workspace
- Schemes: Pulsum, PulsumAgents, PulsumData, PulsumML, PulsumServices, PulsumTypes, PulsumUI
- Command: `xcodebuild -list -json -workspace Pulsum.xcodeproj/project.xcworkspace` (exit 0)
`````json
{
  "workspace" : {
    "name" : "Pulsum",
    "schemes" : [
      "Pulsum",
      "PulsumAgents",
      "PulsumData",
      "PulsumML",
      "PulsumServices",
      "PulsumTypes",
      "PulsumUI",
      "PulsumUI"
    ]
  }
}
`````

## Build Settings Snapshot
### Pulsum.xcodeproj — scheme Pulsum
- Command: `xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme Pulsum`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme Pulsum

Resolve Package Graph


Resolved source packages:
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local

Build settings for action build and target Pulsum:
    ACTION = build
    AD_HOC_CODE_SIGNING_ALLOWED = NO
    AGGREGATE_TRACKED_DOMAINS = YES
    ALLOW_BUILD_REQUEST_OVERRIDES = NO
    ALLOW_TARGET_PLATFORM_SPECIALIZATION = NO
    ALTERNATE_GROUP = staff
    ALTERNATE_MODE = u+w,go-w,a+rX
    ALTERNATE_OWNER = martin.demel
    ALTERNATIVE_DISTRIBUTION_WEB = NO
    ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO
    ALWAYS_SEARCH_USER_PATHS = NO
    ALWAYS_USE_SEPARATE_HEADERMAPS = NO
    APPLICATION_EXTENSION_API_ONLY = NO
    APPLY_RULES_IN_COPY_FILES = NO
    APPLY_RULES_IN_COPY_HEADERS = NO
    APP_SHORTCUTS_ENABLE_FLEXIBLE_MATCHING = YES
    ARCHS = arm64
    ARCHS_STANDARD = arm64
    ARCHS_STANDARD_32_64_BIT = armv7 arm64
    ARCHS_STANDARD_32_BIT = armv7
    ARCHS_STANDARD_64_BIT = arm64
    ARCHS_STANDARD_INCLUDING_64_BIT = arm64
    ARCHS_UNIVERSAL_IPHONE_OS = armv7 arm64
    ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon
    ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES
    ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor
    ASSETCATALOG_FILTER_FOR_DEVICE_MODEL = MacFamily20,1
    ASSETCATALOG_FILTER_FOR_DEVICE_OS_VERSION = 26.2
    ASSETCATALOG_FILTER_FOR_THINNING_DEVICE_CONFIGURATION = MacFamily20,1
    AUTOMATICALLY_MERGE_DEPENDENCIES = NO
    AUTOMATION_APPLE_EVENTS = NO
    AVAILABLE_PLATFORMS = android appletvos appletvsimulator driverkit iphoneos iphonesimulator macosx qnx watchos watchsimulator webassembly xros xrsimulator
    BUILD_ACTIVE_RESOURCES_ONLY = YES
    BUILD_COMPONENTS = headers build
    BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    BUILD_LIBRARY_FOR_DISTRIBUTION = NO
    BUILD_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    BUILD_STYLE = 
    BUILD_VARIANTS = normal
    BUILT_PRODUCTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    BUNDLE_CONTENTS_FOLDER_PATH_deep = Contents/
    BUNDLE_EXECUTABLE_FOLDER_NAME_deep = MacOS
    BUNDLE_EXTENSIONS_FOLDER_PATH = Extensions
    BUNDLE_FORMAT = shallow
    BUNDLE_FRAMEWORKS_FOLDER_PATH = Frameworks
    BUNDLE_PLUGINS_FOLDER_PATH = PlugIns
    BUNDLE_PRIVATE_HEADERS_FOLDER_PATH = PrivateHeaders
    BUNDLE_PUBLIC_HEADERS_FOLDER_PATH = Headers
    CACHE_ROOT = /var/folders/m_/nqk8g4cs5tz8t1yj2kglt8p80000gn/C/com.apple.DeveloperTools/26.1.1-17B100/Xcode
    CCHROOT = /var/folders/m_/nqk8g4cs5tz8t1yj2kglt8p80000gn/C/com.apple.DeveloperTools/26.1.1-17B100/Xcode
    CHMOD = /bin/chmod
    CHOWN = /usr/sbin/chown
    CLANG_ANALYZER_NONNULL = YES
    CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE
    CLANG_CACHE_FINE_GRAINED_OUTPUTS = YES
    CLANG_COVERAGE_MAPPING = YES
    CLANG_CXX_LANGUAGE_STANDARD = gnu++20
    CLANG_ENABLE_EXPLICIT_MODULES = YES
    CLANG_ENABLE_MODULES = YES
    CLANG_ENABLE_OBJC_ARC = YES
    CLANG_ENABLE_OBJC_WEAK = YES
    CLANG_MODULES_BUILD_SESSION_FILE = /Users/martin.demel/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation
    CLANG_PROFILE_DATA_DIRECTORY = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/ProfileData
    CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES
    CLANG_WARN_BOOL_CONVERSION = YES
    CLANG_WARN_COMMA = YES
    CLANG_WARN_CONSTANT_CONVERSION = YES
    CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES
    CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR
    CLANG_WARN_DOCUMENTATION_COMMENTS = YES
    CLANG_WARN_EMPTY_BODY = YES
    CLANG_WARN_ENUM_CONVERSION = YES
    CLANG_WARN_INFINITE_RECURSION = YES
    CLANG_WARN_INT_CONVERSION = YES
    CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES
    CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
    CLANG_WARN_OBJC_LITERAL_CONVERSION = YES
    CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR
    CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES
    CLANG_WARN_RANGE_LOOP_ANALYSIS = YES
    CLANG_WARN_STRICT_PROTOTYPES = YES
    CLANG_WARN_SUSPICIOUS_MOVE = YES
    CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
    CLANG_WARN_UNREACHABLE_CODE = YES
    CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
    CLASS_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/JavaClasses
    CLEAN_PRECOMPS = YES
    CLONE_HEADERS = NO
    CODESIGNING_FOLDER_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/Pulsum.app
    CODE_SIGNING_ALLOWED = YES
    CODE_SIGNING_REQUIRED = YES
    CODE_SIGN_CONTEXT_CLASS = XCiPhoneOSCodeSignContext
    CODE_SIGN_ENTITLEMENTS = Pulsum/Pulsum.entitlements
    CODE_SIGN_IDENTITY = Apple Development
    CODE_SIGN_INJECT_BASE_ENTITLEMENTS = YES
    CODE_SIGN_STYLE = Automatic
    COLOR_DIAGNOSTICS = NO
    COMBINE_HIDPI_IMAGES = NO
    COMPILATION_CACHE_CAS_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/CompilationCache.noindex
    COMPILATION_CACHE_KEEP_CAS_DIRECTORY = YES
    COMPILER_INDEX_STORE_ENABLE = Default
    COMPOSITE_SDK_DIRS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/CompositeSDKs
    COMPRESS_PNG_FILES = YES
    CONFIGURATION = Debug
    CONFIGURATION_BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    CONFIGURATION_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos
    CONTENTS_FOLDER_PATH = Pulsum.app
    CONTENTS_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Contents
    CONTENTS_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    COPYING_PRESERVES_HFS_DATA = NO
    COPY_HEADERS_RUN_UNIFDEF = NO
    COPY_PHASE_STRIP = NO
    CORRESPONDING_SIMULATOR_PLATFORM_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform
    CORRESPONDING_SIMULATOR_PLATFORM_NAME = iphonesimulator
    CORRESPONDING_SIMULATOR_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator26.1.sdk
    CORRESPONDING_SIMULATOR_SDK_NAME = iphonesimulator26.1
    CP = /bin/cp
    CREATE_INFOPLIST_SECTION_IN_BINARY = NO
    CURRENT_ARCH = undefined_arch
    CURRENT_PROJECT_VERSION = 1
    CURRENT_VARIANT = normal
    DEAD_CODE_STRIPPING = YES
    DEBUGGING_SYMBOLS = YES
    DEBUG_INFORMATION_FORMAT = dwarf
    DEBUG_INFORMATION_VERSION = compiler-default
    DEFAULT_COMPILER = com.apple.compilers.llvm.clang.1_0
    DEFAULT_DEXT_INSTALL_PATH = /System/Library/DriverExtensions
    DEFAULT_KEXT_INSTALL_PATH = /System/Library/Extensions
    DEFINES_MODULE = NO
    DEPLOYMENT_LOCATION = NO
    DEPLOYMENT_POSTPROCESSING = NO
    DEPLOYMENT_TARGET_SETTING_NAME = IPHONEOS_DEPLOYMENT_TARGET
    DEPLOYMENT_TARGET_SUGGESTED_VALUES = 12.0 12.1 12.2 12.3 12.4 13.0 13.1 13.2 13.3 13.4 13.5 13.6 14.0 14.1 14.2 14.3 14.4 14.5 14.6 14.7 15.0 15.1 15.2 15.3 15.4 15.5 15.6 16.0 16.1 16.2 16.3 16.4 16.5 16.6 17.0 17.1 17.2 17.3 17.4 17.5 17.6 18.0 18.1 18.2 18.3 18.4 18.5 18.6 26.0 26.1
    DERIVED_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVED_SOURCES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVE_MACCATALYST_PRODUCT_BUNDLE_IDENTIFIER = NO
    DEVELOPER_APPLICATIONS_DIR = /Applications/Xcode.app/Contents/Developer/Applications
    DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/usr/bin
    DEVELOPER_DIR = /Applications/Xcode.app/Contents/Developer
    DEVELOPER_FRAMEWORKS_DIR = /Applications/Xcode.app/Contents/Developer/Library/Frameworks
    DEVELOPER_FRAMEWORKS_DIR_QUOTED = /Applications/Xcode.app/Contents/Developer/Library/Frameworks
    DEVELOPER_LIBRARY_DIR = /Applications/Xcode.app/Contents/Developer/Library
    DEVELOPER_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs
    DEVELOPER_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Tools
    DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/usr
    DEVELOPMENT_LANGUAGE = en
    DEVELOPMENT_TEAM = X6FJFZCXY3
    DIAGNOSE_MISSING_TARGET_DEPENDENCIES = YES
    DIFF = /usr/bin/diff
    DOCUMENTATION_FOLDER_PATH = Pulsum.app/en.lproj/Documentation
    DONT_GENERATE_INFOPLIST_FILE = NO
    DRIVERKIT_DEPLOYMENT_TARGET = 25.1
    DSTROOT = /tmp/Pulsum.dst
    DT_TOOLCHAIN_DIR = /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain
    DWARF_DSYM_FILE_NAME = Pulsum.app.dSYM
    DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT = NO
    DWARF_DSYM_FOLDER_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    DYNAMIC_LIBRARY_EXTENSION = dylib
    EAGER_COMPILATION_ALLOW_SCRIPTS = YES
    EAGER_LINKING = NO
    EFFECTIVE_PLATFORM_NAME = -iphoneos
    EMBEDDED_CONTENT_CONTAINS_SWIFT = NO
    EMBEDDED_PROFILE_NAME = embedded.mobileprovision
    EMBED_ASSET_PACKS_IN_PRODUCT_BUNDLE = NO
    ENABLE_APP_SANDBOX = NO
    ENABLE_CODE_COVERAGE = YES
    ENABLE_CPLUSPLUS_BOUNDS_SAFE_BUFFERS = NO
    ENABLE_C_BOUNDS_SAFETY = NO
    ENABLE_DEBUG_DYLIB = YES
    ENABLE_DEFAULT_HEADER_SEARCH_PATHS = YES
    ENABLE_DEFAULT_SEARCH_PATHS = YES
    ENABLE_ENHANCED_SECURITY = NO
    ENABLE_HARDENED_RUNTIME = NO
    ENABLE_HEADER_DEPENDENCIES = YES
    ENABLE_INCOMING_NETWORK_CONNECTIONS = NO
    ENABLE_ON_DEMAND_RESOURCES = YES
    ENABLE_OUTGOING_NETWORK_CONNECTIONS = NO
    ENABLE_POINTER_AUTHENTICATION = NO
    ENABLE_PREVIEWS = YES
    ENABLE_RESOURCE_ACCESS_AUDIO_INPUT = NO
    ENABLE_RESOURCE_ACCESS_BLUETOOTH = NO
    ENABLE_RESOURCE_ACCESS_CALENDARS = NO
    ENABLE_RESOURCE_ACCESS_CAMERA = NO
    ENABLE_RESOURCE_ACCESS_CONTACTS = NO
    ENABLE_RESOURCE_ACCESS_LOCATION = NO
    ENABLE_RESOURCE_ACCESS_PHOTO_LIBRARY = NO
    ENABLE_RESOURCE_ACCESS_PRINTING = NO
    ENABLE_RESOURCE_ACCESS_USB = NO
    ENABLE_SDK_IMPORTS = NO
    ENABLE_SECURITY_COMPILER_WARNINGS = NO
    ENABLE_STRICT_OBJC_MSGSEND = YES
    ENABLE_TESTABILITY = YES
    ENABLE_TESTING_SEARCH_PATHS = NO
    ENABLE_THREAD_SANITIZER = NO
    ENABLE_USER_SCRIPT_SANDBOXING = YES
    ENFORCE_VALID_ARCHS = YES
    ENTITLEMENTS_ALLOWED = YES
    ENTITLEMENTS_DESTINATION = Signature
    ENTITLEMENTS_REQUIRED = NO
    EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS = .DS_Store .svn .git .hg CVS
    EXCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES = *.nib *.lproj *.framework *.gch *.xcode* *.xcassets *.icon (*) .DS_Store CVS .svn .git .hg *.pbproj *.pbxproj
    EXECUTABLES_FOLDER_PATH = Pulsum.app/Executables
    EXECUTABLE_FOLDER_PATH = Pulsum.app
    EXECUTABLE_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/MacOS
    EXECUTABLE_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    EXECUTABLE_NAME = Pulsum
    EXECUTABLE_PATH = Pulsum.app/Pulsum
    EXTENSIONS_FOLDER_PATH = Pulsum.app/Extensions
    FILE_LIST = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects/LinkFileList
    FIXED_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/FixedFiles
    FRAMEWORKS_FOLDER_PATH = Pulsum.app/Frameworks
    FRAMEWORK_FLAG_PREFIX = -framework
    FRAMEWORK_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    FRAMEWORK_VERSION = A
    FULL_PRODUCT_NAME = Pulsum.app
    FUSE_BUILD_PHASES = YES
    FUSE_BUILD_SCRIPT_PHASES = NO
    GCC3_VERSION = 3.3
    GCC_C_LANGUAGE_STANDARD = gnu17
    GCC_DYNAMIC_NO_PIC = NO
    GCC_INLINES_ARE_PRIVATE_EXTERN = YES
    GCC_NO_COMMON_BLOCKS = YES
    GCC_OPTIMIZATION_LEVEL = 0
    GCC_PFE_FILE_C_DIALECTS = c objective-c c++ objective-c++
    GCC_PREPROCESSOR_DEFINITIONS = DEBUG=1 
    GCC_SYMBOLS_PRIVATE_EXTERN = NO
    GCC_THUMB_SUPPORT = YES
    GCC_TREAT_WARNINGS_AS_ERRORS = NO
    GCC_VERSION = com.apple.compilers.llvm.clang.1_0
    GCC_VERSION_IDENTIFIER = com_apple_compilers_llvm_clang_1_0
    GCC_WARN_64_TO_32_BIT_CONVERSION = YES
    GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR
    GCC_WARN_UNDECLARED_SELECTOR = YES
    GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE
    GCC_WARN_UNUSED_FUNCTION = YES
    GCC_WARN_UNUSED_VARIABLE = YES
    GENERATED_MODULEMAP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/GeneratedModuleMaps-iphoneos
    GENERATE_INFOPLIST_FILE = YES
    GENERATE_INTERMEDIATE_TEXT_BASED_STUBS = YES
    GENERATE_PKGINFO_FILE = YES
    GENERATE_PRELINK_OBJECT_FILE = NO
    GENERATE_PROFILING_CODE = NO
    GENERATE_TEXT_BASED_STUBS = NO
    GID = 20
    GROUP = staff
    HEADERMAP_INCLUDES_FLAT_ENTRIES_FOR_TARGET_BEING_BUILT = YES
    HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_ALL_PRODUCT_TYPES = YES
    HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_TARGETS_NOT_BEING_BUILT = YES
    HEADERMAP_INCLUDES_NONPUBLIC_NONPRIVATE_HEADERS = YES
    HEADERMAP_INCLUDES_PROJECT_HEADERS = YES
    HEADERMAP_USES_FRAMEWORK_PREFIX_ENTRIES = YES
    HEADERMAP_USES_VFS = NO
    HEADER_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/include 
    HOME = /Users/martin.demel
    HOST_ARCH = arm64
    HOST_PLATFORM = macosx
    ICONV = /usr/bin/iconv
    IMPLICIT_DEPENDENCY_DOMAIN = default
    INFOPLIST_ENABLE_CFBUNDLEICONS_MERGE = YES
    INFOPLIST_EXPAND_BUILD_SETTINGS = YES
    INFOPLIST_KEY_ITSAppUsesNonExemptEncryption = NO
    INFOPLIST_KEY_NSHealthShareUsageDescription = Pulsum reads key wellness metrics like HRV and sleep to personalize your coaching.
    INFOPLIST_KEY_NSHealthUpdateUsageDescription = Pulsum references your recent trends to surface the most helpful guidance.
    INFOPLIST_KEY_NSMicrophoneUsageDescription = Pulsum uses the microphone to capture on-device voice journals.
    INFOPLIST_KEY_NSSpeechRecognitionUsageDescription = Pulsum transcribes your voice journals on-device to keep coaching relevant.
    INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES
    INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES
    INFOPLIST_KEY_UILaunchScreen_Generation = YES
    INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight
    INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight
    INFOPLIST_OUTPUT_FORMAT = binary
    INFOPLIST_PATH = Pulsum.app/Info.plist
    INFOPLIST_PREPROCESS = NO
    INFOSTRINGS_PATH = Pulsum.app/en.lproj/InfoPlist.strings
    INLINE_PRIVATE_FRAMEWORKS = NO
    INSTALLAPI_IGNORE_SKIP_INSTALL = YES
    INSTALLHDRS_COPY_PHASE = NO
    INSTALLHDRS_SCRIPT_PHASE = NO
    INSTALL_DIR = /tmp/Pulsum.dst/Applications
    INSTALL_GROUP = staff
    INSTALL_MODE_FLAG = u+w,go-w,a+rX
    INSTALL_OWNER = martin.demel
    INSTALL_PATH = /Applications
    INSTALL_ROOT = /tmp/Pulsum.dst
    IPHONEOS_DEPLOYMENT_TARGET = 26.0
    IS_UNOPTIMIZED_BUILD = YES
    JAVAC_DEFAULT_FLAGS = -J-Xms64m -J-XX:NewSize=4M -J-Dfile.encoding=UTF8
    JAVA_APP_STUB = /System/Library/Frameworks/JavaVM.framework/Resources/MacOS/JavaApplicationStub
    JAVA_ARCHIVE_CLASSES = YES
    JAVA_ARCHIVE_TYPE = JAR
    JAVA_COMPILER = /usr/bin/javac
    JAVA_FOLDER_PATH = Pulsum.app/Java
    JAVA_FRAMEWORK_RESOURCES_DIRS = Resources
    JAVA_JAR_FLAGS = cv
    JAVA_SOURCE_SUBDIR = .
    JAVA_USE_DEPENDENCIES = YES
    JAVA_ZIP_FLAGS = -urg
    JIKES_DEFAULT_FLAGS = +E +OLDCSO
    KASAN_CFLAGS_CLASSIC = -DKASAN=1 -DKASAN_CLASSIC=1 -fsanitize=address -mllvm -asan-globals-live-support -mllvm -asan-force-dynamic-shadow
    KASAN_CFLAGS_TBI = -DKASAN=1 -DKASAN_TBI=1 -fsanitize=kernel-hwaddress -mllvm -hwasan-recover=0 -mllvm -hwasan-instrument-atomics=0 -mllvm -hwasan-instrument-stack=1 -mllvm -hwasan-generate-tags-with-calls=1 -mllvm -hwasan-instrument-with-calls=1 -mllvm -hwasan-use-short-granules=0 -mllvm -hwasan-memory-access-callback-prefix=__asan_
    KASAN_DEFAULT_CFLAGS = -DKASAN=1 -DKASAN_CLASSIC=1 -fsanitize=address -mllvm -asan-globals-live-support -mllvm -asan-force-dynamic-shadow
    KEEP_PRIVATE_EXTERNS = NO
    LD_DEPENDENCY_INFO_FILE = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch/Pulsum_dependency_info.dat
    LD_EXPORT_GLOBAL_SYMBOLS = YES
    LD_EXPORT_SYMBOLS = YES
    LD_GENERATE_MAP_FILE = NO
    LD_MAP_FILE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Pulsum-LinkMap-normal-undefined_arch.txt
    LD_NO_PIE = NO
    LD_QUOTE_LINKER_ARGUMENTS_FOR_COMPILER_DRIVER = YES
    LD_RUNPATH_SEARCH_PATHS =  @executable_path/Frameworks
    LD_RUNPATH_SEARCH_PATHS_YES = @loader_path/../Frameworks
    LD_SHARED_CACHE_ELIGIBLE = Automatic
    LD_WARN_DUPLICATE_LIBRARIES = NO
    LD_WARN_UNUSED_DYLIBS = NO
    LEGACY_DEVELOPER_DIR = /Applications/Xcode.app/Contents/PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer
    LEX = lex
    LIBRARY_DEXT_INSTALL_PATH = /Library/DriverExtensions
    LIBRARY_FLAG_NOSPACE = YES
    LIBRARY_FLAG_PREFIX = -l
    LIBRARY_KEXT_INSTALL_PATH = /Library/Extensions
    LIBRARY_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    LINKER_DISPLAYS_MANGLED_NAMES = NO
    LINK_FILE_LIST_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.LinkFileList
    LINK_OBJC_RUNTIME = YES
    LINK_WITH_STANDARD_LIBRARIES = YES
    LLVM_TARGET_TRIPLE_OS_VERSION = ios26.0
    LLVM_TARGET_TRIPLE_VENDOR = apple
    LM_AUX_CONST_METADATA_LIST_PATH_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.SwiftConstValuesFileList
    LOCALIZATION_EXPORT_SUPPORTED = YES
    LOCALIZATION_PREFERS_STRING_CATALOGS = YES
    LOCALIZED_RESOURCES_FOLDER_PATH = Pulsum.app/en.lproj
    LOCALIZED_STRING_MACRO_NAMES = NSLocalizedString CFCopyLocalizedString
    LOCALIZED_STRING_SWIFTUI_SUPPORT = YES
    LOCAL_ADMIN_APPS_DIR = /Applications/Utilities
    LOCAL_APPS_DIR = /Applications
    LOCAL_DEVELOPER_DIR = /Library/Developer
    LOCAL_LIBRARY_DIR = /Library
    LOCROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    LOCSYMROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    MACH_O_TYPE = mh_execute
    MACOSX_DEPLOYMENT_TARGET = 26.1
    MAC_OS_X_PRODUCT_BUILD_VERSION = 25C56
    MAC_OS_X_VERSION_ACTUAL = 260200
    MAC_OS_X_VERSION_MAJOR = 260000
    MAC_OS_X_VERSION_MINOR = 260200
    MAKE_MERGEABLE = NO
    MARKETING_VERSION = 1.0
    MERGEABLE_LIBRARY = NO
    MERGED_BINARY_TYPE = none
    MERGE_LINKED_LIBRARIES = NO
    METAL_LIBRARY_FILE_BASE = default
    METAL_LIBRARY_OUTPUT_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/Pulsum.app
    MODULES_FOLDER_PATH = Pulsum.app/Modules
    MODULE_CACHE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/ModuleCache.noindex
    MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE
    MTL_FAST_MATH = YES
    NATIVE_ARCH = arm64
    NATIVE_ARCH_32_BIT = arm
    NATIVE_ARCH_64_BIT = arm64
    NATIVE_ARCH_ACTUAL = arm64
    NO_COMMON = YES
    OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects
    OBJECT_FILE_DIR_normal = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal
    OBJROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    ONLY_ACTIVE_ARCH = YES
    OS = MACOS
    OSAC = /usr/bin/osacompile
    PACKAGE_TYPE = com.apple.package-type.wrapper.application
    PASCAL_STRINGS = YES
    PATH = /Applications/Xcode.app/Contents/SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildService.bundle/Contents/PlugIns/SWBUniversalPlatformPlugin.bundle/Contents/Frameworks/SWBUniversalPlatform.framework/Resources:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/local/bin:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/libexec:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/local/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/local/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/local/bin:/Library/Frameworks/Python.framework/Versions/3.13/bin:/Library/Frameworks/Python.framework/Versions/3.12/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/Library/TeX/texbin:/Users/martin.demel/.codex/tmp/path/codex-arg0ZXyiPF:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/martin.demel/.codeium/windsurf/bin:/usr/local/opt/python@3.11/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/martin.demel/.lmstudio/bin:/Users/martin.demel/.cursor/extensions/openai.chatgpt-0.4.66-universal/bin/macos-aarch64
    PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES = /usr/include /usr/local/include /System/Library/Frameworks /System/Library/PrivateFrameworks /Applications/Xcode.app/Contents/Developer/Headers /Applications/Xcode.app/Contents/Developer/SDKs /Applications/Xcode.app/Contents/Developer/Platforms
    PBDEVELOPMENTPLIST_PATH = Pulsum.app/pbdevelopment.plist
    PER_ARCH_MODULE_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    PER_ARCH_OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    PER_VARIANT_OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal
    PKGINFO_FILE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/PkgInfo
    PKGINFO_PATH = Pulsum.app/PkgInfo
    PLATFORM_DEVELOPER_APPLICATIONS_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Applications
    PLATFORM_DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin
    PLATFORM_DEVELOPER_LIBRARY_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library
    PLATFORM_DEVELOPER_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs
    PLATFORM_DEVELOPER_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Tools
    PLATFORM_DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr
    PLATFORM_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform
    PLATFORM_DISPLAY_NAME = iOS
    PLATFORM_FAMILY_NAME = iOS
    PLATFORM_NAME = iphoneos
    PLATFORM_PREFERRED_ARCH = arm64
    PLATFORM_PRODUCT_BUILD_VERSION = 23B77
    PLATFORM_REQUIRES_SWIFT_AUTOLINK_EXTRACT = NO
    PLATFORM_REQUIRES_SWIFT_MODULEWRAP = NO
    PLIST_FILE_OUTPUT_FORMAT = binary
    PLUGINS_FOLDER_PATH = Pulsum.app/PlugIns
    PRECOMPS_INCLUDE_HEADERS_FROM_BUILT_PRODUCTS_DIR = YES
    PRECOMP_DESTINATION_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/PrefixHeaders
    PRIVATE_HEADERS_FOLDER_PATH = Pulsum.app/PrivateHeaders
    PROCESSED_INFOPLIST_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch/Processed-Info.plist
    PRODUCT_BUNDLE_IDENTIFIER = ai.pulsum.Pulsum
    PRODUCT_BUNDLE_PACKAGE_TYPE = APPL
    PRODUCT_MODULE_NAME = Pulsum
    PRODUCT_NAME = Pulsum
    PRODUCT_SETTINGS_PATH = 
    PRODUCT_TYPE = com.apple.product-type.application
    PROFILING_CODE = NO
    PROJECT = Pulsum
    PROJECT_DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/DerivedSources
    PROJECT_DIR = /Users/martin.demel/Desktop/PULSUM/Pulsum
    PROJECT_FILE_PATH = /Users/martin.demel/Desktop/PULSUM/Pulsum/Pulsum.xcodeproj
    PROJECT_GUID = 8a2ebb52ff332eacb0b1d430ce5478d8
    PROJECT_NAME = Pulsum
    PROJECT_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build
    PROJECT_TEMP_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    PROVISIONING_PROFILE_REQUIRED = YES
    PROVISIONING_PROFILE_REQUIRED_YES_YES = YES
    PROVISIONING_PROFILE_SUPPORTED = YES
    PUBLIC_HEADERS_FOLDER_PATH = Pulsum.app/Headers
    RECOMMENDED_IPHONEOS_DEPLOYMENT_TARGET = 15.0
    RECURSIVE_SEARCH_PATHS_FOLLOW_SYMLINKS = YES
    REMOVE_CVS_FROM_RESOURCES = YES
    REMOVE_GIT_FROM_RESOURCES = YES
    REMOVE_HEADERS_FROM_EMBEDDED_BUNDLES = YES
    REMOVE_HG_FROM_RESOURCES = YES
    REMOVE_STATIC_EXECUTABLES_FROM_EMBEDDED_BUNDLES = YES
    REMOVE_SVN_FROM_RESOURCES = YES
    RESCHEDULE_INDEPENDENT_HEADERS_PHASES = YES
    REZ_COLLECTOR_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/ResourceManagerResources
    REZ_OBJECTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/ResourceManagerResources/Objects
    REZ_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    RUNTIME_EXCEPTION_ALLOW_DYLD_ENVIRONMENT_VARIABLES = NO
    RUNTIME_EXCEPTION_ALLOW_JIT = NO
    RUNTIME_EXCEPTION_ALLOW_UNSIGNED_EXECUTABLE_MEMORY = NO
    RUNTIME_EXCEPTION_DEBUGGING_TOOL = NO
    RUNTIME_EXCEPTION_DISABLE_EXECUTABLE_PAGE_PROTECTION = NO
    RUNTIME_EXCEPTION_DISABLE_LIBRARY_VALIDATION = NO
    SCAN_ALL_SOURCE_FILES_FOR_INCLUDES = NO
    SCRIPTS_FOLDER_PATH = Pulsum.app/Scripts
    SDKROOT = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR_iphoneos = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR_iphoneos26_1 = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_NAME = iphoneos26.1
    SDK_NAMES = iphoneos26.1
    SDK_PRODUCT_BUILD_VERSION = 23B77
    SDK_STAT_CACHE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData
    SDK_STAT_CACHE_ENABLE = YES
    SDK_STAT_CACHE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/SDKStatCaches.noindex/iphoneos26.1-23B77-69b33fc7382b27d9b5d46e82a00f8e78.sdkstatcache
    SDK_VERSION = 26.1
    SDK_VERSION_ACTUAL = 260100
    SDK_VERSION_MAJOR = 260000
    SDK_VERSION_MINOR = 260100
    SED = /usr/bin/sed
    SEPARATE_STRIP = NO
    SEPARATE_SYMBOL_EDIT = NO
    SET_DIR_MODE_OWNER_GROUP = YES
    SET_FILE_MODE_OWNER_GROUP = NO
    SHALLOW_BUNDLE = YES
    SHALLOW_BUNDLE_TRIPLE = ios
    SHALLOW_BUNDLE_ios_macabi = NO
    SHALLOW_BUNDLE_macos = NO
    SHARED_DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/DerivedSources
    SHARED_FRAMEWORKS_FOLDER_PATH = Pulsum.app/SharedFrameworks
    SHARED_PRECOMPS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/PrecompiledHeaders
    SHARED_SUPPORT_FOLDER_PATH = Pulsum.app/SharedSupport
    SKIP_INSTALL = NO
    SOURCE_ROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    SRCROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    STRINGSDATA_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    STRINGSDATA_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    STRINGS_FILE_INFOPLIST_RENAME = YES
    STRINGS_FILE_OUTPUT_ENCODING = binary
    STRING_CATALOG_GENERATE_SYMBOLS = YES
    STRIP_BITCODE_FROM_COPIED_FILES = YES
    STRIP_INSTALLED_PRODUCT = NO
    STRIP_STYLE = all
    STRIP_SWIFT_SYMBOLS = YES
    SUPPORTED_DEVICE_FAMILIES = 1,2
    SUPPORTED_PLATFORMS = iphoneos iphonesimulator
    SUPPORTS_MACCATALYST = NO
    SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = YES
    SUPPORTS_ON_DEMAND_RESOURCES = YES
    SUPPORTS_TEXT_BASED_API = NO
    SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = YES
    SUPPRESS_WARNINGS = NO
    SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG 
    SWIFT_APPROACHABLE_CONCURRENCY = YES
    SWIFT_DEFAULT_ACTOR_ISOLATION = MainActor
    SWIFT_EMIT_CONST_VALUE_PROTOCOLS = AppIntent EntityQuery AppEntity TransientEntity AppEnum AppShortcutProviding AppShortcutsProvider AnyResolverProviding AppIntentsPackage DynamicOptionsProvider _IntentValueRepresentable _AssistantIntentsProvider _GenerativeFunctionExtractable IntentValueQuery Resolver AppExtension ExtensionPointDefining
    SWIFT_EMIT_LOC_STRINGS = YES
    SWIFT_ENABLE_EXPLICIT_MODULES = YES
    SWIFT_OPTIMIZATION_LEVEL = -Onone
    SWIFT_PLATFORM_TARGET_PREFIX = ios
    SWIFT_RESPONSE_FILE_PATH_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.SwiftFileList
    SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES
    SWIFT_VERSION = 5.0
    SYMROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    SYSTEM_ADMIN_APPS_DIR = /Applications/Utilities
    SYSTEM_APPS_DIR = /Applications
    SYSTEM_CORE_SERVICES_DIR = /System/Library/CoreServices
    SYSTEM_DEMOS_DIR = /Applications/Extras
    SYSTEM_DEVELOPER_APPS_DIR = /Applications/Xcode.app/Contents/Developer/Applications
    SYSTEM_DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/usr/bin
    SYSTEM_DEVELOPER_DEMOS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Utilities/Built Examples
    SYSTEM_DEVELOPER_DIR = /Applications/Xcode.app/Contents/Developer
    SYSTEM_DEVELOPER_DOC_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library
    SYSTEM_DEVELOPER_GRAPHICS_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Graphics Tools
    SYSTEM_DEVELOPER_JAVA_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Java Tools
    SYSTEM_DEVELOPER_PERFORMANCE_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Performance Tools
    SYSTEM_DEVELOPER_RELEASENOTES_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/releasenotes
    SYSTEM_DEVELOPER_TOOLS = /Applications/Xcode.app/Contents/Developer/Tools
    SYSTEM_DEVELOPER_TOOLS_DOC_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/documentation/DeveloperTools
    SYSTEM_DEVELOPER_TOOLS_RELEASENOTES_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/releasenotes/DeveloperTools
    SYSTEM_DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/usr
    SYSTEM_DEVELOPER_UTILITIES_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Utilities
    SYSTEM_DEXT_INSTALL_PATH = /System/Library/DriverExtensions
    SYSTEM_DOCUMENTATION_DIR = /Library/Documentation
    SYSTEM_EXTENSIONS_FOLDER_PATH = Pulsum.app/SystemExtensions
    SYSTEM_EXTENSIONS_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Library/SystemExtensions
    SYSTEM_EXTENSIONS_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app/SystemExtensions
    SYSTEM_KEXT_INSTALL_PATH = /System/Library/Extensions
    SYSTEM_LIBRARY_DIR = /System/Library
    TAPI_DEMANGLE = YES
    TAPI_ENABLE_PROJECT_HEADERS = NO
    TAPI_LANGUAGE = objective-c
    TAPI_LANGUAGE_STANDARD = compiler-default
    TAPI_USE_SRCROOT = YES
    TAPI_VERIFY_MODE = Pedantic
    TARGETED_DEVICE_FAMILY = 1,2
    TARGETNAME = Pulsum
    TARGET_BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    TARGET_DEVICE_IDENTIFIER = 00006031-001C519921B8001C
    TARGET_DEVICE_MODEL = Mac15,9
    TARGET_DEVICE_OS_VERSION = 26.2
    TARGET_DEVICE_PLATFORM_NAME = macosx
    TARGET_NAME = Pulsum
    TARGET_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    TEMP_SANDBOX_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/TemporaryTaskSandboxes
    TEST_FRAMEWORK_SEARCH_PATHS =  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Frameworks /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk/Developer/Library/Frameworks
    TEST_LIBRARY_SEARCH_PATHS =  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/lib
    TOOLCHAINS = com.apple.dt.toolchain.XcodeDefault
    TOOLCHAIN_DIR = /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain
    TREAT_MISSING_BASELINES_AS_TEST_FAILURES = NO
    TREAT_MISSING_SCRIPT_PHASE_OUTPUTS_AS_ERRORS = NO
    TVOS_DEPLOYMENT_TARGET = 26.1
    UID = 501
    UNINSTALLED_PRODUCTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/UninstalledProducts
    UNLOCALIZED_RESOURCES_FOLDER_PATH = Pulsum.app
    UNLOCALIZED_RESOURCES_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Resources
    UNLOCALIZED_RESOURCES_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    UNSTRIPPED_PRODUCT = NO
    USER = martin.demel
    USER_APPS_DIR = /Users/martin.demel/Applications
    USER_LIBRARY_DIR = /Users/martin.demel/Library
    USE_DYNAMIC_NO_PIC = YES
    USE_HEADERMAP = YES
    USE_HEADER_SYMLINKS = NO
    VALIDATE_DEVELOPMENT_ASSET_PATHS = YES_ERROR
    VALIDATE_PRODUCT = NO
    VALID_ARCHS = arm64 arm64e armv7 armv7s
    VERBOSE_PBXCP = NO
    VERSIONPLIST_PATH = Pulsum.app/version.plist
    VERSION_INFO_BUILDER = martin.demel
    VERSION_INFO_FILE = Pulsum_vers.c
    VERSION_INFO_STRING = "@(#)PROGRAM:Pulsum  PROJECT:Pulsum-1"
    WATCHOS_DEPLOYMENT_TARGET = 26.1
    WORKSPACE_DIR = /Users/martin.demel/Desktop/PULSUM/Pulsum/Pulsum.xcodeproj
    WRAPPER_EXTENSION = app
    WRAPPER_NAME = Pulsum.app
    WRAPPER_SUFFIX = .app
    WRAP_ASSET_PACKS_IN_SEPARATE_DIRECTORIES = NO
    XCODE_APP_SUPPORT_DIR = /Applications/Xcode.app/Contents/Developer/Library/Xcode
    XCODE_PRODUCT_BUILD_VERSION = 17B100
    XCODE_VERSION_ACTUAL = 2611
    XCODE_VERSION_MAJOR = 2600
    XCODE_VERSION_MINOR = 2610
    XPCSERVICES_FOLDER_PATH = Pulsum.app/XPCServices
    XROS_DEPLOYMENT_TARGET = 26.1
    YACC = yacc
    _DISCOVER_COMMAND_LINE_LINKER_INPUTS = YES
    _DISCOVER_COMMAND_LINE_LINKER_INPUTS_INCLUDE_WL = YES
    _LD_MULTIARCH = YES
    _WRAPPER_CONTENTS_DIR_SHALLOW_BUNDLE_NO = /Contents
    _WRAPPER_PARENT_PATH_SHALLOW_BUNDLE_NO = /..
    _WRAPPER_RESOURCES_DIR_SHALLOW_BUNDLE_NO = /Resources
    __DIAGNOSE_DEPRECATED_ARCHS = YES
    __IS_NOT_MACOS = YES
    __IS_NOT_MACOS_macosx = NO
    __IS_NOT_SIMULATOR = YES
    __IS_NOT_SIMULATOR_simulator = NO
    arch = undefined_arch
    variant = normal

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj — scheme PulsumAgents
- Command: `xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumAgents`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumAgents

Resolve Package Graph


Resolved source packages:
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64e, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64e, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:DriverKit, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64_32, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:DriverKit, name:Any DriverKit Host }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:macOS, name:Any Mac }
{ platform:macOS, variant:Mac Catalyst, name:Any Mac }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj — scheme PulsumData
- Command: `xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumData`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumData

Resolve Package Graph


Resolved source packages:
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64e, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64e, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:DriverKit, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64_32, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:DriverKit, name:Any DriverKit Host }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:macOS, name:Any Mac }
{ platform:macOS, variant:Mac Catalyst, name:Any Mac }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj — scheme PulsumML
- Command: `xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumML`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumML

Resolve Package Graph


Resolved source packages:
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64e, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64e, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:DriverKit, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64_32, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:DriverKit, name:Any DriverKit Host }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:macOS, name:Any Mac }
{ platform:macOS, variant:Mac Catalyst, name:Any Mac }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj — scheme PulsumServices
- Command: `xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumServices`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumServices

Resolve Package Graph


Resolved source packages:
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64e, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64e, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:DriverKit, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64_32, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:DriverKit, name:Any DriverKit Host }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:macOS, name:Any Mac }
{ platform:macOS, variant:Mac Catalyst, name:Any Mac }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj — scheme PulsumTypes
- Command: `xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumTypes`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumTypes

Resolve Package Graph


Resolved source packages:
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64e, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64e, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:DriverKit, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64_32, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:DriverKit, name:Any DriverKit Host }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:macOS, name:Any Mac }
{ platform:macOS, variant:Mac Catalyst, name:Any Mac }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj — scheme PulsumUI
- Command: `xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumUI`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -project Pulsum.xcodeproj -scheme PulsumUI

Resolve Package Graph


Resolved source packages:
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local

Build settings for action build and target Pulsum:
    ACTION = build
    AD_HOC_CODE_SIGNING_ALLOWED = NO
    AGGREGATE_TRACKED_DOMAINS = YES
    ALLOW_BUILD_REQUEST_OVERRIDES = NO
    ALLOW_TARGET_PLATFORM_SPECIALIZATION = NO
    ALTERNATE_GROUP = staff
    ALTERNATE_MODE = u+w,go-w,a+rX
    ALTERNATE_OWNER = martin.demel
    ALTERNATIVE_DISTRIBUTION_WEB = NO
    ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO
    ALWAYS_SEARCH_USER_PATHS = NO
    ALWAYS_USE_SEPARATE_HEADERMAPS = NO
    APPLICATION_EXTENSION_API_ONLY = NO
    APPLY_RULES_IN_COPY_FILES = NO
    APPLY_RULES_IN_COPY_HEADERS = NO
    APP_SHORTCUTS_ENABLE_FLEXIBLE_MATCHING = YES
    ARCHS = arm64
    ARCHS_STANDARD = arm64
    ARCHS_STANDARD_32_64_BIT = armv7 arm64
    ARCHS_STANDARD_32_BIT = armv7
    ARCHS_STANDARD_64_BIT = arm64
    ARCHS_STANDARD_INCLUDING_64_BIT = arm64
    ARCHS_UNIVERSAL_IPHONE_OS = armv7 arm64
    ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon
    ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES
    ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor
    ASSETCATALOG_FILTER_FOR_DEVICE_MODEL = MacFamily20,1
    ASSETCATALOG_FILTER_FOR_DEVICE_OS_VERSION = 26.2
    ASSETCATALOG_FILTER_FOR_THINNING_DEVICE_CONFIGURATION = MacFamily20,1
    AUTOMATICALLY_MERGE_DEPENDENCIES = NO
    AUTOMATION_APPLE_EVENTS = NO
    AVAILABLE_PLATFORMS = android appletvos appletvsimulator driverkit iphoneos iphonesimulator macosx qnx watchos watchsimulator webassembly xros xrsimulator
    BUILD_ACTIVE_RESOURCES_ONLY = YES
    BUILD_COMPONENTS = headers build
    BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    BUILD_LIBRARY_FOR_DISTRIBUTION = NO
    BUILD_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    BUILD_STYLE = 
    BUILD_VARIANTS = normal
    BUILT_PRODUCTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    BUNDLE_CONTENTS_FOLDER_PATH_deep = Contents/
    BUNDLE_EXECUTABLE_FOLDER_NAME_deep = MacOS
    BUNDLE_EXTENSIONS_FOLDER_PATH = Extensions
    BUNDLE_FORMAT = shallow
    BUNDLE_FRAMEWORKS_FOLDER_PATH = Frameworks
    BUNDLE_PLUGINS_FOLDER_PATH = PlugIns
    BUNDLE_PRIVATE_HEADERS_FOLDER_PATH = PrivateHeaders
    BUNDLE_PUBLIC_HEADERS_FOLDER_PATH = Headers
    CACHE_ROOT = /var/folders/m_/nqk8g4cs5tz8t1yj2kglt8p80000gn/C/com.apple.DeveloperTools/26.1.1-17B100/Xcode
    CCHROOT = /var/folders/m_/nqk8g4cs5tz8t1yj2kglt8p80000gn/C/com.apple.DeveloperTools/26.1.1-17B100/Xcode
    CHMOD = /bin/chmod
    CHOWN = /usr/sbin/chown
    CLANG_ANALYZER_NONNULL = YES
    CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE
    CLANG_CACHE_FINE_GRAINED_OUTPUTS = YES
    CLANG_COVERAGE_MAPPING = YES
    CLANG_CXX_LANGUAGE_STANDARD = gnu++20
    CLANG_ENABLE_EXPLICIT_MODULES = YES
    CLANG_ENABLE_MODULES = YES
    CLANG_ENABLE_OBJC_ARC = YES
    CLANG_ENABLE_OBJC_WEAK = YES
    CLANG_MODULES_BUILD_SESSION_FILE = /Users/martin.demel/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation
    CLANG_PROFILE_DATA_DIRECTORY = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/ProfileData
    CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES
    CLANG_WARN_BOOL_CONVERSION = YES
    CLANG_WARN_COMMA = YES
    CLANG_WARN_CONSTANT_CONVERSION = YES
    CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES
    CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR
    CLANG_WARN_DOCUMENTATION_COMMENTS = YES
    CLANG_WARN_EMPTY_BODY = YES
    CLANG_WARN_ENUM_CONVERSION = YES
    CLANG_WARN_INFINITE_RECURSION = YES
    CLANG_WARN_INT_CONVERSION = YES
    CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES
    CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
    CLANG_WARN_OBJC_LITERAL_CONVERSION = YES
    CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR
    CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES
    CLANG_WARN_RANGE_LOOP_ANALYSIS = YES
    CLANG_WARN_STRICT_PROTOTYPES = YES
    CLANG_WARN_SUSPICIOUS_MOVE = YES
    CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
    CLANG_WARN_UNREACHABLE_CODE = YES
    CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
    CLASS_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/JavaClasses
    CLEAN_PRECOMPS = YES
    CLONE_HEADERS = NO
    CODESIGNING_FOLDER_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/Pulsum.app
    CODE_SIGNING_ALLOWED = YES
    CODE_SIGNING_REQUIRED = YES
    CODE_SIGN_CONTEXT_CLASS = XCiPhoneOSCodeSignContext
    CODE_SIGN_ENTITLEMENTS = Pulsum/Pulsum.entitlements
    CODE_SIGN_IDENTITY = Apple Development
    CODE_SIGN_INJECT_BASE_ENTITLEMENTS = YES
    CODE_SIGN_STYLE = Automatic
    COLOR_DIAGNOSTICS = NO
    COMBINE_HIDPI_IMAGES = NO
    COMPILATION_CACHE_CAS_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/CompilationCache.noindex
    COMPILATION_CACHE_KEEP_CAS_DIRECTORY = YES
    COMPILER_INDEX_STORE_ENABLE = Default
    COMPOSITE_SDK_DIRS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/CompositeSDKs
    COMPRESS_PNG_FILES = YES
    CONFIGURATION = Debug
    CONFIGURATION_BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    CONFIGURATION_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos
    CONTENTS_FOLDER_PATH = Pulsum.app
    CONTENTS_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Contents
    CONTENTS_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    COPYING_PRESERVES_HFS_DATA = NO
    COPY_HEADERS_RUN_UNIFDEF = NO
    COPY_PHASE_STRIP = NO
    CORRESPONDING_SIMULATOR_PLATFORM_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform
    CORRESPONDING_SIMULATOR_PLATFORM_NAME = iphonesimulator
    CORRESPONDING_SIMULATOR_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator26.1.sdk
    CORRESPONDING_SIMULATOR_SDK_NAME = iphonesimulator26.1
    CP = /bin/cp
    CREATE_INFOPLIST_SECTION_IN_BINARY = NO
    CURRENT_ARCH = undefined_arch
    CURRENT_PROJECT_VERSION = 1
    CURRENT_VARIANT = normal
    DEAD_CODE_STRIPPING = YES
    DEBUGGING_SYMBOLS = YES
    DEBUG_INFORMATION_FORMAT = dwarf
    DEBUG_INFORMATION_VERSION = compiler-default
    DEFAULT_COMPILER = com.apple.compilers.llvm.clang.1_0
    DEFAULT_DEXT_INSTALL_PATH = /System/Library/DriverExtensions
    DEFAULT_KEXT_INSTALL_PATH = /System/Library/Extensions
    DEFINES_MODULE = NO
    DEPLOYMENT_LOCATION = NO
    DEPLOYMENT_POSTPROCESSING = NO
    DEPLOYMENT_TARGET_SETTING_NAME = IPHONEOS_DEPLOYMENT_TARGET
    DEPLOYMENT_TARGET_SUGGESTED_VALUES = 12.0 12.1 12.2 12.3 12.4 13.0 13.1 13.2 13.3 13.4 13.5 13.6 14.0 14.1 14.2 14.3 14.4 14.5 14.6 14.7 15.0 15.1 15.2 15.3 15.4 15.5 15.6 16.0 16.1 16.2 16.3 16.4 16.5 16.6 17.0 17.1 17.2 17.3 17.4 17.5 17.6 18.0 18.1 18.2 18.3 18.4 18.5 18.6 26.0 26.1
    DERIVED_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVED_SOURCES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVE_MACCATALYST_PRODUCT_BUNDLE_IDENTIFIER = NO
    DEVELOPER_APPLICATIONS_DIR = /Applications/Xcode.app/Contents/Developer/Applications
    DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/usr/bin
    DEVELOPER_DIR = /Applications/Xcode.app/Contents/Developer
    DEVELOPER_FRAMEWORKS_DIR = /Applications/Xcode.app/Contents/Developer/Library/Frameworks
    DEVELOPER_FRAMEWORKS_DIR_QUOTED = /Applications/Xcode.app/Contents/Developer/Library/Frameworks
    DEVELOPER_LIBRARY_DIR = /Applications/Xcode.app/Contents/Developer/Library
    DEVELOPER_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs
    DEVELOPER_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Tools
    DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/usr
    DEVELOPMENT_LANGUAGE = en
    DEVELOPMENT_TEAM = X6FJFZCXY3
    DIAGNOSE_MISSING_TARGET_DEPENDENCIES = YES
    DIFF = /usr/bin/diff
    DOCUMENTATION_FOLDER_PATH = Pulsum.app/en.lproj/Documentation
    DONT_GENERATE_INFOPLIST_FILE = NO
    DRIVERKIT_DEPLOYMENT_TARGET = 25.1
    DSTROOT = /tmp/Pulsum.dst
    DT_TOOLCHAIN_DIR = /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain
    DWARF_DSYM_FILE_NAME = Pulsum.app.dSYM
    DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT = NO
    DWARF_DSYM_FOLDER_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    DYNAMIC_LIBRARY_EXTENSION = dylib
    EAGER_COMPILATION_ALLOW_SCRIPTS = YES
    EAGER_LINKING = NO
    EFFECTIVE_PLATFORM_NAME = -iphoneos
    EMBEDDED_CONTENT_CONTAINS_SWIFT = NO
    EMBEDDED_PROFILE_NAME = embedded.mobileprovision
    EMBED_ASSET_PACKS_IN_PRODUCT_BUNDLE = NO
    ENABLE_APP_SANDBOX = NO
    ENABLE_CODE_COVERAGE = YES
    ENABLE_CPLUSPLUS_BOUNDS_SAFE_BUFFERS = NO
    ENABLE_C_BOUNDS_SAFETY = NO
    ENABLE_DEBUG_DYLIB = YES
    ENABLE_DEFAULT_HEADER_SEARCH_PATHS = YES
    ENABLE_DEFAULT_SEARCH_PATHS = YES
    ENABLE_ENHANCED_SECURITY = NO
    ENABLE_HARDENED_RUNTIME = NO
    ENABLE_HEADER_DEPENDENCIES = YES
    ENABLE_INCOMING_NETWORK_CONNECTIONS = NO
    ENABLE_ON_DEMAND_RESOURCES = YES
    ENABLE_OUTGOING_NETWORK_CONNECTIONS = NO
    ENABLE_POINTER_AUTHENTICATION = NO
    ENABLE_PREVIEWS = YES
    ENABLE_RESOURCE_ACCESS_AUDIO_INPUT = NO
    ENABLE_RESOURCE_ACCESS_BLUETOOTH = NO
    ENABLE_RESOURCE_ACCESS_CALENDARS = NO
    ENABLE_RESOURCE_ACCESS_CAMERA = NO
    ENABLE_RESOURCE_ACCESS_CONTACTS = NO
    ENABLE_RESOURCE_ACCESS_LOCATION = NO
    ENABLE_RESOURCE_ACCESS_PHOTO_LIBRARY = NO
    ENABLE_RESOURCE_ACCESS_PRINTING = NO
    ENABLE_RESOURCE_ACCESS_USB = NO
    ENABLE_SDK_IMPORTS = NO
    ENABLE_SECURITY_COMPILER_WARNINGS = NO
    ENABLE_STRICT_OBJC_MSGSEND = YES
    ENABLE_TESTABILITY = YES
    ENABLE_TESTING_SEARCH_PATHS = NO
    ENABLE_THREAD_SANITIZER = NO
    ENABLE_USER_SCRIPT_SANDBOXING = YES
    ENFORCE_VALID_ARCHS = YES
    ENTITLEMENTS_ALLOWED = YES
    ENTITLEMENTS_DESTINATION = Signature
    ENTITLEMENTS_REQUIRED = NO
    EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS = .DS_Store .svn .git .hg CVS
    EXCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES = *.nib *.lproj *.framework *.gch *.xcode* *.xcassets *.icon (*) .DS_Store CVS .svn .git .hg *.pbproj *.pbxproj
    EXECUTABLES_FOLDER_PATH = Pulsum.app/Executables
    EXECUTABLE_FOLDER_PATH = Pulsum.app
    EXECUTABLE_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/MacOS
    EXECUTABLE_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    EXECUTABLE_NAME = Pulsum
    EXECUTABLE_PATH = Pulsum.app/Pulsum
    EXTENSIONS_FOLDER_PATH = Pulsum.app/Extensions
    FILE_LIST = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects/LinkFileList
    FIXED_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/FixedFiles
    FRAMEWORKS_FOLDER_PATH = Pulsum.app/Frameworks
    FRAMEWORK_FLAG_PREFIX = -framework
    FRAMEWORK_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    FRAMEWORK_VERSION = A
    FULL_PRODUCT_NAME = Pulsum.app
    FUSE_BUILD_PHASES = YES
    FUSE_BUILD_SCRIPT_PHASES = NO
    GCC3_VERSION = 3.3
    GCC_C_LANGUAGE_STANDARD = gnu17
    GCC_DYNAMIC_NO_PIC = NO
    GCC_INLINES_ARE_PRIVATE_EXTERN = YES
    GCC_NO_COMMON_BLOCKS = YES
    GCC_OPTIMIZATION_LEVEL = 0
    GCC_PFE_FILE_C_DIALECTS = c objective-c c++ objective-c++
    GCC_PREPROCESSOR_DEFINITIONS = DEBUG=1 
    GCC_SYMBOLS_PRIVATE_EXTERN = NO
    GCC_THUMB_SUPPORT = YES
    GCC_TREAT_WARNINGS_AS_ERRORS = NO
    GCC_VERSION = com.apple.compilers.llvm.clang.1_0
    GCC_VERSION_IDENTIFIER = com_apple_compilers_llvm_clang_1_0
    GCC_WARN_64_TO_32_BIT_CONVERSION = YES
    GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR
    GCC_WARN_UNDECLARED_SELECTOR = YES
    GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE
    GCC_WARN_UNUSED_FUNCTION = YES
    GCC_WARN_UNUSED_VARIABLE = YES
    GENERATED_MODULEMAP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/GeneratedModuleMaps-iphoneos
    GENERATE_INFOPLIST_FILE = YES
    GENERATE_INTERMEDIATE_TEXT_BASED_STUBS = YES
    GENERATE_PKGINFO_FILE = YES
    GENERATE_PRELINK_OBJECT_FILE = NO
    GENERATE_PROFILING_CODE = NO
    GENERATE_TEXT_BASED_STUBS = NO
    GID = 20
    GROUP = staff
    HEADERMAP_INCLUDES_FLAT_ENTRIES_FOR_TARGET_BEING_BUILT = YES
    HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_ALL_PRODUCT_TYPES = YES
    HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_TARGETS_NOT_BEING_BUILT = YES
    HEADERMAP_INCLUDES_NONPUBLIC_NONPRIVATE_HEADERS = YES
    HEADERMAP_INCLUDES_PROJECT_HEADERS = YES
    HEADERMAP_USES_FRAMEWORK_PREFIX_ENTRIES = YES
    HEADERMAP_USES_VFS = NO
    HEADER_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/include 
    HOME = /Users/martin.demel
    HOST_ARCH = arm64
    HOST_PLATFORM = macosx
    ICONV = /usr/bin/iconv
    IMPLICIT_DEPENDENCY_DOMAIN = default
    INFOPLIST_ENABLE_CFBUNDLEICONS_MERGE = YES
    INFOPLIST_EXPAND_BUILD_SETTINGS = YES
    INFOPLIST_KEY_ITSAppUsesNonExemptEncryption = NO
    INFOPLIST_KEY_NSHealthShareUsageDescription = Pulsum reads key wellness metrics like HRV and sleep to personalize your coaching.
    INFOPLIST_KEY_NSHealthUpdateUsageDescription = Pulsum references your recent trends to surface the most helpful guidance.
    INFOPLIST_KEY_NSMicrophoneUsageDescription = Pulsum uses the microphone to capture on-device voice journals.
    INFOPLIST_KEY_NSSpeechRecognitionUsageDescription = Pulsum transcribes your voice journals on-device to keep coaching relevant.
    INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES
    INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES
    INFOPLIST_KEY_UILaunchScreen_Generation = YES
    INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight
    INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight
    INFOPLIST_OUTPUT_FORMAT = binary
    INFOPLIST_PATH = Pulsum.app/Info.plist
    INFOPLIST_PREPROCESS = NO
    INFOSTRINGS_PATH = Pulsum.app/en.lproj/InfoPlist.strings
    INLINE_PRIVATE_FRAMEWORKS = NO
    INSTALLAPI_IGNORE_SKIP_INSTALL = YES
    INSTALLHDRS_COPY_PHASE = NO
    INSTALLHDRS_SCRIPT_PHASE = NO
    INSTALL_DIR = /tmp/Pulsum.dst/Applications
    INSTALL_GROUP = staff
    INSTALL_MODE_FLAG = u+w,go-w,a+rX
    INSTALL_OWNER = martin.demel
    INSTALL_PATH = /Applications
    INSTALL_ROOT = /tmp/Pulsum.dst
    IPHONEOS_DEPLOYMENT_TARGET = 26.0
    IS_UNOPTIMIZED_BUILD = YES
    JAVAC_DEFAULT_FLAGS = -J-Xms64m -J-XX:NewSize=4M -J-Dfile.encoding=UTF8
    JAVA_APP_STUB = /System/Library/Frameworks/JavaVM.framework/Resources/MacOS/JavaApplicationStub
    JAVA_ARCHIVE_CLASSES = YES
    JAVA_ARCHIVE_TYPE = JAR
    JAVA_COMPILER = /usr/bin/javac
    JAVA_FOLDER_PATH = Pulsum.app/Java
    JAVA_FRAMEWORK_RESOURCES_DIRS = Resources
    JAVA_JAR_FLAGS = cv
    JAVA_SOURCE_SUBDIR = .
    JAVA_USE_DEPENDENCIES = YES
    JAVA_ZIP_FLAGS = -urg
    JIKES_DEFAULT_FLAGS = +E +OLDCSO
    KASAN_CFLAGS_CLASSIC = -DKASAN=1 -DKASAN_CLASSIC=1 -fsanitize=address -mllvm -asan-globals-live-support -mllvm -asan-force-dynamic-shadow
    KASAN_CFLAGS_TBI = -DKASAN=1 -DKASAN_TBI=1 -fsanitize=kernel-hwaddress -mllvm -hwasan-recover=0 -mllvm -hwasan-instrument-atomics=0 -mllvm -hwasan-instrument-stack=1 -mllvm -hwasan-generate-tags-with-calls=1 -mllvm -hwasan-instrument-with-calls=1 -mllvm -hwasan-use-short-granules=0 -mllvm -hwasan-memory-access-callback-prefix=__asan_
    KASAN_DEFAULT_CFLAGS = -DKASAN=1 -DKASAN_CLASSIC=1 -fsanitize=address -mllvm -asan-globals-live-support -mllvm -asan-force-dynamic-shadow
    KEEP_PRIVATE_EXTERNS = NO
    LD_DEPENDENCY_INFO_FILE = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch/Pulsum_dependency_info.dat
    LD_EXPORT_GLOBAL_SYMBOLS = YES
    LD_EXPORT_SYMBOLS = YES
    LD_GENERATE_MAP_FILE = NO
    LD_MAP_FILE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Pulsum-LinkMap-normal-undefined_arch.txt
    LD_NO_PIE = NO
    LD_QUOTE_LINKER_ARGUMENTS_FOR_COMPILER_DRIVER = YES
    LD_RUNPATH_SEARCH_PATHS =  @executable_path/Frameworks
    LD_RUNPATH_SEARCH_PATHS_YES = @loader_path/../Frameworks
    LD_SHARED_CACHE_ELIGIBLE = Automatic
    LD_WARN_DUPLICATE_LIBRARIES = NO
    LD_WARN_UNUSED_DYLIBS = NO
    LEGACY_DEVELOPER_DIR = /Applications/Xcode.app/Contents/PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer
    LEX = lex
    LIBRARY_DEXT_INSTALL_PATH = /Library/DriverExtensions
    LIBRARY_FLAG_NOSPACE = YES
    LIBRARY_FLAG_PREFIX = -l
    LIBRARY_KEXT_INSTALL_PATH = /Library/Extensions
    LIBRARY_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    LINKER_DISPLAYS_MANGLED_NAMES = NO
    LINK_FILE_LIST_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.LinkFileList
    LINK_OBJC_RUNTIME = YES
    LINK_WITH_STANDARD_LIBRARIES = YES
    LLVM_TARGET_TRIPLE_OS_VERSION = ios26.0
    LLVM_TARGET_TRIPLE_VENDOR = apple
    LM_AUX_CONST_METADATA_LIST_PATH_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.SwiftConstValuesFileList
    LOCALIZATION_EXPORT_SUPPORTED = YES
    LOCALIZATION_PREFERS_STRING_CATALOGS = YES
    LOCALIZED_RESOURCES_FOLDER_PATH = Pulsum.app/en.lproj
    LOCALIZED_STRING_MACRO_NAMES = NSLocalizedString CFCopyLocalizedString
    LOCALIZED_STRING_SWIFTUI_SUPPORT = YES
    LOCAL_ADMIN_APPS_DIR = /Applications/Utilities
    LOCAL_APPS_DIR = /Applications
    LOCAL_DEVELOPER_DIR = /Library/Developer
    LOCAL_LIBRARY_DIR = /Library
    LOCROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    LOCSYMROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    MACH_O_TYPE = mh_execute
    MACOSX_DEPLOYMENT_TARGET = 26.1
    MAC_OS_X_PRODUCT_BUILD_VERSION = 25C56
    MAC_OS_X_VERSION_ACTUAL = 260200
    MAC_OS_X_VERSION_MAJOR = 260000
    MAC_OS_X_VERSION_MINOR = 260200
    MAKE_MERGEABLE = NO
    MARKETING_VERSION = 1.0
    MERGEABLE_LIBRARY = NO
    MERGED_BINARY_TYPE = none
    MERGE_LINKED_LIBRARIES = NO
    METAL_LIBRARY_FILE_BASE = default
    METAL_LIBRARY_OUTPUT_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/Pulsum.app
    MODULES_FOLDER_PATH = Pulsum.app/Modules
    MODULE_CACHE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/ModuleCache.noindex
    MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE
    MTL_FAST_MATH = YES
    NATIVE_ARCH = arm64
    NATIVE_ARCH_32_BIT = arm
    NATIVE_ARCH_64_BIT = arm64
    NATIVE_ARCH_ACTUAL = arm64
    NO_COMMON = YES
    OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects
    OBJECT_FILE_DIR_normal = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal
    OBJROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    ONLY_ACTIVE_ARCH = YES
    OS = MACOS
    OSAC = /usr/bin/osacompile
    PACKAGE_TYPE = com.apple.package-type.wrapper.application
    PASCAL_STRINGS = YES
    PATH = /Applications/Xcode.app/Contents/SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildService.bundle/Contents/PlugIns/SWBUniversalPlatformPlugin.bundle/Contents/Frameworks/SWBUniversalPlatform.framework/Resources:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/local/bin:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/libexec:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/local/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/local/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/local/bin:/Library/Frameworks/Python.framework/Versions/3.13/bin:/Library/Frameworks/Python.framework/Versions/3.12/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/Library/TeX/texbin:/Users/martin.demel/.codex/tmp/path/codex-arg0ZXyiPF:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/martin.demel/.codeium/windsurf/bin:/usr/local/opt/python@3.11/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/martin.demel/.lmstudio/bin:/Users/martin.demel/.cursor/extensions/openai.chatgpt-0.4.66-universal/bin/macos-aarch64
    PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES = /usr/include /usr/local/include /System/Library/Frameworks /System/Library/PrivateFrameworks /Applications/Xcode.app/Contents/Developer/Headers /Applications/Xcode.app/Contents/Developer/SDKs /Applications/Xcode.app/Contents/Developer/Platforms
    PBDEVELOPMENTPLIST_PATH = Pulsum.app/pbdevelopment.plist
    PER_ARCH_MODULE_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    PER_ARCH_OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    PER_VARIANT_OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal
    PKGINFO_FILE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/PkgInfo
    PKGINFO_PATH = Pulsum.app/PkgInfo
    PLATFORM_DEVELOPER_APPLICATIONS_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Applications
    PLATFORM_DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin
    PLATFORM_DEVELOPER_LIBRARY_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library
    PLATFORM_DEVELOPER_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs
    PLATFORM_DEVELOPER_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Tools
    PLATFORM_DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr
    PLATFORM_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform
    PLATFORM_DISPLAY_NAME = iOS
    PLATFORM_FAMILY_NAME = iOS
    PLATFORM_NAME = iphoneos
    PLATFORM_PREFERRED_ARCH = arm64
    PLATFORM_PRODUCT_BUILD_VERSION = 23B77
    PLATFORM_REQUIRES_SWIFT_AUTOLINK_EXTRACT = NO
    PLATFORM_REQUIRES_SWIFT_MODULEWRAP = NO
    PLIST_FILE_OUTPUT_FORMAT = binary
    PLUGINS_FOLDER_PATH = Pulsum.app/PlugIns
    PRECOMPS_INCLUDE_HEADERS_FROM_BUILT_PRODUCTS_DIR = YES
    PRECOMP_DESTINATION_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/PrefixHeaders
    PRIVATE_HEADERS_FOLDER_PATH = Pulsum.app/PrivateHeaders
    PROCESSED_INFOPLIST_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch/Processed-Info.plist
    PRODUCT_BUNDLE_IDENTIFIER = ai.pulsum.Pulsum
    PRODUCT_BUNDLE_PACKAGE_TYPE = APPL
    PRODUCT_MODULE_NAME = Pulsum
    PRODUCT_NAME = Pulsum
    PRODUCT_SETTINGS_PATH = 
    PRODUCT_TYPE = com.apple.product-type.application
    PROFILING_CODE = NO
    PROJECT = Pulsum
    PROJECT_DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/DerivedSources
    PROJECT_DIR = /Users/martin.demel/Desktop/PULSUM/Pulsum
    PROJECT_FILE_PATH = /Users/martin.demel/Desktop/PULSUM/Pulsum/Pulsum.xcodeproj
    PROJECT_GUID = 8a2ebb52ff332eacb0b1d430ce5478d8
    PROJECT_NAME = Pulsum
    PROJECT_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build
    PROJECT_TEMP_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    PROVISIONING_PROFILE_REQUIRED = YES
    PROVISIONING_PROFILE_REQUIRED_YES_YES = YES
    PROVISIONING_PROFILE_SUPPORTED = YES
    PUBLIC_HEADERS_FOLDER_PATH = Pulsum.app/Headers
    RECOMMENDED_IPHONEOS_DEPLOYMENT_TARGET = 15.0
    RECURSIVE_SEARCH_PATHS_FOLLOW_SYMLINKS = YES
    REMOVE_CVS_FROM_RESOURCES = YES
    REMOVE_GIT_FROM_RESOURCES = YES
    REMOVE_HEADERS_FROM_EMBEDDED_BUNDLES = YES
    REMOVE_HG_FROM_RESOURCES = YES
    REMOVE_STATIC_EXECUTABLES_FROM_EMBEDDED_BUNDLES = YES
    REMOVE_SVN_FROM_RESOURCES = YES
    RESCHEDULE_INDEPENDENT_HEADERS_PHASES = YES
    REZ_COLLECTOR_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/ResourceManagerResources
    REZ_OBJECTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/ResourceManagerResources/Objects
    REZ_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    RUNTIME_EXCEPTION_ALLOW_DYLD_ENVIRONMENT_VARIABLES = NO
    RUNTIME_EXCEPTION_ALLOW_JIT = NO
    RUNTIME_EXCEPTION_ALLOW_UNSIGNED_EXECUTABLE_MEMORY = NO
    RUNTIME_EXCEPTION_DEBUGGING_TOOL = NO
    RUNTIME_EXCEPTION_DISABLE_EXECUTABLE_PAGE_PROTECTION = NO
    RUNTIME_EXCEPTION_DISABLE_LIBRARY_VALIDATION = NO
    SCAN_ALL_SOURCE_FILES_FOR_INCLUDES = NO
    SCRIPTS_FOLDER_PATH = Pulsum.app/Scripts
    SDKROOT = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR_iphoneos = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR_iphoneos26_1 = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_NAME = iphoneos26.1
    SDK_NAMES = iphoneos26.1
    SDK_PRODUCT_BUILD_VERSION = 23B77
    SDK_STAT_CACHE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData
    SDK_STAT_CACHE_ENABLE = YES
    SDK_STAT_CACHE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/SDKStatCaches.noindex/iphoneos26.1-23B77-69b33fc7382b27d9b5d46e82a00f8e78.sdkstatcache
    SDK_VERSION = 26.1
    SDK_VERSION_ACTUAL = 260100
    SDK_VERSION_MAJOR = 260000
    SDK_VERSION_MINOR = 260100
    SED = /usr/bin/sed
    SEPARATE_STRIP = NO
    SEPARATE_SYMBOL_EDIT = NO
    SET_DIR_MODE_OWNER_GROUP = YES
    SET_FILE_MODE_OWNER_GROUP = NO
    SHALLOW_BUNDLE = YES
    SHALLOW_BUNDLE_TRIPLE = ios
    SHALLOW_BUNDLE_ios_macabi = NO
    SHALLOW_BUNDLE_macos = NO
    SHARED_DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/DerivedSources
    SHARED_FRAMEWORKS_FOLDER_PATH = Pulsum.app/SharedFrameworks
    SHARED_PRECOMPS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/PrecompiledHeaders
    SHARED_SUPPORT_FOLDER_PATH = Pulsum.app/SharedSupport
    SKIP_INSTALL = NO
    SOURCE_ROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    SRCROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    STRINGSDATA_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    STRINGSDATA_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    STRINGS_FILE_INFOPLIST_RENAME = YES
    STRINGS_FILE_OUTPUT_ENCODING = binary
    STRING_CATALOG_GENERATE_SYMBOLS = YES
    STRIP_BITCODE_FROM_COPIED_FILES = YES
    STRIP_INSTALLED_PRODUCT = NO
    STRIP_STYLE = all
    STRIP_SWIFT_SYMBOLS = YES
    SUPPORTED_DEVICE_FAMILIES = 1,2
    SUPPORTED_PLATFORMS = iphoneos iphonesimulator
    SUPPORTS_MACCATALYST = NO
    SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = YES
    SUPPORTS_ON_DEMAND_RESOURCES = YES
    SUPPORTS_TEXT_BASED_API = NO
    SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = YES
    SUPPRESS_WARNINGS = NO
    SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG 
    SWIFT_APPROACHABLE_CONCURRENCY = YES
    SWIFT_DEFAULT_ACTOR_ISOLATION = MainActor
    SWIFT_EMIT_CONST_VALUE_PROTOCOLS = AppIntent EntityQuery AppEntity TransientEntity AppEnum AppShortcutProviding AppShortcutsProvider AnyResolverProviding AppIntentsPackage DynamicOptionsProvider _IntentValueRepresentable _AssistantIntentsProvider _GenerativeFunctionExtractable IntentValueQuery Resolver AppExtension ExtensionPointDefining
    SWIFT_EMIT_LOC_STRINGS = YES
    SWIFT_ENABLE_EXPLICIT_MODULES = YES
    SWIFT_OPTIMIZATION_LEVEL = -Onone
    SWIFT_PLATFORM_TARGET_PREFIX = ios
    SWIFT_RESPONSE_FILE_PATH_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.SwiftFileList
    SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES
    SWIFT_VERSION = 5.0
    SYMROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    SYSTEM_ADMIN_APPS_DIR = /Applications/Utilities
    SYSTEM_APPS_DIR = /Applications
    SYSTEM_CORE_SERVICES_DIR = /System/Library/CoreServices
    SYSTEM_DEMOS_DIR = /Applications/Extras
    SYSTEM_DEVELOPER_APPS_DIR = /Applications/Xcode.app/Contents/Developer/Applications
    SYSTEM_DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/usr/bin
    SYSTEM_DEVELOPER_DEMOS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Utilities/Built Examples
    SYSTEM_DEVELOPER_DIR = /Applications/Xcode.app/Contents/Developer
    SYSTEM_DEVELOPER_DOC_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library
    SYSTEM_DEVELOPER_GRAPHICS_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Graphics Tools
    SYSTEM_DEVELOPER_JAVA_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Java Tools
    SYSTEM_DEVELOPER_PERFORMANCE_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Performance Tools
    SYSTEM_DEVELOPER_RELEASENOTES_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/releasenotes
    SYSTEM_DEVELOPER_TOOLS = /Applications/Xcode.app/Contents/Developer/Tools
    SYSTEM_DEVELOPER_TOOLS_DOC_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/documentation/DeveloperTools
    SYSTEM_DEVELOPER_TOOLS_RELEASENOTES_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/releasenotes/DeveloperTools
    SYSTEM_DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/usr
    SYSTEM_DEVELOPER_UTILITIES_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Utilities
    SYSTEM_DEXT_INSTALL_PATH = /System/Library/DriverExtensions
    SYSTEM_DOCUMENTATION_DIR = /Library/Documentation
    SYSTEM_EXTENSIONS_FOLDER_PATH = Pulsum.app/SystemExtensions
    SYSTEM_EXTENSIONS_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Library/SystemExtensions
    SYSTEM_EXTENSIONS_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app/SystemExtensions
    SYSTEM_KEXT_INSTALL_PATH = /System/Library/Extensions
    SYSTEM_LIBRARY_DIR = /System/Library
    TAPI_DEMANGLE = YES
    TAPI_ENABLE_PROJECT_HEADERS = NO
    TAPI_LANGUAGE = objective-c
    TAPI_LANGUAGE_STANDARD = compiler-default
    TAPI_USE_SRCROOT = YES
    TAPI_VERIFY_MODE = Pedantic
    TARGETED_DEVICE_FAMILY = 1,2
    TARGETNAME = Pulsum
    TARGET_BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    TARGET_DEVICE_IDENTIFIER = 00006031-001C519921B8001C
    TARGET_DEVICE_MODEL = Mac15,9
    TARGET_DEVICE_OS_VERSION = 26.2
    TARGET_DEVICE_PLATFORM_NAME = macosx
    TARGET_NAME = Pulsum
    TARGET_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    TEMP_SANDBOX_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/TemporaryTaskSandboxes
    TEST_FRAMEWORK_SEARCH_PATHS =  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Frameworks /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk/Developer/Library/Frameworks
    TEST_LIBRARY_SEARCH_PATHS =  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/lib
    TOOLCHAINS = com.apple.dt.toolchain.XcodeDefault
    TOOLCHAIN_DIR = /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain
    TREAT_MISSING_BASELINES_AS_TEST_FAILURES = NO
    TREAT_MISSING_SCRIPT_PHASE_OUTPUTS_AS_ERRORS = NO
    TVOS_DEPLOYMENT_TARGET = 26.1
    UID = 501
    UNINSTALLED_PRODUCTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/UninstalledProducts
    UNLOCALIZED_RESOURCES_FOLDER_PATH = Pulsum.app
    UNLOCALIZED_RESOURCES_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Resources
    UNLOCALIZED_RESOURCES_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    UNSTRIPPED_PRODUCT = NO
    USER = martin.demel
    USER_APPS_DIR = /Users/martin.demel/Applications
    USER_LIBRARY_DIR = /Users/martin.demel/Library
    USE_DYNAMIC_NO_PIC = YES
    USE_HEADERMAP = YES
    USE_HEADER_SYMLINKS = NO
    VALIDATE_DEVELOPMENT_ASSET_PATHS = YES_ERROR
    VALIDATE_PRODUCT = NO
    VALID_ARCHS = arm64 arm64e armv7 armv7s
    VERBOSE_PBXCP = NO
    VERSIONPLIST_PATH = Pulsum.app/version.plist
    VERSION_INFO_BUILDER = martin.demel
    VERSION_INFO_FILE = Pulsum_vers.c
    VERSION_INFO_STRING = "@(#)PROGRAM:Pulsum  PROJECT:Pulsum-1"
    WATCHOS_DEPLOYMENT_TARGET = 26.1
    WORKSPACE_DIR = /Users/martin.demel/Desktop/PULSUM/Pulsum/Pulsum.xcodeproj
    WRAPPER_EXTENSION = app
    WRAPPER_NAME = Pulsum.app
    WRAPPER_SUFFIX = .app
    WRAP_ASSET_PACKS_IN_SEPARATE_DIRECTORIES = NO
    XCODE_APP_SUPPORT_DIR = /Applications/Xcode.app/Contents/Developer/Library/Xcode
    XCODE_PRODUCT_BUILD_VERSION = 17B100
    XCODE_VERSION_ACTUAL = 2611
    XCODE_VERSION_MAJOR = 2600
    XCODE_VERSION_MINOR = 2610
    XPCSERVICES_FOLDER_PATH = Pulsum.app/XPCServices
    XROS_DEPLOYMENT_TARGET = 26.1
    YACC = yacc
    _DISCOVER_COMMAND_LINE_LINKER_INPUTS = YES
    _DISCOVER_COMMAND_LINE_LINKER_INPUTS_INCLUDE_WL = YES
    _LD_MULTIARCH = YES
    _WRAPPER_CONTENTS_DIR_SHALLOW_BUNDLE_NO = /Contents
    _WRAPPER_PARENT_PATH_SHALLOW_BUNDLE_NO = /..
    _WRAPPER_RESOURCES_DIR_SHALLOW_BUNDLE_NO = /Resources
    __DIAGNOSE_DEPRECATED_ARCHS = YES
    __IS_NOT_MACOS = YES
    __IS_NOT_MACOS_macosx = NO
    __IS_NOT_SIMULATOR = YES
    __IS_NOT_SIMULATOR_simulator = NO
    arch = undefined_arch
    variant = normal

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj/project.xcworkspace — scheme Pulsum
- Command: `xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme Pulsum`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme Pulsum

Resolve Package Graph


Resolved source packages:
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local

Build settings for action build and target Pulsum:
    ACTION = build
    AD_HOC_CODE_SIGNING_ALLOWED = NO
    AGGREGATE_TRACKED_DOMAINS = YES
    ALLOW_BUILD_REQUEST_OVERRIDES = NO
    ALLOW_TARGET_PLATFORM_SPECIALIZATION = NO
    ALTERNATE_GROUP = staff
    ALTERNATE_MODE = u+w,go-w,a+rX
    ALTERNATE_OWNER = martin.demel
    ALTERNATIVE_DISTRIBUTION_WEB = NO
    ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO
    ALWAYS_SEARCH_USER_PATHS = NO
    ALWAYS_USE_SEPARATE_HEADERMAPS = NO
    APPLICATION_EXTENSION_API_ONLY = NO
    APPLY_RULES_IN_COPY_FILES = NO
    APPLY_RULES_IN_COPY_HEADERS = NO
    APP_SHORTCUTS_ENABLE_FLEXIBLE_MATCHING = YES
    ARCHS = arm64
    ARCHS_STANDARD = arm64
    ARCHS_STANDARD_32_64_BIT = armv7 arm64
    ARCHS_STANDARD_32_BIT = armv7
    ARCHS_STANDARD_64_BIT = arm64
    ARCHS_STANDARD_INCLUDING_64_BIT = arm64
    ARCHS_UNIVERSAL_IPHONE_OS = armv7 arm64
    ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon
    ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES
    ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor
    ASSETCATALOG_FILTER_FOR_DEVICE_MODEL = MacFamily20,1
    ASSETCATALOG_FILTER_FOR_DEVICE_OS_VERSION = 26.2
    ASSETCATALOG_FILTER_FOR_THINNING_DEVICE_CONFIGURATION = MacFamily20,1
    AUTOMATICALLY_MERGE_DEPENDENCIES = NO
    AUTOMATION_APPLE_EVENTS = NO
    AVAILABLE_PLATFORMS = android appletvos appletvsimulator driverkit iphoneos iphonesimulator macosx qnx watchos watchsimulator webassembly xros xrsimulator
    BUILD_ACTIVE_RESOURCES_ONLY = YES
    BUILD_COMPONENTS = headers build
    BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    BUILD_LIBRARY_FOR_DISTRIBUTION = NO
    BUILD_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    BUILD_STYLE = 
    BUILD_VARIANTS = normal
    BUILT_PRODUCTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    BUNDLE_CONTENTS_FOLDER_PATH_deep = Contents/
    BUNDLE_EXECUTABLE_FOLDER_NAME_deep = MacOS
    BUNDLE_EXTENSIONS_FOLDER_PATH = Extensions
    BUNDLE_FORMAT = shallow
    BUNDLE_FRAMEWORKS_FOLDER_PATH = Frameworks
    BUNDLE_PLUGINS_FOLDER_PATH = PlugIns
    BUNDLE_PRIVATE_HEADERS_FOLDER_PATH = PrivateHeaders
    BUNDLE_PUBLIC_HEADERS_FOLDER_PATH = Headers
    CACHE_ROOT = /var/folders/m_/nqk8g4cs5tz8t1yj2kglt8p80000gn/C/com.apple.DeveloperTools/26.1.1-17B100/Xcode
    CCHROOT = /var/folders/m_/nqk8g4cs5tz8t1yj2kglt8p80000gn/C/com.apple.DeveloperTools/26.1.1-17B100/Xcode
    CHMOD = /bin/chmod
    CHOWN = /usr/sbin/chown
    CLANG_ANALYZER_NONNULL = YES
    CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE
    CLANG_CACHE_FINE_GRAINED_OUTPUTS = YES
    CLANG_COVERAGE_MAPPING = YES
    CLANG_CXX_LANGUAGE_STANDARD = gnu++20
    CLANG_ENABLE_EXPLICIT_MODULES = YES
    CLANG_ENABLE_MODULES = YES
    CLANG_ENABLE_OBJC_ARC = YES
    CLANG_ENABLE_OBJC_WEAK = YES
    CLANG_MODULES_BUILD_SESSION_FILE = /Users/martin.demel/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation
    CLANG_PROFILE_DATA_DIRECTORY = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/ProfileData
    CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES
    CLANG_WARN_BOOL_CONVERSION = YES
    CLANG_WARN_COMMA = YES
    CLANG_WARN_CONSTANT_CONVERSION = YES
    CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES
    CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR
    CLANG_WARN_DOCUMENTATION_COMMENTS = YES
    CLANG_WARN_EMPTY_BODY = YES
    CLANG_WARN_ENUM_CONVERSION = YES
    CLANG_WARN_INFINITE_RECURSION = YES
    CLANG_WARN_INT_CONVERSION = YES
    CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES
    CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
    CLANG_WARN_OBJC_LITERAL_CONVERSION = YES
    CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR
    CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES
    CLANG_WARN_RANGE_LOOP_ANALYSIS = YES
    CLANG_WARN_STRICT_PROTOTYPES = YES
    CLANG_WARN_SUSPICIOUS_MOVE = YES
    CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
    CLANG_WARN_UNREACHABLE_CODE = YES
    CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
    CLASS_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/JavaClasses
    CLEAN_PRECOMPS = YES
    CLONE_HEADERS = NO
    CODESIGNING_FOLDER_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/Pulsum.app
    CODE_SIGNING_ALLOWED = YES
    CODE_SIGNING_REQUIRED = YES
    CODE_SIGN_CONTEXT_CLASS = XCiPhoneOSCodeSignContext
    CODE_SIGN_ENTITLEMENTS = Pulsum/Pulsum.entitlements
    CODE_SIGN_IDENTITY = Apple Development
    CODE_SIGN_INJECT_BASE_ENTITLEMENTS = YES
    CODE_SIGN_STYLE = Automatic
    COLOR_DIAGNOSTICS = NO
    COMBINE_HIDPI_IMAGES = NO
    COMPILATION_CACHE_CAS_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/CompilationCache.noindex
    COMPILATION_CACHE_KEEP_CAS_DIRECTORY = YES
    COMPILER_INDEX_STORE_ENABLE = Default
    COMPOSITE_SDK_DIRS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/CompositeSDKs
    COMPRESS_PNG_FILES = YES
    CONFIGURATION = Debug
    CONFIGURATION_BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    CONFIGURATION_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos
    CONTENTS_FOLDER_PATH = Pulsum.app
    CONTENTS_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Contents
    CONTENTS_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    COPYING_PRESERVES_HFS_DATA = NO
    COPY_HEADERS_RUN_UNIFDEF = NO
    COPY_PHASE_STRIP = NO
    CORRESPONDING_SIMULATOR_PLATFORM_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform
    CORRESPONDING_SIMULATOR_PLATFORM_NAME = iphonesimulator
    CORRESPONDING_SIMULATOR_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator26.1.sdk
    CORRESPONDING_SIMULATOR_SDK_NAME = iphonesimulator26.1
    CP = /bin/cp
    CREATE_INFOPLIST_SECTION_IN_BINARY = NO
    CURRENT_ARCH = undefined_arch
    CURRENT_PROJECT_VERSION = 1
    CURRENT_VARIANT = normal
    DEAD_CODE_STRIPPING = YES
    DEBUGGING_SYMBOLS = YES
    DEBUG_INFORMATION_FORMAT = dwarf
    DEBUG_INFORMATION_VERSION = compiler-default
    DEFAULT_COMPILER = com.apple.compilers.llvm.clang.1_0
    DEFAULT_DEXT_INSTALL_PATH = /System/Library/DriverExtensions
    DEFAULT_KEXT_INSTALL_PATH = /System/Library/Extensions
    DEFINES_MODULE = NO
    DEPLOYMENT_LOCATION = NO
    DEPLOYMENT_POSTPROCESSING = NO
    DEPLOYMENT_TARGET_SETTING_NAME = IPHONEOS_DEPLOYMENT_TARGET
    DEPLOYMENT_TARGET_SUGGESTED_VALUES = 12.0 12.1 12.2 12.3 12.4 13.0 13.1 13.2 13.3 13.4 13.5 13.6 14.0 14.1 14.2 14.3 14.4 14.5 14.6 14.7 15.0 15.1 15.2 15.3 15.4 15.5 15.6 16.0 16.1 16.2 16.3 16.4 16.5 16.6 17.0 17.1 17.2 17.3 17.4 17.5 17.6 18.0 18.1 18.2 18.3 18.4 18.5 18.6 26.0 26.1
    DERIVED_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVED_SOURCES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVE_MACCATALYST_PRODUCT_BUNDLE_IDENTIFIER = NO
    DEVELOPER_APPLICATIONS_DIR = /Applications/Xcode.app/Contents/Developer/Applications
    DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/usr/bin
    DEVELOPER_DIR = /Applications/Xcode.app/Contents/Developer
    DEVELOPER_FRAMEWORKS_DIR = /Applications/Xcode.app/Contents/Developer/Library/Frameworks
    DEVELOPER_FRAMEWORKS_DIR_QUOTED = /Applications/Xcode.app/Contents/Developer/Library/Frameworks
    DEVELOPER_LIBRARY_DIR = /Applications/Xcode.app/Contents/Developer/Library
    DEVELOPER_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs
    DEVELOPER_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Tools
    DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/usr
    DEVELOPMENT_LANGUAGE = en
    DEVELOPMENT_TEAM = X6FJFZCXY3
    DIAGNOSE_MISSING_TARGET_DEPENDENCIES = YES
    DIFF = /usr/bin/diff
    DOCUMENTATION_FOLDER_PATH = Pulsum.app/en.lproj/Documentation
    DONT_GENERATE_INFOPLIST_FILE = NO
    DRIVERKIT_DEPLOYMENT_TARGET = 25.1
    DSTROOT = /tmp/Pulsum.dst
    DT_TOOLCHAIN_DIR = /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain
    DWARF_DSYM_FILE_NAME = Pulsum.app.dSYM
    DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT = NO
    DWARF_DSYM_FOLDER_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    DYNAMIC_LIBRARY_EXTENSION = dylib
    EAGER_COMPILATION_ALLOW_SCRIPTS = YES
    EAGER_LINKING = NO
    EFFECTIVE_PLATFORM_NAME = -iphoneos
    EMBEDDED_CONTENT_CONTAINS_SWIFT = NO
    EMBEDDED_PROFILE_NAME = embedded.mobileprovision
    EMBED_ASSET_PACKS_IN_PRODUCT_BUNDLE = NO
    ENABLE_APP_SANDBOX = NO
    ENABLE_CODE_COVERAGE = YES
    ENABLE_CPLUSPLUS_BOUNDS_SAFE_BUFFERS = NO
    ENABLE_C_BOUNDS_SAFETY = NO
    ENABLE_DEBUG_DYLIB = YES
    ENABLE_DEFAULT_HEADER_SEARCH_PATHS = YES
    ENABLE_DEFAULT_SEARCH_PATHS = YES
    ENABLE_ENHANCED_SECURITY = NO
    ENABLE_HARDENED_RUNTIME = NO
    ENABLE_HEADER_DEPENDENCIES = YES
    ENABLE_INCOMING_NETWORK_CONNECTIONS = NO
    ENABLE_ON_DEMAND_RESOURCES = YES
    ENABLE_OUTGOING_NETWORK_CONNECTIONS = NO
    ENABLE_POINTER_AUTHENTICATION = NO
    ENABLE_PREVIEWS = YES
    ENABLE_RESOURCE_ACCESS_AUDIO_INPUT = NO
    ENABLE_RESOURCE_ACCESS_BLUETOOTH = NO
    ENABLE_RESOURCE_ACCESS_CALENDARS = NO
    ENABLE_RESOURCE_ACCESS_CAMERA = NO
    ENABLE_RESOURCE_ACCESS_CONTACTS = NO
    ENABLE_RESOURCE_ACCESS_LOCATION = NO
    ENABLE_RESOURCE_ACCESS_PHOTO_LIBRARY = NO
    ENABLE_RESOURCE_ACCESS_PRINTING = NO
    ENABLE_RESOURCE_ACCESS_USB = NO
    ENABLE_SDK_IMPORTS = NO
    ENABLE_SECURITY_COMPILER_WARNINGS = NO
    ENABLE_STRICT_OBJC_MSGSEND = YES
    ENABLE_TESTABILITY = YES
    ENABLE_TESTING_SEARCH_PATHS = NO
    ENABLE_THREAD_SANITIZER = NO
    ENABLE_USER_SCRIPT_SANDBOXING = YES
    ENFORCE_VALID_ARCHS = YES
    ENTITLEMENTS_ALLOWED = YES
    ENTITLEMENTS_DESTINATION = Signature
    ENTITLEMENTS_REQUIRED = NO
    EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS = .DS_Store .svn .git .hg CVS
    EXCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES = *.nib *.lproj *.framework *.gch *.xcode* *.xcassets *.icon (*) .DS_Store CVS .svn .git .hg *.pbproj *.pbxproj
    EXECUTABLES_FOLDER_PATH = Pulsum.app/Executables
    EXECUTABLE_FOLDER_PATH = Pulsum.app
    EXECUTABLE_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/MacOS
    EXECUTABLE_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    EXECUTABLE_NAME = Pulsum
    EXECUTABLE_PATH = Pulsum.app/Pulsum
    EXTENSIONS_FOLDER_PATH = Pulsum.app/Extensions
    FILE_LIST = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects/LinkFileList
    FIXED_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/FixedFiles
    FRAMEWORKS_FOLDER_PATH = Pulsum.app/Frameworks
    FRAMEWORK_FLAG_PREFIX = -framework
    FRAMEWORK_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    FRAMEWORK_VERSION = A
    FULL_PRODUCT_NAME = Pulsum.app
    FUSE_BUILD_PHASES = YES
    FUSE_BUILD_SCRIPT_PHASES = NO
    GCC3_VERSION = 3.3
    GCC_C_LANGUAGE_STANDARD = gnu17
    GCC_DYNAMIC_NO_PIC = NO
    GCC_INLINES_ARE_PRIVATE_EXTERN = YES
    GCC_NO_COMMON_BLOCKS = YES
    GCC_OPTIMIZATION_LEVEL = 0
    GCC_PFE_FILE_C_DIALECTS = c objective-c c++ objective-c++
    GCC_PREPROCESSOR_DEFINITIONS = DEBUG=1 
    GCC_SYMBOLS_PRIVATE_EXTERN = NO
    GCC_THUMB_SUPPORT = YES
    GCC_TREAT_WARNINGS_AS_ERRORS = NO
    GCC_VERSION = com.apple.compilers.llvm.clang.1_0
    GCC_VERSION_IDENTIFIER = com_apple_compilers_llvm_clang_1_0
    GCC_WARN_64_TO_32_BIT_CONVERSION = YES
    GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR
    GCC_WARN_UNDECLARED_SELECTOR = YES
    GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE
    GCC_WARN_UNUSED_FUNCTION = YES
    GCC_WARN_UNUSED_VARIABLE = YES
    GENERATED_MODULEMAP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/GeneratedModuleMaps-iphoneos
    GENERATE_INFOPLIST_FILE = YES
    GENERATE_INTERMEDIATE_TEXT_BASED_STUBS = YES
    GENERATE_PKGINFO_FILE = YES
    GENERATE_PRELINK_OBJECT_FILE = NO
    GENERATE_PROFILING_CODE = NO
    GENERATE_TEXT_BASED_STUBS = NO
    GID = 20
    GROUP = staff
    HEADERMAP_INCLUDES_FLAT_ENTRIES_FOR_TARGET_BEING_BUILT = YES
    HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_ALL_PRODUCT_TYPES = YES
    HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_TARGETS_NOT_BEING_BUILT = YES
    HEADERMAP_INCLUDES_NONPUBLIC_NONPRIVATE_HEADERS = YES
    HEADERMAP_INCLUDES_PROJECT_HEADERS = YES
    HEADERMAP_USES_FRAMEWORK_PREFIX_ENTRIES = YES
    HEADERMAP_USES_VFS = NO
    HEADER_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/include 
    HOME = /Users/martin.demel
    HOST_ARCH = arm64
    HOST_PLATFORM = macosx
    ICONV = /usr/bin/iconv
    IMPLICIT_DEPENDENCY_DOMAIN = default
    INFOPLIST_ENABLE_CFBUNDLEICONS_MERGE = YES
    INFOPLIST_EXPAND_BUILD_SETTINGS = YES
    INFOPLIST_KEY_ITSAppUsesNonExemptEncryption = NO
    INFOPLIST_KEY_NSHealthShareUsageDescription = Pulsum reads key wellness metrics like HRV and sleep to personalize your coaching.
    INFOPLIST_KEY_NSHealthUpdateUsageDescription = Pulsum references your recent trends to surface the most helpful guidance.
    INFOPLIST_KEY_NSMicrophoneUsageDescription = Pulsum uses the microphone to capture on-device voice journals.
    INFOPLIST_KEY_NSSpeechRecognitionUsageDescription = Pulsum transcribes your voice journals on-device to keep coaching relevant.
    INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES
    INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES
    INFOPLIST_KEY_UILaunchScreen_Generation = YES
    INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight
    INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight
    INFOPLIST_OUTPUT_FORMAT = binary
    INFOPLIST_PATH = Pulsum.app/Info.plist
    INFOPLIST_PREPROCESS = NO
    INFOSTRINGS_PATH = Pulsum.app/en.lproj/InfoPlist.strings
    INLINE_PRIVATE_FRAMEWORKS = NO
    INSTALLAPI_IGNORE_SKIP_INSTALL = YES
    INSTALLHDRS_COPY_PHASE = NO
    INSTALLHDRS_SCRIPT_PHASE = NO
    INSTALL_DIR = /tmp/Pulsum.dst/Applications
    INSTALL_GROUP = staff
    INSTALL_MODE_FLAG = u+w,go-w,a+rX
    INSTALL_OWNER = martin.demel
    INSTALL_PATH = /Applications
    INSTALL_ROOT = /tmp/Pulsum.dst
    IPHONEOS_DEPLOYMENT_TARGET = 26.0
    IS_UNOPTIMIZED_BUILD = YES
    JAVAC_DEFAULT_FLAGS = -J-Xms64m -J-XX:NewSize=4M -J-Dfile.encoding=UTF8
    JAVA_APP_STUB = /System/Library/Frameworks/JavaVM.framework/Resources/MacOS/JavaApplicationStub
    JAVA_ARCHIVE_CLASSES = YES
    JAVA_ARCHIVE_TYPE = JAR
    JAVA_COMPILER = /usr/bin/javac
    JAVA_FOLDER_PATH = Pulsum.app/Java
    JAVA_FRAMEWORK_RESOURCES_DIRS = Resources
    JAVA_JAR_FLAGS = cv
    JAVA_SOURCE_SUBDIR = .
    JAVA_USE_DEPENDENCIES = YES
    JAVA_ZIP_FLAGS = -urg
    JIKES_DEFAULT_FLAGS = +E +OLDCSO
    KASAN_CFLAGS_CLASSIC = -DKASAN=1 -DKASAN_CLASSIC=1 -fsanitize=address -mllvm -asan-globals-live-support -mllvm -asan-force-dynamic-shadow
    KASAN_CFLAGS_TBI = -DKASAN=1 -DKASAN_TBI=1 -fsanitize=kernel-hwaddress -mllvm -hwasan-recover=0 -mllvm -hwasan-instrument-atomics=0 -mllvm -hwasan-instrument-stack=1 -mllvm -hwasan-generate-tags-with-calls=1 -mllvm -hwasan-instrument-with-calls=1 -mllvm -hwasan-use-short-granules=0 -mllvm -hwasan-memory-access-callback-prefix=__asan_
    KASAN_DEFAULT_CFLAGS = -DKASAN=1 -DKASAN_CLASSIC=1 -fsanitize=address -mllvm -asan-globals-live-support -mllvm -asan-force-dynamic-shadow
    KEEP_PRIVATE_EXTERNS = NO
    LD_DEPENDENCY_INFO_FILE = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch/Pulsum_dependency_info.dat
    LD_EXPORT_GLOBAL_SYMBOLS = YES
    LD_EXPORT_SYMBOLS = YES
    LD_GENERATE_MAP_FILE = NO
    LD_MAP_FILE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Pulsum-LinkMap-normal-undefined_arch.txt
    LD_NO_PIE = NO
    LD_QUOTE_LINKER_ARGUMENTS_FOR_COMPILER_DRIVER = YES
    LD_RUNPATH_SEARCH_PATHS =  @executable_path/Frameworks
    LD_RUNPATH_SEARCH_PATHS_YES = @loader_path/../Frameworks
    LD_SHARED_CACHE_ELIGIBLE = Automatic
    LD_WARN_DUPLICATE_LIBRARIES = NO
    LD_WARN_UNUSED_DYLIBS = NO
    LEGACY_DEVELOPER_DIR = /Applications/Xcode.app/Contents/PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer
    LEX = lex
    LIBRARY_DEXT_INSTALL_PATH = /Library/DriverExtensions
    LIBRARY_FLAG_NOSPACE = YES
    LIBRARY_FLAG_PREFIX = -l
    LIBRARY_KEXT_INSTALL_PATH = /Library/Extensions
    LIBRARY_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    LINKER_DISPLAYS_MANGLED_NAMES = NO
    LINK_FILE_LIST_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.LinkFileList
    LINK_OBJC_RUNTIME = YES
    LINK_WITH_STANDARD_LIBRARIES = YES
    LLVM_TARGET_TRIPLE_OS_VERSION = ios26.0
    LLVM_TARGET_TRIPLE_VENDOR = apple
    LM_AUX_CONST_METADATA_LIST_PATH_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.SwiftConstValuesFileList
    LOCALIZATION_EXPORT_SUPPORTED = YES
    LOCALIZATION_PREFERS_STRING_CATALOGS = YES
    LOCALIZED_RESOURCES_FOLDER_PATH = Pulsum.app/en.lproj
    LOCALIZED_STRING_MACRO_NAMES = NSLocalizedString CFCopyLocalizedString
    LOCALIZED_STRING_SWIFTUI_SUPPORT = YES
    LOCAL_ADMIN_APPS_DIR = /Applications/Utilities
    LOCAL_APPS_DIR = /Applications
    LOCAL_DEVELOPER_DIR = /Library/Developer
    LOCAL_LIBRARY_DIR = /Library
    LOCROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    LOCSYMROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    MACH_O_TYPE = mh_execute
    MACOSX_DEPLOYMENT_TARGET = 26.1
    MAC_OS_X_PRODUCT_BUILD_VERSION = 25C56
    MAC_OS_X_VERSION_ACTUAL = 260200
    MAC_OS_X_VERSION_MAJOR = 260000
    MAC_OS_X_VERSION_MINOR = 260200
    MAKE_MERGEABLE = NO
    MARKETING_VERSION = 1.0
    MERGEABLE_LIBRARY = NO
    MERGED_BINARY_TYPE = none
    MERGE_LINKED_LIBRARIES = NO
    METAL_LIBRARY_FILE_BASE = default
    METAL_LIBRARY_OUTPUT_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/Pulsum.app
    MODULES_FOLDER_PATH = Pulsum.app/Modules
    MODULE_CACHE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/ModuleCache.noindex
    MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE
    MTL_FAST_MATH = YES
    NATIVE_ARCH = arm64
    NATIVE_ARCH_32_BIT = arm
    NATIVE_ARCH_64_BIT = arm64
    NATIVE_ARCH_ACTUAL = arm64
    NO_COMMON = YES
    OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects
    OBJECT_FILE_DIR_normal = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal
    OBJROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    ONLY_ACTIVE_ARCH = YES
    OS = MACOS
    OSAC = /usr/bin/osacompile
    PACKAGE_TYPE = com.apple.package-type.wrapper.application
    PASCAL_STRINGS = YES
    PATH = /Applications/Xcode.app/Contents/SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildService.bundle/Contents/PlugIns/SWBUniversalPlatformPlugin.bundle/Contents/Frameworks/SWBUniversalPlatform.framework/Resources:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/local/bin:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/libexec:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/local/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/local/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/local/bin:/Library/Frameworks/Python.framework/Versions/3.13/bin:/Library/Frameworks/Python.framework/Versions/3.12/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/Library/TeX/texbin:/Users/martin.demel/.codex/tmp/path/codex-arg0ZXyiPF:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/martin.demel/.codeium/windsurf/bin:/usr/local/opt/python@3.11/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/martin.demel/.lmstudio/bin:/Users/martin.demel/.cursor/extensions/openai.chatgpt-0.4.66-universal/bin/macos-aarch64
    PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES = /usr/include /usr/local/include /System/Library/Frameworks /System/Library/PrivateFrameworks /Applications/Xcode.app/Contents/Developer/Headers /Applications/Xcode.app/Contents/Developer/SDKs /Applications/Xcode.app/Contents/Developer/Platforms
    PBDEVELOPMENTPLIST_PATH = Pulsum.app/pbdevelopment.plist
    PER_ARCH_MODULE_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    PER_ARCH_OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    PER_VARIANT_OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal
    PKGINFO_FILE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/PkgInfo
    PKGINFO_PATH = Pulsum.app/PkgInfo
    PLATFORM_DEVELOPER_APPLICATIONS_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Applications
    PLATFORM_DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin
    PLATFORM_DEVELOPER_LIBRARY_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library
    PLATFORM_DEVELOPER_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs
    PLATFORM_DEVELOPER_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Tools
    PLATFORM_DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr
    PLATFORM_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform
    PLATFORM_DISPLAY_NAME = iOS
    PLATFORM_FAMILY_NAME = iOS
    PLATFORM_NAME = iphoneos
    PLATFORM_PREFERRED_ARCH = arm64
    PLATFORM_PRODUCT_BUILD_VERSION = 23B77
    PLATFORM_REQUIRES_SWIFT_AUTOLINK_EXTRACT = NO
    PLATFORM_REQUIRES_SWIFT_MODULEWRAP = NO
    PLIST_FILE_OUTPUT_FORMAT = binary
    PLUGINS_FOLDER_PATH = Pulsum.app/PlugIns
    PRECOMPS_INCLUDE_HEADERS_FROM_BUILT_PRODUCTS_DIR = YES
    PRECOMP_DESTINATION_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/PrefixHeaders
    PRIVATE_HEADERS_FOLDER_PATH = Pulsum.app/PrivateHeaders
    PROCESSED_INFOPLIST_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch/Processed-Info.plist
    PRODUCT_BUNDLE_IDENTIFIER = ai.pulsum.Pulsum
    PRODUCT_BUNDLE_PACKAGE_TYPE = APPL
    PRODUCT_MODULE_NAME = Pulsum
    PRODUCT_NAME = Pulsum
    PRODUCT_SETTINGS_PATH = 
    PRODUCT_TYPE = com.apple.product-type.application
    PROFILING_CODE = NO
    PROJECT = Pulsum
    PROJECT_DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/DerivedSources
    PROJECT_DIR = /Users/martin.demel/Desktop/PULSUM/Pulsum
    PROJECT_FILE_PATH = /Users/martin.demel/Desktop/PULSUM/Pulsum/Pulsum.xcodeproj
    PROJECT_GUID = 8a2ebb52ff332eacb0b1d430ce5478d8
    PROJECT_NAME = Pulsum
    PROJECT_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build
    PROJECT_TEMP_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    PROVISIONING_PROFILE_REQUIRED = YES
    PROVISIONING_PROFILE_REQUIRED_YES_YES = YES
    PROVISIONING_PROFILE_SUPPORTED = YES
    PUBLIC_HEADERS_FOLDER_PATH = Pulsum.app/Headers
    RECOMMENDED_IPHONEOS_DEPLOYMENT_TARGET = 15.0
    RECURSIVE_SEARCH_PATHS_FOLLOW_SYMLINKS = YES
    REMOVE_CVS_FROM_RESOURCES = YES
    REMOVE_GIT_FROM_RESOURCES = YES
    REMOVE_HEADERS_FROM_EMBEDDED_BUNDLES = YES
    REMOVE_HG_FROM_RESOURCES = YES
    REMOVE_STATIC_EXECUTABLES_FROM_EMBEDDED_BUNDLES = YES
    REMOVE_SVN_FROM_RESOURCES = YES
    RESCHEDULE_INDEPENDENT_HEADERS_PHASES = YES
    REZ_COLLECTOR_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/ResourceManagerResources
    REZ_OBJECTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/ResourceManagerResources/Objects
    REZ_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    RUNTIME_EXCEPTION_ALLOW_DYLD_ENVIRONMENT_VARIABLES = NO
    RUNTIME_EXCEPTION_ALLOW_JIT = NO
    RUNTIME_EXCEPTION_ALLOW_UNSIGNED_EXECUTABLE_MEMORY = NO
    RUNTIME_EXCEPTION_DEBUGGING_TOOL = NO
    RUNTIME_EXCEPTION_DISABLE_EXECUTABLE_PAGE_PROTECTION = NO
    RUNTIME_EXCEPTION_DISABLE_LIBRARY_VALIDATION = NO
    SCAN_ALL_SOURCE_FILES_FOR_INCLUDES = NO
    SCRIPTS_FOLDER_PATH = Pulsum.app/Scripts
    SDKROOT = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR_iphoneos = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR_iphoneos26_1 = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_NAME = iphoneos26.1
    SDK_NAMES = iphoneos26.1
    SDK_PRODUCT_BUILD_VERSION = 23B77
    SDK_STAT_CACHE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData
    SDK_STAT_CACHE_ENABLE = YES
    SDK_STAT_CACHE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/SDKStatCaches.noindex/iphoneos26.1-23B77-69b33fc7382b27d9b5d46e82a00f8e78.sdkstatcache
    SDK_VERSION = 26.1
    SDK_VERSION_ACTUAL = 260100
    SDK_VERSION_MAJOR = 260000
    SDK_VERSION_MINOR = 260100
    SED = /usr/bin/sed
    SEPARATE_STRIP = NO
    SEPARATE_SYMBOL_EDIT = NO
    SET_DIR_MODE_OWNER_GROUP = YES
    SET_FILE_MODE_OWNER_GROUP = NO
    SHALLOW_BUNDLE = YES
    SHALLOW_BUNDLE_TRIPLE = ios
    SHALLOW_BUNDLE_ios_macabi = NO
    SHALLOW_BUNDLE_macos = NO
    SHARED_DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/DerivedSources
    SHARED_FRAMEWORKS_FOLDER_PATH = Pulsum.app/SharedFrameworks
    SHARED_PRECOMPS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/PrecompiledHeaders
    SHARED_SUPPORT_FOLDER_PATH = Pulsum.app/SharedSupport
    SKIP_INSTALL = NO
    SOURCE_ROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    SRCROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    STRINGSDATA_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    STRINGSDATA_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    STRINGS_FILE_INFOPLIST_RENAME = YES
    STRINGS_FILE_OUTPUT_ENCODING = binary
    STRING_CATALOG_GENERATE_SYMBOLS = YES
    STRIP_BITCODE_FROM_COPIED_FILES = YES
    STRIP_INSTALLED_PRODUCT = NO
    STRIP_STYLE = all
    STRIP_SWIFT_SYMBOLS = YES
    SUPPORTED_DEVICE_FAMILIES = 1,2
    SUPPORTED_PLATFORMS = iphoneos iphonesimulator
    SUPPORTS_MACCATALYST = NO
    SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = YES
    SUPPORTS_ON_DEMAND_RESOURCES = YES
    SUPPORTS_TEXT_BASED_API = NO
    SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = YES
    SUPPRESS_WARNINGS = NO
    SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG 
    SWIFT_APPROACHABLE_CONCURRENCY = YES
    SWIFT_DEFAULT_ACTOR_ISOLATION = MainActor
    SWIFT_EMIT_CONST_VALUE_PROTOCOLS = AppIntent EntityQuery AppEntity TransientEntity AppEnum AppShortcutProviding AppShortcutsProvider AnyResolverProviding AppIntentsPackage DynamicOptionsProvider _IntentValueRepresentable _AssistantIntentsProvider _GenerativeFunctionExtractable IntentValueQuery Resolver AppExtension ExtensionPointDefining
    SWIFT_EMIT_LOC_STRINGS = YES
    SWIFT_ENABLE_EXPLICIT_MODULES = YES
    SWIFT_OPTIMIZATION_LEVEL = -Onone
    SWIFT_PLATFORM_TARGET_PREFIX = ios
    SWIFT_RESPONSE_FILE_PATH_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.SwiftFileList
    SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES
    SWIFT_VERSION = 5.0
    SYMROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    SYSTEM_ADMIN_APPS_DIR = /Applications/Utilities
    SYSTEM_APPS_DIR = /Applications
    SYSTEM_CORE_SERVICES_DIR = /System/Library/CoreServices
    SYSTEM_DEMOS_DIR = /Applications/Extras
    SYSTEM_DEVELOPER_APPS_DIR = /Applications/Xcode.app/Contents/Developer/Applications
    SYSTEM_DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/usr/bin
    SYSTEM_DEVELOPER_DEMOS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Utilities/Built Examples
    SYSTEM_DEVELOPER_DIR = /Applications/Xcode.app/Contents/Developer
    SYSTEM_DEVELOPER_DOC_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library
    SYSTEM_DEVELOPER_GRAPHICS_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Graphics Tools
    SYSTEM_DEVELOPER_JAVA_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Java Tools
    SYSTEM_DEVELOPER_PERFORMANCE_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Performance Tools
    SYSTEM_DEVELOPER_RELEASENOTES_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/releasenotes
    SYSTEM_DEVELOPER_TOOLS = /Applications/Xcode.app/Contents/Developer/Tools
    SYSTEM_DEVELOPER_TOOLS_DOC_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/documentation/DeveloperTools
    SYSTEM_DEVELOPER_TOOLS_RELEASENOTES_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/releasenotes/DeveloperTools
    SYSTEM_DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/usr
    SYSTEM_DEVELOPER_UTILITIES_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Utilities
    SYSTEM_DEXT_INSTALL_PATH = /System/Library/DriverExtensions
    SYSTEM_DOCUMENTATION_DIR = /Library/Documentation
    SYSTEM_EXTENSIONS_FOLDER_PATH = Pulsum.app/SystemExtensions
    SYSTEM_EXTENSIONS_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Library/SystemExtensions
    SYSTEM_EXTENSIONS_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app/SystemExtensions
    SYSTEM_KEXT_INSTALL_PATH = /System/Library/Extensions
    SYSTEM_LIBRARY_DIR = /System/Library
    TAPI_DEMANGLE = YES
    TAPI_ENABLE_PROJECT_HEADERS = NO
    TAPI_LANGUAGE = objective-c
    TAPI_LANGUAGE_STANDARD = compiler-default
    TAPI_USE_SRCROOT = YES
    TAPI_VERIFY_MODE = Pedantic
    TARGETED_DEVICE_FAMILY = 1,2
    TARGETNAME = Pulsum
    TARGET_BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    TARGET_DEVICE_IDENTIFIER = 00006031-001C519921B8001C
    TARGET_DEVICE_MODEL = Mac15,9
    TARGET_DEVICE_OS_VERSION = 26.2
    TARGET_DEVICE_PLATFORM_NAME = macosx
    TARGET_NAME = Pulsum
    TARGET_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    TEMP_SANDBOX_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/TemporaryTaskSandboxes
    TEST_FRAMEWORK_SEARCH_PATHS =  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Frameworks /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk/Developer/Library/Frameworks
    TEST_LIBRARY_SEARCH_PATHS =  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/lib
    TOOLCHAINS = com.apple.dt.toolchain.XcodeDefault
    TOOLCHAIN_DIR = /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain
    TREAT_MISSING_BASELINES_AS_TEST_FAILURES = NO
    TREAT_MISSING_SCRIPT_PHASE_OUTPUTS_AS_ERRORS = NO
    TVOS_DEPLOYMENT_TARGET = 26.1
    UID = 501
    UNINSTALLED_PRODUCTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/UninstalledProducts
    UNLOCALIZED_RESOURCES_FOLDER_PATH = Pulsum.app
    UNLOCALIZED_RESOURCES_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Resources
    UNLOCALIZED_RESOURCES_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    UNSTRIPPED_PRODUCT = NO
    USER = martin.demel
    USER_APPS_DIR = /Users/martin.demel/Applications
    USER_LIBRARY_DIR = /Users/martin.demel/Library
    USE_DYNAMIC_NO_PIC = YES
    USE_HEADERMAP = YES
    USE_HEADER_SYMLINKS = NO
    VALIDATE_DEVELOPMENT_ASSET_PATHS = YES_ERROR
    VALIDATE_PRODUCT = NO
    VALID_ARCHS = arm64 arm64e armv7 armv7s
    VERBOSE_PBXCP = NO
    VERSIONPLIST_PATH = Pulsum.app/version.plist
    VERSION_INFO_BUILDER = martin.demel
    VERSION_INFO_FILE = Pulsum_vers.c
    VERSION_INFO_STRING = "@(#)PROGRAM:Pulsum  PROJECT:Pulsum-1"
    WATCHOS_DEPLOYMENT_TARGET = 26.1
    WORKSPACE_DIR = /Users/martin.demel/Desktop/PULSUM/Pulsum/Pulsum.xcodeproj
    WRAPPER_EXTENSION = app
    WRAPPER_NAME = Pulsum.app
    WRAPPER_SUFFIX = .app
    WRAP_ASSET_PACKS_IN_SEPARATE_DIRECTORIES = NO
    XCODE_APP_SUPPORT_DIR = /Applications/Xcode.app/Contents/Developer/Library/Xcode
    XCODE_PRODUCT_BUILD_VERSION = 17B100
    XCODE_VERSION_ACTUAL = 2611
    XCODE_VERSION_MAJOR = 2600
    XCODE_VERSION_MINOR = 2610
    XPCSERVICES_FOLDER_PATH = Pulsum.app/XPCServices
    XROS_DEPLOYMENT_TARGET = 26.1
    YACC = yacc
    _DISCOVER_COMMAND_LINE_LINKER_INPUTS = YES
    _DISCOVER_COMMAND_LINE_LINKER_INPUTS_INCLUDE_WL = YES
    _LD_MULTIARCH = YES
    _WRAPPER_CONTENTS_DIR_SHALLOW_BUNDLE_NO = /Contents
    _WRAPPER_PARENT_PATH_SHALLOW_BUNDLE_NO = /..
    _WRAPPER_RESOURCES_DIR_SHALLOW_BUNDLE_NO = /Resources
    __DIAGNOSE_DEPRECATED_ARCHS = YES
    __IS_NOT_MACOS = YES
    __IS_NOT_MACOS_macosx = NO
    __IS_NOT_SIMULATOR = YES
    __IS_NOT_SIMULATOR_simulator = NO
    arch = undefined_arch
    variant = normal

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj/project.xcworkspace — scheme PulsumAgents
- Command: `xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumAgents`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumAgents

Resolve Package Graph


Resolved source packages:
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64e, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64e, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:DriverKit, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64_32, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:DriverKit, name:Any DriverKit Host }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:macOS, name:Any Mac }
{ platform:macOS, variant:Mac Catalyst, name:Any Mac }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj/project.xcworkspace — scheme PulsumData
- Command: `xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumData`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumData

Resolve Package Graph


Resolved source packages:
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64e, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64e, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:DriverKit, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64_32, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:DriverKit, name:Any DriverKit Host }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:macOS, name:Any Mac }
{ platform:macOS, variant:Mac Catalyst, name:Any Mac }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj/project.xcworkspace — scheme PulsumML
- Command: `xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumML`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumML

Resolve Package Graph


Resolved source packages:
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64e, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64e, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:DriverKit, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64_32, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:DriverKit, name:Any DriverKit Host }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:macOS, name:Any Mac }
{ platform:macOS, variant:Mac Catalyst, name:Any Mac }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj/project.xcworkspace — scheme PulsumServices
- Command: `xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumServices`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumServices

Resolve Package Graph


Resolved source packages:
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64e, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64e, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:DriverKit, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64_32, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:DriverKit, name:Any DriverKit Host }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:macOS, name:Any Mac }
{ platform:macOS, variant:Mac Catalyst, name:Any Mac }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj/project.xcworkspace — scheme PulsumTypes
- Command: `xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumTypes`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumTypes

Resolve Package Graph


Resolved source packages:
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64e, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64e, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:x86_64, variant:Mac Catalyst, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:DriverKit, id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:macOS, arch:arm64_32, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:DriverKit, name:Any DriverKit Host }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:macOS, name:Any Mac }
{ platform:macOS, variant:Mac Catalyst, name:Any Mac }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

### Pulsum.xcodeproj/project.xcworkspace — scheme PulsumUI
- Command: `xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumUI`
- Exit code: 0
`````text
Command line invocation:
    /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -showBuildSettings -workspace Pulsum.xcodeproj/project.xcworkspace -scheme PulsumUI

Resolve Package Graph


Resolved source packages:
  PulsumTypes: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumTypes @ local
  PulsumML: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumML @ local
  PulsumServices: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumServices @ local
  SplineRuntime: https://github.com/splinetool/spline-ios @ 0.2.48
  PulsumData: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumData @ local
  PulsumUI: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumUI @ local
  PulsumAgents: /Users/martin.demel/Desktop/PULSUM/Pulsum/Packages/PulsumAgents @ local

Build settings for action build and target Pulsum:
    ACTION = build
    AD_HOC_CODE_SIGNING_ALLOWED = NO
    AGGREGATE_TRACKED_DOMAINS = YES
    ALLOW_BUILD_REQUEST_OVERRIDES = NO
    ALLOW_TARGET_PLATFORM_SPECIALIZATION = NO
    ALTERNATE_GROUP = staff
    ALTERNATE_MODE = u+w,go-w,a+rX
    ALTERNATE_OWNER = martin.demel
    ALTERNATIVE_DISTRIBUTION_WEB = NO
    ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO
    ALWAYS_SEARCH_USER_PATHS = NO
    ALWAYS_USE_SEPARATE_HEADERMAPS = NO
    APPLICATION_EXTENSION_API_ONLY = NO
    APPLY_RULES_IN_COPY_FILES = NO
    APPLY_RULES_IN_COPY_HEADERS = NO
    APP_SHORTCUTS_ENABLE_FLEXIBLE_MATCHING = YES
    ARCHS = arm64
    ARCHS_STANDARD = arm64
    ARCHS_STANDARD_32_64_BIT = armv7 arm64
    ARCHS_STANDARD_32_BIT = armv7
    ARCHS_STANDARD_64_BIT = arm64
    ARCHS_STANDARD_INCLUDING_64_BIT = arm64
    ARCHS_UNIVERSAL_IPHONE_OS = armv7 arm64
    ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon
    ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES
    ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor
    ASSETCATALOG_FILTER_FOR_DEVICE_MODEL = MacFamily20,1
    ASSETCATALOG_FILTER_FOR_DEVICE_OS_VERSION = 26.2
    ASSETCATALOG_FILTER_FOR_THINNING_DEVICE_CONFIGURATION = MacFamily20,1
    AUTOMATICALLY_MERGE_DEPENDENCIES = NO
    AUTOMATION_APPLE_EVENTS = NO
    AVAILABLE_PLATFORMS = android appletvos appletvsimulator driverkit iphoneos iphonesimulator macosx qnx watchos watchsimulator webassembly xros xrsimulator
    BUILD_ACTIVE_RESOURCES_ONLY = YES
    BUILD_COMPONENTS = headers build
    BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    BUILD_LIBRARY_FOR_DISTRIBUTION = NO
    BUILD_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    BUILD_STYLE = 
    BUILD_VARIANTS = normal
    BUILT_PRODUCTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    BUNDLE_CONTENTS_FOLDER_PATH_deep = Contents/
    BUNDLE_EXECUTABLE_FOLDER_NAME_deep = MacOS
    BUNDLE_EXTENSIONS_FOLDER_PATH = Extensions
    BUNDLE_FORMAT = shallow
    BUNDLE_FRAMEWORKS_FOLDER_PATH = Frameworks
    BUNDLE_PLUGINS_FOLDER_PATH = PlugIns
    BUNDLE_PRIVATE_HEADERS_FOLDER_PATH = PrivateHeaders
    BUNDLE_PUBLIC_HEADERS_FOLDER_PATH = Headers
    CACHE_ROOT = /var/folders/m_/nqk8g4cs5tz8t1yj2kglt8p80000gn/C/com.apple.DeveloperTools/26.1.1-17B100/Xcode
    CCHROOT = /var/folders/m_/nqk8g4cs5tz8t1yj2kglt8p80000gn/C/com.apple.DeveloperTools/26.1.1-17B100/Xcode
    CHMOD = /bin/chmod
    CHOWN = /usr/sbin/chown
    CLANG_ANALYZER_NONNULL = YES
    CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE
    CLANG_CACHE_FINE_GRAINED_OUTPUTS = YES
    CLANG_COVERAGE_MAPPING = YES
    CLANG_CXX_LANGUAGE_STANDARD = gnu++20
    CLANG_ENABLE_EXPLICIT_MODULES = YES
    CLANG_ENABLE_MODULES = YES
    CLANG_ENABLE_OBJC_ARC = YES
    CLANG_ENABLE_OBJC_WEAK = YES
    CLANG_MODULES_BUILD_SESSION_FILE = /Users/martin.demel/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation
    CLANG_PROFILE_DATA_DIRECTORY = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/ProfileData
    CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES
    CLANG_WARN_BOOL_CONVERSION = YES
    CLANG_WARN_COMMA = YES
    CLANG_WARN_CONSTANT_CONVERSION = YES
    CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES
    CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR
    CLANG_WARN_DOCUMENTATION_COMMENTS = YES
    CLANG_WARN_EMPTY_BODY = YES
    CLANG_WARN_ENUM_CONVERSION = YES
    CLANG_WARN_INFINITE_RECURSION = YES
    CLANG_WARN_INT_CONVERSION = YES
    CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES
    CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
    CLANG_WARN_OBJC_LITERAL_CONVERSION = YES
    CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR
    CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES
    CLANG_WARN_RANGE_LOOP_ANALYSIS = YES
    CLANG_WARN_STRICT_PROTOTYPES = YES
    CLANG_WARN_SUSPICIOUS_MOVE = YES
    CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
    CLANG_WARN_UNREACHABLE_CODE = YES
    CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
    CLASS_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/JavaClasses
    CLEAN_PRECOMPS = YES
    CLONE_HEADERS = NO
    CODESIGNING_FOLDER_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/Pulsum.app
    CODE_SIGNING_ALLOWED = YES
    CODE_SIGNING_REQUIRED = YES
    CODE_SIGN_CONTEXT_CLASS = XCiPhoneOSCodeSignContext
    CODE_SIGN_ENTITLEMENTS = Pulsum/Pulsum.entitlements
    CODE_SIGN_IDENTITY = Apple Development
    CODE_SIGN_INJECT_BASE_ENTITLEMENTS = YES
    CODE_SIGN_STYLE = Automatic
    COLOR_DIAGNOSTICS = NO
    COMBINE_HIDPI_IMAGES = NO
    COMPILATION_CACHE_CAS_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/CompilationCache.noindex
    COMPILATION_CACHE_KEEP_CAS_DIRECTORY = YES
    COMPILER_INDEX_STORE_ENABLE = Default
    COMPOSITE_SDK_DIRS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/CompositeSDKs
    COMPRESS_PNG_FILES = YES
    CONFIGURATION = Debug
    CONFIGURATION_BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    CONFIGURATION_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos
    CONTENTS_FOLDER_PATH = Pulsum.app
    CONTENTS_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Contents
    CONTENTS_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    COPYING_PRESERVES_HFS_DATA = NO
    COPY_HEADERS_RUN_UNIFDEF = NO
    COPY_PHASE_STRIP = NO
    CORRESPONDING_SIMULATOR_PLATFORM_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform
    CORRESPONDING_SIMULATOR_PLATFORM_NAME = iphonesimulator
    CORRESPONDING_SIMULATOR_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator26.1.sdk
    CORRESPONDING_SIMULATOR_SDK_NAME = iphonesimulator26.1
    CP = /bin/cp
    CREATE_INFOPLIST_SECTION_IN_BINARY = NO
    CURRENT_ARCH = undefined_arch
    CURRENT_PROJECT_VERSION = 1
    CURRENT_VARIANT = normal
    DEAD_CODE_STRIPPING = YES
    DEBUGGING_SYMBOLS = YES
    DEBUG_INFORMATION_FORMAT = dwarf
    DEBUG_INFORMATION_VERSION = compiler-default
    DEFAULT_COMPILER = com.apple.compilers.llvm.clang.1_0
    DEFAULT_DEXT_INSTALL_PATH = /System/Library/DriverExtensions
    DEFAULT_KEXT_INSTALL_PATH = /System/Library/Extensions
    DEFINES_MODULE = NO
    DEPLOYMENT_LOCATION = NO
    DEPLOYMENT_POSTPROCESSING = NO
    DEPLOYMENT_TARGET_SETTING_NAME = IPHONEOS_DEPLOYMENT_TARGET
    DEPLOYMENT_TARGET_SUGGESTED_VALUES = 12.0 12.1 12.2 12.3 12.4 13.0 13.1 13.2 13.3 13.4 13.5 13.6 14.0 14.1 14.2 14.3 14.4 14.5 14.6 14.7 15.0 15.1 15.2 15.3 15.4 15.5 15.6 16.0 16.1 16.2 16.3 16.4 16.5 16.6 17.0 17.1 17.2 17.3 17.4 17.5 17.6 18.0 18.1 18.2 18.3 18.4 18.5 18.6 26.0 26.1
    DERIVED_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVED_SOURCES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/DerivedSources
    DERIVE_MACCATALYST_PRODUCT_BUNDLE_IDENTIFIER = NO
    DEVELOPER_APPLICATIONS_DIR = /Applications/Xcode.app/Contents/Developer/Applications
    DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/usr/bin
    DEVELOPER_DIR = /Applications/Xcode.app/Contents/Developer
    DEVELOPER_FRAMEWORKS_DIR = /Applications/Xcode.app/Contents/Developer/Library/Frameworks
    DEVELOPER_FRAMEWORKS_DIR_QUOTED = /Applications/Xcode.app/Contents/Developer/Library/Frameworks
    DEVELOPER_LIBRARY_DIR = /Applications/Xcode.app/Contents/Developer/Library
    DEVELOPER_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs
    DEVELOPER_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Tools
    DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/usr
    DEVELOPMENT_LANGUAGE = en
    DEVELOPMENT_TEAM = X6FJFZCXY3
    DIAGNOSE_MISSING_TARGET_DEPENDENCIES = YES
    DIFF = /usr/bin/diff
    DOCUMENTATION_FOLDER_PATH = Pulsum.app/en.lproj/Documentation
    DONT_GENERATE_INFOPLIST_FILE = NO
    DRIVERKIT_DEPLOYMENT_TARGET = 25.1
    DSTROOT = /tmp/Pulsum.dst
    DT_TOOLCHAIN_DIR = /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain
    DWARF_DSYM_FILE_NAME = Pulsum.app.dSYM
    DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT = NO
    DWARF_DSYM_FOLDER_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    DYNAMIC_LIBRARY_EXTENSION = dylib
    EAGER_COMPILATION_ALLOW_SCRIPTS = YES
    EAGER_LINKING = NO
    EFFECTIVE_PLATFORM_NAME = -iphoneos
    EMBEDDED_CONTENT_CONTAINS_SWIFT = NO
    EMBEDDED_PROFILE_NAME = embedded.mobileprovision
    EMBED_ASSET_PACKS_IN_PRODUCT_BUNDLE = NO
    ENABLE_APP_SANDBOX = NO
    ENABLE_CODE_COVERAGE = YES
    ENABLE_CPLUSPLUS_BOUNDS_SAFE_BUFFERS = NO
    ENABLE_C_BOUNDS_SAFETY = NO
    ENABLE_DEBUG_DYLIB = YES
    ENABLE_DEFAULT_HEADER_SEARCH_PATHS = YES
    ENABLE_DEFAULT_SEARCH_PATHS = YES
    ENABLE_ENHANCED_SECURITY = NO
    ENABLE_HARDENED_RUNTIME = NO
    ENABLE_HEADER_DEPENDENCIES = YES
    ENABLE_INCOMING_NETWORK_CONNECTIONS = NO
    ENABLE_ON_DEMAND_RESOURCES = YES
    ENABLE_OUTGOING_NETWORK_CONNECTIONS = NO
    ENABLE_POINTER_AUTHENTICATION = NO
    ENABLE_PREVIEWS = YES
    ENABLE_RESOURCE_ACCESS_AUDIO_INPUT = NO
    ENABLE_RESOURCE_ACCESS_BLUETOOTH = NO
    ENABLE_RESOURCE_ACCESS_CALENDARS = NO
    ENABLE_RESOURCE_ACCESS_CAMERA = NO
    ENABLE_RESOURCE_ACCESS_CONTACTS = NO
    ENABLE_RESOURCE_ACCESS_LOCATION = NO
    ENABLE_RESOURCE_ACCESS_PHOTO_LIBRARY = NO
    ENABLE_RESOURCE_ACCESS_PRINTING = NO
    ENABLE_RESOURCE_ACCESS_USB = NO
    ENABLE_SDK_IMPORTS = NO
    ENABLE_SECURITY_COMPILER_WARNINGS = NO
    ENABLE_STRICT_OBJC_MSGSEND = YES
    ENABLE_TESTABILITY = YES
    ENABLE_TESTING_SEARCH_PATHS = NO
    ENABLE_THREAD_SANITIZER = NO
    ENABLE_USER_SCRIPT_SANDBOXING = YES
    ENFORCE_VALID_ARCHS = YES
    ENTITLEMENTS_ALLOWED = YES
    ENTITLEMENTS_DESTINATION = Signature
    ENTITLEMENTS_REQUIRED = NO
    EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS = .DS_Store .svn .git .hg CVS
    EXCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES = *.nib *.lproj *.framework *.gch *.xcode* *.xcassets *.icon (*) .DS_Store CVS .svn .git .hg *.pbproj *.pbxproj
    EXECUTABLES_FOLDER_PATH = Pulsum.app/Executables
    EXECUTABLE_FOLDER_PATH = Pulsum.app
    EXECUTABLE_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/MacOS
    EXECUTABLE_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    EXECUTABLE_NAME = Pulsum
    EXECUTABLE_PATH = Pulsum.app/Pulsum
    EXTENSIONS_FOLDER_PATH = Pulsum.app/Extensions
    FILE_LIST = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects/LinkFileList
    FIXED_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/FixedFiles
    FRAMEWORKS_FOLDER_PATH = Pulsum.app/Frameworks
    FRAMEWORK_FLAG_PREFIX = -framework
    FRAMEWORK_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    FRAMEWORK_VERSION = A
    FULL_PRODUCT_NAME = Pulsum.app
    FUSE_BUILD_PHASES = YES
    FUSE_BUILD_SCRIPT_PHASES = NO
    GCC3_VERSION = 3.3
    GCC_C_LANGUAGE_STANDARD = gnu17
    GCC_DYNAMIC_NO_PIC = NO
    GCC_INLINES_ARE_PRIVATE_EXTERN = YES
    GCC_NO_COMMON_BLOCKS = YES
    GCC_OPTIMIZATION_LEVEL = 0
    GCC_PFE_FILE_C_DIALECTS = c objective-c c++ objective-c++
    GCC_PREPROCESSOR_DEFINITIONS = DEBUG=1 
    GCC_SYMBOLS_PRIVATE_EXTERN = NO
    GCC_THUMB_SUPPORT = YES
    GCC_TREAT_WARNINGS_AS_ERRORS = NO
    GCC_VERSION = com.apple.compilers.llvm.clang.1_0
    GCC_VERSION_IDENTIFIER = com_apple_compilers_llvm_clang_1_0
    GCC_WARN_64_TO_32_BIT_CONVERSION = YES
    GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR
    GCC_WARN_UNDECLARED_SELECTOR = YES
    GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE
    GCC_WARN_UNUSED_FUNCTION = YES
    GCC_WARN_UNUSED_VARIABLE = YES
    GENERATED_MODULEMAP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/GeneratedModuleMaps-iphoneos
    GENERATE_INFOPLIST_FILE = YES
    GENERATE_INTERMEDIATE_TEXT_BASED_STUBS = YES
    GENERATE_PKGINFO_FILE = YES
    GENERATE_PRELINK_OBJECT_FILE = NO
    GENERATE_PROFILING_CODE = NO
    GENERATE_TEXT_BASED_STUBS = NO
    GID = 20
    GROUP = staff
    HEADERMAP_INCLUDES_FLAT_ENTRIES_FOR_TARGET_BEING_BUILT = YES
    HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_ALL_PRODUCT_TYPES = YES
    HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_TARGETS_NOT_BEING_BUILT = YES
    HEADERMAP_INCLUDES_NONPUBLIC_NONPRIVATE_HEADERS = YES
    HEADERMAP_INCLUDES_PROJECT_HEADERS = YES
    HEADERMAP_USES_FRAMEWORK_PREFIX_ENTRIES = YES
    HEADERMAP_USES_VFS = NO
    HEADER_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/include 
    HOME = /Users/martin.demel
    HOST_ARCH = arm64
    HOST_PLATFORM = macosx
    ICONV = /usr/bin/iconv
    IMPLICIT_DEPENDENCY_DOMAIN = default
    INFOPLIST_ENABLE_CFBUNDLEICONS_MERGE = YES
    INFOPLIST_EXPAND_BUILD_SETTINGS = YES
    INFOPLIST_KEY_ITSAppUsesNonExemptEncryption = NO
    INFOPLIST_KEY_NSHealthShareUsageDescription = Pulsum reads key wellness metrics like HRV and sleep to personalize your coaching.
    INFOPLIST_KEY_NSHealthUpdateUsageDescription = Pulsum references your recent trends to surface the most helpful guidance.
    INFOPLIST_KEY_NSMicrophoneUsageDescription = Pulsum uses the microphone to capture on-device voice journals.
    INFOPLIST_KEY_NSSpeechRecognitionUsageDescription = Pulsum transcribes your voice journals on-device to keep coaching relevant.
    INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES
    INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES
    INFOPLIST_KEY_UILaunchScreen_Generation = YES
    INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight
    INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight
    INFOPLIST_OUTPUT_FORMAT = binary
    INFOPLIST_PATH = Pulsum.app/Info.plist
    INFOPLIST_PREPROCESS = NO
    INFOSTRINGS_PATH = Pulsum.app/en.lproj/InfoPlist.strings
    INLINE_PRIVATE_FRAMEWORKS = NO
    INSTALLAPI_IGNORE_SKIP_INSTALL = YES
    INSTALLHDRS_COPY_PHASE = NO
    INSTALLHDRS_SCRIPT_PHASE = NO
    INSTALL_DIR = /tmp/Pulsum.dst/Applications
    INSTALL_GROUP = staff
    INSTALL_MODE_FLAG = u+w,go-w,a+rX
    INSTALL_OWNER = martin.demel
    INSTALL_PATH = /Applications
    INSTALL_ROOT = /tmp/Pulsum.dst
    IPHONEOS_DEPLOYMENT_TARGET = 26.0
    IS_UNOPTIMIZED_BUILD = YES
    JAVAC_DEFAULT_FLAGS = -J-Xms64m -J-XX:NewSize=4M -J-Dfile.encoding=UTF8
    JAVA_APP_STUB = /System/Library/Frameworks/JavaVM.framework/Resources/MacOS/JavaApplicationStub
    JAVA_ARCHIVE_CLASSES = YES
    JAVA_ARCHIVE_TYPE = JAR
    JAVA_COMPILER = /usr/bin/javac
    JAVA_FOLDER_PATH = Pulsum.app/Java
    JAVA_FRAMEWORK_RESOURCES_DIRS = Resources
    JAVA_JAR_FLAGS = cv
    JAVA_SOURCE_SUBDIR = .
    JAVA_USE_DEPENDENCIES = YES
    JAVA_ZIP_FLAGS = -urg
    JIKES_DEFAULT_FLAGS = +E +OLDCSO
    KASAN_CFLAGS_CLASSIC = -DKASAN=1 -DKASAN_CLASSIC=1 -fsanitize=address -mllvm -asan-globals-live-support -mllvm -asan-force-dynamic-shadow
    KASAN_CFLAGS_TBI = -DKASAN=1 -DKASAN_TBI=1 -fsanitize=kernel-hwaddress -mllvm -hwasan-recover=0 -mllvm -hwasan-instrument-atomics=0 -mllvm -hwasan-instrument-stack=1 -mllvm -hwasan-generate-tags-with-calls=1 -mllvm -hwasan-instrument-with-calls=1 -mllvm -hwasan-use-short-granules=0 -mllvm -hwasan-memory-access-callback-prefix=__asan_
    KASAN_DEFAULT_CFLAGS = -DKASAN=1 -DKASAN_CLASSIC=1 -fsanitize=address -mllvm -asan-globals-live-support -mllvm -asan-force-dynamic-shadow
    KEEP_PRIVATE_EXTERNS = NO
    LD_DEPENDENCY_INFO_FILE = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch/Pulsum_dependency_info.dat
    LD_EXPORT_GLOBAL_SYMBOLS = YES
    LD_EXPORT_SYMBOLS = YES
    LD_GENERATE_MAP_FILE = NO
    LD_MAP_FILE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Pulsum-LinkMap-normal-undefined_arch.txt
    LD_NO_PIE = NO
    LD_QUOTE_LINKER_ARGUMENTS_FOR_COMPILER_DRIVER = YES
    LD_RUNPATH_SEARCH_PATHS =  @executable_path/Frameworks
    LD_RUNPATH_SEARCH_PATHS_YES = @loader_path/../Frameworks
    LD_SHARED_CACHE_ELIGIBLE = Automatic
    LD_WARN_DUPLICATE_LIBRARIES = NO
    LD_WARN_UNUSED_DYLIBS = NO
    LEGACY_DEVELOPER_DIR = /Applications/Xcode.app/Contents/PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer
    LEX = lex
    LIBRARY_DEXT_INSTALL_PATH = /Library/DriverExtensions
    LIBRARY_FLAG_NOSPACE = YES
    LIBRARY_FLAG_PREFIX = -l
    LIBRARY_KEXT_INSTALL_PATH = /Library/Extensions
    LIBRARY_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    LINKER_DISPLAYS_MANGLED_NAMES = NO
    LINK_FILE_LIST_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.LinkFileList
    LINK_OBJC_RUNTIME = YES
    LINK_WITH_STANDARD_LIBRARIES = YES
    LLVM_TARGET_TRIPLE_OS_VERSION = ios26.0
    LLVM_TARGET_TRIPLE_VENDOR = apple
    LM_AUX_CONST_METADATA_LIST_PATH_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.SwiftConstValuesFileList
    LOCALIZATION_EXPORT_SUPPORTED = YES
    LOCALIZATION_PREFERS_STRING_CATALOGS = YES
    LOCALIZED_RESOURCES_FOLDER_PATH = Pulsum.app/en.lproj
    LOCALIZED_STRING_MACRO_NAMES = NSLocalizedString CFCopyLocalizedString
    LOCALIZED_STRING_SWIFTUI_SUPPORT = YES
    LOCAL_ADMIN_APPS_DIR = /Applications/Utilities
    LOCAL_APPS_DIR = /Applications
    LOCAL_DEVELOPER_DIR = /Library/Developer
    LOCAL_LIBRARY_DIR = /Library
    LOCROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    LOCSYMROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    MACH_O_TYPE = mh_execute
    MACOSX_DEPLOYMENT_TARGET = 26.1
    MAC_OS_X_PRODUCT_BUILD_VERSION = 25C56
    MAC_OS_X_VERSION_ACTUAL = 260200
    MAC_OS_X_VERSION_MAJOR = 260000
    MAC_OS_X_VERSION_MINOR = 260200
    MAKE_MERGEABLE = NO
    MARKETING_VERSION = 1.0
    MERGEABLE_LIBRARY = NO
    MERGED_BINARY_TYPE = none
    MERGE_LINKED_LIBRARIES = NO
    METAL_LIBRARY_FILE_BASE = default
    METAL_LIBRARY_OUTPUT_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/Pulsum.app
    MODULES_FOLDER_PATH = Pulsum.app/Modules
    MODULE_CACHE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/ModuleCache.noindex
    MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE
    MTL_FAST_MATH = YES
    NATIVE_ARCH = arm64
    NATIVE_ARCH_32_BIT = arm
    NATIVE_ARCH_64_BIT = arm64
    NATIVE_ARCH_ACTUAL = arm64
    NO_COMMON = YES
    OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects
    OBJECT_FILE_DIR_normal = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal
    OBJROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    ONLY_ACTIVE_ARCH = YES
    OS = MACOS
    OSAC = /usr/bin/osacompile
    PACKAGE_TYPE = com.apple.package-type.wrapper.application
    PASCAL_STRINGS = YES
    PATH = /Applications/Xcode.app/Contents/SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildService.bundle/Contents/PlugIns/SWBUniversalPlatformPlugin.bundle/Contents/Frameworks/SWBUniversalPlatform.framework/Resources:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/local/bin:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/libexec:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/local/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/local/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/local/bin:/Library/Frameworks/Python.framework/Versions/3.13/bin:/Library/Frameworks/Python.framework/Versions/3.12/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/Library/TeX/texbin:/Users/martin.demel/.codex/tmp/path/codex-arg0ZXyiPF:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/martin.demel/.codeium/windsurf/bin:/usr/local/opt/python@3.11/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/martin.demel/.lmstudio/bin:/Users/martin.demel/.cursor/extensions/openai.chatgpt-0.4.66-universal/bin/macos-aarch64
    PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES = /usr/include /usr/local/include /System/Library/Frameworks /System/Library/PrivateFrameworks /Applications/Xcode.app/Contents/Developer/Headers /Applications/Xcode.app/Contents/Developer/SDKs /Applications/Xcode.app/Contents/Developer/Platforms
    PBDEVELOPMENTPLIST_PATH = Pulsum.app/pbdevelopment.plist
    PER_ARCH_MODULE_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    PER_ARCH_OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    PER_VARIANT_OBJECT_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal
    PKGINFO_FILE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/PkgInfo
    PKGINFO_PATH = Pulsum.app/PkgInfo
    PLATFORM_DEVELOPER_APPLICATIONS_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Applications
    PLATFORM_DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin
    PLATFORM_DEVELOPER_LIBRARY_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library
    PLATFORM_DEVELOPER_SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs
    PLATFORM_DEVELOPER_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Tools
    PLATFORM_DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr
    PLATFORM_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform
    PLATFORM_DISPLAY_NAME = iOS
    PLATFORM_FAMILY_NAME = iOS
    PLATFORM_NAME = iphoneos
    PLATFORM_PREFERRED_ARCH = arm64
    PLATFORM_PRODUCT_BUILD_VERSION = 23B77
    PLATFORM_REQUIRES_SWIFT_AUTOLINK_EXTRACT = NO
    PLATFORM_REQUIRES_SWIFT_MODULEWRAP = NO
    PLIST_FILE_OUTPUT_FORMAT = binary
    PLUGINS_FOLDER_PATH = Pulsum.app/PlugIns
    PRECOMPS_INCLUDE_HEADERS_FROM_BUILT_PRODUCTS_DIR = YES
    PRECOMP_DESTINATION_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/PrefixHeaders
    PRIVATE_HEADERS_FOLDER_PATH = Pulsum.app/PrivateHeaders
    PROCESSED_INFOPLIST_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch/Processed-Info.plist
    PRODUCT_BUNDLE_IDENTIFIER = ai.pulsum.Pulsum
    PRODUCT_BUNDLE_PACKAGE_TYPE = APPL
    PRODUCT_MODULE_NAME = Pulsum
    PRODUCT_NAME = Pulsum
    PRODUCT_SETTINGS_PATH = 
    PRODUCT_TYPE = com.apple.product-type.application
    PROFILING_CODE = NO
    PROJECT = Pulsum
    PROJECT_DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/DerivedSources
    PROJECT_DIR = /Users/martin.demel/Desktop/PULSUM/Pulsum
    PROJECT_FILE_PATH = /Users/martin.demel/Desktop/PULSUM/Pulsum/Pulsum.xcodeproj
    PROJECT_GUID = 8a2ebb52ff332eacb0b1d430ce5478d8
    PROJECT_NAME = Pulsum
    PROJECT_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build
    PROJECT_TEMP_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    PROVISIONING_PROFILE_REQUIRED = YES
    PROVISIONING_PROFILE_REQUIRED_YES_YES = YES
    PROVISIONING_PROFILE_SUPPORTED = YES
    PUBLIC_HEADERS_FOLDER_PATH = Pulsum.app/Headers
    RECOMMENDED_IPHONEOS_DEPLOYMENT_TARGET = 15.0
    RECURSIVE_SEARCH_PATHS_FOLLOW_SYMLINKS = YES
    REMOVE_CVS_FROM_RESOURCES = YES
    REMOVE_GIT_FROM_RESOURCES = YES
    REMOVE_HEADERS_FROM_EMBEDDED_BUNDLES = YES
    REMOVE_HG_FROM_RESOURCES = YES
    REMOVE_STATIC_EXECUTABLES_FROM_EMBEDDED_BUNDLES = YES
    REMOVE_SVN_FROM_RESOURCES = YES
    RESCHEDULE_INDEPENDENT_HEADERS_PHASES = YES
    REZ_COLLECTOR_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/ResourceManagerResources
    REZ_OBJECTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/ResourceManagerResources/Objects
    REZ_SEARCH_PATHS = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos 
    RUNTIME_EXCEPTION_ALLOW_DYLD_ENVIRONMENT_VARIABLES = NO
    RUNTIME_EXCEPTION_ALLOW_JIT = NO
    RUNTIME_EXCEPTION_ALLOW_UNSIGNED_EXECUTABLE_MEMORY = NO
    RUNTIME_EXCEPTION_DEBUGGING_TOOL = NO
    RUNTIME_EXCEPTION_DISABLE_EXECUTABLE_PAGE_PROTECTION = NO
    RUNTIME_EXCEPTION_DISABLE_LIBRARY_VALIDATION = NO
    SCAN_ALL_SOURCE_FILES_FOR_INCLUDES = NO
    SCRIPTS_FOLDER_PATH = Pulsum.app/Scripts
    SDKROOT = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR_iphoneos = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_DIR_iphoneos26_1 = /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk
    SDK_NAME = iphoneos26.1
    SDK_NAMES = iphoneos26.1
    SDK_PRODUCT_BUILD_VERSION = 23B77
    SDK_STAT_CACHE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData
    SDK_STAT_CACHE_ENABLE = YES
    SDK_STAT_CACHE_PATH = /Users/martin.demel/Library/Developer/Xcode/DerivedData/SDKStatCaches.noindex/iphoneos26.1-23B77-69b33fc7382b27d9b5d46e82a00f8e78.sdkstatcache
    SDK_VERSION = 26.1
    SDK_VERSION_ACTUAL = 260100
    SDK_VERSION_MAJOR = 260000
    SDK_VERSION_MINOR = 260100
    SED = /usr/bin/sed
    SEPARATE_STRIP = NO
    SEPARATE_SYMBOL_EDIT = NO
    SET_DIR_MODE_OWNER_GROUP = YES
    SET_FILE_MODE_OWNER_GROUP = NO
    SHALLOW_BUNDLE = YES
    SHALLOW_BUNDLE_TRIPLE = ios
    SHALLOW_BUNDLE_ios_macabi = NO
    SHALLOW_BUNDLE_macos = NO
    SHARED_DERIVED_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos/DerivedSources
    SHARED_FRAMEWORKS_FOLDER_PATH = Pulsum.app/SharedFrameworks
    SHARED_PRECOMPS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/PrecompiledHeaders
    SHARED_SUPPORT_FOLDER_PATH = Pulsum.app/SharedSupport
    SKIP_INSTALL = NO
    SOURCE_ROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    SRCROOT = /Users/martin.demel/Desktop/PULSUM/Pulsum
    STRINGSDATA_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/undefined_arch
    STRINGSDATA_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    STRINGS_FILE_INFOPLIST_RENAME = YES
    STRINGS_FILE_OUTPUT_ENCODING = binary
    STRING_CATALOG_GENERATE_SYMBOLS = YES
    STRIP_BITCODE_FROM_COPIED_FILES = YES
    STRIP_INSTALLED_PRODUCT = NO
    STRIP_STYLE = all
    STRIP_SWIFT_SYMBOLS = YES
    SUPPORTED_DEVICE_FAMILIES = 1,2
    SUPPORTED_PLATFORMS = iphoneos iphonesimulator
    SUPPORTS_MACCATALYST = NO
    SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = YES
    SUPPORTS_ON_DEMAND_RESOURCES = YES
    SUPPORTS_TEXT_BASED_API = NO
    SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = YES
    SUPPRESS_WARNINGS = NO
    SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG 
    SWIFT_APPROACHABLE_CONCURRENCY = YES
    SWIFT_DEFAULT_ACTOR_ISOLATION = MainActor
    SWIFT_EMIT_CONST_VALUE_PROTOCOLS = AppIntent EntityQuery AppEntity TransientEntity AppEnum AppShortcutProviding AppShortcutsProvider AnyResolverProviding AppIntentsPackage DynamicOptionsProvider _IntentValueRepresentable _AssistantIntentsProvider _GenerativeFunctionExtractable IntentValueQuery Resolver AppExtension ExtensionPointDefining
    SWIFT_EMIT_LOC_STRINGS = YES
    SWIFT_ENABLE_EXPLICIT_MODULES = YES
    SWIFT_OPTIMIZATION_LEVEL = -Onone
    SWIFT_PLATFORM_TARGET_PREFIX = ios
    SWIFT_RESPONSE_FILE_PATH_normal_arm64 = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build/Objects-normal/arm64/Pulsum.SwiftFileList
    SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES
    SWIFT_VERSION = 5.0
    SYMROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products
    SYSTEM_ADMIN_APPS_DIR = /Applications/Utilities
    SYSTEM_APPS_DIR = /Applications
    SYSTEM_CORE_SERVICES_DIR = /System/Library/CoreServices
    SYSTEM_DEMOS_DIR = /Applications/Extras
    SYSTEM_DEVELOPER_APPS_DIR = /Applications/Xcode.app/Contents/Developer/Applications
    SYSTEM_DEVELOPER_BIN_DIR = /Applications/Xcode.app/Contents/Developer/usr/bin
    SYSTEM_DEVELOPER_DEMOS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Utilities/Built Examples
    SYSTEM_DEVELOPER_DIR = /Applications/Xcode.app/Contents/Developer
    SYSTEM_DEVELOPER_DOC_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library
    SYSTEM_DEVELOPER_GRAPHICS_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Graphics Tools
    SYSTEM_DEVELOPER_JAVA_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Java Tools
    SYSTEM_DEVELOPER_PERFORMANCE_TOOLS_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Performance Tools
    SYSTEM_DEVELOPER_RELEASENOTES_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/releasenotes
    SYSTEM_DEVELOPER_TOOLS = /Applications/Xcode.app/Contents/Developer/Tools
    SYSTEM_DEVELOPER_TOOLS_DOC_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/documentation/DeveloperTools
    SYSTEM_DEVELOPER_TOOLS_RELEASENOTES_DIR = /Applications/Xcode.app/Contents/Developer/ADC Reference Library/releasenotes/DeveloperTools
    SYSTEM_DEVELOPER_USR_DIR = /Applications/Xcode.app/Contents/Developer/usr
    SYSTEM_DEVELOPER_UTILITIES_DIR = /Applications/Xcode.app/Contents/Developer/Applications/Utilities
    SYSTEM_DEXT_INSTALL_PATH = /System/Library/DriverExtensions
    SYSTEM_DOCUMENTATION_DIR = /Library/Documentation
    SYSTEM_EXTENSIONS_FOLDER_PATH = Pulsum.app/SystemExtensions
    SYSTEM_EXTENSIONS_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Library/SystemExtensions
    SYSTEM_EXTENSIONS_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app/SystemExtensions
    SYSTEM_KEXT_INSTALL_PATH = /System/Library/Extensions
    SYSTEM_LIBRARY_DIR = /System/Library
    TAPI_DEMANGLE = YES
    TAPI_ENABLE_PROJECT_HEADERS = NO
    TAPI_LANGUAGE = objective-c
    TAPI_LANGUAGE_STANDARD = compiler-default
    TAPI_USE_SRCROOT = YES
    TAPI_VERIFY_MODE = Pedantic
    TARGETED_DEVICE_FAMILY = 1,2
    TARGETNAME = Pulsum
    TARGET_BUILD_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Products/Debug-iphoneos
    TARGET_DEVICE_IDENTIFIER = 00006031-001C519921B8001C
    TARGET_DEVICE_MODEL = Mac15,9
    TARGET_DEVICE_OS_VERSION = 26.2
    TARGET_DEVICE_PLATFORM_NAME = macosx
    TARGET_NAME = Pulsum
    TARGET_TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_FILES_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_FILE_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/Pulsum.build/Debug-iphoneos/Pulsum.build
    TEMP_ROOT = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex
    TEMP_SANDBOX_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/TemporaryTaskSandboxes
    TEST_FRAMEWORK_SEARCH_PATHS =  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Frameworks /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.1.sdk/Developer/Library/Frameworks
    TEST_LIBRARY_SEARCH_PATHS =  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/lib
    TOOLCHAINS = com.apple.dt.toolchain.XcodeDefault
    TOOLCHAIN_DIR = /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain
    TREAT_MISSING_BASELINES_AS_TEST_FAILURES = NO
    TREAT_MISSING_SCRIPT_PHASE_OUTPUTS_AS_ERRORS = NO
    TVOS_DEPLOYMENT_TARGET = 26.1
    UID = 501
    UNINSTALLED_PRODUCTS_DIR = /Users/martin.demel/Library/Developer/Xcode/DerivedData/Pulsum-asfryqahqiaobxecgecemhvmrxwa/Build/Intermediates.noindex/UninstalledProducts
    UNLOCALIZED_RESOURCES_FOLDER_PATH = Pulsum.app
    UNLOCALIZED_RESOURCES_FOLDER_PATH_SHALLOW_BUNDLE_NO = Pulsum.app/Resources
    UNLOCALIZED_RESOURCES_FOLDER_PATH_SHALLOW_BUNDLE_YES = Pulsum.app
    UNSTRIPPED_PRODUCT = NO
    USER = martin.demel
    USER_APPS_DIR = /Users/martin.demel/Applications
    USER_LIBRARY_DIR = /Users/martin.demel/Library
    USE_DYNAMIC_NO_PIC = YES
    USE_HEADERMAP = YES
    USE_HEADER_SYMLINKS = NO
    VALIDATE_DEVELOPMENT_ASSET_PATHS = YES_ERROR
    VALIDATE_PRODUCT = NO
    VALID_ARCHS = arm64 arm64e armv7 armv7s
    VERBOSE_PBXCP = NO
    VERSIONPLIST_PATH = Pulsum.app/version.plist
    VERSION_INFO_BUILDER = martin.demel
    VERSION_INFO_FILE = Pulsum_vers.c
    VERSION_INFO_STRING = "@(#)PROGRAM:Pulsum  PROJECT:Pulsum-1"
    WATCHOS_DEPLOYMENT_TARGET = 26.1
    WORKSPACE_DIR = /Users/martin.demel/Desktop/PULSUM/Pulsum/Pulsum.xcodeproj
    WRAPPER_EXTENSION = app
    WRAPPER_NAME = Pulsum.app
    WRAPPER_SUFFIX = .app
    WRAP_ASSET_PACKS_IN_SEPARATE_DIRECTORIES = NO
    XCODE_APP_SUPPORT_DIR = /Applications/Xcode.app/Contents/Developer/Library/Xcode
    XCODE_PRODUCT_BUILD_VERSION = 17B100
    XCODE_VERSION_ACTUAL = 2611
    XCODE_VERSION_MAJOR = 2600
    XCODE_VERSION_MINOR = 2610
    XPCSERVICES_FOLDER_PATH = Pulsum.app/XPCServices
    XROS_DEPLOYMENT_TARGET = 26.1
    YACC = yacc
    _DISCOVER_COMMAND_LINE_LINKER_INPUTS = YES
    _DISCOVER_COMMAND_LINE_LINKER_INPUTS_INCLUDE_WL = YES
    _LD_MULTIARCH = YES
    _WRAPPER_CONTENTS_DIR_SHALLOW_BUNDLE_NO = /Contents
    _WRAPPER_PARENT_PATH_SHALLOW_BUNDLE_NO = /..
    _WRAPPER_RESOURCES_DIR_SHALLOW_BUNDLE_NO = /Resources
    __DIAGNOSE_DEPRECATED_ARCHS = YES
    __IS_NOT_MACOS = YES
    __IS_NOT_MACOS_macosx = NO
    __IS_NOT_SIMULATOR = YES
    __IS_NOT_SIMULATOR_simulator = NO
    arch = undefined_arch
    variant = normal

--- xcodebuild: WARNING: Using the first of multiple matching destinations:
{ platform:macOS, arch:arm64, variant:Designed for [iPad,iPhone], id:00006031-001C519921B8001C, name:My Mac }
{ platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Any iOS Device }
{ platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Any iOS Simulator Device }
{ platform:iOS Simulator, arch:arm64, id:869D471E-CE14-4FBB-B507-EAA2882819F7, OS:26.0, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:ED83EC8E-39CA-4375-BB00-1B4AE2048CC3, OS:26.1, name:iPad (A16) }
{ platform:iOS Simulator, arch:arm64, id:098B3166-048F-41DE-B8E1-98029D339BDC, OS:26.0, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:31213194-32AB-4F3E-A6AF-2CF1B011041C, OS:26.1, name:iPad Air 11-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:B2D11E82-9752-4808-8FD3-7DACC7E8C9AC, OS:26.0, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:549938D5-3309-400F-B615-9456E392DBC0, OS:26.1, name:iPad Air 13-inch (M3) }
{ platform:iOS Simulator, arch:arm64, id:A15FEDC8-D4A2-42A2-8268-84445EF9DAE3, OS:26.0, name:iPad Pro 11-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:8D527C3E-764A-4912-A4D0-7C2C840CFF20, OS:26.0, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:4B3E783A-652B-4EEB-86F7-E43E0439442F, OS:26.1, name:iPad Pro 11-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:95305811-81AD-4DA0-AB65-ECBD6279C008, OS:26.0, name:iPad Pro 13-inch (M4) }
{ platform:iOS Simulator, arch:arm64, id:7DD34D2D-209E-445F-BCB3-92117DD0F774, OS:26.0, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:66E38349-3916-49EE-9C99-94A5D46B3FFF, OS:26.1, name:iPad Pro 13-inch (M5) }
{ platform:iOS Simulator, arch:arm64, id:35A25EDD-E40A-4EE0-8D69-003BD301B71D, OS:26.0, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:09D7B8AD-77F8-4F68-8032-3126D416EA7A, OS:26.1, name:iPad mini (A17 Pro) }
{ platform:iOS Simulator, arch:arm64, id:FE936B55-B3DE-41C5-80CE-0BFEE14E5A65, OS:26.0, name:iPhone 15 }
{ platform:iOS Simulator, arch:arm64, id:EBC3DCC2-7086-4B7E-96C5-D8CB64C60EAE, OS:26.1, name:iPhone 15 (26.1) }
{ platform:iOS Simulator, arch:arm64, id:3F412EFF-3ECA-46D4-90A3-EBA25C785C35, OS:26.0, name:iPhone 16 }
{ platform:iOS Simulator, arch:arm64, id:87ACE978-8D7C-4E84-8288-2E59636F417B, OS:26.0, name:iPhone 16 Plus }
{ platform:iOS Simulator, arch:arm64, id:E4A4F913-D2F4-47F1-A524-DD32C76D9DFD, OS:26.0, name:iPhone 16 Pro }
{ platform:iOS Simulator, arch:arm64, id:4E4EE484-29DC-4D2E-A5BA-869DA4126A45, OS:26.0, name:iPhone 16 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:4A8F96D1-50B0-4342-97D3-90B8941D54A3, OS:26.0, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:533B775D-6816-4BE7-889D-6882D7645D50, OS:26.1, name:iPhone 16e }
{ platform:iOS Simulator, arch:arm64, id:2D3A7F33-8D47-45CE-926F-B54D3BF244CE, OS:26.0, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:BE03CA5E-9D50-4B5B-A8F9-F7A35E9AE9BE, OS:26.1, name:iPhone 17 }
{ platform:iOS Simulator, arch:arm64, id:6D66C36C-8DA8-4F11-8026-A4D964FC5C35, OS:26.0, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:71ED22EF-97AD-454A-97AC-647CE12F5780, OS:26.1, name:iPhone 17 Pro }
{ platform:iOS Simulator, arch:arm64, id:3709A005-3068-4EB5-A195-BBD967869C6B, OS:26.0, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:E78867BF-700F-4373-994A-99A741B46740, OS:26.1, name:iPhone 17 Pro Max }
{ platform:iOS Simulator, arch:arm64, id:7DA203A0-43DA-4C9A-9821-4F55A253D936, OS:26.0, name:iPhone Air }
{ platform:iOS Simulator, arch:arm64, id:83D0808F-0DEE-4B0D-AA74-2A0566596636, OS:26.1, name:iPhone Air }
`````

## File Tree Summary
- Text files (196):
  - .github/coderabbit.yaml
  - .github/workflows/auto-merge.yml
  - .github/workflows/auto-pr.yml
  - .github/workflows/test-harness.yml
  - .gitignore
  - Config.xcconfig
  - Config.xcconfig.template
  - Packages/PulsumAgents/Package.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/AgentOrchestrator.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/BackfillStateStore.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/CheerAgent.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent+Coverage.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/DataAgent.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/EstimatorStateStore.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/HealthAccessStatus.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/PulsumAgents.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/RecRankerStateStore.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/SafetyAgent.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/SentimentAgent.swift
  - Packages/PulsumAgents/Sources/PulsumAgents/WellbeingScoreState.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/AgentSystemTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailAcceptanceTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/CoachAgentKeywordFallbackTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/DebugLogBufferTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_JournalSessionTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_OrchestratorLLMKeyAPITests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_TypesWiringTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_FreshnessBusTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_HealthAccessStatusTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_IngestionIdempotenceTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_ConsentRoutingTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_LLMKeyTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_RoutingTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_EmbeddingAvailabilityDegradationTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_RecRankerLearningTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_RecRankerPersistenceTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_SentimentJournalingFallbackTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_StateEstimatorPersistenceTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_StateEstimatorWeightsAndLabelsTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_WellbeingBackfillPhasingTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_WellbeingStateMappingTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate7_FirstRunWatchdogTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/HealthKitServiceStub.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/LibraryImportRetryTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/RecommendationsTimeoutTests.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/Resources/library_retry_test.json
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/TestCoreDataStack.swift
  - Packages/PulsumAgents/Tests/PulsumAgentsTests/TestHealthKitSampleSeeder.swift
  - Packages/PulsumData/Package.swift
  - Packages/PulsumData/Sources/PulsumData/Bundle+PulsumDataResources.swift
  - Packages/PulsumData/Sources/PulsumData/DataStack.swift
  - Packages/PulsumData/Sources/PulsumData/EvidenceScorer.swift
  - Packages/PulsumData/Sources/PulsumData/LibraryImporter.swift
  - Packages/PulsumData/Sources/PulsumData/Model/ManagedObjects.swift
  - Packages/PulsumData/Sources/PulsumData/PulsumData.swift
  - Packages/PulsumData/Sources/PulsumData/PulsumManagedObjectModel.swift
  - Packages/PulsumData/Sources/PulsumData/VectorIndex.swift
  - Packages/PulsumData/Sources/PulsumData/VectorIndexManager.swift
  - Packages/PulsumData/Tests/PulsumDataTests/DataStackSecurityTests.swift
  - Packages/PulsumData/Tests/PulsumDataTests/Gate0_DataStackSecurityTests.swift
  - Packages/PulsumData/Tests/PulsumDataTests/Gate5_LibraryImporterAtomicityTests.swift
  - Packages/PulsumData/Tests/PulsumDataTests/Gate5_LibraryImporterPerfTests.swift
  - Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexConcurrencyTests.swift
  - Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexFileHandleTests.swift
  - Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexManagerActorTests.swift
  - Packages/PulsumData/Tests/PulsumDataTests/LibraryImporterTests.swift
  - Packages/PulsumData/Tests/PulsumDataTests/PulsumDataBootstrapTests.swift
  - Packages/PulsumData/Tests/PulsumDataTests/Resources/podcasts_sample.json
  - Packages/PulsumData/Tests/PulsumDataTests/VectorIndexTests.swift
  - Packages/PulsumML/Package.swift
  - Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsAvailability.swift
  - Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsStub.swift
  - Packages/PulsumML/Sources/PulsumML/BaselineMath.swift
  - Packages/PulsumML/Sources/PulsumML/Bundle+PulsumMLResources.swift
  - Packages/PulsumML/Sources/PulsumML/Embedding/AFMTextEmbeddingProvider.swift
  - Packages/PulsumML/Sources/PulsumML/Embedding/CoreMLEmbeddingFallbackProvider.swift
  - Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingError.swift
  - Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingService.swift
  - Packages/PulsumML/Sources/PulsumML/Embedding/TextEmbeddingProviding.swift
  - Packages/PulsumML/Sources/PulsumML/Placeholder.swift
  - Packages/PulsumML/Sources/PulsumML/RecRanker.swift
  - Packages/PulsumML/Sources/PulsumML/Safety/FoundationModelsSafetyProvider.swift
  - Packages/PulsumML/Sources/PulsumML/SafetyLocal.swift
  - Packages/PulsumML/Sources/PulsumML/Sentiment/AFMSentimentProvider.swift
  - Packages/PulsumML/Sources/PulsumML/Sentiment/CoreMLSentimentProvider.swift
  - Packages/PulsumML/Sources/PulsumML/Sentiment/FoundationModelsSentimentProvider.swift
  - Packages/PulsumML/Sources/PulsumML/Sentiment/NaturalLanguageSentimentProvider.swift
  - Packages/PulsumML/Sources/PulsumML/Sentiment/PIIRedactor.swift
  - Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentProviding.swift
  - Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentService.swift
  - Packages/PulsumML/Sources/PulsumML/StateEstimator.swift
  - Packages/PulsumML/Sources/PulsumML/TopicGate/EmbeddingTopicGateProvider.swift
  - Packages/PulsumML/Sources/PulsumML/TopicGate/FoundationModelsTopicGateProvider.swift
  - Packages/PulsumML/Sources/PulsumML/TopicGate/TopicGateProviding.swift
  - Packages/PulsumML/Tests/PulsumMLTests/EmbeddingServiceAvailabilityTests.swift
  - Packages/PulsumML/Tests/PulsumMLTests/EmbeddingServiceFallbackTests.swift
  - Packages/PulsumML/Tests/PulsumMLTests/Gate0_EmbeddingServiceFallbackTests.swift
  - Packages/PulsumML/Tests/PulsumMLTests/Gate6_EmbeddingProviderContextualTests.swift
  - Packages/PulsumML/Tests/PulsumMLTests/PackageEmbedTests.swift
  - Packages/PulsumML/Tests/PulsumMLTests/SafetyLocalTests.swift
  - Packages/PulsumML/Tests/PulsumMLTests/TopicGateMarginTests.swift
  - Packages/PulsumML/Tests/PulsumMLTests/TopicGateTests.swift
  - Packages/PulsumServices/Package.swift
  - Packages/PulsumServices/Sources/PulsumServices/BuildFlags.swift
  - Packages/PulsumServices/Sources/PulsumServices/Bundle+PulsumServicesResources.swift
  - Packages/PulsumServices/Sources/PulsumServices/CoachPhrasingSchema.swift
  - Packages/PulsumServices/Sources/PulsumServices/FoundationModelsCoachGenerator.swift
  - Packages/PulsumServices/Sources/PulsumServices/HealthKitAnchorStore.swift
  - Packages/PulsumServices/Sources/PulsumServices/HealthKitService.swift
  - Packages/PulsumServices/Sources/PulsumServices/KeychainService.swift
  - Packages/PulsumServices/Sources/PulsumServices/LLMGateway.swift
  - Packages/PulsumServices/Sources/PulsumServices/Placeholder.swift
  - Packages/PulsumServices/Sources/PulsumServices/SpeechService.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_LLMGatewayTests.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_SpeechServiceAuthorizationTests.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_SpeechServiceLoggingTests.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/Gate1_LLMGatewayUITestSeams.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/Gate1_SpeechFakeBackendTests.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/Gate2_ModernSpeechBackendTests.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/Gate4_LLMGatewayPingSeams.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/HealthKitAnchorStoreTests.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/KeychainServiceTests.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewaySchemaTests.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewayTests.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/PulsumServicesDependencyTests.swift
  - Packages/PulsumServices/Tests/PulsumServicesTests/SpeechServiceTests.swift
  - Packages/PulsumServices/Tests/Support/LLMURLProtocolStub.swift
  - Packages/PulsumTypes/Package.swift
  - Packages/PulsumTypes/Sources/PulsumTypes/AppRuntimeConfig.swift
  - Packages/PulsumTypes/Sources/PulsumTypes/DebugLog.swift
  - Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsLogger.swift
  - Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsPaths.swift
  - Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsReport.swift
  - Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsTypes.swift
  - Packages/PulsumTypes/Sources/PulsumTypes/Notifications.swift
  - Packages/PulsumTypes/Sources/PulsumTypes/SpeechTypes.swift
  - Packages/PulsumTypes/Sources/PulsumTypes/Timeout.swift
  - Packages/PulsumTypes/Sources/PulsumTypes/WellbeingSnapshotKind.swift
  - Packages/PulsumTypes/Tests/DiagnosticsLoggerTests.swift
  - Packages/PulsumTypes/Tests/PulsumTypesTests/TimeoutTests.swift
  - Packages/PulsumUI/Package.swift
  - Packages/PulsumUI/Sources/PulsumUI/AppViewModel.swift
  - Packages/PulsumUI/Sources/PulsumUI/CoachView.swift
  - Packages/PulsumUI/Sources/PulsumUI/CoachViewModel.swift
  - Packages/PulsumUI/Sources/PulsumUI/ConsentBannerView.swift
  - Packages/PulsumUI/Sources/PulsumUI/GlassEffect.swift
  - Packages/PulsumUI/Sources/PulsumUI/HealthAccessRequirement.swift
  - Packages/PulsumUI/Sources/PulsumUI/LiquidGlassComponents.swift
  - Packages/PulsumUI/Sources/PulsumUI/LiveWaveformLevels.swift
  - Packages/PulsumUI/Sources/PulsumUI/OnboardingView.swift
  - Packages/PulsumUI/Sources/PulsumUI/PulseView.swift
  - Packages/PulsumUI/Sources/PulsumUI/PulseViewModel.swift
  - Packages/PulsumUI/Sources/PulsumUI/PulsumDesignSystem.swift
  - Packages/PulsumUI/Sources/PulsumUI/PulsumRootView.swift
  - Packages/PulsumUI/Sources/PulsumUI/SafetyCardView.swift
  - Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownView.swift
  - Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownViewModel.swift
  - Packages/PulsumUI/Sources/PulsumUI/SettingsView.swift
  - Packages/PulsumUI/Sources/PulsumUI/SettingsViewModel.swift
  - Packages/PulsumUI/Tests/PulsumUITests/CoachViewModelTests.swift
  - Packages/PulsumUI/Tests/PulsumUITests/LiveWaveformBufferTests.swift
  - Packages/PulsumUI/Tests/PulsumUITests/PulsumRootViewTests.swift
  - Packages/PulsumUI/Tests/PulsumUITests/SettingsViewModelHealthAccessTests.swift
  - Packages/PulsumUI/Tests/PulsumUITests/TestCoreDataStack.swift
  - Pulsum.xcodeproj/project.pbxproj
  - Pulsum.xcodeproj/project.xcworkspace/contents.xcworkspacedata
  - Pulsum.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved
  - Pulsum.xcodeproj/xcshareddata/xcschemes/Pulsum.xcscheme
  - Pulsum.xcodeproj/xcshareddata/xcschemes/PulsumUI.xcscheme
  - Pulsum.xcodeproj/xcuserdata/martin.demel.xcuserdatad/xcschemes/xcschememanagement.plist
  - Pulsum/Assets.xcassets/AccentColor.colorset/Contents.json
  - Pulsum/Assets.xcassets/AppIcon.appiconset/Contents.json
  - Pulsum/Assets.xcassets/Contents.json
  - Pulsum/Pulsum.entitlements
  - Pulsum/PulsumApp.swift
  - PulsumTests/PulsumTests.swift
  - PulsumUITests/FirstRunPermissionsUITests.swift
  - PulsumUITests/Gate3_HealthAccessUITests.swift
  - PulsumUITests/Gate4_CloudConsentUITests.swift
  - PulsumUITests/JournalFlowUITests.swift
  - PulsumUITests/PulsumUITestCase.swift
  - PulsumUITests/PulsumUITestsLaunchTests.swift
  - PulsumUITests/SettingsAndCoachUITests.swift
  - baseline 5_2/baseline_file_inventory_5_2.json
  - inventory.json
  - ios support files/glow.swift
  - podcastrecommendations 2.json
  - scripts/ci/build-release.sh
  - scripts/ci/check-privacy-manifests.sh
  - scripts/ci/integrity.sh
  - scripts/ci/scan-placeholders.sh
  - scripts/ci/scan-secrets.sh
  - scripts/ci/test-harness.sh
  - scripts/ci/ui-tests.sh
- Binary files (19):
  - MAINDESIGN.png
  - Packages/PulsumData/Sources/PulsumData/Resources/PulsumCompiled.momd/Pulsum.mom
  - Packages/PulsumData/Sources/PulsumData/Resources/PulsumCompiled.momd/Pulsum.omo
  - Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew 1.png
  - Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew 2.png
  - Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew.png
  - checkin.PNG
  - coach.PNG
  - iconlogo.png
  - iconnew.png
  - infinity_blubs_copy.splineswift
  - insights.PNG
  - ios app mockup.png
  - logo.jpg
  - logo2.png
  - main.gif
  - main_screen.PNG
  - mainanimation.usdz
  - streak_low_poly_copy.splineswift

## Binary Assets Manifest
- MAINDESIGN.png | bytes: 3873254 | sha256: 2b9e9954ae9bc6745f489cb2b13ca1107537986573244cfe11118addd2cd6975 | mime: image/png
- Packages/PulsumData/Sources/PulsumData/Resources/PulsumCompiled.momd/Pulsum.mom | bytes: 8979 | sha256: 68428a1ca3616794a23639244e64bca6067ce5d0aa60d6af3f8dd98812292e2a | mime: application/octet-stream
- Packages/PulsumData/Sources/PulsumData/Resources/PulsumCompiled.momd/Pulsum.omo | bytes: 22072 | sha256: c55bdf15726e2c4928e56429ddd4a5be3225469b4edd403baab16bd595123f02 | mime: application/octet-stream
- Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew 1.png | bytes: 1003595 | sha256: 385725135bac608155c1053621e7f4fb29f1eadb6e4c684e97a0daf114293f3e | mime: image/png
- Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew 2.png | bytes: 1003595 | sha256: 385725135bac608155c1053621e7f4fb29f1eadb6e4c684e97a0daf114293f3e | mime: image/png
- Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew.png | bytes: 1003595 | sha256: 385725135bac608155c1053621e7f4fb29f1eadb6e4c684e97a0daf114293f3e | mime: image/png
- checkin.PNG | bytes: 3611007 | sha256: 641ca102a24016ef38d97f4ce93b366e082c4247a84d55444328328d215004d3 | mime: image/png
- coach.PNG | bytes: 923693 | sha256: 50352b61e1ea7ae0d2d2fdfad53a3c3439fe084861e6be5b8c340338c7a167ab | mime: image/png
- iconlogo.png | bytes: 1075847 | sha256: 5361f97e227b7a233531a1e0000fad2bfaef29e5d17e8c118508376bebc8a235 | mime: image/png
- iconnew.png | bytes: 1003595 | sha256: 385725135bac608155c1053621e7f4fb29f1eadb6e4c684e97a0daf114293f3e | mime: image/png
- infinity_blubs_copy.splineswift | bytes: 272828 | sha256: fe4f7c35996a6a20cf60816d913b93aa18ca959e8b8ef3bb5acfa04dd704c461 | mime: application/octet-stream
- insights.PNG | bytes: 1287335 | sha256: 05d1fe48775dbe2629ab67d0c749f51e482cc6cc0b8b1bd8ffe9311ab2ea1691 | mime: image/png
- ios app mockup.png | bytes: 2821699 | sha256: a0d118c867dba9ef8f52097419c608d7912946fcd85e7584df81b189a38094ff | mime: image/png
- logo.jpg | bytes: 152344 | sha256: 49ecea236ea825afed3f4dbe6f374299cbbb87aadbaaf5ce029c8c7c1ca34de2 | mime: image/jpeg
- logo2.png | bytes: 585439 | sha256: 0cb9ec37668a50f75151942e2d993608f7a9507c805fabac700cae47805bfe46 | mime: image/png
- main.gif | bytes: 21811312 | sha256: d49ff5e5cfa2570bebd3ecb24870f4b2e8631ebb1b936773ee9b631071bd3c19 | mime: image/gif
- main_screen.PNG | bytes: 1106195 | sha256: 5891481a24daa3fd7c0ef4eada6801717240f5b1a717f44dcf04d83b4381a931 | mime: image/png
- mainanimation.usdz | bytes: 47388 | sha256: 9dd79ebe7c92c39a772b39316f8dbf3c4c459721363aaee27215453374e9a0e3 | mime: application/octet-stream
- streak_low_poly_copy.splineswift | bytes: 49425 | sha256: 60b540c0a7857b24f6406627dd3f64b7760d08037d4384aaaf4e99b66a7fd9b9 | mime: application/octet-stream

## File Contents (VERBATIM)

### .github/coderabbit.yaml
- bytes: 2912
- lines: 91
- sha256: f03696726f48b362128f629b36624fd88aebce0a0fe328262535340984e2fbda
- trailing_newline: true

<!-- BEGIN_FILE: .github/coderabbit.yaml -->
```text
# CodeRabbit Configuration for Pulsum
# https://docs.coderabbit.ai/guides/review-instructions/

# Language and Frameworks
language: en-US
early_access: true
reviews:
  # Review settings
  profile: chill
  request_changes_workflow: false
  high_level_summary: true
  poem: false
  review_status: true
  collapse_walkthrough: false
  
  # Auto-review PRs
  auto_review:
    enabled: true
    drafts: false
    base_branches:
      - main
  
  # Path-specific instructions
  path_instructions:
    - path: "Packages/PulsumAgents/**/*.swift"
      instructions: |
        Focus on agent coordination, state management, and memory handling.
        Check for proper error handling and async/await patterns.
    
    - path: "Packages/PulsumML/**/*.swift"
      instructions: |
        Review ML model integration, safety guardrails, and performance.
        Ensure proper handling of Foundation Models API.
    
    - path: "Packages/PulsumServices/**/*.swift"
      instructions: |
        Check service layer patterns, API contracts, and error handling.
        Verify proper dependency injection and testing.
    
    - path: "Packages/PulsumUI/**/*.swift"
      instructions: |
        Review SwiftUI best practices, state management, and accessibility.
        Check for performance issues and proper view composition.
    
    - path: "Packages/PulsumData/**/*.swift"
      instructions: |
        Focus on Core Data models, migrations, and data integrity.
        Review persistence layer and memory management.

# Chat settings
chat:
  auto_reply: true

# Knowledge base
knowledge_base:
  opt_out: false
  
  # Project-specific context
  learnings:
    scope: auto

# Tools configuration
tools:
  # AST-based analysis
  ast:
    enabled: true
  
  # Static analysis
  static_analysis:
    enabled: true
  
  # GitHub Actions integration
  github_actions:
    enabled: true

# Review focus areas for iOS/Swift project
review_instructions: |
  This is an iOS app (Pulsum) built with SwiftUI, using modular Swift packages.
  Key areas to focus on:
  
  1. **Swift Best Practices**: Modern Swift patterns, proper use of protocols, generics, and type safety
  2. **SwiftUI**: Proper state management (@State, @StateObject, @ObservedObject), view composition, performance
  3. **Concurrency**: Correct usage of async/await, actors, and Swift Concurrency patterns
  4. **Memory Management**: Proper use of weak/unowned references, avoiding retain cycles
  5. **Core Data**: Thread safety, proper context usage, and data integrity
  6. **Foundation Models**: Proper integration with Apple's Foundation Models API and safety guardrails
  7. **Testing**: Suggest testable patterns and potential edge cases
  8. **Architecture**: Maintain separation of concerns across packages (Agents, ML, Services, Data, UI)
  
  Be constructive and focus on actionable feedback. Prioritize correctness, safety, and maintainability.

```
<!-- END_FILE: .github/coderabbit.yaml -->

### .github/workflows/auto-merge.yml
- bytes: 3598
- lines: 104
- sha256: 0512dcbd61988c4f4229dfa033be784b9be92295e1ce6c65d8f2a4f5fe219ab9
- trailing_newline: true

<!-- BEGIN_FILE: .github/workflows/auto-merge.yml -->
```text
name: Auto Merge PR

# OPTIONAL: Automatically merges PRs after CodeRabbit approval
# This is disabled by default for safety. Enable it by uncommenting the 'on' triggers below.

# Uncomment the lines below to enable auto-merge:
# on:
#   pull_request_review:
#     types: [submitted]
#   check_suite:
#     types: [completed]

# Keep this commented out initially - you can enable it later once you're comfortable
on:
  workflow_dispatch:  # Manual trigger only for now

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    
    # Only run on PRs with the auto-created label
    if: |
      github.event_name == 'workflow_dispatch' ||
      (contains(github.event.pull_request.labels.*.name, 'auto-created') && 
       github.event.review.state == 'approved')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Check PR status
        id: check-status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Manual workflow dispatch - skipping"
            echo "should_merge=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          # Check if all checks passed
          CHECKS_STATUS=$(gh pr checks "$PR_NUMBER" --json state --jq 'all(.state == "SUCCESS")')
          echo "checks_passed=$CHECKS_STATUS" >> $GITHUB_OUTPUT
          
          # Check if PR is approved
          APPROVALS=$(gh pr view "$PR_NUMBER" --json reviewDecision --jq .reviewDecision)
          echo "approval_status=$APPROVALS" >> $GITHUB_OUTPUT
          
          if [ "$CHECKS_STATUS" = "true" ] && [ "$APPROVALS" = "APPROVED" ]; then
            echo "should_merge=true" >> $GITHUB_OUTPUT
          else
            echo "should_merge=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Auto merge PR
        if: steps.check-status.outputs.should_merge == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          echo "✅ All checks passed and PR is approved"
          echo "🔀 Merging PR #$PR_NUMBER..."
          
          gh pr merge "$PR_NUMBER" \
            --squash \
            --auto \
            --delete-branch
          
          echo "✅ PR merged and branch deleted successfully!"
      
      - name: Skip merge
        if: steps.check-status.outputs.should_merge != 'true'
        run: |
          echo "⏸️ Skipping auto-merge:"
          echo "   - Checks passed: ${{ steps.check-status.outputs.checks_passed }}"
          echo "   - Approval status: ${{ steps.check-status.outputs.approval_status }}"
          echo "   Merge will happen when all conditions are met."

# ============================================================================
# HOW TO ENABLE AUTO-MERGE:
# ============================================================================
# 
# Once you're comfortable with the workflow:
# 
# 1. Uncomment lines 6-10 (the 'on:' triggers)
# 2. Comment out or remove line 13 (workflow_dispatch)
# 3. Commit and push this file
# 4. Future PRs will auto-merge after CodeRabbit approves and checks pass
# 
# Note: You can also enable manual merging in GitHub settings:
# Repository Settings → General → Pull Requests → 
# ✓ Allow auto-merge
# 
# ============================================================================

```
<!-- END_FILE: .github/workflows/auto-merge.yml -->

### .github/workflows/auto-pr.yml
- bytes: 2608
- lines: 85
- sha256: 3065d4e0b62f2faf6cef076c3e9b55e42546f861e8bb8ba4532d10124ae331d3
- trailing_newline: true

<!-- BEGIN_FILE: .github/workflows/auto-pr.yml -->
```text
name: Auto Create Pull Request

# Automatically creates a PR when you push a feature branch
# This enables CodeRabbit to review your changes

on:
  push:
    branches:
      - 'feature/**'
      - 'bugfix/**'
      - 'hotfix/**'
      - 'refactor/**'
      - 'chore/**'

permissions:
  contents: write
  pull-requests: write

jobs:
  create-pr:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Check if PR already exists
        id: check-pr
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          PR_EXISTS=$(gh pr list --head "$BRANCH_NAME" --json number --jq length)
          echo "pr_exists=$PR_EXISTS" >> $GITHUB_OUTPUT
      
      - name: Create Pull Request
        if: steps.check-pr.outputs.pr_exists == '0'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.check-pr.outputs.branch }}"
          
          # Extract meaningful title from branch name
          # e.g., feature/add-user-auth -> Add user auth
          PR_TITLE=$(echo "$BRANCH_NAME" | sed 's/.*\///' | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g')
          
          # Create PR body with useful information
          PR_BODY="## Changes
          
          This PR was automatically created from branch \`$BRANCH_NAME\`.
          
          ### 🤖 Automated PR Creation
          
          CodeRabbit will review this PR automatically. Once approved, you can merge it manually or it will auto-merge if configured.
          
          ### ✅ Checklist
          
          - [ ] Code follows project style guidelines
          - [ ] Tests pass locally
          - [ ] Documentation updated if needed
          - [ ] No breaking changes
          
          ---
          *Auto-generated by GitHub Actions*"
          
          gh pr create \
            --title "[$BRANCH_NAME] $PR_TITLE" \
            --body "$PR_BODY" \
            --base main \
            --head "$BRANCH_NAME" \
            --label "auto-created"
      
      - name: Comment on PR creation
        if: steps.check-pr.outputs.pr_exists == '0'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "✅ Pull Request created successfully!"
          echo "🤖 CodeRabbit will review it shortly"
          echo "📊 Check the PR at: https://github.com/${{ github.repository }}/pulls"

```
<!-- END_FILE: .github/workflows/auto-pr.yml -->

### .github/workflows/test-harness.yml
- bytes: 484
- lines: 25
- sha256: 897b2845a62966a48136ba47be910ccc3234ca422c09a347acbf0102b698b8c8
- trailing_newline: true

<!-- BEGIN_FILE: .github/workflows/test-harness.yml -->
```text
name: gate-tests
on:
  push:
    branches: [ main, gate1-testing-harness ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  gate-tests:
    runs-on: macos-15
    env:
      PULSUM_SIM_OS: "26.0.1"
    steps:
      - uses: actions/checkout@v4

      - name: Tools
        run: |
          brew update
          brew install ripgrep xcbeautify || true

      - name: Dynamic gate harness
        run: |
          swift --version
          scripts/ci/test-harness.sh
```
<!-- END_FILE: .github/workflows/test-harness.yml -->

### .gitignore
- bytes: 792
- lines: 59
- sha256: 57cba5cc4f664efa32f4b0f9b4bd5b24299e94e76627cbf1d4fee3ceacf46ae5
- trailing_newline: true

<!-- BEGIN_FILE: .gitignore -->
```text
# macOS
.DS_Store
*.swp

# Xcode user data
xcuserdata/
*.xcuserstate
*.pbxuser
*.mode1v3
*.mode2v3
*.perspectivev3
!default.pbxuser
!default.mode1v3
!default.mode2v3
!default.perspectivev3
*.moved-aside
*.xccheckout
*.xcscmblueprint
*.xcworkspace/xcuserdata/
Pulsum.xcodeproj/project.xcworkspace/xcuserdata/

# Build outputs
DerivedData/
Build/
*.xcarchive
*.xcresult
*.ipa
*.dSYM
*.dSYM.zip
*.app

# SwiftPM
.build/
.swiftpm/

# CocoaPods
Pods/

# Carthage
Carthage/Build/

# Editors / tooling
.vscode/
.idea/
.claude/

# Logs / temp
*.log
*.tmp

# Local config / secrets (track only template)
## CI needs this tracked: Config.xcconfig
.env
.env.*
!Config.xcconfig.template

# NOTE: DO NOT ignore
#  • PrivacyInfo.xcprivacy (app + packages)
#  • Package.resolved (recommended to commit)
```
<!-- END_FILE: .gitignore -->

### Config.xcconfig
- bytes: 260
- lines: 12
- sha256: 632f4dbdd1aaf681a0715a1b74dabd1e05a00ab0dd386d288d0a46b36ead6be9
- trailing_newline: true

<!-- BEGIN_FILE: Config.xcconfig -->
```text
// Pulsum Build Configuration
// Secrets are never stored in this file. Use Keychain or environment variables on the build machine.
// For local development, provide `PULSUM_COACH_API_KEY` via `launchctl setenv` or an .xcconfig that is not committed.









```
<!-- END_FILE: Config.xcconfig -->

### Config.xcconfig.template
- bytes: 274
- lines: 12
- sha256: 9fac47b34d6f545fbbc607aa678ff1a46eb73c38443794db0b251195a81ad7cc
- trailing_newline: true

<!-- BEGIN_FILE: Config.xcconfig.template -->
```text
// Pulsum Build Configuration Template
// Copy this file to Config.xcconfig if you need local overrides.
// Secrets are never stored here. Provide `PULSUM_COACH_API_KEY` via the environment (e.g., launchctl setenv) instead.

OPENAI_API_KEY = YOUR_OPENAI_API_KEY_HERE







```
<!-- END_FILE: Config.xcconfig.template -->

### Packages/PulsumAgents/Package.swift
- bytes: 1351
- lines: 53
- sha256: a853f5614a7d5d7228091a0223e4bf53b711984a75c039a151cd9440c446dd27
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Package.swift -->
```swift
// swift-tools-version: 6.1
import PackageDescription

let package = Package(
    name: "PulsumAgents",
    platforms: [
        .iOS("26.0"),
        .macOS(.v14)
    ],
    products: [
        .library(
            name: "PulsumAgents",
            targets: ["PulsumAgents"]
        )
    ],
    dependencies: [
        .package(path: "../PulsumData"),
        .package(path: "../PulsumServices"),
        .package(path: "../PulsumML"),
        .package(path: "../PulsumTypes")
    ],
    targets: [
        .target(
            name: "PulsumAgents",
            dependencies: [
                "PulsumData",
                "PulsumServices",
                "PulsumML",
                "PulsumTypes"
            ],
            path: "Sources",
            resources: [
                .process("PulsumAgents/PrivacyInfo.xcprivacy")
            ],
            linkerSettings: [
                .linkedFramework("FoundationModels", .when(platforms: [.iOS]))
            ]
        ),
        .testTarget(
            name: "PulsumAgentsTests",
            dependencies: [
                "PulsumAgents",
                "PulsumServices",
                "PulsumML",
                "PulsumTypes"
            ],
            path: "Tests",
            resources: [
                .process("PulsumAgentsTests/Resources")
            ]
        )
    ]
)
```
<!-- END_FILE: Packages/PulsumAgents/Package.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/AgentOrchestrator.swift
- bytes: 46483
- lines: 963
- sha256: 4f4ea8e88721aff22f8b2c8854180e3afe59dd3eb6668bd386ae123cd4357a68
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/AgentOrchestrator.swift -->
```swift
import Foundation
import CoreData
#if canImport(FoundationModels)
import FoundationModels
#endif
import os
import PulsumData
import PulsumServices
import PulsumML
import PulsumTypes

public enum OrchestratorStartupError: Error {
    case healthDataUnavailable
    case healthBackgroundDeliveryMissing(underlying: Error)
}

// MARK: - Topic routing helpers

struct TopicSignalResolver {
    static func mapTopicToSignalOrDataDominant(topic: String?,
                                               snapshot: FeatureVectorSnapshot) -> String {
        if let topic,
           let focus = TopicFocus(rawValue: topic) {
            return focus.signalKey
        }
        return dataDominantSignal(from: snapshot)
    }

    static func dataDominantSignal(from snapshot: FeatureVectorSnapshot) -> String {
        let prioritizedKeys = snapshot.features.keys
            .filter { $0.hasPrefix("z_") || $0.hasPrefix("subj_") || $0 == "sentiment" }
            .sorted()

        var dominantSignal = "subj_energy"
        var maxAbsZ = 0.0

        for key in prioritizedKeys {
            guard let value = snapshot.features[key] else { continue }
            let magnitude = abs(value)
            if magnitude > maxAbsZ {
                maxAbsZ = magnitude
                dominantSignal = key
            }
        }

        return dominantSignal
    }

    private enum TopicFocus: String {
        case sleep
        case stress
        case energy
        case hrv
        case mood
        case movement
        case mindfulness
        case goals

        var signalKey: String {
            switch self {
            case .sleep: return "subj_sleepQuality"
            case .stress: return "subj_stress"
            case .energy: return "subj_energy"
            case .hrv: return "z_hrv"
            case .mood: return "sentiment"
            case .movement: return "z_steps"
            case .mindfulness: return "z_rr"
            case .goals: return "subj_energy"
            }
        }
    }
}

protocol DataAgentProviding: AnyObject, Sendable {
    func start() async throws
    func setDiagnosticsTraceId(_ traceId: UUID?) async
    func latestFeatureVector() async throws -> FeatureVectorSnapshot?
    func recordSubjectiveInputs(date: Date, stress: Double, energy: Double, sleepQuality: Double) async throws
    func scoreBreakdown() async throws -> ScoreBreakdown?
    func reprocessDay(date: Date) async throws
    func currentHealthAccessStatus() async -> HealthAccessStatus
    func requestHealthAccess() async throws -> HealthAccessStatus
    func restartIngestionAfterPermissionsChange() async throws -> HealthAccessStatus
    func diagnosticsBackfillCounts() async -> (warmCompleted: Int, fullCompleted: Int)
    func latestSnapshotMetadata() async -> (dayString: String?, score: Double?)
}

extension DataAgent: DataAgentProviding {}

@MainActor
protocol SentimentAgentProviding: AnyObject {
    func beginVoiceJournal(maxDuration: TimeInterval) async throws
    func finishVoiceJournal(transcript: String?) async throws -> JournalResult
    func recordVoiceJournal(maxDuration: TimeInterval) async throws -> JournalResult
    func importTranscript(_ transcript: String) async throws -> JournalResult
    func requestAuthorization() async throws
    func stopRecording()
    var audioLevels: AsyncStream<Float>? { get }
    var speechStream: AsyncThrowingStream<SpeechSegment, Error>? { get }
    func updateTranscript(_ transcript: String)
    func latestTranscriptSnapshot() -> String
    func reprocessPendingJournals(traceId: UUID?) async
    func pendingEmbeddingCount() async -> Int
}

extension SentimentAgent: SentimentAgentProviding {}

public struct RecommendationResponse {
    public let cards: [RecommendationCard]
    public let wellbeingScore: Double
    public let contributions: [String: Double]
    public let wellbeingState: WellbeingScoreState
    public let notice: String?
}

public struct WellbeingSnapshotResponse: Sendable {
    public let wellbeingState: WellbeingScoreState
    public let snapshotKind: WellbeingSnapshotKind
    public let dayString: String?
}

public struct JournalCaptureResponse {
    public let result: JournalResult
    public let safety: SafetyDecision
}

public struct RecommendationCard: Equatable, Sendable {
    public let id: String
    public let title: String
    public let body: String
    public let caution: String?
    public let sourceBadge: String
}

public struct SafetyDecision {
    public let classification: SafetyClassification
    public let allowCloud: Bool
    public let crisisMessage: String?
}

public struct JournalResult: @unchecked Sendable {
    public let entryID: NSManagedObjectID
    public let date: Date
    public let transcript: String
    public let sentimentScore: Double
    public let vectorURL: URL?
    public let embeddingPending: Bool
}

public struct CheerEvent {
    public enum HapticStyle {
        case success
        case light
        case heavy
    }

    public let message: String
    public let haptic: HapticStyle
    public let timestamp: Date
}

@MainActor
public final class AgentOrchestrator {
    private let dataAgent: any DataAgentProviding
    private let sentimentAgent: any SentimentAgentProviding
    private let coachAgent: CoachAgent
    private let safetyAgent: SafetyAgent
    private let cheerAgent: CheerAgent
    private let embeddingService: EmbeddingService

    private let afmAvailable: Bool
    private let topicGate: TopicGateProviding
    private let logger = Logger(subsystem: "com.pulsum", category: "AgentOrchestrator")
    private var isVoiceJournalActive = false
    private let recommendationSnapshotTimeoutSeconds: Double = 2
    private let recommendationsTimeoutSeconds: Double
    
    public init() throws {
        // Check Foundation Models availability
#if canImport(FoundationModels) && os(iOS)
        if #available(iOS 26.0, *) {
            self.afmAvailable = SystemLanguageModel.default.isAvailable
        } else {
            self.afmAvailable = false
        }
#else
        self.afmAvailable = false
#endif

        // Initialize TopicGate with cascade: AFM → embedding fallback
#if canImport(FoundationModels) && os(iOS)
        if #available(iOS 26.0, *), SystemLanguageModel.default.isAvailable {
            self.topicGate = FoundationModelsTopicGateProvider()
        } else {
            self.topicGate = EmbeddingTopicGateProvider()
        }
#else
        self.topicGate = EmbeddingTopicGateProvider()
#endif

        self.dataAgent = DataAgent()
        self.sentimentAgent = SentimentAgent()
        self.coachAgent = try CoachAgent()
        self.safetyAgent = SafetyAgent()
        self.cheerAgent = CheerAgent()
        self.embeddingService = EmbeddingService.shared
        self.recommendationsTimeoutSeconds = 30
    }
#if DEBUG
    init(dataAgent: any DataAgentProviding,
                sentimentAgent: any SentimentAgentProviding,
                coachAgent: CoachAgent,
                safetyAgent: SafetyAgent,
                cheerAgent: CheerAgent,
                topicGate: TopicGateProviding,
                embeddingService: EmbeddingService = .shared,
                afmAvailable: Bool = false,
                recommendationsTimeoutSeconds: Double = 30) {
        self.dataAgent = dataAgent
        self.sentimentAgent = sentimentAgent
        self.coachAgent = coachAgent
        self.safetyAgent = safetyAgent
        self.cheerAgent = cheerAgent
        self.topicGate = topicGate
        self.afmAvailable = afmAvailable
        self.embeddingService = embeddingService
        self.recommendationsTimeoutSeconds = recommendationsTimeoutSeconds
    }
#endif

#if DEBUG
    init(testDataAgent: DataAgent,
         testSentimentAgent: any SentimentAgentProviding,
         testCoachAgent: CoachAgent,
         testSafetyAgent: SafetyAgent,
         testCheerAgent: CheerAgent,
         testTopicGate: TopicGateProviding,
         afmAvailable: Bool = false,
         recommendationsTimeoutSeconds: Double = 30) {
        self.dataAgent = testDataAgent
        self.sentimentAgent = testSentimentAgent
        self.coachAgent = testCoachAgent
        self.safetyAgent = testSafetyAgent
        self.cheerAgent = testCheerAgent
        self.afmAvailable = afmAvailable
        self.topicGate = testTopicGate
        self.embeddingService = .shared
        self.recommendationsTimeoutSeconds = recommendationsTimeoutSeconds
    }
#endif
    
    public var foundationModelsStatus: String {
        if #available(iOS 26.0, *) {
            let status = FoundationModelsAvailability.checkAvailability()
            return FoundationModelsAvailability.availabilityMessage(for: status)
        } else {
            return "Foundation Models require iOS 26 or later."
        }
    }

    public func debugLogSnapshot() async -> String {
        await DebugLogBuffer.shared.snapshot()
    }

    public func start(traceId: UUID? = nil) async throws {
        let span = Diagnostics.span(category: .orchestrator,
                                    name: "orchestrator.start",
                                    fields: ["afm_available": .bool(afmAvailable)],
                                    traceId: traceId)
        do {
            let librarySpan = Diagnostics.span(category: .library,
                                               name: "orchestrator.start.prepareLibrary",
                                               traceId: traceId,
                                               level: .info)
            do {
                try await coachAgent.prepareLibraryIfNeeded()
                librarySpan.end(error: nil)
            } catch {
                librarySpan.end(error: error)
                throw error
            }

            await dataAgent.setDiagnosticsTraceId(traceId)
            let dataSpan = Diagnostics.span(category: .dataAgent,
                                            name: "orchestrator.start.dataAgent",
                                            traceId: traceId)
            do {
                try await dataAgent.start()
                dataSpan.end(error: nil)
            } catch {
                dataSpan.end(error: error)
                throw error
            }

            let refreshSpan = Diagnostics.span(category: .orchestrator,
                                               name: "orchestrator.start.refreshDeferred",
                                               traceId: traceId)
            await refreshOnDeviceModelAvailabilityAndRetryDeferredWork(traceId: traceId)
            refreshSpan.end(error: nil)
            let healthStatus = await dataAgent.currentHealthAccessStatus()
            let embeddingsAvailable = embeddingService.availabilityMode(trigger: "start") == .available
            let pendingJournals = await sentimentAgent.pendingEmbeddingCount()
            let backfillCounts = await dataAgent.diagnosticsBackfillCounts()
            let checkpointFields: [String: DiagnosticsValue] = [
                "health_granted": .int(healthStatus.granted.count),
                "health_denied": .int(healthStatus.denied.count),
                "health_pending": .int(healthStatus.notDetermined.count),
                "health_available": .safeString(.stage(healthStatus.availability == .available ? "available" : "unavailable",
                                                       allowed: ["available", "unavailable"])),
                "embeddings_available": .bool(embeddingsAvailable),
                "pending_journals": .int(pendingJournals),
                "backfill_warm_completed": .int(backfillCounts.warmCompleted),
                "backfill_full_completed": .int(backfillCounts.fullCompleted),
                "library_deferred": .bool(coachAgent.libraryImportDeferred)
            ]
            Diagnostics.log(level: .info,
                            category: .orchestrator,
                            name: "timeline.firstRun.checkpoint",
                            fields: checkpointFields,
                            traceId: traceId)
            span.end(additionalFields: checkpointFields, error: nil)
        } catch let healthError as HealthKitServiceError {
            span.end(additionalFields: [:], error: healthError)
            switch healthError {
            case .healthDataUnavailable:
                throw OrchestratorStartupError.healthDataUnavailable
            case let .backgroundDeliveryFailed(_, underlying):
                throw OrchestratorStartupError.healthBackgroundDeliveryMissing(underlying: underlying)
            default:
                throw healthError
            }
        } catch {
            span.end(additionalFields: [:], error: error)
            throw error
        }
    }

    public func currentHealthAccessStatus() async -> HealthAccessStatus {
        await dataAgent.currentHealthAccessStatus()
    }

    public func requestHealthAccess() async throws -> HealthAccessStatus {
        try await dataAgent.requestHealthAccess()
    }

    public func restartHealthDataIngestion() async throws -> HealthAccessStatus {
        try await dataAgent.restartIngestionAfterPermissionsChange()
    }

    /// Re-probes on-device embedding availability and retries any deferred work (pending journal embeddings, library indexing).
    public func refreshOnDeviceModelAvailabilityAndRetryDeferredWork(traceId: UUID? = nil) async {
        embeddingService.invalidateAvailabilityCache()
        let mode = await embeddingService.refreshAvailability(force: true, trigger: "retry_deferred")
        Diagnostics.log(level: .info,
                        category: .embeddings,
                        name: "embeddings.availability.changed",
                        fields: ["state": .safeString(.stage(mode == .available ? "available" : "unavailable",
                                                             allowed: ["available", "unavailable"]))],
                        traceId: traceId)
        guard mode == .available else { return }
        await sentimentAgent.reprocessPendingJournals(traceId: traceId)
        await coachAgent.retryDeferredLibraryImport(traceId: traceId)
    }

    /// Begins voice journal recording and returns immediately after starting audio capture.
    /// Audio levels and speech stream become available synchronously via properties.
    /// The caller should consume `voiceJournalSpeechStream` for real-time transcription.
    /// Call `finishVoiceJournalRecording(transcript:)` to complete recording and get the result.
    public func beginVoiceJournalRecording(maxDuration: TimeInterval = 30) async throws {
        guard !isVoiceJournalActive else {
            throw SentimentAgentError.sessionAlreadyActive
        }
        isVoiceJournalActive = true
        do {
            try await sentimentAgent.beginVoiceJournal(maxDuration: maxDuration)
        } catch {
            isVoiceJournalActive = false
            throw error
        }
    }
    
    /// Completes the voice journal recording that was started with `beginVoiceJournalRecording()`.
    /// Uses the provided transcript (from consuming the speech stream) to persist the journal.
    /// Returns the journal result with safety evaluation.
    public func finishVoiceJournalRecording(transcript: String? = nil) async throws -> JournalCaptureResponse {
        defer { isVoiceJournalActive = false }
        let result = try await sentimentAgent.finishVoiceJournal(transcript: transcript)
        let safety = await safetyAgent.evaluate(text: result.transcript)
        try await dataAgent.reprocessDay(date: result.date)
        return JournalCaptureResponse(result: result, safety: safety)
    }

    /// Legacy method that combines begin + finish for backward compatibility
    public func recordVoiceJournal(maxDuration: TimeInterval = 30) async throws -> JournalCaptureResponse {
        try await beginVoiceJournalRecording(maxDuration: maxDuration)
        var transcript = ""
        do {
            if let stream = voiceJournalSpeechStream {
                for try await segment in stream {
                    transcript = segment.transcript
                    sentimentAgent.updateTranscript(transcript)
                }
            }
            return try await finishVoiceJournalRecording(transcript: transcript)
        } catch {
            let fallbackTranscript = transcript.isEmpty ? sentimentAgent.latestTranscriptSnapshot() : transcript
            if !fallbackTranscript.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                _ = try? await finishVoiceJournalRecording(transcript: fallbackTranscript)
            } else {
                stopVoiceJournalRecording()
            }
            throw error
        }
    }

    public func submitTranscript(_ text: String) async throws -> JournalCaptureResponse {
        let result = try await sentimentAgent.importTranscript(text)
        let safety = await safetyAgent.evaluate(text: result.transcript)
        return JournalCaptureResponse(result: result, safety: safety)
    }

    public func currentLLMAPIKey() -> String? {
        coachAgent.currentLLMAPIKey()
    }

    public func setLLMAPIKey(_ key: String) throws {
        try coachAgent.setLLMAPIKey(key)
    }

    public func testLLMAPIConnection() async throws -> Bool {
        try await coachAgent.testLLMAPIConnection()
    }

    public func stopVoiceJournalRecording() {
        isVoiceJournalActive = false
        sentimentAgent.stopRecording()
    }
    
    public var voiceJournalAudioLevels: AsyncStream<Float>? {
        sentimentAgent.audioLevels
    }
    
    public var voiceJournalSpeechStream: AsyncThrowingStream<SpeechSegment, Error>? {
        sentimentAgent.speechStream
    }

    public func updateVoiceJournalTranscript(_ transcript: String) {
        sentimentAgent.updateTranscript(transcript)
    }

    public func updateSubjectiveInputs(date: Date, stress: Double, energy: Double, sleepQuality: Double) async throws {
        try await dataAgent.recordSubjectiveInputs(date: date, stress: stress, energy: energy, sleepQuality: sleepQuality)
    }

    public func wellbeingSnapshotState(consentGranted: Bool) async throws -> WellbeingSnapshotResponse {
        _ = consentGranted
        try Task.checkCancellation()
        let healthStatus = await dataAgent.currentHealthAccessStatus()

        let snapshotResult: HardTimeoutResult<FeatureVectorSnapshot?>
        do {
            snapshotResult = try await withHardTimeout(seconds: recommendationSnapshotTimeoutSeconds) {
                try await self.dataAgent.latestFeatureVector()
            }
        } catch {
            if error is CancellationError { throw error }
            let metadata = await dataAgent.latestSnapshotMetadata()
            return Self.makeNoDataSnapshotResponse(for: healthStatus,
                                                   dayString: metadata.dayString,
                                                   snapshotKind: .none)
        }

        switch snapshotResult {
        case .timedOut:
            Diagnostics.log(level: .warn,
                            category: .dataAgent,
                            name: "data.snapshot.timeout",
                            fields: [
                                "timeout_seconds": .double(recommendationSnapshotTimeoutSeconds)
                            ])
            let metadata = await dataAgent.latestSnapshotMetadata()
            return Self.makeNoDataSnapshotResponse(for: healthStatus,
                                                   dayString: metadata.dayString,
                                                   snapshotKind: .none)
        case .value(let snapshot):
            guard let snapshot else {
                let metadata = await dataAgent.latestSnapshotMetadata()
                return Self.makeNoDataSnapshotResponse(for: healthStatus,
                                                       dayString: metadata.dayString,
                                                       snapshotKind: .none)
            }
            if SnapshotPlaceholder.isPlaceholder(snapshot) {
                let metadata = await dataAgent.latestSnapshotMetadata()
                return Self.makeNoDataSnapshotResponse(for: healthStatus,
                                                       dayString: metadata.dayString,
                                                       snapshotKind: .placeholder)
            }
            return WellbeingSnapshotResponse(wellbeingState: .ready(score: snapshot.wellbeingScore,
                                                                    contributions: snapshot.contributions),
                                             snapshotKind: .real,
                                             dayString: DiagnosticsDayFormatter.dayString(from: snapshot.date))
        }
    }

    public func recommendations(consentGranted: Bool) async throws -> RecommendationResponse {
        try Task.checkCancellation()
        let healthStatus = await dataAgent.currentHealthAccessStatus()

        let snapshotResult: HardTimeoutResult<FeatureVectorSnapshot?>
        do {
            snapshotResult = try await withHardTimeout(seconds: recommendationSnapshotTimeoutSeconds) {
                try await self.dataAgent.latestFeatureVector()
            }
        } catch {
            if error is CancellationError { throw error }
            return Self.makeNoDataRecommendationResponse(for: healthStatus)
        }

        switch snapshotResult {
        case .timedOut:
            Diagnostics.log(level: .warn,
                            category: .dataAgent,
                            name: "data.snapshot.timeout",
                            fields: [
                                "timeout_seconds": .double(recommendationSnapshotTimeoutSeconds)
                            ])
            return Self.makeNoDataRecommendationResponse(for: healthStatus)
        case .value(let snapshot):
            guard let snapshot else {
                return Self.makeNoDataRecommendationResponse(for: healthStatus)
            }
            if SnapshotPlaceholder.isPlaceholder(snapshot) {
                return Self.makeNoDataRecommendationResponse(for: healthStatus)
            }
            do {
                try Task.checkCancellation()
                let recommendationResult = try await withHardTimeout(seconds: recommendationsTimeoutSeconds) {
                    try await self.coachAgent.recommendationCards(for: snapshot, consentGranted: consentGranted)
                }
                try Task.checkCancellation()
                switch recommendationResult {
                case .timedOut:
                    Diagnostics.log(level: .warn,
                                    category: .coach,
                                    name: "coach.recommendations.timeout",
                                    fields: [
                                        "timeout_seconds": .double(recommendationsTimeoutSeconds)
                                    ])
                    return RecommendationResponse(cards: [],
                                                  wellbeingScore: snapshot.wellbeingScore,
                                                  contributions: snapshot.contributions,
                                                  wellbeingState: .ready(score: snapshot.wellbeingScore,
                                                                          contributions: snapshot.contributions),
                                                  notice: "Recommendations are taking longer than expected. Try refreshing again soon.")
                case .value(let cards):
                    let notice = coachAgent.recommendationNotice
                    return RecommendationResponse(cards: cards,
                                                  wellbeingScore: snapshot.wellbeingScore,
                                                  contributions: snapshot.contributions,
                                                  wellbeingState: .ready(score: snapshot.wellbeingScore,
                                                                          contributions: snapshot.contributions),
                                                  notice: notice)
                }
            } catch {
                if error is CancellationError { throw error }
                let sanitized = "Unable to compute wellbeing right now."
                return RecommendationResponse(cards: [],
                                              wellbeingScore: 0,
                                              contributions: [:],
                                              wellbeingState: .error(message: sanitized),
                                              notice: "Personalized recommendations are limited on this device right now.")
            }
        }
    }

    nonisolated static func computeWellbeingState(for healthStatus: HealthAccessStatus) -> WellbeingScoreState {
        switch healthStatus.availability {
        case .unavailable:
            return .noData(.healthDataUnavailable)
        case .available:
            if !healthStatus.denied.isEmpty || !healthStatus.notDetermined.isEmpty {
                return .noData(.permissionsDeniedOrPending)
            }
            return .noData(.insufficientSamples)
        }
    }

    private static func makeNoDataRecommendationResponse(for healthStatus: HealthAccessStatus) -> RecommendationResponse {
        let state = computeWellbeingState(for: healthStatus)
        return RecommendationResponse(cards: [],
                                      wellbeingScore: 0,
                                      contributions: [:],
                                      wellbeingState: state,
                                      notice: nil)
    }

    private static func makeNoDataSnapshotResponse(for healthStatus: HealthAccessStatus,
                                                   dayString: String?,
                                                   snapshotKind: WellbeingSnapshotKind) -> WellbeingSnapshotResponse {
        let state = computeWellbeingState(for: healthStatus)
        return WellbeingSnapshotResponse(wellbeingState: state,
                                         snapshotKind: snapshotKind,
                                         dayString: dayString)
    }

    public func scoreBreakdown() async throws -> ScoreBreakdown? {
        try await dataAgent.scoreBreakdown()
    }

    public func diagnosticsSnapshot() async -> DiagnosticsSnapshot {
        let healthStatus = await dataAgent.currentHealthAccessStatus()
        let embeddingsAvailable = embeddingService.availabilityMode(trigger: "snapshot") == .available
        let pendingJournals = await sentimentAgent.pendingEmbeddingCount()
        let backfillCounts = await dataAgent.diagnosticsBackfillCounts()
        let latest = await dataAgent.latestSnapshotMetadata()
        return DiagnosticsSnapshot(
            healthGrantedCount: healthStatus.granted.count,
            healthDeniedCount: healthStatus.denied.count,
            healthPendingCount: healthStatus.notDetermined.count,
            healthAvailability: DiagnosticsSafeString.stage(
                healthStatus.availability == .available ? "available" : "unavailable",
                allowed: ["available", "unavailable"]
            ),
            embeddingsAvailable: embeddingsAvailable,
            pendingJournalsCount: pendingJournals,
            backfillWarmCompleted: backfillCounts.warmCompleted,
            backfillFullCompleted: backfillCounts.fullCompleted,
            deferredLibraryImport: coachAgent.libraryImportDeferred,
            lastSnapshotDay: latest.dayString,
            wellbeingScore: latest.score
        )
    }

    public func chat(userInput: String, consentGranted: Bool) async throws -> String {
#if DEBUG
        if AppRuntimeConfig.useStubLLM {
            return "Stub response: Pulsum coach stub reply for UI testing."
        }
#endif
        let sanitizedInput = PIIRedactor.redact(userInput)
        Diagnostics.log(level: .info,
                        category: .coach,
                        name: "coach.chat.request",
                        fields: [
                            "consent": .bool(consentGranted),
                            "input_chars": .int(userInput.count)
                        ])

        guard let snapshot = try await dataAgent.latestFeatureVector(),
              !SnapshotPlaceholder.isPlaceholder(snapshot) else {
            logger.info("No feature vector snapshot available; returning warmup prompt.")
            return "Let's take a moment to capture your pulse first."
        }

        return await performChat(userInput: userInput,
                                 sanitizedInput: sanitizedInput,
                                 snapshot: snapshot,
                                 consentGranted: consentGranted,
                                 diagnosticsContext: "live")
    }

#if DEBUG
    public func chat(userInput: String,
                     consentGranted: Bool,
                     snapshotOverride: FeatureVectorSnapshot) async -> String {
        let sanitizedInput = PIIRedactor.redact(userInput)
        Diagnostics.log(level: .debug,
                        category: .coach,
                        name: "coach.chat.request.override",
                        fields: [
                            "consent": .bool(consentGranted),
                            "input_chars": .int(userInput.count)
                        ])
        return await performChat(userInput: userInput,
                                 sanitizedInput: sanitizedInput,
                                 snapshot: snapshotOverride,
                                 consentGranted: consentGranted,
                                 diagnosticsContext: "override")
    }
#endif

    private func performChat(userInput: String,
                             sanitizedInput: String,
                             snapshot: FeatureVectorSnapshot,
                             consentGranted: Bool,
                             diagnosticsContext: String) async -> String {
        // WALL 1: Safety + On-Topic Guardrail (on-device)
        let safety = await safetyAgent.evaluate(text: userInput)
        let classification: String
        switch safety.classification {
        case .safe:
            classification = "safe"
        case .caution:
            classification = "caution"
        case .crisis:
            classification = "crisis"
        }
        logger.debug("Safety decision → allowCloud: \(safety.allowCloud, privacy: .public), classification: \(classification, privacy: .public)")

        let allowCloud = consentGranted && safety.allowCloud

        if !safety.allowCloud {
            logger.notice("Safety gate blocked cloud usage. Returning guardrail message.")
            switch safety.classification {
            case .crisis:
                emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=nil coverage=fail → safety", decision: nil, top: nil, median: nil, count: nil, context: diagnosticsContext)
                return safety.crisisMessage ?? "If you're in immediate danger, please contact 911."
            case .caution:
                emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=nil coverage=fail → safety", decision: nil, top: nil, median: nil, count: nil, context: diagnosticsContext)
                return "Let's stay with grounding actions for a moment."
            case .safe:
                break
            }
        }

        if Self.isGreeting(sanitizedInput) {
            emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=greeting coverage=skip → on-device", decision: nil, top: nil, median: nil, count: nil, context: diagnosticsContext)
            let context = coachAgent.minimalCoachContext(from: snapshot, topic: "greeting")
            let payload = await coachAgent.generateResponse(context: context,
                                                            intentTopic: "greeting",
                                                            consentGranted: false,
                                                            groundingFloor: 0.40)
            return payload.coachReply
        }

        // Step 2: Topic gate (on-device ML classification)
        let intentTopic: String?
        var topSignal: String
        do {
            let gateDecision = try await topicGate.classify(sanitizedInput)
            logger.debug("Topic gate → isOnTopic: \(gateDecision.isOnTopic, privacy: .public), confidence: \(String(format: "%.2f", gateDecision.confidence), privacy: .public), topic: \(gateDecision.topic ?? "none", privacy: .public)")

            if !gateDecision.isOnTopic {
                logger.notice("Topic gate blocked off-topic request. Returning redirect message.")
                emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=nil coverage=fail → redirect", decision: nil, top: nil, median: nil, count: nil, context: diagnosticsContext)
                return "Let's keep Pulsum focused on your wellbeing data. Ask me about stress, sleep, energy, or today's recommendations."
            }

            // Step 2b: Deterministic intent → topSignal mapping (4-step override)
            var topic = gateDecision.topic
            let lower = sanitizedInput.lowercased()
            let phraseToTopic: [(substr: String, topic: String)] = [
                ("sleep", "sleep"), ("insomnia", "sleep"), ("rest", "sleep"), ("tired", "sleep"),
                ("stress", "stress"), ("anxiety", "stress"), ("overwhelm", "stress"), ("worry", "stress"),
                ("energy", "energy"), ("fatigue", "energy"), ("motivation", "energy"), ("motivat", "energy"),
                ("hrv", "hrv"), ("heart rate variability", "hrv"), ("recovery", "hrv"), ("rmssd", "hrv"),
                ("mood", "mood"), ("feeling", "mood"), ("emotion", "mood"),
                ("movement", "movement"), ("steps", "movement"), ("walk", "movement"), ("exercise", "movement"),
                ("mindfulness", "mindfulness"), ("meditation", "mindfulness"), ("breathe", "mindfulness"), ("calm", "mindfulness"),
                ("goal", "goals"), ("habit", "goals"), ("micro", "goals"), ("activity", "goals")
            ]
            if let hit = phraseToTopic.first(where: { lower.contains($0.substr) }) {
                topic = hit.topic
            }

            let candidateMoments = await coachAgent.candidateMoments(for: topic ?? "goals", limit: 2)
            if let dominantFromCandidates = dominantTopic(from: candidateMoments, coachAgent: coachAgent) {
                topic = dominantFromCandidates
            }

            topSignal = TopicSignalResolver.mapTopicToSignalOrDataDominant(topic: topic, snapshot: snapshot)
            if let topic {
                topSignal += " topic=\(topic)"
            }
            intentTopic = topic

            logger.debug("Intent mapping → topic: \(topic ?? "none", privacy: .public), topSignal: \(topSignal, privacy: .public)")
        } catch {
            let nsError = error as NSError
            logger.error("Topic gate failed. domain=\(nsError.domain, privacy: .public) code=\(nsError.code, privacy: .public). Failing closed.")
            emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=nil coverage=fail → redirect", decision: nil, top: nil, median: nil, count: nil, context: diagnosticsContext)
            return "Let's keep Pulsum focused on your wellbeing data. Ask me about stress, sleep, energy, or today's recommendations."
        }

        // Embedding availability gate: if no on-device embeddings are available, fail closed and respond on-device.
        if !embeddingService.isAvailable() {
            logger.error("Embeddings unavailable; skipping coverage and routing to on-device response.")
            emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=\(intentTopic ?? "nil") coverage=unavailable → on-device",
                                decision: nil,
                                top: nil,
                                median: nil,
                                count: nil,
                                context: diagnosticsContext)
            let topic = intentTopic ?? "wellbeing"
            let context = coachAgent.minimalCoachContext(from: snapshot, topic: topic)
            let payload = await coachAgent.generateResponse(context: context,
                                                            intentTopic: intentTopic ?? topic,
                                                            consentGranted: false,
                                                            groundingFloor: 0.40)
            return payload.coachReply
        }

        // Step 3: Retrieval coverage with hybrid backfill
        let coverageResult: (matches: [VectorMatch], decision: CoverageDecision)
        do {
            coverageResult = try await coachAgent.coverageDecision(for: sanitizedInput,
                                                                   canonicalTopic: intentTopic,
                                                                   snapshot: snapshot)
        } catch {
            if let embeddingError = error as? EmbeddingError, case .generatorUnavailable = embeddingError {
                logger.error("Coverage evaluation skipped: embeddings unavailable. Routing to on-device response.")
                emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=\(intentTopic ?? "nil") coverage=unavailable → on-device", decision: nil, top: nil, median: nil, count: nil, context: diagnosticsContext)
                let topic = intentTopic ?? "wellbeing"
                let context = coachAgent.minimalCoachContext(from: snapshot, topic: topic)
                let payload = await coachAgent.generateResponse(context: context,
                                                                intentTopic: intentTopic ?? topic,
                                                                consentGranted: false,
                                                                groundingFloor: 0.40)
                return payload.coachReply
            }
            let nsError = error as NSError
            logger.error("Coverage evaluation failed. domain=\(nsError.domain, privacy: .public) code=\(nsError.code, privacy: .public). Falling back to redirect.")
            emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=\(intentTopic ?? "nil") coverage=unknown → redirect", decision: nil, top: nil, median: nil, count: nil, context: diagnosticsContext)
            return "Let's keep Pulsum focused on your wellbeing data. Ask me about stress, sleep, energy, or today's recommendations."
        }

        let decision = coverageResult.decision
        let routeDestination = allowCloud ? "cloud" : "on-device"
        let groundingFloor: Double

        switch decision.kind {
        case .strong:
            groundingFloor = 0.50
            emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=\(intentTopic ?? "nil") coverage=strong → \(routeDestination)",
                                decision: decision,
                                top: decision.top,
                                median: decision.median,
                                count: decision.count,
                                context: diagnosticsContext)
        case .soft:
            groundingFloor = 0.40
            emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=\(intentTopic ?? "nil") coverage=soft → \(routeDestination)",
                                decision: decision,
                                top: decision.top,
                                median: decision.median,
                                count: decision.count,
                                context: diagnosticsContext)
        case .fail:
            if intentTopic == nil {
                emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=nil coverage=fail → on-device",
                                    decision: decision,
                                    top: decision.top,
                                    median: decision.median,
                                    count: decision.count,
                                    context: diagnosticsContext)
                let context = coachAgent.minimalCoachContext(from: snapshot, topic: "greeting")
                let payload = await coachAgent.generateResponse(context: context,
                                                                intentTopic: "greeting",
                                                                consentGranted: false,
                                                                groundingFloor: 0.40)
                return payload.coachReply
            }
            emitRouteDiagnostics(line: "ChatRoute consent=\(consentGranted) topic=\(intentTopic ?? "nil") coverage=fail → on-device",
                                decision: decision,
                                top: decision.top,
                                median: decision.median,
                                count: decision.count,
                                context: diagnosticsContext)
            let context = coachAgent.minimalCoachContext(from: snapshot, topic: intentTopic!)
            let payload = await coachAgent.generateResponse(context: context,
                                                            intentTopic: intentTopic,
                                                            consentGranted: false,
                                                            groundingFloor: 0.40)
            return payload.coachReply
        }

        let payload = await coachAgent.chatResponse(userInput: userInput,
                                                    snapshot: snapshot,
                                                    consentGranted: allowCloud,
                                                    intentTopic: intentTopic,
                                                    topSignal: topSignal,
                                                    groundingFloor: groundingFloor)
        logger.debug("Chat response delivered. Length: \(payload.coachReply.count, privacy: .public), hasNextAction: \(payload.nextAction != nil, privacy: .public)")

        return payload.coachReply
    }

    private func emitRouteDiagnostics(line: String,
                                      decision: CoverageDecision?,
                                      top: Double?,
                                      median: Double?,
                                      count: Int?,
                                      context: String) {
        var fields: [String: DiagnosticsValue] = [
            "context": .safeString(.stage(context, allowed: ["live", "override"]))
        ]
        if let decision {
            let kind: String
            switch decision.kind {
            case .strong: kind = "strong"
            case .soft: kind = "soft"
            case .fail: kind = "fail"
            }
            fields["coverage_kind"] = .safeString(.stage(kind, allowed: ["strong", "soft", "fail"]))
            fields["coverage_reason"] = .safeString(.metadata(decision.reason))
            fields["coverage_threshold"] = .double(decision.thresholdUsed)
        }
        if let top { fields["top"] = .double(top) }
        if let median { fields["median"] = .double(median) }
        if let count { fields["match_count"] = .int(count) }
        Diagnostics.log(level: .info,
                        category: .coach,
                        name: "coach.route",
                        fields: fields)
#if DEBUG
        var info: [String: Any] = [
            "route": line,
            "context": context
        ]
        if let decision {
            info["reason"] = decision.reason
        }
        if let top { info["top"] = top }
        if let median { info["median"] = median }
        if let count { info["count"] = count }
        NotificationCenter.default.post(name: .pulsumChatRouteDiagnostics,
                                        object: nil,
                                        userInfo: info)
#endif
    }

    public func logCompletion(momentId: String) async throws -> CheerEvent {
        try await coachAgent.logEvent(momentId: momentId, accepted: true)
        let title = await coachAgent.momentTitle(for: momentId) ?? momentId
        return await cheerAgent.celebrateCompletion(momentTitle: title)
    }

    // MARK: - Intent Mapping Helpers

    /// Extract dominant topic from candidate moments (Step 3 of intent mapping)
    private func dominantTopic(from candidates: [CandidateMoment], coachAgent: CoachAgent) -> String? {
        // Use embedding similarity to infer dominant topic from candidate titles
        let topicKeywords: [String: [String]] = [
            "sleep": ["sleep", "rest", "recovery", "insomnia", "tired"],
            "stress": ["stress", "anxiety", "overwhelm", "worry", "tension"],
            "energy": ["energy", "fatigue", "motivation", "vitality"],
            "hrv": ["hrv", "heart rate", "variability", "recovery", "vagal"],
            "mood": ["mood", "feeling", "emotion", "mental"],
            "movement": ["movement", "steps", "walk", "exercise", "activity"],
            "mindfulness": ["mindfulness", "meditation", "breathe", "calm", "grounding"],
            "goals": ["goal", "habit", "micro", "moment", "action"]
        ]

        var topicScores: [String: Int] = [:]
        for candidate in candidates {
            let detail = candidate.detail ?? ""
            let text = (candidate.title + " " + candidate.shortDescription + " " + detail).lowercased()
            for (topic, keywords) in topicKeywords {
                let matches = keywords.filter { text.contains($0) }.count
                topicScores[topic, default: 0] += matches
            }
        }

        return topicScores.max(by: { $0.value < $1.value })?.key
    }

    private static func isGreeting(_ text: String) -> Bool {
        let lower = text.lowercased()
        let greetings = ["hi", "hello", "hey", "good morning", "good afternoon", "good evening"]
        return greetings.contains(where: { lower.hasPrefix($0) || lower == $0 })
    }

}
```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/AgentOrchestrator.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/BackfillStateStore.swift
- bytes: 5866
- lines: 150
- sha256: 87163f2a803a4ed6a07e4e9a1611a82f4e428a9355744fdef6188d214ffa1890
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/BackfillStateStore.swift -->
```swift
import Foundation
import os.log
import PulsumData

protocol BackfillStateStoring: Sendable {
    func loadState() -> BackfillProgress?
    func saveState(_ state: BackfillProgress)
}

private struct SendableFileManager: @unchecked Sendable {
    let value: FileManager
}

struct BackfillProgress: Codable, Sendable {
    static let schemaVersion = 1

    var version: Int = BackfillProgress.schemaVersion
    var warmStartCompletedTypes: Set<String> = []
    var fullBackfillCompletedTypes: Set<String> = []
    var earliestProcessedByType: [String: Date] = [:]

    mutating func recordWarmStart(for typeIdentifier: String, earliestDate: Date, calendar: Calendar) {
        let normalized = calendar.startOfDay(for: earliestDate)
        warmStartCompletedTypes.insert(typeIdentifier)
        earliestProcessedByType[typeIdentifier] = minDate(normalized, earliestProcessedByType[typeIdentifier], calendar: calendar)
    }

    mutating func recordProcessedRange(for typeIdentifier: String, startDate: Date, targetStartDate: Date, calendar: Calendar) {
        let normalized = calendar.startOfDay(for: startDate)
        earliestProcessedByType[typeIdentifier] = minDate(normalized, earliestProcessedByType[typeIdentifier], calendar: calendar)
        if normalized <= calendar.startOfDay(for: targetStartDate) {
            fullBackfillCompletedTypes.insert(typeIdentifier)
        }
    }

    mutating func markFullBackfillComplete(for typeIdentifier: String) {
        fullBackfillCompletedTypes.insert(typeIdentifier)
    }

    mutating func removeProgress(for typeIdentifier: String) {
        warmStartCompletedTypes.remove(typeIdentifier)
        fullBackfillCompletedTypes.remove(typeIdentifier)
        earliestProcessedByType.removeValue(forKey: typeIdentifier)
    }

    func earliestProcessedDate(for typeIdentifier: String, calendar: Calendar) -> Date? {
        earliestProcessedByType[typeIdentifier].map { calendar.startOfDay(for: $0) }
    }

    private func minDate(_ lhs: Date, _ rhs: Date?, calendar: Calendar) -> Date {
        guard let rhs else { return lhs }
        return calendar.startOfDay(for: min(lhs, rhs))
    }
}

final class BackfillStateStore: BackfillStateStoring, Sendable {
    private let queue = DispatchQueue(label: "ai.pulsum.backfillStateStore", qos: .utility)
    private let fileURL: URL
    private let fileManager: SendableFileManager
    private var fm: FileManager { fileManager.value }
    private let logger = Logger(subsystem: "ai.pulsum", category: "BackfillStateStore")
    private func logError(_ message: String, error: Error) {
        let nsError = error as NSError
        logger.error("\(message) domain=\(nsError.domain, privacy: .public) code=\(nsError.code, privacy: .public)")
    }

    init(baseDirectory: URL = PulsumData.applicationSupportDirectory,
         fileManager: FileManager = .default) {
        self.fileManager = SendableFileManager(value: fileManager)
        let directory = baseDirectory.appendingPathComponent("BackfillState", isDirectory: true)
        self.fileURL = directory.appendingPathComponent("state_v\(BackfillProgress.schemaVersion).json")
        queue.sync {
            prepareDirectory(at: directory)
        }
    }

    func loadState() -> BackfillProgress? {
        queue.sync {
            guard fm.fileExists(atPath: fileURL.path) else { return nil }
            do {
                let data = try Data(contentsOf: fileURL)
                let state = try JSONDecoder().decode(BackfillProgress.self, from: data)
                guard state.version == BackfillProgress.schemaVersion else {
                    logger.warning("Backfill state version mismatch. Expected \(BackfillProgress.schemaVersion), found \(state.version). Ignoring persisted state.")
                    return nil
                }
                return state
            } catch {
                logError("Failed to load backfill state.", error: error)
                return nil
            }
        }
    }

    func saveState(_ state: BackfillProgress) {
        queue.sync {
            do {
                let data = try JSONEncoder().encode(state)
                try data.write(to: fileURL, options: .atomic)
                applyFileProtection()
                excludeFromBackup()
            } catch {
                logError("Failed to persist backfill state.", error: error)
            }
        }
    }

    private func prepareDirectory(at url: URL) {
        if !fm.fileExists(atPath: url.path) {
            do {
#if os(iOS)
                try fm.createDirectory(at: url, withIntermediateDirectories: true, attributes: [.protectionKey: FileProtectionType.complete])
#else
                try fm.createDirectory(at: url, withIntermediateDirectories: true, attributes: nil)
#endif
            } catch {
                logError("Failed to prepare backfill state directory.", error: error)
            }
        } else {
#if os(iOS)
            do {
                try fm.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: url.path)
            } catch {
                logError("Failed to update backfill state directory protection.", error: error)
            }
#endif
        }
    }

    private func applyFileProtection() {
#if os(iOS)
        do {
            try fm.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: fileURL.path)
        } catch {
            logError("Failed to set file protection on backfill state.", error: error)
        }
#endif
    }

    private func excludeFromBackup() {
        var values = URLResourceValues()
        values.isExcludedFromBackup = true
        var mutableURL = fileURL
        do {
            try mutableURL.setResourceValues(values)
        } catch {
            logError("Failed to mark backfill state as backup-excluded.", error: error)
        }
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/BackfillStateStore.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/CheerAgent.swift
- bytes: 1255
- lines: 41
- sha256: a238c8f93627b3160af6095a401c582965aa587fd6acd03351cd186fdb1f899c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/CheerAgent.swift -->
```swift
import Foundation

@MainActor
public final class CheerAgent {
    private let calendar = Calendar(identifier: .gregorian)

    public init() {}

    public func celebrateCompletion(momentTitle: String) async -> CheerEvent {
        let now = Date()
        let hour = calendar.component(.hour, from: now)
        let timeQualifier: String
        switch hour {
        case 5..<12: timeQualifier = "morning momentum"
        case 12..<17: timeQualifier = "midday reset"
        case 17..<22: timeQualifier = "evening follow-through"
        default: timeQualifier = "late-day commitment"
        }

        let affirmations = [
            "That move keeps your trend headed the right way.",
            "Nice follow-through—log how it felt while it's fresh.",
            "Your consistency is building a durable baseline.",
            "You're stacking evidence you can count on."
        ]
        let affirmation = affirmations.randomElement() ?? "Great job locking in the win."

        let message = "\(momentTitle) • \(timeQualifier). \(affirmation)"
        let haptic: CheerEvent.HapticStyle = affirmation.contains("consistency") ? .success : .light
        return CheerEvent(message: message, haptic: haptic, timestamp: now)
    }
}









```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/CheerAgent.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent+Coverage.swift
- bytes: 4128
- lines: 122
- sha256: 45a61bdf8ba977266836f6bd9ade6217c1dee10c8e221bced3275f004e110a61
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent+Coverage.swift -->
```swift
import Foundation
import PulsumData
import PulsumTypes

public enum CoveragePassKind {
    case strong
    case soft
    case fail
}

public struct CoverageDecision {
    public let kind: CoveragePassKind
    public let reason: String
    public let count: Int
    public let top: Double
    public let median: Double
    public let thresholdUsed: Double
}

@inline(__always)
private func simFromL2(_ d: Double) -> Double {
    let clamped = min(max(d, 0.0), 4.0)
    return 1.0 / (1.0 + clamped)
}

@inline(__always)
private func median(_ xs: [Double]) -> Double {
    guard !xs.isEmpty else { return 0 }
    let sorted = xs.sorted()
    let mid = sorted.count / 2
    if sorted.count % 2 == 0 {
        return (sorted[mid - 1] + sorted[mid]) / 2.0
    } else {
        return sorted[mid]
    }
}

public struct CoverageInputs {
    public let l2Matches: [VectorMatch]
    public let canonicalTopic: String?
    public let snapshot: FeatureVectorSnapshot?

    public init(l2Matches: [VectorMatch], canonicalTopic: String?, snapshot: FeatureVectorSnapshot?) {
        self.l2Matches = l2Matches
        self.canonicalTopic = canonicalTopic
        self.snapshot = snapshot
    }
}

public func decideCoverage(_ input: CoverageInputs) -> CoverageDecision {
    let sims = input.l2Matches.prefix(10).map { simFromL2(Double($0.score)) }
    let count = sims.count
    let top = sims.max() ?? 0.0
    let med = median(sims)
    let onTopic = (input.canonicalTopic != nil)

    let sparse: Bool = {
        guard let snapshot = input.snapshot else { return true }
        let flags = snapshot.imputedFlags
        let imputedHRV = flags["hrv"] == true
        let imputedResting = flags["restingHR"] == true
        let missingSteps = flags["steps_missing"] == true
        return imputedHRV || imputedResting || missingSteps
    }()

    if count >= 3 && med >= 0.42 && top >= 0.58 {
        return CoverageDecision(kind: .strong,
                                reason: "strong-pass",
                                count: count,
                                top: top,
                                median: med,
                                thresholdUsed: 0.42)
    }

    if onTopic && med >= 0.35 {
        return CoverageDecision(kind: .soft,
                                reason: "on-topic-median",
                                count: count,
                                top: top,
                                median: med,
                                thresholdUsed: 0.35)
    }

    if onTopic && top >= 0.50 && med > 0 && (med / max(top, 1e-6)) >= 0.70 {
        return CoverageDecision(kind: .soft,
                                reason: "cohesive-soft",
                                count: count,
                                top: top,
                                median: med,
                                thresholdUsed: 0.35)
    }

    if sparse {
        return CoverageDecision(kind: .soft,
                                reason: "data-sparse-soft",
                                count: count,
                                top: top,
                                median: med,
                                thresholdUsed: 0.35)
    }

    return CoverageDecision(kind: .fail,
                             reason: "low-coverage",
                             count: count,
                             top: top,
                             median: med,
                             thresholdUsed: 0.40)
}

public func logCoverage(_ decision: CoverageDecision) {
    Diagnostics.log(level: .debug,
                    category: .coach,
                    name: "coach.coverage.decision",
                    fields: [
                        "kind": .safeString(.stage("\(decision.kind)", allowed: ["strong", "soft", "fail"])),
                        "reason": .safeString(.metadata(decision.reason)),
                        "match_count": .int(decision.count),
                        "top": .double(decision.top),
                        "median": .double(decision.median),
                        "threshold": .double(decision.thresholdUsed)
                    ])
}
```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent+Coverage.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent.swift
- bytes: 32137
- lines: 709
- sha256: dde2d4df8ed26e97e1bf5db739e436c708bd68e93396683c71e88983549b591f
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent.swift -->
```swift
import Foundation
import CoreData
#if canImport(FoundationModels)
import FoundationModels
#endif
import os
import PulsumData
import PulsumML
import PulsumServices
import PulsumTypes

@MainActor
public final class CoachAgent {
    private let context: NSManagedObjectContext
    private let vectorIndex: VectorIndexProviding
    private let ranker: RecRanker
    private let rankerStore: RecRankerStateStoring
    private var lastRankedFeatures: [RecommendationFeatures] = []
    private let libraryImporter: LibraryImporter
    private let llmGateway: LLMGateway
    private let shouldIngestLibrary: Bool
    private var hasPreparedLibrary = false
    private var libraryEmbeddingsDeferred = false
    private var lastRecommendationNotice: String?
    private var libraryPreparationTask: Task<Void, Error>?
    private let logger = Logger(subsystem: "com.pulsum", category: "CoachAgent")

    public init(container: NSPersistentContainer = PulsumData.container,
                vectorIndex: VectorIndexProviding = VectorIndexManager.shared,
                libraryImporter: LibraryImporter = LibraryImporter(),
                llmGateway: LLMGateway = LLMGateway(),
                shouldIngestLibrary: Bool = true,
                rankerStore: RecRankerStateStoring = RecRankerStateStore()) throws {
        self.context = container.newBackgroundContext()
        self.context.name = "Pulsum.CoachAgent.FoundationModels"
        self.context.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
        self.vectorIndex = vectorIndex
        self.libraryImporter = libraryImporter
        self.llmGateway = llmGateway
        self.shouldIngestLibrary = shouldIngestLibrary
        self.rankerStore = rankerStore
        self.ranker = RecRanker(state: rankerStore.loadState())
    }

    public var libraryImportDeferred: Bool {
        libraryEmbeddingsDeferred
    }

    public func prepareLibraryIfNeeded() async throws {
        guard shouldIngestLibrary else { return }
        if let inFlight = libraryPreparationTask {
            try await inFlight.value
            return
        }
        if hasPreparedLibrary && !libraryEmbeddingsDeferred { return }
        if libraryEmbeddingsDeferred && EmbeddingService.shared.availabilityMode() == .unavailable {
            return
        }
        let task = Task { @MainActor [weak self] in
            guard let self else { return }
            try await self.performLibraryPreparation()
        }
        libraryPreparationTask = task
        defer { libraryPreparationTask = nil }
        try await task.value
    }

    public func retryDeferredLibraryImport(traceId: UUID? = nil) async {
        guard shouldIngestLibrary else { return }
        guard libraryEmbeddingsDeferred else { return }
        let span = Diagnostics.span(category: .library,
                                    name: "library.import.retry",
                                    fields: ["deferred": .bool(libraryEmbeddingsDeferred)],
                                    traceId: traceId)
        do {
            try await prepareLibraryIfNeeded()
            Diagnostics.log(level: .info,
                            category: .library,
                            name: "library.import.retry.end",
                            fields: ["deferred": .bool(libraryEmbeddingsDeferred)],
                            traceId: traceId)
            span.end(error: nil)
        } catch {
            let nsError = error as NSError
            logger.error("Deferred library import retry failed. domain=\(nsError.domain, privacy: .public) code=\(nsError.code, privacy: .public)")
            Diagnostics.log(level: .warn,
                            category: .library,
                            name: "library.import.retry.failed",
                            fields: ["deferred": .bool(true)],
                            traceId: traceId,
                            error: error)
            span.end(error: error)
        }
    }

    public func recommendationCards(for snapshot: FeatureVectorSnapshot,
                                    consentGranted: Bool) async throws -> [RecommendationCard] {
        let span = Diagnostics.span(category: .coach,
                                    name: "coach.recommendations",
                                    fields: ["consent": .bool(consentGranted)],
                                    level: .info)
        var route = "library"
        var candidateCount = 0
        do {
            try Task.checkCancellation()
            try await prepareLibraryIfNeeded()
            lastRecommendationNotice = nil

            let query = buildQuery(from: snapshot)
            let matches: [VectorMatch]
            do {
                try Task.checkCancellation()
                matches = try await vectorIndex.searchMicroMoments(query: query, topK: 20)
            } catch let embeddingError as EmbeddingError where embeddingError == .generatorUnavailable {
                libraryEmbeddingsDeferred = true
                lastRecommendationNotice = "Personalized recommendations are limited on this device right now. We'll enable smarter suggestions when on-device embeddings are available."
                route = "fallback_embeddings_unavailable"
                try Task.checkCancellation()
                let cards = await fallbackRecommendations(snapshot: snapshot, topic: nil)
                candidateCount = cards.count
                span.end(additionalFields: [
                    "route": .safeString(.stage(route, allowed: ["library", "fallback_embeddings_unavailable", "fallback_no_matches"])),
                    "candidate_count": .int(candidateCount)
                ], error: nil)
                return cards
            }
            guard !matches.isEmpty else {
                if libraryEmbeddingsDeferred {
                    lastRecommendationNotice = "Personalized recommendations are limited on this device right now. We'll enable smarter suggestions when on-device embeddings are available."
                }
                route = "fallback_no_matches"
                try Task.checkCancellation()
                let cards = await fallbackRecommendations(snapshot: snapshot, topic: nil)
                candidateCount = cards.count
                span.end(additionalFields: [
                    "route": .safeString(.stage(route, allowed: ["library", "fallback_embeddings_unavailable", "fallback_no_matches"])),
                    "candidate_count": .int(candidateCount)
                ], error: nil)
                return cards
            }

            let scoreLookup = Dictionary(uniqueKeysWithValues: matches.map { ($0.id, $0.score) })
            try Task.checkCancellation()
            let moments = try await fetchMicroMoments(ids: Array(scoreLookup.keys))

            var candidates: [CardCandidate] = []
            for moment in moments {
                try Task.checkCancellation()
                guard let distance = scoreLookup[moment.id] else { continue }
                if let candidate = await makeCandidate(moment: moment,
                                                       distance: distance,
                                                       snapshot: snapshot) {
                    candidates.append(candidate)
                }
            }

            guard !candidates.isEmpty else { return [] }

            try Task.checkCancellation()
            let rankedFeatures = ranker.rank(candidates.map { $0.features })
            lastRankedFeatures = rankedFeatures
            var rankedCards: [RecommendationCard] = []
            for feature in rankedFeatures {
                try Task.checkCancellation()
                guard let candidate = candidates.first(where: { $0.features.id == feature.id }) else { continue }
                rankedCards.append(candidate.card)
                if rankedCards.count == 3 { break }
            }
            candidateCount = rankedCards.count
            span.end(additionalFields: [
                "route": .safeString(.stage(route, allowed: ["library", "fallback_embeddings_unavailable", "fallback_no_matches"])),
                "candidate_count": .int(candidateCount),
                "matches_considered": .int(matches.count)
            ], error: nil)
            return rankedCards
        } catch {
            span.end(additionalFields: [
                "route": .safeString(.stage(route, allowed: ["library", "fallback_embeddings_unavailable", "fallback_no_matches"])),
                "candidate_count": .int(candidateCount)
            ], error: error)
            throw error
        }
    }

    public func chatResponse(userInput: String,
                             snapshot: FeatureVectorSnapshot,
                             consentGranted: Bool,
                             intentTopic: String?,
                             topSignal: String,
                             groundingFloor: Double) async -> CoachReplyPayload {
        let sanitizedInput = PIIRedactor.redact(userInput)
        Diagnostics.log(level: .info,
                        category: .coach,
                        name: "coach.chat.prepare",
                        fields: [
                            "consent": .bool(consentGranted),
                            "input_chars": .int(userInput.count)
                        ])
        let rationale = snapshot.contributions.sorted { abs($0.value) > abs($1.value) }
            .prefix(3)
            .map { "\($0.key): \(String(format: "%.2f", $0.value))" }
            .joined(separator: ", ")
        let summary = snapshot.contributions.map { "\($0.key)=\(String(format: "%.2f", $0.value))" }
            .joined(separator: ", ")

        let candidateMoments: [CandidateMoment]
        if let topic = intentTopic {
            candidateMoments = await self.candidateMoments(for: topic, limit: 3)
        } else {
            candidateMoments = []
        }

        let context = CoachLLMContext(userToneHints: String(sanitizedInput.prefix(180)),
                                      topSignal: topSignal,
                                      topMomentId: candidateMoments.first?.id,
                                      rationale: rationale,
                                      zScoreSummary: summary,
                                      candidateMoments: candidateMoments)
        return await llmGateway.generateCoachResponse(context: context,
                                                     intentTopic: intentTopic,
                                                     candidateMoments: candidateMoments,
                                                     consentGranted: consentGranted,
                                                     groundingFloor: groundingFloor)
    }

    private func mapIntentToSignal(intentTopic: String?, snapshot: FeatureVectorSnapshot) -> String {
        guard let topic = intentTopic else {
            return snapshot.contributions.max(by: { abs($0.value) < abs($1.value) })?.key ?? "wellbeing"
        }

        // Map canonical topics to signal keys
        switch topic {
        case "sleep": return "subj_sleepQuality"
        case "stress": return "subj_stress"
        case "energy": return "subj_energy"
        case "hrv": return "z_hrv"
        case "mood": return "sentiment"
        case "movement": return "z_steps"
        case "mindfulness": return "z_rr"
        default: return "subj_energy"
        }
    }

    public func logEvent(momentId: String, accepted: Bool) async throws {
        try await context.perform { [context] in
            let event = RecommendationEvent(context: context)
            event.momentId = momentId
            event.date = Date()
            event.accepted = accepted
            event.completedAt = accepted ? Date() : nil
            try context.save()
        }
        let feedback = await applyFeedback(for: momentId, accepted: accepted)
        Diagnostics.log(level: .info,
                        category: .coach,
                        name: accepted ? "coach.feedback.accept" : "coach.feedback.dismiss",
                        fields: [
                            "moment_id": .safeString(.metadata(momentId)),
                            "weights_changed": .int(feedback?.changedCount ?? 0),
                            "learning_rate_bucket": .safeString(.stage(feedback?.learningRateBucket ?? "unknown",
                                                                       allowed: ["coldstart", "learning", "stable", "unknown"]))
                        ])
    }

    public func momentTitle(for id: String) async -> String? {
        await context.perform { [context] in
            let request = MicroMoment.fetchRequest()
            request.predicate = NSPredicate(format: "id == %@", id)
            request.fetchLimit = 1
            return try? context.fetch(request).first?.title
        }
    }

    /// Fetch candidate micro-moments for intent-aware coaching
    /// Returns privacy-safe title and oneLiner (no PHI)
    public func candidateMoments(for intentTopic: String, limit: Int = 2) async -> [CandidateMoment] {
        let query = "wellbeing \(intentTopic)"
        let matches: [VectorMatch]
        do {
            matches = try await vectorIndex.searchMicroMoments(query: query, topK: limit)
        } catch let embeddingError as EmbeddingError where embeddingError == .generatorUnavailable {
            let keyword = try? await keywordBackfillMoments(for: intentTopic, limit: limit)
            guard let keyword, !keyword.isEmpty else { return [] }
            return keyword.compactMap { moment in
                let title = moment.title.trimmingCharacters(in: .whitespacesAndNewlines)
                let short = moment.shortDescription.trimmingCharacters(in: .whitespacesAndNewlines)
                guard !title.isEmpty, !short.isEmpty else { return nil }
                let detail = normalizeOptionalText(moment.detail, limit: 240)
                return CandidateMoment(id: moment.id,
                                       title: title,
                                       shortDescription: String(short.prefix(200)),
                                       detail: detail,
                                       evidenceBadge: moment.evidenceBadge)
            }
        } catch {
            return []
        }
        guard !matches.isEmpty else {
            return []
        }

        let ids = matches.map { $0.id }
        guard let moments = try? await fetchMicroMoments(ids: ids) else {
            return []
        }

        let lookup = Dictionary(uniqueKeysWithValues: moments.map { ($0.id, $0) })

        return ids.compactMap { id in
            guard let moment = lookup[id] else { return nil }
            let title = moment.title.trimmingCharacters(in: .whitespacesAndNewlines)
            let short = moment.shortDescription.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !id.isEmpty, !title.isEmpty, !short.isEmpty else { return nil }
            let detail = normalizeOptionalText(moment.detail, limit: 240)
            return CandidateMoment(id: id,
                                   title: title,
                                   shortDescription: String(short.prefix(200)),
                                   detail: detail,
                                   evidenceBadge: moment.evidenceBadge)
        }
    }

    private func normalizeOptionalText(_ text: String?, limit: Int) -> String? {
        guard let trimmed = text?.trimmingCharacters(in: .whitespacesAndNewlines),
              !trimmed.isEmpty else {
            return nil
        }
        return String(trimmed.prefix(limit))
    }

    private func buildQuery(from snapshot: FeatureVectorSnapshot) -> String {
        let leadingSignals = snapshot.contributions.sorted { abs($0.value) > abs($1.value) }
            .prefix(4)
            .map { "\($0.key)=\(String(format: "%.2f", $0.value))" }
            .joined(separator: " ")
        return "wellbeing=\(String(format: "%.2f", snapshot.wellbeingScore)) \(leadingSignals)"
    }

    private func fetchMicroMoments(ids: [String]) async throws -> [MicroMoment] {
        try await context.perform { [context] in
            let request = MicroMoment.fetchRequest()
            request.predicate = NSPredicate(format: "id IN %@", ids)
            return try context.fetch(request)
        }
    }

    func generateResponse(context: CoachLLMContext,
                          intentTopic: String?,
                          consentGranted: Bool,
                          groundingFloor: Double) async -> CoachReplyPayload {
        await llmGateway.generateCoachResponse(context: context,
                                               intentTopic: intentTopic,
                                               candidateMoments: context.candidateMoments,
                                               consentGranted: consentGranted,
                                               groundingFloor: groundingFloor)
    }

    func coverageDecision(for query: String,
                          canonicalTopic: String?,
                          snapshot: FeatureVectorSnapshot?) async throws -> (matches: [VectorMatch], decision: CoverageDecision) {
        var matches = try await vectorIndex.searchMicroMoments(query: query, topK: 20)
        var decision = decideCoverage(CoverageInputs(l2Matches: matches,
                                                     canonicalTopic: canonicalTopic,
                                                     snapshot: snapshot))

        if case .fail = decision.kind, let topic = canonicalTopic {
            let backfill = try await keywordBackfillMoments(for: topic, limit: 8)
            for moment in backfill {
                let backfillMatches = try await vectorIndex.searchMicroMoments(query: moment.title, topK: 1)
                for match in backfillMatches where !matches.contains(where: { $0.id == match.id }) {
                    matches.append(match)
                }
            }
            decision = decideCoverage(CoverageInputs(l2Matches: matches,
                                                     canonicalTopic: canonicalTopic,
                                                     snapshot: snapshot))
        }

        logCoverage(decision)
        return (matches, decision)
    }

    private func keywordBackfillMoments(for topic: String,
                                        limit: Int) async throws -> [MicroMoment] {
        try await context.perform { [context] in
            let request = NSFetchRequest<MicroMoment>(entityName: "MicroMoment")
            let candidateLimit = max(limit * 20, 200)
            request.fetchLimit = candidateLimit
            request.fetchBatchSize = candidateLimit
            request.sortDescriptors = [
                NSSortDescriptor(key: "title",
                                 ascending: true,
                                 selector: #selector(NSString.localizedCaseInsensitiveCompare(_:))),
                NSSortDescriptor(key: "id", ascending: true)
            ]

            // tags is Transformable; filter matches in-memory to avoid SQL string predicates
            let candidates = try context.fetch(request)
            let filtered = candidates.filter { moment in
                if moment.title.range(of: topic, options: .caseInsensitive) != nil {
                    return true
                }
                guard let tags = moment.tags else { return false }
                return tags.contains { tag in
                    tag.range(of: topic, options: .caseInsensitive) != nil
                }
            }

            let sorted = filtered.sorted {
                let comparison = $0.title.localizedCaseInsensitiveCompare($1.title)
                if comparison == .orderedSame {
                    return $0.id < $1.id
                }
                return comparison == .orderedAscending
            }

            return Array(sorted.prefix(limit))
        }
    }

    func minimalCoachContext(from snapshot: FeatureVectorSnapshot?, topic: String) -> CoachLLMContext {
        let summary: String
        if let features = snapshot?.features, !features.isEmpty {
            summary = features
                .sorted(by: { abs($0.value) > abs($1.value) })
                .prefix(5)
                .map { "\($0.key)=\(String(format: "%.2f", $0.value))" }
                .joined(separator: ", ")
        } else {
            summary = "insufficient recent data"
        }

        return CoachLLMContext(
            userToneHints: "supportive, concise",
            topSignal: "topic=\(topic)",
            topMomentId: nil,
            rationale: "User asked about \(topic)",
            zScoreSummary: summary
        )
    }

    private func makeCandidate(moment: MicroMoment,
                               distance: Float,
                               snapshot: FeatureVectorSnapshot) async -> CardCandidate? {
        let evidenceStrength = badgeScore(moment.evidenceBadge)
        let acceptance = await acceptanceRate(for: moment.id)
        let cooldown = await cooldownScore(for: moment)
        let novelty = max(0, 1 - acceptance)
        let similarityScore = max(0, 1 - min(Double(distance) / 5, 1))
        let blendedNovelty = min(1, (novelty * 0.7) + (similarityScore * 0.3))
        let timeFit = timeCostFit(for: moment)
        let zScores = snapshot.features.reduce(into: [String: Double]()) { result, element in
            if element.key.hasPrefix("z_") {
                result[element.key] = element.value
            }
        }

        let features = RecommendationFeatures(id: moment.id,
                                              wellbeingScore: snapshot.wellbeingScore,
                                              evidenceStrength: evidenceStrength,
                                              novelty: blendedNovelty,
                                              cooldown: cooldown,
                                              acceptanceRate: acceptance,
                                              timeCostFit: timeFit,
                                              zScores: zScores)
        
        let card = RecommendationCard(id: moment.id,
                                      title: moment.title,
                                      body: buildBody(for: moment),
                                      caution: await cautionMessage(for: moment, snapshot: snapshot),
                                      sourceBadge: moment.evidenceBadge ?? "Weak")
        return CardCandidate(card: card, features: features)
    }

    public func currentLLMAPIKey() -> String? {
        llmGateway.currentAPIKey()
    }

    public func setLLMAPIKey(_ key: String) throws {
        try llmGateway.setAPIKey(key)
    }

    public func testLLMAPIConnection() async throws -> Bool {
        try await llmGateway.testAPIConnection()
    }

    private func buildBody(for moment: MicroMoment) -> String {
        var paragraphs: [String] = [moment.shortDescription]
        if let detail = moment.detail, !detail.isEmpty {
            let filteredDetail = detail
                .split(separator: "\n")
                .filter { line in
                    let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
                    return !trimmed.hasPrefix("Episode #")
                }
                .joined(separator: "\n")
            if !filteredDetail.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                paragraphs.append(filteredDetail)
            }
        }
        if let activity = moment.cooldownSec?.intValue, activity > 0 {
            paragraphs.append("Cooldown: \(activity / 60) min between repeats")
        }
        return paragraphs.prefix(2).joined(separator: "\n\n")
    }

    private func cautionMessage(for moment: MicroMoment, snapshot: FeatureVectorSnapshot) async -> String? {
#if canImport(FoundationModels) && os(iOS)
        // Use Foundation Models for intelligent caution assessment instead of simple rules
        if #available(iOS 26.0, *), SystemLanguageModel.default.isAvailable {
            return await generateFoundationModelsCaution(for: moment, snapshot: snapshot)
        }
#endif
        // Fallback to basic heuristics only when Foundation Models unavailable
        guard let difficulty = moment.difficulty?.lowercased() else { return nil }
        if difficulty.contains("hard") {
            return "Check in with your energy before tackling this higher-effort option."
        }
        if moment.category?.lowercased().contains("injury") == true {
            return "Adjust intensity if your body signals any discomfort."
        }
        return nil
    }

#if canImport(FoundationModels) && os(iOS)
    @available(iOS 26.0, *)
    private func generateFoundationModelsCaution(for moment: MicroMoment, snapshot: FeatureVectorSnapshot) async -> String? {
        let session = LanguageModelSession(
            instructions: Instructions("""
            You are assessing whether a wellness activity needs a caution message.
            Generate a brief caution ONLY if the activity could be risky given the person's current state.
            Consider their energy levels, stress, and physical readiness.
            Keep cautions under 20 words and supportive in tone.
            Return empty string if no caution needed.
            """)
        )
        
        let contextInfo = """
        Activity: \(moment.title)
        Difficulty: \(moment.difficulty ?? "Unknown")
        Category: \(moment.category ?? "General")
        Current wellbeing score: \(snapshot.wellbeingScore)
        Energy level: \(snapshot.features["subj_energy"] ?? 0)
        Stress level: \(snapshot.features["subj_stress"] ?? 0)
        """
        
        do {
            let response = try await session.respond(
                to: Prompt("Should this activity have a caution message? \(contextInfo)"),
                options: GenerationOptions(temperature: 0.3)
            )
            let caution = response.content.trimmingCharacters(in: .whitespacesAndNewlines)
            return caution.isEmpty ? nil : caution
        } catch {
            return nil // No caution on error
        }
    }
#endif

    private func badgeScore(_ badge: String?) -> Double {
        switch badge {
        case EvidenceBadge.strong.rawValue:
            return 1.0
        case EvidenceBadge.medium.rawValue:
            return 0.7
        default:
            return 0.3
        }
    }

    private func cooldownScore(for moment: MicroMoment) async -> Double {
        guard let cooldown = moment.cooldownSec?.doubleValue, cooldown > 0 else { return 0 }
        let momentId = moment.id
        let elapsed: TimeInterval? = await context.perform { [context] in
            let request = RecommendationEvent.fetchRequest()
            request.predicate = NSPredicate(format: "momentId == %@ AND accepted == YES", momentId)
            request.sortDescriptors = [NSSortDescriptor(key: #keyPath(RecommendationEvent.completedAt), ascending: false)]
            request.fetchLimit = 1
            guard let last = try? context.fetch(request).first, let completed = last.completedAt else { return nil }
            return Date().timeIntervalSince(completed)
        }
        guard let elapsed else { return 0 }
        if elapsed >= cooldown { return 0 }
        return 1 - (elapsed / cooldown)
    }

    private func applyFeedback(for momentId: String, accepted: Bool) async -> (changedCount: Int, learningRateBucket: String)? {
        guard let target = lastRankedFeatures.first(where: { $0.id == momentId }) else { return nil }
        let comparators = lastRankedFeatures.filter { $0.id != momentId }
        guard !comparators.isEmpty else { return nil }

        for candidate in comparators {
            if accepted {
                ranker.update(preferred: target, other: candidate)
            } else {
                ranker.update(preferred: candidate, other: target)
            }
        }

        let history = await acceptanceHistory(for: momentId)
        ranker.updateLearningRate(basedOn: history)
        persistRankerState()
        return (changedCount: comparators.count, learningRateBucket: learningRateBucket(for: history.sampleCount))
    }

    private func learningRateBucket(for sampleCount: Int) -> String {
        switch sampleCount {
        case ..<3:
            return "coldstart"
        case 3..<10:
            return "learning"
        default:
            return "stable"
        }
    }

    private func acceptanceHistory(for momentId: String) async -> AcceptanceHistory {
        await context.perform { [context] in
            let request = RecommendationEvent.fetchRequest()
            request.predicate = NSPredicate(format: "momentId == %@", momentId)
            guard let events = try? context.fetch(request), !events.isEmpty else {
                return AcceptanceHistory(rollingAcceptance: 0.5, sampleCount: 0)
            }
            let acceptances = events.filter { $0.accepted }.count
            let rate = Double(acceptances) / Double(events.count)
            return AcceptanceHistory(rollingAcceptance: rate, sampleCount: events.count)
        }
    }

    private func acceptanceRate(for momentId: String) async -> Double {
        await context.perform { [context] in
            let request = RecommendationEvent.fetchRequest()
            request.predicate = NSPredicate(format: "momentId == %@", momentId)
            guard let events = try? context.fetch(request), !events.isEmpty else { return 0.1 }
            let acceptances = events.filter { $0.accepted }.count
            return Double(acceptances) / Double(events.count)
        }
    }

    private func timeCostFit(for moment: MicroMoment) -> Double {
        guard let seconds = moment.estimatedTimeSec?.doubleValue else { return 0.5 }
        let normalized = max(0, min(1, 1 - (seconds / 1800)))
        return normalized
    }

#if DEBUG
    func _testRankerMetrics() -> RankerMetrics {
        ranker.getPerformanceMetrics()
    }

    func _injectRankedFeaturesForTesting(_ features: [RecommendationFeatures]) {
        lastRankedFeatures = features
    }
#endif
}

private struct CardCandidate {
    let card: RecommendationCard
    let features: RecommendationFeatures
}

private extension CoachAgent {
    func persistRankerState() {
        let state = ranker.snapshotState()
        rankerStore.saveState(state)
    }

    func fallbackRecommendations(snapshot: FeatureVectorSnapshot, topic: String?) async -> [RecommendationCard] {
        let topic = topic ?? "wellbeing"
        let moments = (try? await keywordBackfillMoments(for: topic, limit: 6)) ?? []
        guard !moments.isEmpty else { return [] }

        var candidates: [CardCandidate] = []
        for moment in moments {
            if let candidate = await makeCandidate(moment: moment, distance: 1.0, snapshot: snapshot) {
                candidates.append(candidate)
            }
        }
        guard !candidates.isEmpty else { return [] }

        let rankedFeatures = ranker.rank(candidates.map { $0.features })
        lastRankedFeatures = rankedFeatures
        var rankedCards: [RecommendationCard] = []
        for feature in rankedFeatures {
            guard let candidate = candidates.first(where: { $0.features.id == feature.id }) else { continue }
            rankedCards.append(candidate.card)
            if rankedCards.count == 3 { break }
        }
        return rankedCards
    }
}

extension CoachAgent {
    public var recommendationNotice: String? { lastRecommendationNotice }
}

private extension CoachAgent {
    func performLibraryPreparation() async throws {
        do {
            try await libraryImporter.ingestIfNeeded()
            libraryEmbeddingsDeferred = libraryImporter.lastImportHadDeferredEmbeddings
            hasPreparedLibrary = !libraryEmbeddingsDeferred
        } catch {
            hasPreparedLibrary = false
            libraryEmbeddingsDeferred = false
            throw error
        }
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/DataAgent.swift
- bytes: 175266
- lines: 3694
- sha256: 1914e16626125adcce27403e2e6e594375e2517b77d1b9c74040d806be34431f
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/DataAgent.swift -->
```swift
import Foundation
@preconcurrency import CoreData
import HealthKit
@preconcurrency import PulsumData
import PulsumML
import PulsumServices
import PulsumTypes

public struct FeatureVectorSnapshot: Sendable {
    public let date: Date
    public let wellbeingScore: Double
    public let contributions: [String: Double]
    public let imputedFlags: [String: Bool]
    public let featureVectorObjectID: NSManagedObjectID
    public let features: [String: Double]
}

public struct ScoreBreakdown: Sendable {
    public struct MetricDetail: Identifiable, Sendable {
        public enum Kind: String, Sendable {
            case objective
            case subjective
            case sentiment
        }

        public struct Coverage: Sendable {
            public let daysWithSamples: Int
            public let sampleCount: Int
        }

        public let id: String
        public let name: String
        public let kind: Kind
        public let value: Double?
        public let unit: String?
        public let zScore: Double?
        public let contribution: Double
        public let baselineMedian: Double?
        public let baselineEwma: Double?
        public let baselineMad: Double?
        public let rollingWindowDays: Int?
        public let explanation: String
        public let notes: [String]
        public let coverage: Coverage?
    }

    public let date: Date
    public let wellbeingScore: Double
    public let metrics: [MetricDetail]
    public let generalNotes: [String]
}

enum SnapshotPlaceholder {
    static let imputedFlagKey = "snapshot_placeholder"

    static func isPlaceholder(_ flags: [String: Bool]) -> Bool {
        flags[imputedFlagKey] == true
    }

    static func isPlaceholder(_ snapshot: FeatureVectorSnapshot) -> Bool {
        isPlaceholder(snapshot.imputedFlags)
    }
}

struct DataAgentBootstrapPolicy: Sendable {
    let bootstrapTimeoutSeconds: Double
    let heartRateTimeoutSeconds: Double
    let backfillTimeoutSeconds: Double
    let placeholderDeadlineSeconds: Double
    let retryDelaySeconds: Double
    let retryTimeoutSeconds: Double
    let retryMaxAttempts: Int
    let retryMaxElapsedSeconds: Double

    static let `default` = DataAgentBootstrapPolicy(
        bootstrapTimeoutSeconds: 3,
        heartRateTimeoutSeconds: 3,
        backfillTimeoutSeconds: 5,
        placeholderDeadlineSeconds: 5,
        retryDelaySeconds: 4,
        retryTimeoutSeconds: 10,
        retryMaxAttempts: 2,
        retryMaxElapsedSeconds: 60
    )
}

actor DataAgent {
    private let healthKit: any HealthKitServicing
    private let calendar = Calendar(identifier: .gregorian)
    private let estimatorStore: EstimatorStateStoring
    private var stateEstimator: StateEstimator
    private let context: NSManagedObjectContext
    private var observers: [String: HealthKitObservationToken] = [:]
    private let requiredSampleTypes: [HKSampleType]
    private let sampleTypesByIdentifier: [String: HKSampleType]
    private let notificationCenter: NotificationCenter
    private let backfillStore: BackfillStateStoring
    private var backfillProgress: BackfillProgress
    private var pendingSnapshotUpdate: Task<Void, Never>?
    private var backgroundBackfillTask: Task<Void, Never>?
    private let bootstrapPolicy: DataAgentBootstrapPolicy
    private var bootstrapWatchdogTask: Task<Void, Never>?
    private var bootstrapRetryTask: Task<Void, Never>?
    private var bootstrapRetryAttempt = 0
    private var bootstrapRetryStart: Date?
    private var pendingBootstrapRetryIdentifiers: Set<String> = []
    private var cachedReadAccess: (timestamp: Date, results: [String: ReadAuthorizationProbeResult])?
    private let readProbeCacheTTL: TimeInterval = 30
    private var diagnosticsTraceId: UUID?

    // Phase 1: small foreground window for fast first score; Phase 2: full context restored in background.
    private let warmStartWindowDays = 7
    private let fullAnalysisWindowDays = 30
    private let bootstrapWindowDays = 2
    private let sleepDebtWindowDays = 7
    private let backgroundBackfillBatchDays = 5
    private let sedentaryThresholdStepsPerHour: Double = 30
    private let sedentaryMinimumDuration: TimeInterval = 30 * 60

    init(healthKit: any HealthKitServicing = PulsumServices.healthKit,
         container: NSPersistentContainer = PulsumData.container,
         notificationCenter: NotificationCenter = .default,
         estimatorStore: EstimatorStateStoring = EstimatorStateStore(),
         backfillStore: BackfillStateStoring = BackfillStateStore(),
         bootstrapPolicy: DataAgentBootstrapPolicy = .default) {
        self.healthKit = healthKit
        self.estimatorStore = estimatorStore
        self.backfillStore = backfillStore
        self.bootstrapPolicy = bootstrapPolicy
        self.stateEstimator = StateEstimator()
        self.context = container.newBackgroundContext()
        self.context.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
        self.context.name = "Pulsum.DataAgent"
        self.notificationCenter = notificationCenter
        self.requiredSampleTypes = HealthKitService.orderedReadSampleTypes
        var dictionary: [String: HKSampleType] = [:]
        for type in requiredSampleTypes {
            dictionary[type.identifier] = type
        }
        self.sampleTypesByIdentifier = dictionary

        if let persistedBackfill = backfillStore.loadState() {
            self.backfillProgress = persistedBackfill
        } else {
            self.backfillProgress = BackfillProgress()
        }

        if let persisted = estimatorStore.loadState() {
            self.stateEstimator = StateEstimator(state: persisted)
        }
    }

    // MARK: - Lifecycle

    func setDiagnosticsTraceId(_ traceId: UUID?) async {
        diagnosticsTraceId = traceId
    }

    func start() async throws {
        let span = Diagnostics.span(category: .dataAgent,
                                    name: "data.start",
                                    traceId: diagnosticsTraceId)
        // Always re-request to refresh HealthKit's internal state; authorized paths return immediately.
        do {
            try await healthKit.requestAuthorization()
            logDiagnostics(level: .info,
                           category: .healthkit,
                           name: "data.healthkit.authorization",
                           fields: ["state": .safeString(.stage("authorized", allowed: ["authorized", "failed"]))])
            invalidateReadAccessCache()
        } catch {
            logDiagnostics(level: .error,
                           category: .healthkit,
                           name: "data.healthkit.authorization",
                           fields: ["state": .safeString(.stage("failed", allowed: ["authorized", "failed"]))],
                           error: error)
            span.end(error: error)
            throw error
        }

        let refreshedStatus = await currentHealthAccessStatus()
        scheduleBootstrapWatchdog(for: refreshedStatus)
        await bootstrapFirstScore(for: refreshedStatus)
        try await configureObservation(for: refreshedStatus, resetRevokedAnchors: true)
        scheduleBackfill(for: refreshedStatus)
        span.end(error: nil)
    }

    @discardableResult
    func startIngestionIfAuthorized() async throws -> HealthAccessStatus {
        let status = await currentHealthAccessStatus()
        await DebugLogBuffer.shared.append("startIngestionIfAuthorized status: \(statusSummary(status))")
        try await configureObservation(for: status, resetRevokedAnchors: false)
        scheduleBackfill(for: status)
        return status
    }

    @discardableResult
    func restartIngestionAfterPermissionsChange() async throws -> HealthAccessStatus {
        invalidateReadAccessCache()
        let status = await currentHealthAccessStatus()
        await DebugLogBuffer.shared.append("restartIngestionAfterPermissionsChange status: \(statusSummary(status))")
        scheduleBootstrapWatchdog(for: status)
        await bootstrapFirstScore(for: status)
        try await configureObservation(for: status, resetRevokedAnchors: true)
        scheduleBackfill(for: status)
        return status
    }

    @discardableResult
    func requestHealthAccess() async throws -> HealthAccessStatus {
        try await healthKit.requestAuthorization()
        invalidateReadAccessCache()
        let status = await currentHealthAccessStatus()
        await DebugLogBuffer.shared.append("requestHealthAccess refreshed status: \(statusSummary(status))")
        scheduleBootstrapWatchdog(for: status)
        await bootstrapFirstScore(for: status)
        try await configureObservation(for: status, resetRevokedAnchors: true)
        scheduleBackfill(for: status)
        return status
    }

    func currentHealthAccessStatus() async -> HealthAccessStatus {
        if !healthKit.isHealthDataAvailable {
            let unavailable = HealthAccessStatus(required: requiredSampleTypes,
                                                 granted: [],
                                                 denied: [],
                                                 notDetermined: [],
                                                 availability: .unavailable(reason: "Health data is not available on this device."))
            return unavailable
        }

        var granted: Set<HKSampleType> = []
        var denied: Set<HKSampleType> = []
        var pending: Set<HKSampleType> = []
        var probeResults: [String: ReadAuthorizationProbeResult] = [:]

        let requestStatus = await healthKit.requestStatusForAuthorization(readTypes: Set(requiredSampleTypes))

        if requestStatus == .shouldRequest || requestStatus == nil {
            pending = Set(requiredSampleTypes)
        } else {
            probeResults = await readAuthorizationProbeResults()
            for type in requiredSampleTypes {
                switch probeResults[type.identifier] ?? .notDetermined {
                case .authorized:
                    granted.insert(type)
                case .denied:
                    denied.insert(type)
                case .notDetermined, .protectedDataUnavailable, .healthDataUnavailable, .error:
                    pending.insert(type)
                }
            }
        }

        let status = HealthAccessStatus(required: requiredSampleTypes,
                                        granted: granted,
                                        denied: denied,
                                        notDetermined: pending,
                                        availability: .available)
        logHealthStatus(status, requestStatus: requestStatus, probeResults: probeResults)
        return status
    }

    private func scheduleBootstrapWatchdog(for status: HealthAccessStatus) {
        bootstrapWatchdogTask?.cancel()
        guard case .available = status.availability else { return }
        let deadlineSeconds = bootstrapPolicy.placeholderDeadlineSeconds
        let traceId = diagnosticsTraceId
        bootstrapWatchdogTask = Task { [weak self] in
            do {
                try await Task.sleep(nanoseconds: UInt64(max(0, deadlineSeconds) * 1_000_000_000))
            } catch {
                return
            }
            guard let self else { return }
            do {
                if let _ = try await self.latestFeatureVector() {
                    return
                }
            } catch {
                return
            }
            let created = await self.ensurePlaceholderSnapshot(for: Date(),
                                                               reason: .stage("bootstrap",
                                                                              allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]),
                                                               trigger: "watchdog")
            Diagnostics.log(level: .info,
                            category: .dataAgent,
                            name: "data.bootstrap.watchdog.triggered",
                            fields: [
                                "deadline_seconds": .double(deadlineSeconds),
                                "placeholder_created": .bool(created)
                            ],
                            traceId: traceId)
        }
    }

    private func shouldIgnoreBackgroundDeliveryError(_ error: Error) -> Bool {
        if let hkError = error as? HKError {
            // Explicitly ignore only the missing entitlement case; other HKError codes should surface.
            if hkError.errorCode == HKError.errorInvalidArgument.rawValue {
                return false
            }
        }
        let nsError = error as NSError
        if nsError.domain == HKError.errorDomain,
           nsError.code == HKError.errorInvalidArgument.rawValue {
            return false
        }
        // Fallback for older SDKs/localized messages; keep localization-safe by avoiding string equality.
        return nsError.localizedDescription.localizedCaseInsensitiveContains("background-delivery")
    }

    private func configureObservation(for status: HealthAccessStatus,
                                      resetRevokedAnchors: Bool) async throws {
        await DebugLogBuffer.shared.append("configureObservation availability=\(status.availability) granted=\(status.granted.map { $0.identifier })")
        guard case .available = status.availability else {
            stopAllObservers(resetAnchors: resetRevokedAnchors)
            return
        }

        try await enableBackgroundDelivery(for: status.granted)
        try await startObserversIfNeeded(for: status.granted)
        stopRevokedObservers(keeping: status.granted, resetAnchors: resetRevokedAnchors)
    }

    private func backfillHistoricalSamplesIfNeeded(for status: HealthAccessStatus) async {
        guard case .available = status.availability else {
            logDiagnostics(level: .info,
                           category: .backfill,
                           name: "data.backfill.phase.skip",
                           fields: [
                               "phase": .safeString(.stage("warmStart7d", allowed: ["warmStart7d", "full30d"])),
                               "reason": .safeString(.stage("health_unavailable", allowed: ["health_unavailable", "no_granted"]))
                           ])
            return
        }
        let grantedTypes = status.granted
        guard !grantedTypes.isEmpty else {
            logDiagnostics(level: .info,
                           category: .backfill,
                           name: "data.backfill.phase.skip",
                           fields: [
                               "phase": .safeString(.stage("warmStart7d", allowed: ["warmStart7d", "full30d"])),
                               "reason": .safeString(.stage("no_granted", allowed: ["health_unavailable", "no_granted"]))
                           ])
            return
        }

        let today = calendar.startOfDay(for: Date())
        let warmStartStart = calendar.date(byAdding: .day, value: -(warmStartWindowDays - 1), to: today) ?? today
        let fullWindowStart = calendar.date(byAdding: .day, value: -(fullAnalysisWindowDays - 1), to: today) ?? today

        let warmStartTypes = grantedTypes.filter { !backfillProgress.warmStartCompletedTypes.contains($0.identifier) }
        if warmStartTypes.isEmpty {
            logDiagnostics(level: .info,
                           category: .backfill,
                           name: "data.backfill.phase.skip",
                           fields: [
                               "phase": .safeString(.stage("warmStart7d", allowed: ["warmStart7d", "full30d"])),
                               "reason": .safeString(.stage("already_complete", allowed: ["health_unavailable", "no_granted", "already_complete"]))
                           ])
        } else {
            let phaseSpan = Diagnostics.span(category: .backfill,
                                             name: "data.backfill.phase",
                                             fields: [
                                                 "phase": .safeString(.stage("warmStart7d", allowed: ["warmStart7d", "full30d"])),
                                                 "start_day": .day(warmStartStart),
                                                 "end_day": .day(today),
                                                 "target_start_day": .day(fullWindowStart)
                                             ],
                                             traceId: diagnosticsTraceId,
                                             level: .info)
            let monitor = DiagnosticsStallMonitor(category: .backfill,
                                                  name: "data.backfill.warmStart",
                                                  traceId: diagnosticsTraceId,
                                                  thresholdSeconds: 25,
                                                  initialFields: [
                                                      "phase": .safeString(.stage("warmStart7d", allowed: ["warmStart7d", "full30d"])),
                                                      "type_count": .int(warmStartTypes.count)
                                                  ])
            await monitor.start()
            let result = await performBackfill(for: warmStartTypes.sorted { $0.identifier < $1.identifier },
                                               startDate: warmStartStart,
                                               endDate: today,
                                               phase: "warm-start",
                                               targetStartDate: fullWindowStart,
                                               markWarmStart: true,
                                               monitor: monitor)
            await monitor.stop(finalFields: [
                "touched_days": .int(result.days.count),
                "raw_sample_count": .int(result.totalSamples)
            ])
            phaseSpan.end(additionalFields: [
                "touched_days": .int(result.days.count),
                "raw_sample_count": .int(result.totalSamples)
            ], error: nil)
            notifySnapshotUpdate(for: today,
                                 reason: .stage("warm_backfill",
                                                allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]))
        }

        scheduleBackgroundFullBackfillIfNeeded(grantedTypes: grantedTypes, targetStartDate: fullWindowStart)
    }

    private func bootstrapFirstScore(for status: HealthAccessStatus) async {
        guard case .available = status.availability else {
            Diagnostics.log(level: .info,
                            category: .dataAgent,
                            name: "data.bootstrap.end",
                            fields: [
                                "reason": .safeString(.stage("health_unavailable", allowed: ["health_unavailable", "no_granted"])),
                                "has_snapshot": .bool(false),
                                "no_feature_vector": .bool(true)
                            ],
                            traceId: diagnosticsTraceId)
            return
        }
        guard !status.granted.isEmpty else {
            Diagnostics.log(level: .info,
                            category: .dataAgent,
                            name: "data.bootstrap.end",
                            fields: [
                                "reason": .safeString(.stage("no_granted", allowed: ["health_unavailable", "no_granted"])),
                                "has_snapshot": .bool(false),
                                "no_feature_vector": .bool(true)
                            ],
                            traceId: diagnosticsTraceId)
            return
        }
        let today = calendar.startOfDay(for: Date())
        guard let start = calendar.date(byAdding: .day, value: -(bootstrapWindowDays - 1), to: today) else { return }
        let types = status.granted.sorted { $0.identifier < $1.identifier }
        let bootstrapSpan = Diagnostics.span(category: .dataAgent,
                                             name: "data.bootstrap",
                                             fields: [
                                                 "window_days": .int(bootstrapWindowDays),
                                                 "start_day": .day(start),
                                                 "end_day": .day(today)
                                             ],
                                             traceId: diagnosticsTraceId)
        let fetchTimeoutSeconds = bootstrapPolicy.bootstrapTimeoutSeconds
        let heartRateTimeoutSeconds = bootstrapPolicy.heartRateTimeoutSeconds
        var touchedDays = Set<Date>()
        var totalSamples = 0
        var outcomes: [String: BootstrapBatchResult] = [:]
        var retryIdentifiers: Set<String> = []
        var snapshotDay: Date?
        var placeholderPublished = false
        var endError: Error?
        var allFailed = false

        func recordOutcome(_ identifier: String, result: BootstrapBatchResult) {
            outcomes[identifier] = result
            if result == .timeout || result == .error {
                retryIdentifiers.insert(identifier)
            }
        }

        defer {
            let successCount = outcomes.values.filter { $0 == .success }.count
            let emptyCount = outcomes.values.filter { $0 == .empty }.count
            let timeoutCount = outcomes.values.filter { $0 == .timeout }.count
            let errorCount = outcomes.values.filter { $0 == .error }.count
            let cancelledCount = outcomes.values.filter { $0 == .cancelled }.count
            var fields: [String: DiagnosticsValue] = [
                "touched_days": .int(touchedDays.count),
                "raw_sample_count": .int(totalSamples),
                "type_success_count": .int(successCount),
                "type_empty_count": .int(emptyCount),
                "type_timeout_count": .int(timeoutCount),
                "type_error_count": .int(errorCount),
                "type_cancelled_count": .int(cancelledCount),
                "all_failed": .bool(allFailed),
                "placeholder_published": .bool(placeholderPublished),
                "has_snapshot": .bool(snapshotDay != nil),
                "no_feature_vector": .bool(snapshotDay == nil)
            ]
            if let snapshotDay {
                fields["snapshot_day"] = .day(snapshotDay)
            }
            bootstrapSpan.end(additionalFields: fields, error: endError)
            Diagnostics.log(level: endError == nil ? .info : .error,
                            category: .dataAgent,
                            name: "data.bootstrap.end",
                            fields: fields,
                            traceId: diagnosticsTraceId,
                            error: endError)
        }

        for type in types {
            let identifier = type.identifier
            let batchSpan = Diagnostics.span(category: .dataAgent,
                                             name: "data.bootstrap.batch",
                                             fields: [
                                                 "type": .safeString(.metadata(identifier)),
                                                 "batch_start_day": .day(start),
                                                 "batch_end_day": .day(today)
                                             ],
                                             traceId: diagnosticsTraceId,
                                             level: .info)
            do {
                switch identifier {
                case HKQuantityTypeIdentifier.stepCount.rawValue:
                    let totalsResult: HardTimeoutResult<[Date: Int]>
                    do {
                        totalsResult = try await withHardTimeout(seconds: fetchTimeoutSeconds) {
                            try await self.safeFetchDailyStepTotals(startDate: start,
                                                                    endDate: today,
                                                                    context: "Bootstrap \(identifier)")
                        }
                    } catch {
                        if isProtectedHealthDataInaccessible(error) {
                            endBootstrapBatch(batchSpan,
                                              result: .empty,
                                              skipReason: .stage("protected_data", allowed: ["protected_data", "fetch_failed"]))
                            recordOutcome(identifier, result: .empty)
                            continue
                        }
                        endBootstrapBatch(batchSpan,
                                          result: .error,
                                          skipReason: .stage("fetch_failed", allowed: ["protected_data", "fetch_failed"]),
                                          error: error)
                        recordOutcome(identifier, result: .error)
                        continue
                    }

                    switch totalsResult {
                    case .timedOut:
                        endBootstrapBatch(batchSpan,
                                          result: .timeout,
                                          rawCount: 0,
                                          processedDays: 0,
                                          timeoutMs: Int(fetchTimeoutSeconds * 1_000))
                        recordOutcome(identifier, result: .timeout)
                    case .value(let totals):
                        let days = try await applyStepTotals(totals)
                        touchedDays.formUnion(days)
                        totalSamples += totals.count
                        let result: BootstrapBatchResult = totals.isEmpty ? .empty : .success
                        endBootstrapBatch(batchSpan,
                                          result: result,
                                          rawCount: totals.count,
                                          processedDays: days.count)
                        recordOutcome(identifier, result: result)
                    }
                case HKQuantityTypeIdentifier.heartRate.rawValue:
                    let hrResult = await fetchHeartRateStatsWithTimeout(startDate: start,
                                                                        endDate: today,
                                                                        context: "Bootstrap \(identifier)",
                                                                        timeoutSeconds: heartRateTimeoutSeconds)
                    switch hrResult.result {
                    case .success:
                        do {
                            let days = try await applyNocturnalStats(hrResult.stats)
                            touchedDays.formUnion(days)
                            totalSamples += hrResult.stats.count
                            endBootstrapBatch(batchSpan,
                                              result: .success,
                                              rawCount: hrResult.stats.count,
                                              processedDays: days.count)
                            recordOutcome(identifier, result: .success)
                        } catch {
                            endBootstrapBatch(batchSpan,
                                              result: .error,
                                              rawCount: hrResult.stats.count,
                                              processedDays: hrResult.stats.count,
                                              error: error)
                            recordOutcome(identifier, result: .error)
                        }
                    case .empty:
                        endBootstrapBatch(batchSpan,
                                          result: .empty,
                                          rawCount: 0,
                                          processedDays: 0)
                        recordOutcome(identifier, result: .empty)
                    case .timeout:
                        endBootstrapBatch(batchSpan,
                                          result: .timeout,
                                          rawCount: 0,
                                          processedDays: 0,
                                          timeoutMs: Int(heartRateTimeoutSeconds * 1_000))
                        recordOutcome(identifier, result: .timeout)
                    case .error:
                        endBootstrapBatch(batchSpan,
                                          result: .error,
                                          rawCount: 0,
                                          processedDays: 0,
                                          error: hrResult.error)
                        recordOutcome(identifier, result: .error)
                    case .cancelled:
                        endBootstrapBatch(batchSpan,
                                          result: .cancelled,
                                          rawCount: 0,
                                          processedDays: 0)
                        recordOutcome(identifier, result: .cancelled)
                    }
                default:
                    let samplesResult: HardTimeoutResult<[HKSample]>
                    do {
                        samplesResult = try await withHardTimeout(seconds: fetchTimeoutSeconds) {
                            try await self.healthKit.fetchSamples(for: type, startDate: start, endDate: today)
                        }
                    } catch {
                        if isProtectedHealthDataInaccessible(error) {
                            endBootstrapBatch(batchSpan,
                                              result: .empty,
                                              skipReason: .stage("protected_data", allowed: ["protected_data", "fetch_failed"]))
                            recordOutcome(identifier, result: .empty)
                            continue
                        }
                        endBootstrapBatch(batchSpan,
                                          result: .error,
                                          skipReason: .stage("fetch_failed", allowed: ["protected_data", "fetch_failed"]),
                                          error: error)
                        recordOutcome(identifier, result: .error)
                        continue
                    }

                    switch samplesResult {
                    case .timedOut:
                        endBootstrapBatch(batchSpan,
                                          result: .timeout,
                                          rawCount: 0,
                                          processedDays: 0,
                                          timeoutMs: Int(fetchTimeoutSeconds * 1_000))
                        recordOutcome(identifier, result: .timeout)
                    case .value(let samples):
                        let processed = try await processBackfillSamples(samples, type: type)
                        touchedDays.formUnion(processed.days)
                        totalSamples += processed.processedSamples
                        let result: BootstrapBatchResult = samples.isEmpty ? .empty : .success
                        endBootstrapBatch(batchSpan,
                                          result: result,
                                          rawCount: samples.count,
                                          processedCount: processed.processedSamples,
                                          processedDays: processed.days.count)
                        recordOutcome(identifier, result: result)
                    }
                }
            } catch {
                if isProtectedHealthDataInaccessible(error) {
                    endBootstrapBatch(batchSpan,
                                      result: .empty,
                                      skipReason: .stage("protected_data", allowed: ["protected_data", "fetch_failed"]))
                    recordOutcome(identifier, result: .empty)
                    continue
                }
                endBootstrapBatch(batchSpan,
                                  result: .error,
                                  skipReason: .stage("fetch_failed", allowed: ["protected_data", "fetch_failed"]),
                                  error: error)
                recordOutcome(identifier, result: .error)
            }
        }
        notifySnapshotUpdate(for: today,
                             reason: .stage("bootstrap",
                                            allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]))

        do {
            if let snapshot = try await latestRealFeatureVector() {
                snapshotDay = snapshot.date
                return
            }
        } catch {
            endError = error
        }

        allFailed = !outcomes.isEmpty && outcomes.values.allSatisfy { $0 == .timeout || $0 == .error }
        if allFailed {
            placeholderPublished = await ensurePlaceholderSnapshot(for: today,
                                                                   reason: .stage("bootstrap",
                                                                                  allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]),
                                                                   trigger: "bootstrap_failures")
        }

        if !retryIdentifiers.isEmpty {
            scheduleBootstrapRetry(for: retryIdentifiers,
                                   startDate: start,
                                   endDate: today,
                                   trigger: "bootstrap_failures")
        }

        let fallbackEnd = calendar.date(byAdding: .day, value: 1, to: today) ?? today
        let fallbackStart = calendar.date(byAdding: .day, value: -(fullAnalysisWindowDays - 1), to: today) ?? today
        let fallbackSucceeded = await bootstrapFromFallbackWindow(status: status,
                                                                  fallbackStartDate: fallbackStart,
                                                                  fallbackEndDate: fallbackEnd)
        if !fallbackSucceeded {
            notifySnapshotUpdate(for: today,
                                 reason: .stage("bootstrap",
                                                allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]))
        }

        do {
            if let snapshot = try await latestRealFeatureVector() {
                snapshotDay = snapshot.date
                return
            }
        } catch {
            endError = error
        }

        if snapshotDay == nil && !placeholderPublished {
            placeholderPublished = await ensurePlaceholderSnapshot(for: today,
                                                                   reason: .stage("bootstrap",
                                                                                  allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]),
                                                                   trigger: "bootstrap_complete")
        }
    }

    private func scheduleBackfill(for status: HealthAccessStatus) {
        guard case .available = status.availability else { return }
        backgroundBackfillTask?.cancel()
        backgroundBackfillTask = Task.detached(priority: .background) { [weak self] in
            guard let self else { return }
            await self.backfillHistoricalSamplesIfNeeded(for: status)
        }
    }

    private func scheduleBootstrapRetry(for identifiers: Set<String>,
                                        startDate: Date,
                                        endDate: Date,
                                        trigger: String) {
        guard !identifiers.isEmpty else { return }
        pendingBootstrapRetryIdentifiers.formUnion(identifiers)

        let now = Date()
        if bootstrapRetryStart == nil {
            bootstrapRetryStart = now
        }
        if let retryStart = bootstrapRetryStart,
           now.timeIntervalSince(retryStart) > bootstrapPolicy.retryMaxElapsedSeconds {
            Diagnostics.log(level: .info,
                            category: .dataAgent,
                            name: "data.bootstrap.retry.skipped",
                            fields: [
                                "reason": .safeString(.stage("max_elapsed", allowed: ["max_elapsed", "max_attempts"])),
                                "attempt": .int(bootstrapRetryAttempt)
                            ],
                            traceId: diagnosticsTraceId)
            return
        }

        let nextAttempt = bootstrapRetryAttempt + 1
        guard nextAttempt <= bootstrapPolicy.retryMaxAttempts else {
            Diagnostics.log(level: .info,
                            category: .dataAgent,
                            name: "data.bootstrap.retry.skipped",
                            fields: [
                                "reason": .safeString(.stage("max_attempts", allowed: ["max_elapsed", "max_attempts"])),
                                "attempt": .int(bootstrapRetryAttempt)
                            ],
                            traceId: diagnosticsTraceId)
            return
        }

        guard bootstrapRetryTask == nil else { return }
        bootstrapRetryAttempt = nextAttempt
        let attempt = nextAttempt
        let delaySeconds = bootstrapPolicy.retryDelaySeconds * pow(2.0, Double(attempt - 1))
        let timeoutSeconds = bootstrapPolicy.retryTimeoutSeconds + Double(attempt - 1) * 2
        let traceId = diagnosticsTraceId

        Diagnostics.log(level: .info,
                        category: .dataAgent,
                        name: "data.bootstrap.retry.scheduled",
                        fields: [
                            "attempt": .int(attempt),
                            "type_count": .int(identifiers.count),
                            "delay_seconds": .double(delaySeconds),
                            "timeout_seconds": .double(timeoutSeconds),
                            "window_start_day": .day(startDate),
                            "window_end_day": .day(endDate),
                            "trigger": .safeString(.stage(trigger,
                                                          allowed: ["bootstrap_timeout", "bootstrap_failures", "retry_timeout", "unknown"]))
                        ],
                        traceId: traceId)

        bootstrapRetryTask = Task.detached(priority: .background) { [weak self] in
            do {
                try await Task.sleep(nanoseconds: UInt64(max(0, delaySeconds) * 1_000_000_000))
            } catch {
                return
            }
            await self?.performBootstrapRetry(attempt: attempt,
                                              timeoutSeconds: timeoutSeconds,
                                              startDate: startDate,
                                              endDate: endDate)
        }
    }

    private func performBootstrapRetry(attempt: Int,
                                       timeoutSeconds: Double,
                                       startDate: Date,
                                       endDate: Date) async {
        let identifiers = pendingBootstrapRetryIdentifiers
        pendingBootstrapRetryIdentifiers.removeAll()
        let types = identifiers.compactMap { sampleTypesByIdentifier[$0] }.sorted { $0.identifier < $1.identifier }
        guard !types.isEmpty else {
            bootstrapRetryTask = nil
            return
        }

        let span = Diagnostics.span(category: .dataAgent,
                                    name: "data.bootstrap.retry",
                                    fields: [
                                        "attempt": .int(attempt),
                                        "type_count": .int(types.count),
                                        "window_start_day": .day(startDate),
                                        "window_end_day": .day(endDate),
                                        "timeout_seconds": .double(timeoutSeconds)
                                    ],
                                    traceId: diagnosticsTraceId,
                                    level: .info)

        var touchedDays = Set<Date>()
        var totalSamples = 0
        var outcomes: [String: BootstrapBatchResult] = [:]
        var timedOutIdentifiers: Set<String> = []

        func recordOutcome(_ identifier: String, result: BootstrapBatchResult) {
            outcomes[identifier] = result
            if result == .timeout {
                timedOutIdentifiers.insert(identifier)
            }
        }

        for type in types {
            let identifier = type.identifier
            let batchSpan = Diagnostics.span(category: .dataAgent,
                                             name: "data.bootstrap.retry.batch",
                                             fields: [
                                                 "type": .safeString(.metadata(identifier)),
                                                 "batch_start_day": .day(startDate),
                                                 "batch_end_day": .day(endDate),
                                                 "attempt": .int(attempt)
                                             ],
                                             traceId: diagnosticsTraceId,
                                             level: .info)
            do {
                switch identifier {
                case HKQuantityTypeIdentifier.stepCount.rawValue:
                    let totalsResult: HardTimeoutResult<[Date: Int]>
                    do {
                        totalsResult = try await withHardTimeout(seconds: timeoutSeconds) {
                            try await self.safeFetchDailyStepTotals(startDate: startDate,
                                                                    endDate: endDate,
                                                                    context: "Bootstrap retry \(identifier)")
                        }
                    } catch {
                        if isProtectedHealthDataInaccessible(error) {
                            endBootstrapBatch(batchSpan,
                                              result: .empty,
                                              skipReason: .stage("protected_data", allowed: ["protected_data", "fetch_failed"]))
                            recordOutcome(identifier, result: .empty)
                            continue
                        }
                        endBootstrapBatch(batchSpan,
                                          result: .error,
                                          skipReason: .stage("fetch_failed", allowed: ["protected_data", "fetch_failed"]),
                                          error: error)
                        recordOutcome(identifier, result: .error)
                        continue
                    }

                    switch totalsResult {
                    case .timedOut:
                        endBootstrapBatch(batchSpan,
                                          result: .timeout,
                                          rawCount: 0,
                                          processedDays: 0,
                                          timeoutMs: Int(timeoutSeconds * 1_000))
                        recordOutcome(identifier, result: .timeout)
                    case .value(let totals):
                        let days = try await applyStepTotals(totals)
                        touchedDays.formUnion(days)
                        totalSamples += totals.count
                        let result: BootstrapBatchResult = totals.isEmpty ? .empty : .success
                        endBootstrapBatch(batchSpan,
                                          result: result,
                                          rawCount: totals.count,
                                          processedDays: days.count)
                        recordOutcome(identifier, result: result)
                    }
                case HKQuantityTypeIdentifier.heartRate.rawValue:
                    let hrResult = await fetchHeartRateStatsWithTimeout(startDate: startDate,
                                                                        endDate: endDate,
                                                                        context: "Bootstrap retry \(identifier)",
                                                                        timeoutSeconds: timeoutSeconds)
                    switch hrResult.result {
                    case .success:
                        do {
                            let days = try await applyNocturnalStats(hrResult.stats)
                            touchedDays.formUnion(days)
                            totalSamples += hrResult.stats.count
                            endBootstrapBatch(batchSpan,
                                              result: .success,
                                              rawCount: hrResult.stats.count,
                                              processedDays: days.count)
                            recordOutcome(identifier, result: .success)
                        } catch {
                            endBootstrapBatch(batchSpan,
                                              result: .error,
                                              rawCount: hrResult.stats.count,
                                              processedDays: hrResult.stats.count,
                                              error: error)
                            recordOutcome(identifier, result: .error)
                        }
                    case .empty:
                        endBootstrapBatch(batchSpan,
                                          result: .empty,
                                          rawCount: 0,
                                          processedDays: 0)
                        recordOutcome(identifier, result: .empty)
                    case .timeout:
                        endBootstrapBatch(batchSpan,
                                          result: .timeout,
                                          rawCount: 0,
                                          processedDays: 0,
                                          timeoutMs: Int(timeoutSeconds * 1_000))
                        recordOutcome(identifier, result: .timeout)
                    case .error:
                        endBootstrapBatch(batchSpan,
                                          result: .error,
                                          rawCount: 0,
                                          processedDays: 0,
                                          error: hrResult.error)
                        recordOutcome(identifier, result: .error)
                    case .cancelled:
                        endBootstrapBatch(batchSpan,
                                          result: .cancelled,
                                          rawCount: 0,
                                          processedDays: 0)
                        recordOutcome(identifier, result: .cancelled)
                    }
                default:
                    let samplesResult: HardTimeoutResult<[HKSample]>
                    do {
                        samplesResult = try await withHardTimeout(seconds: timeoutSeconds) {
                            try await self.healthKit.fetchSamples(for: type, startDate: startDate, endDate: endDate)
                        }
                    } catch {
                        if isProtectedHealthDataInaccessible(error) {
                            endBootstrapBatch(batchSpan,
                                              result: .empty,
                                              skipReason: .stage("protected_data", allowed: ["protected_data", "fetch_failed"]))
                            recordOutcome(identifier, result: .empty)
                            continue
                        }
                        endBootstrapBatch(batchSpan,
                                          result: .error,
                                          skipReason: .stage("fetch_failed", allowed: ["protected_data", "fetch_failed"]),
                                          error: error)
                        recordOutcome(identifier, result: .error)
                        continue
                    }

                    switch samplesResult {
                    case .timedOut:
                        endBootstrapBatch(batchSpan,
                                          result: .timeout,
                                          rawCount: 0,
                                          processedDays: 0,
                                          timeoutMs: Int(timeoutSeconds * 1_000))
                        recordOutcome(identifier, result: .timeout)
                    case .value(let samples):
                        let processed = try await processBackfillSamples(samples, type: type)
                        touchedDays.formUnion(processed.days)
                        totalSamples += processed.processedSamples
                        let result: BootstrapBatchResult = samples.isEmpty ? .empty : .success
                        endBootstrapBatch(batchSpan,
                                          result: result,
                                          rawCount: samples.count,
                                          processedCount: processed.processedSamples,
                                          processedDays: processed.days.count)
                        recordOutcome(identifier, result: result)
                    }
                }
            } catch {
                if isProtectedHealthDataInaccessible(error) {
                    endBootstrapBatch(batchSpan,
                                      result: .empty,
                                      skipReason: .stage("protected_data", allowed: ["protected_data", "fetch_failed"]))
                    recordOutcome(identifier, result: .empty)
                    continue
                }
                endBootstrapBatch(batchSpan,
                                  result: .error,
                                  skipReason: .stage("fetch_failed", allowed: ["protected_data", "fetch_failed"]),
                                  error: error)
                recordOutcome(identifier, result: .error)
            }
        }

        if let latestDay = touchedDays.max() {
            notifySnapshotUpdate(for: latestDay,
                                 reason: .stage("bootstrap",
                                                allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]))
        }

        let hasSnapshot: Bool
        do {
            hasSnapshot = (try await latestRealFeatureVector()) != nil
        } catch {
            hasSnapshot = false
        }

        let successCount = outcomes.values.filter { $0 == .success }.count
        let emptyCount = outcomes.values.filter { $0 == .empty }.count
        let timeoutCount = outcomes.values.filter { $0 == .timeout }.count
        let errorCount = outcomes.values.filter { $0 == .error }.count
        let cancelledCount = outcomes.values.filter { $0 == .cancelled }.count
        let fields: [String: DiagnosticsValue] = [
            "attempt": .int(attempt),
            "touched_days": .int(touchedDays.count),
            "raw_sample_count": .int(totalSamples),
            "type_success_count": .int(successCount),
            "type_empty_count": .int(emptyCount),
            "type_timeout_count": .int(timeoutCount),
            "type_error_count": .int(errorCount),
            "type_cancelled_count": .int(cancelledCount),
            "has_snapshot": .bool(hasSnapshot)
        ]
        span.end(additionalFields: fields, error: nil)
        Diagnostics.log(level: .info,
                        category: .dataAgent,
                        name: "data.bootstrap.retry.end",
                        fields: fields,
                        traceId: diagnosticsTraceId)

        if hasSnapshot {
            bootstrapRetryAttempt = 0
            bootstrapRetryStart = nil
        }

        bootstrapRetryTask = nil

        if !timedOutIdentifiers.isEmpty {
            scheduleBootstrapRetry(for: timedOutIdentifiers,
                                   startDate: startDate,
                                   endDate: endDate,
                                   trigger: "retry_timeout")
        }
    }

    @discardableResult
    private func ensurePlaceholderSnapshot(for date: Date,
                                           reason: DiagnosticsSafeString,
                                           trigger: String) async -> Bool {
        do {
            if let _ = try await latestRealFeatureVector() {
                return false
            }
        } catch {
            return false
        }

        let day = calendar.startOfDay(for: date)
        do {
            let context = self.context
            let created = try await context.perform { () throws -> Bool in
                let request = FeatureVector.fetchRequest()
                request.predicate = NSPredicate(format: "date == %@", day as NSDate)
                request.fetchLimit = 1
                if let existing = try context.fetch(request).first {
                    let bundle = DataAgent.materializeFeatures(from: existing)
                    if SnapshotPlaceholder.isPlaceholder(bundle.imputed) {
                        return false
                    }
                    return false
                }
                let vector = FeatureVector(context: context)
                vector.date = day
                var zeroFeatures: [String: Double] = [:]
                for key in FeatureBundle.requiredKeys {
                    zeroFeatures[key] = 0
                }
                DataAgent.apply(features: zeroFeatures, to: vector)
                let imputed: [String: Bool] = [SnapshotPlaceholder.imputedFlagKey: true]
                vector.imputedFlags = DataAgent.encodeFeatureMetadata(imputed: imputed,
                                                                      contributions: [:],
                                                                      wellbeing: 0)
                if context.hasChanges {
                    try context.save()
                }
                return true
            }
            if created {
                notifySnapshotUpdate(for: day, reason: reason)
                Diagnostics.log(level: .info,
                                category: .dataAgent,
                                name: "data.snapshot.placeholder",
                                fields: [
                                    "trigger": .safeString(.stage(trigger,
                                                                  allowed: ["watchdog", "bootstrap_failures", "bootstrap_complete", "bootstrap_timeout", "unknown"])),
                                    "snapshot_day": .day(day)
                                ],
                                traceId: diagnosticsTraceId)
            }
            return created
        } catch {
            Diagnostics.log(level: .error,
                            category: .dataAgent,
                            name: "data.snapshot.placeholder.failed",
                            fields: [
                                "trigger": .safeString(.stage(trigger,
                                                              allowed: ["watchdog", "bootstrap_failures", "bootstrap_complete", "bootstrap_timeout", "unknown"])),
                                "snapshot_day": .day(day)
                            ],
                            traceId: diagnosticsTraceId,
                            error: error)
            return false
        }
    }

    private func bootstrapFromFallbackWindow(status: HealthAccessStatus,
                                             fallbackStartDate: Date,
                                             fallbackEndDate: Date) async -> Bool {
        guard case .available = status.availability else { return false }
        guard !status.granted.isEmpty else { return false }

        let span = Diagnostics.span(category: .dataAgent,
                                    name: "data.bootstrap.fallback",
                                    fields: [
                                        "start_day": .day(fallbackStartDate),
                                        "end_day": .day(fallbackEndDate)
                                    ],
                                    traceId: diagnosticsTraceId,
                                    level: .info)
        var touchedDays: Set<Date> = []
        var totalSamples = 0
        let fetchTimeoutSeconds = bootstrapPolicy.bootstrapTimeoutSeconds
        let heartRateTimeoutSeconds = bootstrapPolicy.heartRateTimeoutSeconds
        let types = status.granted.sorted { $0.identifier < $1.identifier }

        for type in types {
            let identifier = type.identifier
            let batchSpan = Diagnostics.span(category: .dataAgent,
                                             name: "data.bootstrap.fallback.batch",
                                             fields: [
                                                 "type": .safeString(.metadata(identifier)),
                                                 "batch_start_day": .day(fallbackStartDate),
                                                 "batch_end_day": .day(fallbackEndDate)
                                             ],
                                             traceId: diagnosticsTraceId,
                                             level: .info)
            do {
                switch identifier {
                case HKQuantityTypeIdentifier.stepCount.rawValue:
                    let totalsResult: HardTimeoutResult<[Date: Int]>
                    do {
                        totalsResult = try await withHardTimeout(seconds: fetchTimeoutSeconds) {
                            try await self.safeFetchDailyStepTotals(startDate: fallbackStartDate,
                                                                    endDate: fallbackEndDate,
                                                                    context: "Bootstrap fallback \(identifier)")
                        }
                    } catch {
                        if isProtectedHealthDataInaccessible(error) {
                            endBootstrapBatch(batchSpan,
                                              result: .empty,
                                              skipReason: .stage("protected_data", allowed: ["protected_data", "fetch_failed"]))
                            continue
                        }
                        endBootstrapBatch(batchSpan,
                                          result: .error,
                                          skipReason: .stage("fetch_failed", allowed: ["protected_data", "fetch_failed"]),
                                          error: error)
                        continue
                    }

                    switch totalsResult {
                    case .timedOut:
                        endBootstrapBatch(batchSpan,
                                          result: .timeout,
                                          rawCount: 0,
                                          processedDays: 0,
                                          timeoutMs: Int(fetchTimeoutSeconds * 1_000))
                    case .value(let totals):
                        let days = try await applyStepTotals(totals)
                        touchedDays.formUnion(days)
                        totalSamples += totals.count
                        let result: BootstrapBatchResult = totals.isEmpty ? .empty : .success
                        endBootstrapBatch(batchSpan,
                                          result: result,
                                          rawCount: totals.count,
                                          processedDays: days.count)
                    }
                case HKQuantityTypeIdentifier.heartRate.rawValue:
                    let hrResult = await fetchHeartRateStatsWithTimeout(startDate: fallbackStartDate,
                                                                        endDate: fallbackEndDate,
                                                                        context: "Bootstrap fallback \(identifier)",
                                                                        timeoutSeconds: heartRateTimeoutSeconds)
                    switch hrResult.result {
                    case .success:
                        do {
                            let days = try await applyNocturnalStats(hrResult.stats)
                            touchedDays.formUnion(days)
                            totalSamples += hrResult.stats.count
                            endBootstrapBatch(batchSpan,
                                              result: .success,
                                              rawCount: hrResult.stats.count,
                                              processedDays: days.count)
                        } catch {
                            endBootstrapBatch(batchSpan,
                                              result: .error,
                                              rawCount: hrResult.stats.count,
                                              processedDays: hrResult.stats.count,
                                              error: error)
                        }
                    case .empty:
                        endBootstrapBatch(batchSpan,
                                          result: .empty,
                                          rawCount: 0,
                                          processedDays: 0)
                    case .timeout:
                        endBootstrapBatch(batchSpan,
                                          result: .timeout,
                                          rawCount: 0,
                                          processedDays: 0,
                                          timeoutMs: Int(heartRateTimeoutSeconds * 1_000))
                    case .error:
                        endBootstrapBatch(batchSpan,
                                          result: .error,
                                          rawCount: 0,
                                          processedDays: 0,
                                          error: hrResult.error)
                    case .cancelled:
                        endBootstrapBatch(batchSpan,
                                          result: .cancelled,
                                          rawCount: 0,
                                          processedDays: 0)
                    }
                default:
                    let samplesResult: HardTimeoutResult<[HKSample]>
                    do {
                        samplesResult = try await withHardTimeout(seconds: fetchTimeoutSeconds) {
                            try await self.healthKit.fetchSamples(for: type, startDate: fallbackStartDate, endDate: fallbackEndDate)
                        }
                    } catch {
                        if isProtectedHealthDataInaccessible(error) {
                            endBootstrapBatch(batchSpan,
                                              result: .empty,
                                              skipReason: .stage("protected_data", allowed: ["protected_data", "fetch_failed"]))
                            continue
                        }
                        endBootstrapBatch(batchSpan,
                                          result: .error,
                                          skipReason: .stage("fetch_failed", allowed: ["protected_data", "fetch_failed"]),
                                          error: error)
                        span.end(additionalFields: [
                            "touched_days": .int(touchedDays.count),
                            "raw_sample_count": .int(totalSamples)
                        ], error: error)
                        return false
                    }

                    switch samplesResult {
                    case .timedOut:
                        endBootstrapBatch(batchSpan,
                                          result: .timeout,
                                          rawCount: 0,
                                          processedDays: 0,
                                          timeoutMs: Int(fetchTimeoutSeconds * 1_000))
                    case .value(let samples):
                        let processed = try await processBackfillSamples(samples, type: type)
                        touchedDays.formUnion(processed.days)
                        totalSamples += processed.processedSamples
                        let result: BootstrapBatchResult = samples.isEmpty ? .empty : .success
                        endBootstrapBatch(batchSpan,
                                          result: result,
                                          rawCount: samples.count,
                                          processedCount: processed.processedSamples,
                                          processedDays: processed.days.count)
                    }
                }
            } catch {
                if isProtectedHealthDataInaccessible(error) {
                    endBootstrapBatch(batchSpan,
                                      result: .empty,
                                      skipReason: .stage("protected_data", allowed: ["protected_data", "fetch_failed"]))
                    continue
                }
                endBootstrapBatch(batchSpan,
                                  result: .error,
                                  skipReason: .stage("fetch_failed", allowed: ["protected_data", "fetch_failed"]),
                                  error: error)
                span.end(additionalFields: [
                    "touched_days": .int(touchedDays.count),
                    "raw_sample_count": .int(totalSamples)
                ], error: error)
                return false
            }
        }

        guard let latestDay = touchedDays.max() else {
            span.end(additionalFields: [
                "touched_days": .int(touchedDays.count),
                "raw_sample_count": .int(totalSamples)
            ], error: nil)
            return false
        }
        notifySnapshotUpdate(for: latestDay,
                             reason: .stage("bootstrap",
                                            allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]))
        span.end(additionalFields: [
            "touched_days": .int(touchedDays.count),
            "raw_sample_count": .int(totalSamples),
            "snapshot_day": .day(latestDay)
        ], error: nil)
        return true
    }

    private func processBackfillSamples(_ samples: [HKSample], type: HKSampleType) async throws -> (processedSamples: Int, days: Set<Date>) {
        switch type {
        case let quantityType as HKQuantityType:
            let quantitySamples = samples.compactMap { $0 as? HKQuantitySample }
            guard !quantitySamples.isEmpty else {
                logDiagnostics(level: .info,
                               category: .backfill,
                               name: "data.backfill.skip",
                               fields: [
                                   "type": .safeString(.metadata(quantityType.identifier)),
                                   "reason": .safeString(.stage("no_castable_samples", allowed: ["no_castable_samples"]))
                               ])
                return (0, [])
            }
            // Group by day to avoid huge single calls and to log progress.
            let grouped = Dictionary(grouping: quantitySamples) { calendar.startOfDay(for: $0.startDate) }
            var touched: Set<Date> = []
            var processedCount = 0
            for (_, daySamples) in grouped {
                let days = try await processQuantitySamples(daySamples, type: quantityType)
                touched.formUnion(days)
                processedCount += daySamples.count
            }
            return (processedCount, touched)

        case let categoryType as HKCategoryType:
            let categorySamples = samples.compactMap { $0 as? HKCategorySample }
            guard !categorySamples.isEmpty else {
                logDiagnostics(level: .info,
                               category: .backfill,
                               name: "data.backfill.skip",
                               fields: [
                                   "type": .safeString(.metadata(categoryType.identifier)),
                                   "reason": .safeString(.stage("no_castable_samples", allowed: ["no_castable_samples"]))
                               ])
                return (0, [])
            }
            let grouped = Dictionary(grouping: categorySamples) { calendar.startOfDay(for: $0.startDate) }
            var touched: Set<Date> = []
            var processedCount = 0
            for (_, daySamples) in grouped {
                let days = try await processCategorySamples(daySamples, type: categoryType)
                touched.formUnion(days)
                processedCount += daySamples.count
            }
            return (processedCount, touched)

        default:
            logDiagnostics(level: .info,
                           category: .backfill,
                           name: "data.backfill.skip",
                           fields: [
                               "type": .safeString(.metadata(type.identifier)),
                               "reason": .safeString(.stage("unsupported_type", allowed: ["unsupported_type"]))
                           ])
            return (0, [])
        }
    }

    private func performBackfill(for types: [HKSampleType],
                                 startDate: Date,
                                 endDate: Date,
                                 phase: String,
                                 targetStartDate: Date,
                                 markWarmStart: Bool,
                                 monitor: DiagnosticsStallMonitor? = nil) async -> (days: Set<Date>, totalSamples: Int) {
        guard !types.isEmpty else { return ([], 0) }
        let sorted = types.sorted { $0.identifier < $1.identifier }
        let backfillTimeoutSeconds = bootstrapPolicy.backfillTimeoutSeconds
        var touchedDays: Set<Date> = []
        var totalSamples = 0
        var processedTypeCount = 0
        for type in sorted {
            let identifier = type.identifier
            let batchSpan = Diagnostics.span(category: .backfill,
                                             name: "data.backfill.batch",
                                             fields: [
                                                 "phase": .safeString(.stage(phase, allowed: ["warm-start", "full"])),
                                                 "type": .safeString(.metadata(identifier)),
                                                 "batch_start_day": .day(startDate),
                                                 "batch_end_day": .day(endDate),
                                                 "target_start_day": .day(targetStartDate),
                                                 "mark_warm_start": .bool(markWarmStart)
                                             ],
                                             traceId: diagnosticsTraceId,
                                             level: .info)
            do {
                switch identifier {
                case HKQuantityTypeIdentifier.stepCount.rawValue:
                    let totalsResult: HardTimeoutResult<[Date: Int]>
                    do {
                        totalsResult = try await withHardTimeout(seconds: backfillTimeoutSeconds) {
                            try await self.safeFetchDailyStepTotals(startDate: startDate,
                                                                    endDate: endDate,
                                                                    context: "Backfill (\(phase)) \(identifier)")
                        }
                    } catch {
                        if isProtectedHealthDataInaccessible(error) {
                            batchSpan.end(additionalFields: [
                                "skip_reason": .safeString(.stage("protected_data", allowed: ["zero_samples", "protected_data", "fetch_failed"]))
                            ], error: nil)
                        } else {
                            batchSpan.end(additionalFields: [
                                "skip_reason": .safeString(.stage("fetch_failed", allowed: ["zero_samples", "protected_data", "fetch_failed"]))
                            ], error: error)
                        }
                        continue
                    }
                    switch totalsResult {
                    case .timedOut:
                        batchSpan.end(additionalFields: [
                            "result": .safeString(.stage("timeout", allowed: ["timeout"])),
                            "timeout_ms": .int(Int(backfillTimeoutSeconds * 1_000))
                        ], error: nil)
                    case .value(let totals):
                        let processedDays = try await applyStepTotals(totals)
                        touchedDays.formUnion(processedDays)
                        totalSamples += totals.count
                        batchSpan.end(additionalFields: [
                            "raw_sample_count": .int(totals.count),
                            "processed_days": .int(processedDays.count)
                        ], error: nil)
                    }
                case HKQuantityTypeIdentifier.heartRate.rawValue:
                    let statsResult: HardTimeoutResult<[Date: (avgBPM: Double, minBPM: Double?)]>
                    do {
                        statsResult = try await withHardTimeout(seconds: backfillTimeoutSeconds) {
                            try await self.safeFetchNocturnalHeartRateStats(startDate: startDate,
                                                                            endDate: endDate,
                                                                            context: "Backfill (\(phase)) \(identifier)")
                        }
                    } catch {
                        if isProtectedHealthDataInaccessible(error) {
                            batchSpan.end(additionalFields: [
                                "skip_reason": .safeString(.stage("protected_data", allowed: ["zero_samples", "protected_data", "fetch_failed"]))
                            ], error: nil)
                        } else {
                            batchSpan.end(additionalFields: [
                                "skip_reason": .safeString(.stage("fetch_failed", allowed: ["zero_samples", "protected_data", "fetch_failed"]))
                            ], error: error)
                        }
                        continue
                    }

                    switch statsResult {
                    case .timedOut:
                        batchSpan.end(additionalFields: [
                            "result": .safeString(.stage("timeout", allowed: ["timeout"])),
                            "timeout_ms": .int(Int(backfillTimeoutSeconds * 1_000))
                        ], error: nil)
                    case .value(let stats):
                        let processedDays = try await applyNocturnalStats(stats)
                        touchedDays.formUnion(processedDays)
                        totalSamples += stats.count
                        batchSpan.end(additionalFields: [
                            "raw_sample_count": .int(stats.count),
                            "processed_days": .int(processedDays.count)
                        ], error: nil)
                    }
                default:
                    let samplesResult: HardTimeoutResult<[HKSample]>
                    do {
                        samplesResult = try await withHardTimeout(seconds: backfillTimeoutSeconds) {
                            try await self.healthKit.fetchSamples(for: type, startDate: startDate, endDate: endDate)
                        }
                    } catch {
                        if isProtectedHealthDataInaccessible(error) {
                            batchSpan.end(additionalFields: [
                                "skip_reason": .safeString(.stage("protected_data", allowed: ["zero_samples", "protected_data", "fetch_failed"]))
                            ], error: nil)
                        } else {
                            batchSpan.end(additionalFields: [
                                "skip_reason": .safeString(.stage("fetch_failed", allowed: ["zero_samples", "protected_data", "fetch_failed"]))
                            ], error: error)
                        }
                        continue
                    }

                    switch samplesResult {
                    case .timedOut:
                        batchSpan.end(additionalFields: [
                            "result": .safeString(.stage("timeout", allowed: ["timeout"])),
                            "timeout_ms": .int(Int(backfillTimeoutSeconds * 1_000))
                        ], error: nil)
                    case .value(let samples):
                        var processed: (processedSamples: Int, days: Set<Date>) = (0, [])
                        if !samples.isEmpty {
                            processed = try await processBackfillSamples(samples, type: type)
                            touchedDays.formUnion(processed.days)
                            totalSamples += processed.processedSamples
                            batchSpan.end(additionalFields: [
                                "raw_sample_count": .int(samples.count),
                                "processed_sample_count": .int(processed.processedSamples),
                                "processed_days": .int(processed.days.count)
                            ], error: nil)
                        } else {
                            batchSpan.end(additionalFields: [
                                "skip_reason": .safeString(.stage("zero_samples", allowed: ["zero_samples", "protected_data", "fetch_failed"]))
                            ], error: nil)
                        }
                    }
                }

                if markWarmStart {
                    backfillProgress.recordWarmStart(for: type.identifier, earliestDate: startDate, calendar: calendar)
                } else {
                    backfillProgress.recordProcessedRange(for: type.identifier,
                                                          startDate: startDate,
                                                          targetStartDate: targetStartDate,
                                                         calendar: calendar)
                }
                persistBackfillProgress()
            } catch {
                if isProtectedHealthDataInaccessible(error) {
                    batchSpan.end(additionalFields: [
                        "skip_reason": .safeString(.stage("protected_data", allowed: ["zero_samples", "protected_data", "fetch_failed"]))
                    ], error: nil)
                } else {
                    batchSpan.end(additionalFields: [
                        "skip_reason": .safeString(.stage("fetch_failed", allowed: ["zero_samples", "protected_data", "fetch_failed"]))
                    ], error: error)
                }
            }
            await monitor?.heartbeat(progressFields: [
                "phase": .safeString(.stage(phase, allowed: ["warm-start", "full"])),
                "processed_types": .int(processedTypeCount + 1)
            ])
            processedTypeCount += 1
        }
        return (touchedDays, totalSamples)
    }

    private func scheduleBackgroundFullBackfillIfNeeded(grantedTypes: Set<HKSampleType>, targetStartDate: Date) {
        guard needsFullBackfill(for: grantedTypes, targetStartDate: targetStartDate) else {
            Task { await DebugLogBuffer.shared.append("Background backfill skipped: full window already covered") }
            return
        }
        if let task = backgroundBackfillTask, !task.isCancelled {
            return
        }
        backgroundBackfillTask = Task { [weak self] in
            await self?.performBackgroundFullBackfill(grantedTypes: grantedTypes, targetStartDate: targetStartDate)
        }
    }

    private func needsFullBackfill(for grantedTypes: Set<HKSampleType>, targetStartDate: Date) -> Bool {
        for type in grantedTypes {
            let identifier = type.identifier
            if backfillProgress.fullBackfillCompletedTypes.contains(identifier) {
                continue
            }
            guard let earliest = backfillProgress.earliestProcessedDate(for: identifier, calendar: calendar) else {
                return true
            }
            if earliest > targetStartDate {
                return true
            }
        }
        return false
    }

    private func performBackgroundFullBackfill(grantedTypes: Set<HKSampleType>, targetStartDate: Date) async {
        let phaseSpan = Diagnostics.span(category: .backfill,
                                         name: "data.backfill.phase",
                                         fields: [
                                             "phase": .safeString(.stage("full30d", allowed: ["warmStart7d", "full30d"])),
                                             "target_start_day": .day(targetStartDate)
                                         ],
                                         traceId: diagnosticsTraceId,
                                         level: .info)
        let monitor = DiagnosticsStallMonitor(category: .backfill,
                                              name: "data.backfill.full",
                                              traceId: diagnosticsTraceId,
                                              thresholdSeconds: 90,
                                              initialFields: [
                                                  "phase": .safeString(.stage("full30d", allowed: ["warmStart7d", "full30d"])),
                                                  "granted_types": .int(grantedTypes.count)
                                              ])
        await monitor.start()
        defer { backgroundBackfillTask = nil }

        var iteration = 0
        var batchTouchedDays: Set<Date> = []
        var batchSampleCount = 0
        var batchTypes: [String] = []
        var totalTouchedDays: Set<Date> = []
        var totalSamples = 0
        let today = calendar.startOfDay(for: Date())

        while !Task.isCancelled {
            var madeProgress = false
            let sorted = grantedTypes.sorted { $0.identifier < $1.identifier }

            for type in sorted {
                let identifier = type.identifier
                if backfillProgress.fullBackfillCompletedTypes.contains(identifier) {
                    continue
                }

                let currentEarliest = backfillProgress.earliestProcessedDate(for: identifier, calendar: calendar) ?? calendar.startOfDay(for: Date())
                if currentEarliest <= targetStartDate {
                    backfillProgress.markFullBackfillComplete(for: identifier)
                    persistBackfillProgress()
                    continue
                }

                let batchEnd = calendar.date(byAdding: .day, value: -1, to: currentEarliest) ?? targetStartDate
                var batchStart = calendar.date(byAdding: .day, value: -(backgroundBackfillBatchDays - 1), to: batchEnd) ?? targetStartDate
                if batchStart < targetStartDate { batchStart = targetStartDate }

                let touched = await performBackfill(for: [type],
                                                    startDate: batchStart,
                                                    endDate: batchEnd,
                                                    phase: "full",
                                                    targetStartDate: targetStartDate,
                                                    markWarmStart: false,
                                                    monitor: monitor)
                batchTypes.append(identifier)
                batchSampleCount += touched.totalSamples
                totalSamples += touched.totalSamples
                batchTouchedDays.formUnion(touched.days)
                totalTouchedDays.formUnion(touched.days)
                madeProgress = true
            }

            if !needsFullBackfill(for: grantedTypes, targetStartDate: targetStartDate) {
                break
            }
            if !madeProgress {
                logDiagnostics(level: .warn,
                               category: .backfill,
                               name: "data.backfill.phase.pause",
                               fields: [
                                   "phase": .safeString(.stage("full30d", allowed: ["warmStart7d", "full30d"])),
                                   "reason": .safeString(.stage("no_progress", allowed: ["no_progress"]))
                               ])
                break
            }
            logDiagnostics(level: .info,
                           category: .backfill,
                           name: "data.backfill.phase.iteration",
                           fields: [
                               "phase": .safeString(.stage("full30d", allowed: ["warmStart7d", "full30d"])),
                               "iteration": .int(iteration),
                               "window_start_day": batchTouchedDays.min().map { .day($0) } ?? .day(today),
                               "window_end_day": batchTouchedDays.max().map { .day($0) } ?? .day(today),
                               "types_processed": .int(batchTypes.count),
                               "touched_days": .int(batchTouchedDays.count),
                               "raw_sample_count": .int(batchSampleCount)
                           ])
            if !batchTouchedDays.isEmpty {
                notifySnapshotUpdate(for: today,
                                     reason: .stage("full_backfill",
                                                    allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]))
            }
            batchTouchedDays.removeAll()
            batchSampleCount = 0
            batchTypes.removeAll()
            iteration += 1
            if iteration > 64 { break }
            try? await Task.sleep(nanoseconds: 150_000_000)
        }

        await monitor.stop(finalFields: [
            "touched_days": .int(totalTouchedDays.count),
            "raw_sample_count": .int(totalSamples),
            "iterations": .int(iteration)
        ])

        phaseSpan.end(additionalFields: [
            "phase": .safeString(.stage("full30d", allowed: ["warmStart7d", "full30d"])),
            "touched_days": .int(totalTouchedDays.count),
            "raw_sample_count": .int(totalSamples),
            "iterations": .int(iteration)
        ], error: nil)
    }


    private func enableBackgroundDelivery(for grantedTypes: Set<HKSampleType>) async throws {
        guard !grantedTypes.isEmpty else {
            await DebugLogBuffer.shared.append("enableBackgroundDelivery skipped: no granted types")
            return
        }
        do {
            try await healthKit.enableBackgroundDelivery(for: grantedTypes)
            await DebugLogBuffer.shared.append("enableBackgroundDelivery enabled for \(grantedTypes.map { $0.identifier })")
        } catch HealthKitServiceError.backgroundDeliveryFailed(let type, let underlying) {
            if shouldIgnoreBackgroundDeliveryError(underlying) {
                await DebugLogBuffer.shared.append("enableBackgroundDelivery ignored missing entitlement for \(type.identifier)")
                Diagnostics.log(level: .warn,
                                category: .healthkit,
                                name: "data.healthkit.backgroundDelivery.missingEntitlement",
                                fields: ["type": .safeString(.metadata(type.identifier))])
            } else {
                throw HealthKitServiceError.backgroundDeliveryFailed(type: type, underlying: underlying)
            }
        } catch {
            throw error
        }
    }

    private func startObserversIfNeeded(for types: Set<HKSampleType>) async throws {
        guard !types.isEmpty else {
            await DebugLogBuffer.shared.append("startObserversIfNeeded skipped: no granted types")
            return
        }
        for type in types {
            await DebugLogBuffer.shared.append("Starting observer for \(type.identifier)")
            try await observe(sampleType: type)
        }
    }

    private func stopRevokedObservers(keeping granted: Set<HKSampleType>, resetAnchors: Bool) {
        let grantedIdentifiers = Set(granted.map { $0.identifier })
        let identifiers = Array(observers.keys)
        var revoked: [String] = []
        for identifier in identifiers where !grantedIdentifiers.contains(identifier) {
            if let type = sampleTypesByIdentifier[identifier] {
                stopObservation(for: type, resetAnchor: resetAnchors)
                revoked.append(identifier)
            } else {
                observers.removeValue(forKey: identifier)
            }
        }
        if resetAnchors, !revoked.isEmpty {
            for identifier in revoked {
                backfillProgress.removeProgress(for: identifier)
            }
            persistBackfillProgress()
        }
    }

    private func readAuthorizationProbeResults(forceRefresh: Bool = false) async -> [String: ReadAuthorizationProbeResult] {
        if !forceRefresh,
           let cached = cachedReadAccess,
           Date().timeIntervalSince(cached.timestamp) < readProbeCacheTTL {
            return cached.results
        }

        let resultsByType = await healthKit.probeReadAuthorization(for: requiredSampleTypes)
        var mapped: [String: ReadAuthorizationProbeResult] = [:]
        for (type, result) in resultsByType {
            mapped[type.identifier] = result
        }
        cachedReadAccess = (timestamp: Date(), results: mapped)
        return mapped
    }

    private func invalidateReadAccessCache() {
        cachedReadAccess = nil
    }

    private func logHealthStatus(_ status: HealthAccessStatus,
                                 requestStatus: HKAuthorizationRequestStatus?,
                                 probeResults: [String: ReadAuthorizationProbeResult]) {
        var debugLines: [String] = []
        debugLines.append("Health access status → granted: \(status.granted.map(\.identifier)), denied: \(status.denied.map(\.identifier)), pending: \(status.notDetermined.map(\.identifier)), availability: \(status.availability)")
        if let requestStatus {
            debugLines.append("HealthKit requestStatusForAuthorization=\(requestStatus.rawValue)")
        }
        if !probeResults.isEmpty {
            debugLines.append(readProbeSummary(probeResults))
            let perType = probeResults
                .map { "\($0.key)=\(probeLabel(for: $0.value))" }
                .sorted()
                .joined(separator: ", ")
            debugLines.append("HealthKit read probe per-type: \(perType)")
        }
        for line in debugLines {
            Task { await DebugLogBuffer.shared.append(line) }
        }
        Diagnostics.log(level: .info,
                        category: .healthkit,
                        name: "data.healthkit.status",
                        fields: [
                            "granted": .int(status.granted.count),
                            "denied": .int(status.denied.count),
                            "pending": .int(status.notDetermined.count),
                            "availability": .safeString(DiagnosticsSafeString.stage(status.availability == .available ? "available" : "unavailable",
                                                                                    allowed: Set(["available", "unavailable"])))
                        ],
                        traceId: diagnosticsTraceId)
    }

    private func logDiagnostics(level: DiagnosticsLevel,
                                category: DiagnosticsCategory = .dataAgent,
                                name: String,
                                fields: [String: DiagnosticsValue] = [:],
                                error: Error? = nil) {
        Diagnostics.log(level: level,
                        category: category,
                        name: name,
                        fields: fields,
                        traceId: diagnosticsTraceId,
                        error: error)
    }

    private func statusSummary(_ status: HealthAccessStatus) -> String {
        let grantedIds = status.granted.map(\.identifier).sorted().joined(separator: ",")
        let deniedIds = status.denied.map(\.identifier).sorted().joined(separator: ",")
        let pendingIds = status.notDetermined.map(\.identifier).sorted().joined(separator: ",")
        return "granted=[\(grantedIds)] denied=[\(deniedIds)] pending=[\(pendingIds)] availability=\(status.availability)"
    }

    private func stopAllObservers(resetAnchors: Bool) {
        let identifiers = Array(observers.keys)
        for identifier in identifiers {
            if let type = sampleTypesByIdentifier[identifier] {
                stopObservation(for: type, resetAnchor: resetAnchors)
            }
        }
        observers.removeAll()
    }

    private func stopObservation(for type: HKSampleType, resetAnchor: Bool) {
        observers.removeValue(forKey: type.identifier)
        healthKit.stopObserving(sampleType: type, resetAnchor: resetAnchor)
    }

    private func readProbeSummary(_ results: [String: ReadAuthorizationProbeResult]) -> String {
        var authorized = 0
        var denied = 0
        var pending = 0
        var protected = 0
        var errors = 0

        for result in results.values {
            switch result {
            case .authorized:
                authorized += 1
            case .denied:
                denied += 1
            case .notDetermined:
                pending += 1
            case .protectedDataUnavailable, .healthDataUnavailable:
                protected += 1
            case .error:
                errors += 1
            }
        }

        return "HealthKit read probe summary: authorized=\(authorized) denied=\(denied) pending=\(pending) protected=\(protected) error=\(errors)"
    }

    private func probeLabel(for result: ReadAuthorizationProbeResult) -> String {
        switch result {
        case .authorized:
            return "authorized"
        case .denied:
            return "denied"
        case .notDetermined:
            return "notDetermined"
        case .protectedDataUnavailable:
            return "protectedDataUnavailable"
        case .healthDataUnavailable:
            return "healthDataUnavailable"
        case let .error(domain, code):
            return "error(\(domain):\(code))"
        }
    }

    func latestFeatureVector() async throws -> FeatureVectorSnapshot? {
        try await latestFeatureVector(includePlaceholder: true)
    }

    private func latestRealFeatureVector() async throws -> FeatureVectorSnapshot? {
        try await latestFeatureVector(includePlaceholder: false)
    }

    private func latestFeatureVector(includePlaceholder: Bool) async throws -> FeatureVectorSnapshot? {
        let context = self.context
        let result = try await context.perform { () throws -> FeatureComputation? in
            let request = FeatureVector.fetchRequest()
            request.sortDescriptors = [NSSortDescriptor(key: #keyPath(FeatureVector.date), ascending: false)]
            request.fetchLimit = 5
            let vectors = try context.fetch(request)
            guard !vectors.isEmpty else { return nil }

            var placeholderCandidate: FeatureComputation?
            for vector in vectors {
                let bundle = DataAgent.materializeFeatures(from: vector)
                let computation = FeatureComputation(date: vector.date,
                                                     featureValues: bundle.values,
                                                     imputedFlags: bundle.imputed,
                                                     featureVectorObjectID: vector.objectID)
                if SnapshotPlaceholder.isPlaceholder(bundle.imputed) {
                    if includePlaceholder, placeholderCandidate == nil {
                        placeholderCandidate = computation
                    }
                    continue
                }
                return computation
            }
            return includePlaceholder ? placeholderCandidate : nil
        }

        guard let computation = result else {
            await DebugLogBuffer.shared.append("latestFeatureVector -> none found")
            return nil
        }
        let modelFeatures = WellbeingModeling.normalize(features: computation.featureValues,
                                                        imputedFlags: computation.imputedFlags)
        let snapshot = stateEstimator.currentSnapshot(features: modelFeatures)
        let dayString = DiagnosticsDayFormatter.dayString(from: computation.date)
        let placeholder = SnapshotPlaceholder.isPlaceholder(computation.imputedFlags)
        await DebugLogBuffer.shared.append("latestFeatureVector -> day=\(dayString) feature_count=\(computation.featureValues.count) placeholder=\(placeholder)")
        return FeatureVectorSnapshot(date: computation.date,
                                     wellbeingScore: snapshot.wellbeingScore,
                                     contributions: snapshot.contributions,
                                     imputedFlags: computation.imputedFlags,
                                     featureVectorObjectID: computation.featureVectorObjectID,
                                     features: computation.featureValues)
    }

    func scoreBreakdown() async throws -> ScoreBreakdown? {
        guard let snapshot = try await latestRealFeatureVector() else { return nil }

        let context = self.context
        let dayString = DiagnosticsDayFormatter.dayString(from: snapshot.date)
        await DebugLogBuffer.shared.append("Computing scoreBreakdown for day=\(dayString)")

        struct BaselinePayload: Sendable {
            let median: Double?
            let mad: Double?
            let ewma: Double?
            let updatedAt: Date?
        }

        let descriptors = Self.scoreMetricDescriptors
        let coverageByFeature = try await metricCoverage(for: snapshot, descriptors: descriptors)
        let rawAndBaselines = try await context.perform { () throws -> ([String: Double], [String: BaselinePayload]) in
            var rawValues: [String: Double] = [:]
            var baselines: [String: BaselinePayload] = [:]

            let metricsRequest = DailyMetrics.fetchRequest()
            metricsRequest.predicate = NSPredicate(format: "date == %@", snapshot.date as NSDate)
            metricsRequest.fetchLimit = 1
            if let metrics = try context.fetch(metricsRequest).first {
                rawValues["hrv"] = metrics.hrvMedian?.doubleValue
                rawValues["nocthr"] = metrics.nocturnalHRPercentile10?.doubleValue
                rawValues["resthr"] = metrics.restingHR?.doubleValue
                rawValues["sleepDebt"] = metrics.sleepDebt?.doubleValue
                rawValues["rr"] = metrics.respiratoryRate?.doubleValue
                rawValues["steps"] = metrics.steps?.doubleValue
            }

            let baselineKeys = Array(Set(descriptors.compactMap { $0.baselineKey }))
            if !baselineKeys.isEmpty {
                let baselineKeysPredicate = baselineKeys as NSArray
                let baselineRequest = Baseline.fetchRequest()
                baselineRequest.predicate = NSPredicate(format: "metric IN %@", baselineKeysPredicate)
                let baselineObjects = try context.fetch(baselineRequest)
                for baseline in baselineObjects {
                    let key = baseline.metric
                    guard !key.isEmpty else { continue }
                    baselines[key] = BaselinePayload(
                        median: baseline.median?.doubleValue,
                        mad: baseline.mad?.doubleValue,
                        ewma: baseline.ewma?.doubleValue,
                        updatedAt: baseline.updatedAt
                    )
                }
            }

            return (rawValues, baselines)
        }

        let rawValues = rawAndBaselines.0
        let baselineValues = rawAndBaselines.1

        var metrics: [ScoreBreakdown.MetricDetail] = []
        metrics.reserveCapacity(descriptors.count)

        for descriptor in descriptors.sorted(by: { $0.order < $1.order }) {
            let value: Double?
            if let rawKey = descriptor.rawValueKey {
                value = rawValues[rawKey]
            } else {
                value = snapshot.features[descriptor.featureKey]
            }

            let zScore: Double?
            if descriptor.usesZScore {
                zScore = snapshot.features[descriptor.featureKey]
            } else {
                zScore = nil
            }

            let baseline = descriptor.baselineKey.flatMap { baselineValues[$0] }
            let contribution = snapshot.contributions[descriptor.featureKey] ?? 0
            let notes = descriptor.flagMessages(for: snapshot.imputedFlags)

            let detail = ScoreBreakdown.MetricDetail(
                id: descriptor.featureKey,
                name: descriptor.displayName,
                kind: descriptor.kind,
                value: value,
                unit: descriptor.unit,
                zScore: zScore,
                contribution: contribution,
                baselineMedian: baseline?.median,
                baselineEwma: baseline?.ewma,
                baselineMad: baseline?.mad,
                rollingWindowDays: descriptor.rollingWindowDays,
                explanation: descriptor.explanation,
                notes: notes,
                coverage: coverageByFeature[descriptor.featureKey]
            )

            metrics.append(detail)
        }

        let generalNotes = Self.generalFlagMessages(for: snapshot.imputedFlags)

        return ScoreBreakdown(date: snapshot.date,
                              wellbeingScore: snapshot.wellbeingScore,
                              metrics: metrics,
                              generalNotes: generalNotes)
    }

    private func metricCoverage(for snapshot: FeatureVectorSnapshot,
                                descriptors: [ScoreMetricDescriptor]) async throws -> [String: ScoreBreakdown.MetricDetail.Coverage] {
        let calendar = self.calendar
        let context = self.context

        return try await context.perform {
            var coverage: [String: ScoreBreakdown.MetricDetail.Coverage] = [:]
            let endDate = calendar.startOfDay(for: snapshot.date)

            var windowStarts: [String: Date] = [:]
            for descriptor in descriptors {
                guard let window = descriptor.rollingWindowDays else { continue }
                let start = calendar.date(byAdding: .day, value: -(window - 1), to: endDate) ?? endDate
                windowStarts[descriptor.featureKey] = start
            }

            guard let earliest = windowStarts.values.min() else { return [:] }

            let request = DailyMetrics.fetchRequest()
            request.predicate = NSPredicate(format: "date >= %@ AND date <= %@", earliest as NSDate, endDate as NSDate)
            let metrics = try context.fetch(request)

            var counts: [String: (days: Set<Date>, samples: Int)] = [:]

            for metric in metrics {
                let flags = DataAgent.decodeFlags(from: metric)
                let day = calendar.startOfDay(for: metric.date)

                let hrvCount = flags.hrvSamples.isEmpty ? (metric.hrvMedian != nil ? 1 : 0) : flags.hrvSamples.count
                let nocturnalAvailable = metric.nocturnalHRPercentile10 != nil || flags.aggregatedNocturnalAverage != nil || !flags.heartRateSamples.isEmpty
                let restingSamples = flags.heartRateSamples.filter { $0.context == .resting }.count
                let restingCount = restingSamples == 0 ? (metric.restingHR != nil ? 1 : 0) : restingSamples
                let sleepDebtCount = metric.sleepDebt != nil ? 1 : 0
                let rrCount = flags.respiratorySamples.isEmpty ? (metric.respiratoryRate != nil ? 1 : 0) : flags.respiratorySamples.count
                let stepsAvailable = metric.steps != nil || flags.aggregatedStepTotal != nil || !flags.stepBuckets.isEmpty

                let sampleCounts: [String: Int] = [
                    "z_hrv": hrvCount,
                    "z_nocthr": nocturnalAvailable ? 1 : 0,
                    "z_resthr": restingCount,
                    "z_sleepDebt": sleepDebtCount,
                    "z_rr": rrCount,
                    "z_steps": stepsAvailable ? 1 : 0
                ]

                for (featureKey, count) in sampleCounts {
                    guard let windowStart = windowStarts[featureKey] else { continue }
                    guard day >= windowStart else { continue }
                    guard count > 0 else { continue }

                    var entry = counts[featureKey] ?? (Set<Date>(), 0)
                    entry.days.insert(day)
                    entry.samples += count
                    counts[featureKey] = entry
                }
            }

            for (featureKey, _) in windowStarts {
                if let entry = counts[featureKey] {
                    coverage[featureKey] = ScoreBreakdown.MetricDetail.Coverage(daysWithSamples: entry.days.count,
                                                                                sampleCount: entry.samples)
                } else {
                    // Explicitly surface zero coverage when no samples are available
                    coverage[featureKey] = ScoreBreakdown.MetricDetail.Coverage(daysWithSamples: 0, sampleCount: 0)
                }
            }

            return coverage
        }
    }

    func reprocessDay(date: Date) async throws {
        let day = calendar.startOfDay(for: date)
        try await reprocessDayInternal(day)
        notifySnapshotUpdate(for: day,
                             reason: .stage("reprocess",
                                            allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]))
    }

    func recordSubjectiveInputs(date: Date, stress: Double, energy: Double, sleepQuality: Double) async throws {
        let targetDate = calendar.startOfDay(for: date)
        let context = self.context
        let dayString = DiagnosticsDayFormatter.dayString(from: targetDate)
        await DebugLogBuffer.shared.append("Recording subjective inputs for day=\(dayString)")
        try await context.perform {
            let request = FeatureVector.fetchRequest()
            request.predicate = NSPredicate(format: "date == %@", targetDate as NSDate)
            request.fetchLimit = 1
            let vector = try context.fetch(request).first ?? FeatureVector(context: context)
            vector.date = targetDate
            vector.subjectiveStress = NSNumber(value: stress)
            vector.subjectiveEnergy = NSNumber(value: energy)
            vector.subjectiveSleepQuality = NSNumber(value: sleepQuality)
            try context.save()
        }
        try await reprocessDayInternal(targetDate)
        notifySnapshotUpdate(for: targetDate,
                             reason: .stage("reprocess",
                                            allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]))
    }

    // MARK: - Observation

    private func observe(sampleType: HKSampleType) async throws {
        let identifier = sampleType.identifier
        guard observers[identifier] == nil else { return }
        let token = try healthKit.observeSampleType(sampleType, predicate: nil) { result in
            switch result {
            case let .success(update):
                Task { await self.handle(update: update, sampleType: sampleType) }
            case let .failure(error):
                let nsError = error as NSError
                Task { await DebugLogBuffer.shared.append("HealthKit observe error for \(sampleType.identifier): domain=\(nsError.domain) code=\(nsError.code)") }
                Diagnostics.log(level: .warn,
                                category: .healthkit,
                                name: "data.healthkit.observe.error",
                                fields: ["type": .safeString(.metadata(sampleType.identifier))],
                                error: error)
            }
        }
        observers[identifier] = token
    }

    private func handle(update: HealthKitService.AnchoredUpdate, sampleType: HKSampleType) async {
        do {
            var touchedDays: Set<Date> = []
            switch sampleType {
            case let quantityType as HKQuantityType:
                let days = try await processQuantitySamples(update.samples.compactMap { $0 as? HKQuantitySample },
                                                            type: quantityType)
                touchedDays.formUnion(days)
            case let categoryType as HKCategoryType:
                let days = try await processCategorySamples(update.samples.compactMap { $0 as? HKCategorySample },
                                                            type: categoryType)
                touchedDays.formUnion(days)
            default:
                break
            }
            let deletedDays = try await handleDeletedSamples(update.deletedSamples)
            touchedDays.formUnion(deletedDays)

            logDiagnostics(level: .info,
                           category: .healthkit,
                           name: "data.healthkit.update",
                           fields: [
                               "type": .safeString(.metadata(sampleType.identifier)),
                               "sample_count": .int(update.samples.count),
                               "deleted_count": .int(update.deletedSamples.count),
                               "touched_days": .int(touchedDays.count)
                           ])

            if touchedDays.isEmpty {
                notifySnapshotUpdate(for: calendar.startOfDay(for: Date()),
                                     reason: .stage("refresh",
                                                    allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]))
            } else {
                for day in touchedDays {
                    notifySnapshotUpdate(for: day,
                                         reason: .stage("refresh",
                                                        allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"]))
                }
            }
        } catch {
            Diagnostics.log(level: .error,
                            category: .dataAgent,
                            name: "dataAgent.handleUpdate.error",
                            fields: ["type": .safeString(.metadata(sampleType.identifier))],
                            error: error)
        }
    }

    // MARK: - Sample Processing

    private func processQuantitySamples(_ samples: [HKQuantitySample],
                                        type: HKQuantityType) async throws -> Set<Date> {
        guard !samples.isEmpty else { return [] }

        let calendar = self.calendar
        let context = self.context
        let identifier = type.identifier

        if identifier == HKQuantityTypeIdentifier.stepCount.rawValue {
            guard let range = dayRange(for: samples) else { return [] }
            do {
                let totals = try await safeFetchDailyStepTotals(startDate: range.start,
                                                                endDate: range.end,
                                                                context: "Backfill \(identifier)")
                return try await applyStepTotals(totals)
            } catch {
                if isProtectedHealthDataInaccessible(error) {
                    await DebugLogBuffer.shared.append("Backfill skipped for \(identifier): protected data inaccessible (device likely locked).")
                    return []
                }
                throw error
            }
        } else if identifier == HKQuantityTypeIdentifier.heartRate.rawValue {
            guard let range = dayRange(for: samples) else { return [] }
            do {
                let stats = try await safeFetchNocturnalHeartRateStats(startDate: range.start,
                                                                       endDate: range.end,
                                                                       context: "Backfill \(identifier)")
                return try await applyNocturnalStats(stats)
            } catch {
                if isProtectedHealthDataInaccessible(error) {
                    await DebugLogBuffer.shared.append("Backfill skipped for \(identifier): protected data inaccessible (device likely locked).")
                    return []
                }
                throw error
            }
        }

        let dirtyDays = try await context.perform { () throws -> Set<Date> in
            var dirtyDays: Set<Date> = []
            for sample in samples {
                let day = calendar.startOfDay(for: sample.startDate)
                let metrics = DataAgent.fetchOrCreateDailyMetrics(in: context, date: day)
                DataAgent.mutateFlags(metrics) { flags in
                    flags.append(quantitySample: sample, type: type)
                }
                dirtyDays.insert(day)
            }

            if context.hasChanges {
                try context.save()
            }
            return dirtyDays
        }

        for day in dirtyDays {
            try await reprocessDayInternal(day)
        }

        return dirtyDays
    }

    private func processCategorySamples(_ samples: [HKCategorySample],
                                        type: HKCategoryType) async throws -> Set<Date> {
        guard type.identifier == HKCategoryTypeIdentifier.sleepAnalysis.rawValue else { return [] }
        guard !samples.isEmpty else { return [] }

        let calendar = self.calendar
        let context = self.context

        let dirtyDays = try await context.perform { () throws -> Set<Date> in
            var dirtyDays: Set<Date> = []
            for sample in samples {
                let day = calendar.startOfDay(for: sample.startDate)
                let metrics = DataAgent.fetchOrCreateDailyMetrics(in: context, date: day)
                DataAgent.mutateFlags(metrics) { flags in
                    let appended = flags.append(sleepSample: sample)
                    if appended {
                        dirtyDays.insert(day)
                    }
                }
            }
            if context.hasChanges {
                try context.save()
            }
            return dirtyDays
        }

        for day in dirtyDays {
            try await reprocessDayInternal(day)
        }

        return dirtyDays
    }

    private func handleDeletedSamples(_ deletedObjects: [HKDeletedObject]) async throws -> Set<Date> {
        guard !deletedObjects.isEmpty else { return [] }

        let identifiers = Set(deletedObjects.map { $0.uuid })
        let context = self.context
        let dirtyDays = try await context.perform { () throws -> Set<Date> in
            let request = DailyMetrics.fetchRequest()
            let metrics = try context.fetch(request)
            var dirty: Set<Date> = []
            for metric in metrics {
                var flags = DataAgent.decodeFlags(from: metric)
                if flags.pruneDeletedSamples(identifiers) {
                    metric.flags = DataAgent.encodeFlags(flags)
                    dirty.insert(metric.date)
                }
            }
            if context.hasChanges {
                try context.save()
            }
            return dirty
        }

        for day in dirtyDays {
            try await reprocessDayInternal(day)
        }

        return dirtyDays
    }

    private func dayRange(for samples: [HKSample]) -> (start: Date, end: Date)? {
        guard let earliest = samples.map(\.startDate).min(),
              let latest = samples.map(\.startDate).max() else { return nil }
        let startDay = calendar.startOfDay(for: earliest)
        let endExclusive = calendar.date(byAdding: .day, value: 1, to: calendar.startOfDay(for: latest)) ?? calendar.startOfDay(for: latest)
        return (startDay, endExclusive)
    }

    private func applyStepTotals(_ totals: [Date: Int]) async throws -> Set<Date> {
        guard !totals.isEmpty else { return [] }
        let calendar = self.calendar
        let context = self.context

        let dirtyDays = try await context.perform { () throws -> Set<Date> in
            var dirty: Set<Date> = []
            for (rawDay, total) in totals {
                let day = calendar.startOfDay(for: rawDay)
                let metrics = DataAgent.fetchOrCreateDailyMetrics(in: context, date: day)
                DataAgent.mutateFlags(metrics) { flags in
                    flags.aggregatedStepTotal = Double(total)
                    flags.stepBuckets = []
                }
                dirty.insert(day)
            }
            if context.hasChanges {
                try context.save()
            }
            return dirty
        }

        for day in dirtyDays {
            try await reprocessDayInternal(day)
        }

        return dirtyDays
    }

    private func applyNocturnalStats(_ stats: [Date: (avgBPM: Double, minBPM: Double?)]) async throws -> Set<Date> {
        guard !stats.isEmpty else { return [] }
        let calendar = self.calendar
        let context = self.context

        let dirtyDays = try await context.perform { () throws -> Set<Date> in
            var dirty: Set<Date> = []
            for (rawDay, value) in stats {
                let day = calendar.startOfDay(for: rawDay)
                let metrics = DataAgent.fetchOrCreateDailyMetrics(in: context, date: day)
                DataAgent.mutateFlags(metrics) { flags in
                    flags.aggregatedNocturnalAverage = value.avgBPM
                    flags.aggregatedNocturnalMin = value.minBPM
                    flags.heartRateSamples.removeAll { $0.context == .normal }
                }
                dirty.insert(day)
            }
            if context.hasChanges {
                try context.save()
            }
            return dirty
        }

        for day in dirtyDays {
            try await reprocessDayInternal(day)
        }

        return dirtyDays
    }

    // MARK: - Daily Computation

    private func reprocessDayInternal(_ day: Date) async throws {
        let context = self.context
        let calendar = self.calendar
        let sedentaryThreshold = sedentaryThresholdStepsPerHour
        let sedentaryDuration = sedentaryMinimumDuration
        let sleepDebtWindowDays = self.sleepDebtWindowDays
        let analysisWindowDays = self.fullAnalysisWindowDays

        let computation = try await context.perform { () throws -> FeatureComputation in
            let metrics = try DataAgent.fetchDailyMetrics(in: context, date: day)
            var flags = DataAgent.decodeFlags(from: metrics)
            let summary = try DataAgent.computeSummary(for: metrics,
                                                       flags: flags,
                                                       context: context,
                                                       calendar: calendar,
                                                       sedentaryThreshold: sedentaryThreshold,
                                                       sedentaryMinimumDuration: sedentaryDuration,
                                                       sleepDebtWindowDays: sleepDebtWindowDays,
                                                       analysisWindowDays: analysisWindowDays)
            flags = summary.updatedFlags

            metrics.hrvMedian = summary.hrv.map(NSNumber.init(value:))
            metrics.nocturnalHRPercentile10 = summary.nocturnalHR.map(NSNumber.init(value:))
            metrics.restingHR = summary.restingHR.map(NSNumber.init(value:))
            metrics.totalSleepTime = summary.totalSleepSeconds.map(NSNumber.init(value:))
            metrics.sleepDebt = summary.sleepDebtHours.map(NSNumber.init(value:))
            metrics.respiratoryRate = summary.respiratoryRate.map(NSNumber.init(value:))
            metrics.steps = summary.stepCount.map(NSNumber.init(value:))
            metrics.flags = DataAgent.encodeFlags(flags)

            let baselines = try DataAgent.updateBaselines(in: context,
                                                          summary: summary,
                                                          referenceDate: day,
                                                          windowDays: analysisWindowDays)
            let bundle = try DataAgent.buildFeatureBundle(for: metrics,
                                                          summary: summary,
                                                          baselines: baselines,
                                                          context: context)
            let featureVector = try DataAgent.fetchOrCreateFeatureVector(in: context, date: day)
            DataAgent.apply(features: bundle.values, to: featureVector)

            if context.hasChanges {
                try context.save()
            }

            return FeatureComputation(date: day,
                                      featureValues: bundle.values,
                                      imputedFlags: bundle.imputed,
                                      featureVectorObjectID: featureVector.objectID)
        }

        let modelFeatures = WellbeingModeling.normalize(features: computation.featureValues,
                                                        imputedFlags: computation.imputedFlags)
        let target = WellbeingModeling.target(for: modelFeatures)
        let snapshot = stateEstimator.update(features: modelFeatures, target: target)
        let dayString = DiagnosticsDayFormatter.dayString(from: day)
        await DebugLogBuffer.shared.append("Reprocessed day \(dayString) -> feature_count=\(computation.featureValues.count)")
        persistEstimatorState(from: snapshot)

        try await context.perform {
            guard let vector = try? context.existingObject(with: computation.featureVectorObjectID) as? FeatureVector else { return }
            vector.imputedFlags = DataAgent.encodeFeatureMetadata(imputed: computation.imputedFlags,
                                                                  contributions: snapshot.contributions,
                                                                  wellbeing: snapshot.wellbeingScore)
            if context.hasChanges {
                try context.save()
            }
        }
    }

    private func persistEstimatorState(from snapshot: StateEstimatorSnapshot) {
        let state = StateEstimatorState(version: EstimatorStateStore.schemaVersion,
                                        weights: snapshot.weights,
                                        bias: snapshot.bias)
        estimatorStore.saveState(state)
    }

    private func safeFetchDailyStepTotals(startDate: Date, endDate: Date, context: String) async throws -> [Date: Int] {
        do {
            return try await healthKit.fetchDailyStepTotals(startDate: startDate, endDate: endDate)
        } catch {
            if isProtectedHealthDataInaccessible(error) {
                await DebugLogBuffer.shared.append("\(context): protected data inaccessible (device likely locked); returning empty step totals.")
                return [:]
            }
            throw error
        }
    }

    private func safeFetchNocturnalHeartRateStats(startDate: Date, endDate: Date, context: String) async throws -> [Date: (avgBPM: Double, minBPM: Double?)] {
        do {
            return try await healthKit.fetchNocturnalHeartRateStats(startDate: startDate, endDate: endDate)
        } catch {
            if let hkError = error as? HKError, hkError.code == .errorNoData {
                await DebugLogBuffer.shared.append("\(context): no heart-rate data available; returning empty stats.")
                return [:]
            }
            let nsError = error as NSError
            if nsError.domain == HKError.errorDomain,
               nsError.code == HKError.Code.errorNoData.rawValue {
                await DebugLogBuffer.shared.append("\(context): no heart-rate data available; returning empty stats.")
                return [:]
            }
            if isProtectedHealthDataInaccessible(error) {
                await DebugLogBuffer.shared.append("\(context): protected data inaccessible (device likely locked); returning empty nocturnal HR stats.")
                return [:]
            }
            throw error
        }
    }

    private enum BootstrapBatchResult: String {
        case success
        case empty
        case timeout
        case error
        case cancelled
    }

    private func fetchHeartRateStatsWithTimeout(startDate: Date,
                                                endDate: Date,
                                                context: String,
                                                timeoutSeconds: Double) async -> (result: BootstrapBatchResult, stats: [Date: (avgBPM: Double, minBPM: Double?)], error: Error?) {
        do {
            let timed = try await withHardTimeout(seconds: timeoutSeconds) {
                try await self.safeFetchNocturnalHeartRateStats(startDate: startDate,
                                                                endDate: endDate,
                                                                context: context)
            }
            switch timed {
            case .timedOut:
                await DebugLogBuffer.shared.append("\(context): heart-rate fetch timed out after \(timeoutSeconds)s; treating as empty.")
                return (.timeout, [:], nil)
            case .value(let stats):
                if stats.isEmpty {
                    return (.empty, [:], nil)
                }
                return (.success, stats, nil)
            }
        } catch {
            return (.error, [:], error)
        }
    }

    private func endBootstrapBatch(_ span: DiagnosticsSpanToken,
                                   result: BootstrapBatchResult,
                                   rawCount: Int = 0,
                                   processedCount: Int? = nil,
                                   processedDays: Int? = nil,
                                   timeoutMs: Int? = nil,
                                   skipReason: DiagnosticsSafeString? = nil,
                                   error: Error? = nil) {
        var fields: [String: DiagnosticsValue] = [
            "result": .safeString(.stage(result.rawValue,
                                         allowed: ["success", "empty", "timeout", "error", "cancelled"])),
            "raw_sample_count": .int(rawCount)
        ]
        if let processedCount {
            fields["processed_sample_count"] = .int(processedCount)
        }
        if let processedDays {
            fields["processed_days"] = .int(processedDays)
        }
        if let timeoutMs {
            fields["timeout_ms"] = .int(timeoutMs)
        }
        if let skipReason {
            fields["skip_reason"] = .safeString(skipReason)
        }

        span.end(additionalFields: fields, error: error)
    }

    private func isProtectedHealthDataInaccessible(_ error: Error) -> Bool {
        if let hkError = error as? HKError {
            return hkError.code == .errorDatabaseInaccessible || hkError.code == .errorHealthDataUnavailable
        }
        let nsError = error as NSError
        if nsError.domain == HKError.errorDomain {
            return nsError.code == HKError.errorDatabaseInaccessible.rawValue
        }
        // Fallback for unexpected error domains where localizedDescription is the only indicator.
        return nsError.localizedDescription.localizedCaseInsensitiveContains("Protected health data is inaccessible")
    }

    private static func computeSummary(for metrics: DailyMetrics,
                                       flags: DailyFlags,
                                       context: NSManagedObjectContext,
                                       calendar: Calendar,
                                       sedentaryThreshold: Double,
                                       sedentaryMinimumDuration: TimeInterval,
                                       sleepDebtWindowDays: Int,
                                       analysisWindowDays: Int) throws -> DailySummary {
        var imputed: [String: Bool] = [:]

        let sleepIntervals = flags.sleepIntervals()
        let sedentaryIntervals = flags.sedentaryIntervals(thresholdStepsPerHour: sedentaryThreshold,
                                                          minimumDuration: sedentaryMinimumDuration,
                                                          excluding: sleepIntervals)
        if sedentaryIntervals.isEmpty && sleepIntervals.isEmpty {
            imputed["sedentary_missing"] = true
        }

        let previousHRV = try previousMetricValue(in: context,
                                                  keyPath: #keyPath(DailyMetrics.hrvMedian),
                                                  before: metrics.date)
        let hrvValue = flags.medianHRV(in: sleepIntervals,
                                       fallback: sedentaryIntervals,
                                       previous: previousHRV,
                                       imputed: &imputed)

        let previousNocturnal = try previousMetricValue(in: context,
                                                        keyPath: #keyPath(DailyMetrics.nocturnalHRPercentile10),
                                                        before: metrics.date)
        let nocturnalHR = flags.nocturnalHeartRate(in: sleepIntervals,
                                                   fallback: sedentaryIntervals,
                                                   previous: previousNocturnal,
                                                   imputed: &imputed)

        let previousResting = try previousMetricValue(in: context,
                                                      keyPath: #keyPath(DailyMetrics.restingHR),
                                                      before: metrics.date)
        let restingHR = flags.restingHeartRate(fallback: sedentaryIntervals,
                                               previous: previousResting,
                                               imputed: &imputed)

        let sleepSeconds = flags.sleepDurations()
        let sleepNeed = try personalizedSleepNeedHours(context: context,
                                                       referenceDate: metrics.date,
                                                       latestActualHours: (sleepSeconds ?? 0) / 3600,
                                                       windowDays: analysisWindowDays)
        var sleepDebt: Double?
        if let sleepSeconds {
            let actualSleepHours = sleepSeconds / 3600
            if sleepSeconds < 3 * 3600 {
                imputed["sleep_low_confidence"] = true
            }
            sleepDebt = try sleepDebtHours(context: context,
                                           personalNeed: sleepNeed,
                                           currentHours: actualSleepHours,
                                           referenceDate: metrics.date,
                                           windowDays: sleepDebtWindowDays,
                                           calendar: calendar)
        } else {
            imputed["sleepDebt_missing"] = true
        }

        let respiratoryRate = flags.averageRespiratoryRate(in: sleepIntervals)
        if respiratoryRate == nil {
            imputed["rr_missing"] = true
        }
        let stepCount = flags.totalSteps()
        if stepCount == nil {
            imputed["steps_missing"] = true
        } else if (stepCount ?? 0) < 500 {
            imputed["steps_low_confidence"] = true
        }

        return DailySummary(date: metrics.date,
                            hrv: hrvValue,
                            nocturnalHR: nocturnalHR,
                            restingHR: restingHR,
                            totalSleepSeconds: sleepSeconds,
                            sleepNeedHours: sleepNeed,
                            sleepDebtHours: sleepDebt,
                            respiratoryRate: respiratoryRate,
                            stepCount: stepCount,
                            updatedFlags: flags,
                            imputed: imputed)
    }

    private static func buildFeatureBundle(for metrics: DailyMetrics,
                                           summary: DailySummary,
                                           baselines: [String: BaselineMath.RobustStats],
                                           context: NSManagedObjectContext) throws -> FeatureBundle {
        var values: [String: Double] = [:]

        if let hrv = summary.hrv, let stats = baselines["hrv"] {
            values["z_hrv"] = BaselineMath.zScore(value: hrv, stats: stats)
        }
        if let nocturnal = summary.nocturnalHR, let stats = baselines["nocthr"] {
            values["z_nocthr"] = BaselineMath.zScore(value: nocturnal, stats: stats)
        }
        if let resting = summary.restingHR, let stats = baselines["resthr"] {
            values["z_resthr"] = BaselineMath.zScore(value: resting, stats: stats)
        }
        if let debt = summary.sleepDebtHours, let stats = baselines["sleepDebt"] {
            values["z_sleepDebt"] = BaselineMath.zScore(value: debt, stats: stats)
        }
        if let resp = summary.respiratoryRate, let stats = baselines["rr"] {
            values["z_rr"] = BaselineMath.zScore(value: resp, stats: stats)
        }
        if let steps = summary.stepCount, let stats = baselines["steps"] {
            values["z_steps"] = BaselineMath.zScore(value: steps, stats: stats)
        }

        let vector = try fetchOrCreateFeatureVector(in: context, date: summary.date)
        if let stress = vector.subjectiveStress?.doubleValue { values["subj_stress"] = stress }
        if let energy = vector.subjectiveEnergy?.doubleValue { values["subj_energy"] = energy }
        if let sleepQuality = vector.subjectiveSleepQuality?.doubleValue { values["subj_sleepQuality"] = sleepQuality }
        if let sentiment = vector.sentiment?.doubleValue { values["sentiment"] = sentiment }

        for key in FeatureBundle.requiredKeys where values[key] == nil {
            values[key] = 0
        }

        return FeatureBundle(values: values, imputed: summary.imputed)
    }

    private static func apply(features: [String: Double], to vector: FeatureVector) {
        vector.zHrv = NSNumber(value: features["z_hrv"] ?? 0)
        vector.zNocturnalHR = NSNumber(value: features["z_nocthr"] ?? 0)
        vector.zRestingHR = NSNumber(value: features["z_resthr"] ?? 0)
        vector.zSleepDebt = NSNumber(value: features["z_sleepDebt"] ?? 0)
        vector.zRespiratoryRate = NSNumber(value: features["z_rr"] ?? 0)
        vector.zSteps = NSNumber(value: features["z_steps"] ?? 0)
        vector.subjectiveStress = NSNumber(value: features["subj_stress"] ?? 0)
        vector.subjectiveEnergy = NSNumber(value: features["subj_energy"] ?? 0)
        vector.subjectiveSleepQuality = NSNumber(value: features["subj_sleepQuality"] ?? 0)
        vector.sentiment = NSNumber(value: features["sentiment"] ?? 0)
    }

    // MARK: - Persistence Helpers

    private static func fetchDailyMetrics(in context: NSManagedObjectContext, date: Date) throws -> DailyMetrics {
        let request = DailyMetrics.fetchRequest()
        request.predicate = NSPredicate(format: "date == %@", date as NSDate)
        request.fetchLimit = 1
        if let metrics = try context.fetch(request).first {
            return metrics
        }
        let metrics = DailyMetrics(context: context)
        metrics.date = date
        metrics.flags = Self.encodeFlags(DailyFlags())
        return metrics
    }

    private static func fetchOrCreateDailyMetrics(in context: NSManagedObjectContext, date: Date) -> DailyMetrics {
        let request = DailyMetrics.fetchRequest()
        request.predicate = NSPredicate(format: "date == %@", date as NSDate)
        request.fetchLimit = 1
        if let metrics = try? context.fetch(request).first {
            return metrics
        }
        let metrics = DailyMetrics(context: context)
        metrics.date = date
        metrics.flags = Self.encodeFlags(DailyFlags())
        return metrics
    }

    private static func fetchOrCreateFeatureVector(in context: NSManagedObjectContext, date: Date) throws -> FeatureVector {
        let request = FeatureVector.fetchRequest()
        request.predicate = NSPredicate(format: "date == %@", date as NSDate)
        request.fetchLimit = 1
        if let vector = try context.fetch(request).first {
            return vector
        }
        let vector = FeatureVector(context: context)
        vector.date = date
        return vector
    }

    private static func mutateFlags(_ metrics: DailyMetrics, mutate: (inout DailyFlags) -> Void) {
        var flags = Self.decodeFlags(from: metrics)
        mutate(&flags)
        metrics.flags = Self.encodeFlags(flags)
    }

    private static func decodeFlags(from metrics: DailyMetrics) -> DailyFlags {
        guard let payload = metrics.flags, let data = payload.data(using: .utf8) else { return DailyFlags() }
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        return (try? decoder.decode(DailyFlags.self, from: data)) ?? DailyFlags()
    }

    private static func encodeFlags(_ flags: DailyFlags) -> String {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        guard let data = try? encoder.encode(flags) else { return "{}" }
        return String(data: data, encoding: .utf8) ?? "{}"
    }

    private static func encodeFeatureMetadata(imputed: [String: Bool], contributions: [String: Double], wellbeing: Double) -> String? {
        let payload: [String: Any] = [
            "imputed": imputed,
            "contributions": contributions,
            "wellbeing": wellbeing
        ]
        guard let data = try? JSONSerialization.data(withJSONObject: payload, options: []) else { return nil }
        return String(data: data, encoding: .utf8)
    }

    private func notifySnapshotUpdate(for date: Date,
                                      reason: DiagnosticsSafeString = .stage("unknown", allowed: ["bootstrap", "warm_backfill", "full_backfill", "journal", "reprocess", "refresh", "unknown"])) {
        pendingSnapshotUpdate?.cancel()
        let center = notificationCenter
        let today = calendar.startOfDay(for: Date())
        let trace = diagnosticsTraceId
        pendingSnapshotUpdate = Task { [weak self, center, trace, today, date, reason] in
            do {
                try await Task.sleep(nanoseconds: 300_000_000)
            } catch {
                return
            }
            guard !Task.isCancelled else { return }
            center.post(name: .pulsumScoresUpdated,
                        object: nil,
                        userInfo: [AgentNotificationKeys.date: today])
            var fields: [String: DiagnosticsValue] = [
                "reason": .safeString(reason),
                "snapshot_day": .day(date)
            ]
            if let details = await self?.latestSnapshotDiagnostics() {
                if let day = details.dayString {
                    fields["latest_snapshot_day"] = .safeString(.metadata(day))
                }
                if let score = details.score {
                    fields["wellbeing_score"] = .double(score)
                }
                fields["placeholder"] = .bool(details.placeholder)
            }
            Diagnostics.log(level: .info,
                            category: .dataAgent,
                            name: "data.snapshot.published",
                            fields: fields,
                            traceId: trace)
        }
    }

    private func persistBackfillProgress() {
        backfillStore.saveState(backfillProgress)
    }

    func diagnosticsBackfillCounts() async -> (warmCompleted: Int, fullCompleted: Int) {
        let warmCount = backfillProgress.warmStartCompletedTypes.count
        let fullCount = backfillProgress.fullBackfillCompletedTypes.count
        return (warmCount, fullCount)
    }

    func latestSnapshotMetadata() async -> (dayString: String?, score: Double?) {
        let details = await latestSnapshotDiagnostics()
        return (details.dayString, details.score)
    }

    private func latestSnapshotDiagnostics() async -> (dayString: String?, score: Double?, placeholder: Bool) {
        do {
            if let snapshot = try await latestFeatureVector() {
                let day = DiagnosticsDayFormatter.dayString(from: snapshot.date)
                return (day, snapshot.wellbeingScore, SnapshotPlaceholder.isPlaceholder(snapshot))
            }
        } catch {
            return (nil, nil, false)
        }
        return (nil, nil, false)
    }

#if DEBUG
    func _testPublishSnapshotUpdate(for date: Date) {
        notifySnapshotUpdate(for: date)
    }
#endif

    private static func materializeFeatures(from vector: FeatureVector) -> FeatureBundle {
        var imputed: [String: Bool] = [:]
        if let payload = vector.imputedFlags,
           let data = payload.data(using: .utf8),
           let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
           let map = json["imputed"] as? [String: Bool] {
            imputed = map
        }

        let values: [String: Double] = [
            "z_hrv": vector.zHrv?.doubleValue ?? 0,
            "z_nocthr": vector.zNocturnalHR?.doubleValue ?? 0,
            "z_resthr": vector.zRestingHR?.doubleValue ?? 0,
            "z_sleepDebt": vector.zSleepDebt?.doubleValue ?? 0,
            "z_rr": vector.zRespiratoryRate?.doubleValue ?? 0,
            "z_steps": vector.zSteps?.doubleValue ?? 0,
            "subj_stress": vector.subjectiveStress?.doubleValue ?? 0,
            "subj_energy": vector.subjectiveEnergy?.doubleValue ?? 0,
            "subj_sleepQuality": vector.subjectiveSleepQuality?.doubleValue ?? 0,
            "sentiment": vector.sentiment?.doubleValue ?? 0
        ]
        return FeatureBundle(values: values, imputed: imputed)
    }

    private static func previousMetricValue(in context: NSManagedObjectContext,
                                            keyPath: String,
                                            before date: Date) throws -> Double? {
        let request = DailyMetrics.fetchRequest()
        request.predicate = NSPredicate(format: "date < %@", date as NSDate)
        request.sortDescriptors = [NSSortDescriptor(key: #keyPath(DailyMetrics.date), ascending: false)]
        request.fetchLimit = 1
        let metrics = try context.fetch(request)
        guard let number = (metrics.first?.value(forKey: keyPath) as? NSNumber) else { return nil }
        return number.doubleValue
    }

    private static func updateBaselines(in context: NSManagedObjectContext,
                                        summary: DailySummary,
                                        referenceDate: Date,
                                        windowDays: Int) throws -> [String: BaselineMath.RobustStats] {
        let stats = try computeBaselines(in: context, referenceDate: referenceDate, windowDays: windowDays)
        let latestValues: [String: Double?] = [
            "hrv": summary.hrv,
            "nocthr": summary.nocturnalHR,
            "resthr": summary.restingHR,
            "sleepDebt": summary.sleepDebtHours,
            "rr": summary.respiratoryRate,
            "steps": summary.stepCount
        ]

        for (metricKey, stat) in stats {
            let baseline = try fetchBaseline(in: context, metric: metricKey)
            baseline.metric = metricKey
            baseline.windowDays = Int16(windowDays)
            baseline.median = NSNumber(value: stat.median)
            baseline.mad = NSNumber(value: stat.mad)
            if let latest = latestValues[metricKey] ?? nil {
                let previous = baseline.ewma?.doubleValue
                let ewma = BaselineMath.ewma(previous: previous, newValue: latest)
                baseline.ewma = NSNumber(value: ewma)
            }
            baseline.updatedAt = referenceDate
        }

        return stats
    }

    private static func computeBaselines(in context: NSManagedObjectContext,
                                         referenceDate: Date,
                                         windowDays: Int) throws -> [String: BaselineMath.RobustStats] {
        let request = DailyMetrics.fetchRequest()
        request.predicate = NSPredicate(format: "date <= %@", referenceDate as NSDate)
        request.sortDescriptors = [NSSortDescriptor(key: #keyPath(DailyMetrics.date), ascending: false)]
        request.fetchLimit = windowDays
        let metrics = try context.fetch(request)

        func stats(_ keyPath: KeyPath<DailyMetrics, NSNumber?>) -> BaselineMath.RobustStats? {
            let values = metrics.compactMap { $0[keyPath: keyPath]?.doubleValue }
            return BaselineMath.robustStats(for: values)
        }

        var result: [String: BaselineMath.RobustStats] = [:]
        if let stats = stats(\DailyMetrics.hrvMedian) { result["hrv"] = stats }
        if let stats = stats(\DailyMetrics.nocturnalHRPercentile10) { result["nocthr"] = stats }
        if let stats = stats(\DailyMetrics.restingHR) { result["resthr"] = stats }
        if let stats = stats(\DailyMetrics.sleepDebt) { result["sleepDebt"] = stats }
        if let stats = stats(\DailyMetrics.respiratoryRate) { result["rr"] = stats }
        if let stats = stats(\DailyMetrics.steps) { result["steps"] = stats }
        return result
    }

    private static func fetchBaseline(in context: NSManagedObjectContext, metric: String) throws -> Baseline {
        let request = Baseline.fetchRequest()
        request.predicate = NSPredicate(format: "metric == %@", metric)
        request.fetchLimit = 1
        if let baseline = try context.fetch(request).first {
            return baseline
        }
        let baseline = Baseline(context: context)
        baseline.metric = metric
        baseline.windowDays = 0
        return baseline
    }

    private static func personalizedSleepNeedHours(context: NSManagedObjectContext,
                                                   referenceDate: Date,
                                                   latestActualHours: Double,
                                                   windowDays: Int) throws -> Double {
        let request = DailyMetrics.fetchRequest()
        request.predicate = NSPredicate(format: "date <= %@", referenceDate as NSDate)
        request.sortDescriptors = [NSSortDescriptor(key: #keyPath(DailyMetrics.date), ascending: false)]
        request.fetchLimit = windowDays
        let metrics = try context.fetch(request)
        let historical = metrics.compactMap { $0.totalSleepTime?.doubleValue }.map { $0 / 3600 }
        let defaultNeed = 7.5
        guard historical.count >= 7 else { return defaultNeed }
        let mean = historical.reduce(0, +) / Double(historical.count)
        return min(max(mean, defaultNeed - 0.75), defaultNeed + 0.75)
    }

    private static func sleepDebtHours(context: NSManagedObjectContext,
                                       personalNeed: Double,
                                       currentHours: Double?,
                                       referenceDate: Date,
                                       windowDays: Int,
                                       calendar: Calendar) throws -> Double? {
        guard let currentHours else { return nil }
        let start = calendar.date(byAdding: .day, value: -(windowDays - 1), to: referenceDate) ?? referenceDate
        let request = DailyMetrics.fetchRequest()
        request.predicate = NSPredicate(format: "date >= %@ AND date <= %@", start as NSDate, referenceDate as NSDate)
        request.sortDescriptors = [NSSortDescriptor(key: #keyPath(DailyMetrics.date), ascending: true)]
        let metrics = try context.fetch(request)
        var window = metrics.map { ($0.totalSleepTime?.doubleValue ?? 0) / 3600 }
        if metrics.last?.date != referenceDate {
            window.append(currentHours)
        }
        return window.map { max(0, personalNeed - $0) }.reduce(0, +)
    }

    private struct ScoreMetricDescriptor {
        let featureKey: String
        let displayName: String
        let kind: ScoreBreakdown.MetricDetail.Kind
        let order: Int
        let unit: String?
        let usesZScore: Bool
        let rawValueKey: String?
        let baselineKey: String?
        let rollingWindowDays: Int?
        let explanation: String
        let flagKeys: [String]

        func flagMessages(for flags: [String: Bool]) -> [String] {
            flagKeys.compactMap { key in
                guard flags[key] == true else { return nil }
                return DataAgent.flagMessages[key]
            }
        }
    }

    private static let scoreMetricDescriptors: [ScoreMetricDescriptor] = [
        ScoreMetricDescriptor(
            featureKey: "z_hrv",
            displayName: "Heart Rate Variability",
            kind: .objective,
            order: 0,
            unit: "ms",
            usesZScore: true,
            rawValueKey: "hrv",
            baselineKey: "hrv",
            rollingWindowDays: 30,
            explanation: "Median overnight SDNN. Higher values mean the autonomic nervous system is more recovered.",
            flagKeys: ["hrv", "sedentary_missing"]
        ),
        ScoreMetricDescriptor(
            featureKey: "z_nocthr",
            displayName: "Nocturnal Heart Rate",
            kind: .objective,
            order: 1,
            unit: "bpm",
            usesZScore: true,
            rawValueKey: "nocthr",
            baselineKey: "nocthr",
            rollingWindowDays: 30,
            explanation: "10th percentile of heart rate while asleep. Lower values indicate better overnight recovery.",
            flagKeys: ["nocturnalHR", "sedentary_missing"]
        ),
        ScoreMetricDescriptor(
            featureKey: "z_resthr",
            displayName: "Resting Heart Rate",
            kind: .objective,
            order: 2,
            unit: "bpm",
            usesZScore: true,
            rawValueKey: "resthr",
            baselineKey: "resthr",
            rollingWindowDays: 30,
            explanation: "Latest resting heart rate sample. Lower relative to baseline typically reflects parasympathetic dominance.",
            flagKeys: ["restingHR", "sedentary_missing"]
        ),
        ScoreMetricDescriptor(
            featureKey: "z_sleepDebt",
            displayName: "Sleep Debt",
            kind: .objective,
            order: 3,
            unit: "h",
            usesZScore: true,
            rawValueKey: "sleepDebt",
            baselineKey: "sleepDebt",
            rollingWindowDays: 7,
            explanation: "Cumulative sleep debt over the past 7 days vs your personalized sleep need.",
            flagKeys: ["sleep_low_confidence", "sleepDebt_missing"]
        ),
        ScoreMetricDescriptor(
            featureKey: "z_rr",
            displayName: "Respiratory Rate",
            kind: .objective,
            order: 4,
            unit: "breaths/min",
            usesZScore: true,
            rawValueKey: "rr",
            baselineKey: "rr",
            rollingWindowDays: 30,
            explanation: "Average sleeping respiratory rate. Stable values indicate steady recovery.",
            flagKeys: ["rr_missing"]
        ),
        ScoreMetricDescriptor(
            featureKey: "z_steps",
            displayName: "Steps",
            kind: .objective,
            order: 5,
            unit: "steps",
            usesZScore: true,
            rawValueKey: "steps",
            baselineKey: "steps",
            rollingWindowDays: 30,
            explanation: "Total steps captured today relative to your rolling baseline.",
            flagKeys: ["steps_missing", "steps_low_confidence"]
        ),
        ScoreMetricDescriptor(
            featureKey: "subj_stress",
            displayName: "Stress",
            kind: .subjective,
            order: 6,
            unit: "(1-7)",
            usesZScore: false,
            rawValueKey: nil,
            baselineKey: nil,
            rollingWindowDays: nil,
            explanation: "Self-reported stress level captured in today's pulse check.",
            flagKeys: []
        ),
        ScoreMetricDescriptor(
            featureKey: "subj_energy",
            displayName: "Energy",
            kind: .subjective,
            order: 7,
            unit: "(1-7)",
            usesZScore: false,
            rawValueKey: nil,
            baselineKey: nil,
            rollingWindowDays: nil,
            explanation: "Self-reported energy level from today's pulse check.",
            flagKeys: []
        ),
        ScoreMetricDescriptor(
            featureKey: "subj_sleepQuality",
            displayName: "Sleep Quality",
            kind: .subjective,
            order: 8,
            unit: "(1-7)",
            usesZScore: false,
            rawValueKey: nil,
            baselineKey: nil,
            rollingWindowDays: nil,
            explanation: "Perceived sleep quality for the prior night.",
            flagKeys: []
        ),
        ScoreMetricDescriptor(
            featureKey: "sentiment",
            displayName: "Journal Sentiment",
            kind: .sentiment,
            order: 9,
            unit: nil,
            usesZScore: false,
            rawValueKey: nil,
            baselineKey: nil,
            rollingWindowDays: nil,
            explanation: "On-device sentiment score from your latest journal entry (negative to positive).",
            flagKeys: []
        )
    ]

    private static let flagMessages: [String: String] = [
        "hrv": "HRV carried forward from a previous day because no fresh overnight samples were available.",
        "sedentary_missing": "No restful sedentary window detected today; fallbacks were used for recovery metrics.",
        "nocturnalHR": "No nocturnal heart rate samples during sleep; carried forward the last reliable value.",
        "restingHR": "Resting heart rate sample missing; reused the most recent reliable value.",
        "rr_missing": "Sleeping respiratory rate missing, so this signal is omitted today.",
        "steps_missing": "Step data unavailable; activity impact excluded from today's score.",
        "steps_low_confidence": "Very low step count (<500) flagged as low confidence.",
        "sleep_low_confidence": "Less than 3 hours of sleep recorded; sleep-related calculations are low confidence.",
        "sleepDebt_missing": "No sleep data available; sleep debt is omitted from today's score."
    ]

    private static func generalFlagMessages(for flags: [String: Bool]) -> [String] {
        let handledKeys = Set(scoreMetricDescriptors.flatMap { $0.flagKeys })
        return flags.compactMap { key, value in
            guard value, !handledKeys.contains(key) else { return nil }
            return flagMessages[key]
        }
    }
#if DEBUG
    func _testProcessQuantitySamples(_ samples: [HKQuantitySample], type: HKQuantityType) async throws {
        _ = try await processQuantitySamples(samples, type: type)
    }

    func _testProcessCategorySamples(_ samples: [HKCategorySample], type: HKCategoryType) async throws {
        _ = try await processCategorySamples(samples, type: type)
    }

    func _testReprocess(day: Date) async throws {
        try await reprocessDayInternal(day)
    }

    @discardableResult
    func _testUpdateEstimator(features: [String: Double], imputed: [String: Bool] = [:]) -> StateEstimatorSnapshot {
        let normalized = WellbeingModeling.normalize(features: features, imputedFlags: imputed)
        let target = WellbeingModeling.target(for: normalized)
        let snapshot = stateEstimator.update(features: normalized, target: target)
        persistEstimatorState(from: snapshot)
        return snapshot
    }

    func _testEstimatorState() -> StateEstimatorState {
        stateEstimator.persistedState(version: EstimatorStateStore.schemaVersion)
    }

    func _testBackfillProgress() -> BackfillProgress {
        backfillProgress
    }

    func _testRunFullBackfillNow(targetStartDate: Date? = nil, grantedTypes: Set<HKSampleType>? = nil) async {
        let today = calendar.startOfDay(for: Date())
        let target = targetStartDate ?? calendar.date(byAdding: .day, value: -(fullAnalysisWindowDays - 1), to: today) ?? today
        let types = grantedTypes ?? Set(requiredSampleTypes)
        await performBackgroundFullBackfill(grantedTypes: types, targetStartDate: target)
    }
#endif
}

enum WellbeingModeling {
    static let targetWeights: [String: Double] = [
        "z_hrv": 0.55,
        "z_nocthr": -0.4,
        "z_resthr": -0.35,
        "z_sleepDebt": -0.65,
        "z_steps": 0.32,
        "z_rr": -0.1,
        "subj_stress": -0.4,
        "subj_energy": 0.45,
        "subj_sleepQuality": 0.3,
        "sentiment": 0.22
    ]

    static func normalize(features: [String: Double], imputedFlags: [String: Bool]) -> [String: Double] {
        var normalized: [String: Double] = [:]
        for key in FeatureBundle.requiredKeys {
            let raw = features[key] ?? 0
            normalized[key] = normalizedValue(for: key, value: raw, imputedFlags: imputedFlags)
        }
        return normalized
    }

    static func target(for normalizedFeatures: [String: Double]) -> Double {
        var target = 0.0
        for (feature, weight) in targetWeights {
            target += weight * (normalizedFeatures[feature] ?? 0)
        }
        return clamp(target, limit: 2.5)
    }

    private static func normalizedValue(for key: String, value: Double, imputedFlags: [String: Bool]) -> Double {
        let adjusted = adjustForImputation(key: key, value: value, imputedFlags: imputedFlags)
        switch key {
        case let feature where feature.hasPrefix("z_"):
            return clamp(adjusted, limit: 3)
        case "subj_stress", "subj_energy", "subj_sleepQuality":
            let centered = (adjusted - 4.0) / 3.0
            return clamp(centered, limit: 1)
        case "sentiment":
            return clamp(adjusted, limit: 1)
        default:
            return adjusted
        }
    }

    private static func adjustForImputation(key: String, value: Double, imputedFlags: [String: Bool]) -> Double {
        var adjusted = value

        switch key {
        case "z_hrv", "z_nocthr", "z_resthr":
            if imputedFlags["sedentary_missing"] == true {
                adjusted *= 0.5
            }
        case "z_sleepDebt":
            if imputedFlags["sleep_low_confidence"] == true {
                adjusted = 0
            }
        case "z_rr":
            if imputedFlags["rr_missing"] == true {
                adjusted = 0
            }
        case "z_steps":
            if imputedFlags["steps_missing"] == true {
                adjusted = 0
            } else if imputedFlags["steps_low_confidence"] == true {
                adjusted *= 0.5
            }
        default:
            break
        }

        let missingKey = key.replacingOccurrences(of: "z_", with: "") + "_missing"
        if imputedFlags[missingKey] == true {
            adjusted = 0
        }

        return adjusted
    }

    private static func clamp(_ value: Double, limit: Double) -> Double {
        min(max(value, -limit), limit)
    }
}

// MARK: - Supporting Types

private struct FeatureBundle {
    static let requiredKeys: Set<String> = [
        "z_hrv",
        "z_nocthr",
        "z_resthr",
        "z_sleepDebt",
        "z_rr",
        "z_steps",
        "subj_stress",
        "subj_energy",
        "subj_sleepQuality",
        "sentiment"
    ]

    var values: [String: Double]
    var imputed: [String: Bool]
}

private struct FeatureComputation: Sendable {
    let date: Date
    let featureValues: [String: Double]
    let imputedFlags: [String: Bool]
    let featureVectorObjectID: NSManagedObjectID
}

private struct DailySummary {
    let date: Date
    let hrv: Double?
    let nocturnalHR: Double?
    let restingHR: Double?
    let totalSleepSeconds: Double?
    let sleepNeedHours: Double
    let sleepDebtHours: Double?
    let respiratoryRate: Double?
    let stepCount: Double?
    let updatedFlags: DailyFlags
    let imputed: [String: Bool]
}

private struct DailyFlags: Codable {
    var aggregatedStepTotal: Double?
    var aggregatedNocturnalAverage: Double?
    var aggregatedNocturnalMin: Double?
    var aggregatedSleepDurationSeconds: Double?
    var hrvSamples: [HRVSample] = []
    var heartRateSamples: [HeartRateSample] = []
    var respiratorySamples: [RespiratorySample] = []
    var sleepSegments: [SleepSegment] = []
    var stepBuckets: [StepBucket] = []

    mutating func append(quantitySample sample: HKQuantitySample, type: HKQuantityType) {
        switch type.identifier {
        case HKQuantityTypeIdentifier.heartRateVariabilitySDNN.rawValue:
            hrvSamples.append(HRVSample(sample))
            hrvSamples.trim(to: 512)
        case HKQuantityTypeIdentifier.heartRate.rawValue:
            heartRateSamples.append(HeartRateSample(sample))
            heartRateSamples.trim(to: 4096)
        case HKQuantityTypeIdentifier.restingHeartRate.rawValue:
            heartRateSamples.append(HeartRateSample(sample, context: .resting))
            heartRateSamples.trim(to: 4096)
        case HKQuantityTypeIdentifier.respiratoryRate.rawValue:
            respiratorySamples.append(RespiratorySample(sample))
            respiratorySamples.trim(to: 512)
        case HKQuantityTypeIdentifier.stepCount.rawValue:
            stepBuckets.append(StepBucket(sample))
            stepBuckets.trim(to: 4096)
        default:
            break
        }
    }

    mutating func append(sleepSample sample: HKCategorySample) -> Bool {
        let segment = SleepSegment(sample)
        guard !sleepSegments.contains(where: { $0.id == segment.id }) else { return false }
        sleepSegments.append(segment)
        sleepSegments.trim(to: 256)
        if segment.stage.isAsleep {
            aggregatedSleepDurationSeconds = (aggregatedSleepDurationSeconds ?? 0) + segment.duration
        }
        return true
    }

    mutating func removeSample(with uuid: UUID) {
        hrvSamples.removeAll { $0.id == uuid }
        heartRateSamples.removeAll { $0.id == uuid }
        respiratorySamples.removeAll { $0.id == uuid }
        sleepSegments.removeAll { $0.id == uuid }
        stepBuckets.removeAll { $0.id == uuid }
    }

    mutating func pruneDeletedSamples(_ identifiers: Set<UUID>) -> Bool {
        let originalCounts = (hrvSamples.count, heartRateSamples.count, respiratorySamples.count, sleepSegments.count, stepBuckets.count)
        hrvSamples.removeAll { identifiers.contains($0.id) }
        heartRateSamples.removeAll { identifiers.contains($0.id) }
        respiratorySamples.removeAll { identifiers.contains($0.id) }
        sleepSegments.removeAll { identifiers.contains($0.id) }
        stepBuckets.removeAll { identifiers.contains($0.id) }
        let updatedCounts = (hrvSamples.count, heartRateSamples.count, respiratorySamples.count, sleepSegments.count, stepBuckets.count)
        return originalCounts != updatedCounts
    }

    // Computations
    func sleepIntervals() -> [DateInterval] {
        sleepSegments
            .filter { $0.stage.isAsleep }
            .map { DateInterval(start: $0.start, end: $0.end) }
    }

    func sedentaryIntervals(thresholdStepsPerHour: Double,
                            minimumDuration: TimeInterval,
                            excluding sleep: [DateInterval]) -> [DateInterval] {
        guard !stepBuckets.isEmpty else { return [] }
        let sorted = stepBuckets.sorted { $0.start < $1.start }
        var intervals: [DateInterval] = []
        var currentStart: Date?
        var currentEnd: Date?
        var totalSteps: Double = 0

        func finalize() {
            guard let start = currentStart, let end = currentEnd else { return }
            let duration = end.timeIntervalSince(start)
            guard duration >= minimumDuration else { reset() ; return }
            let stepsPerHour = totalSteps / max(duration / 3600, 0.001)
            guard stepsPerHour <= thresholdStepsPerHour else { reset(); return }
            let candidate = DateInterval(start: start, end: end)
            if !candidate.intersectsAny(of: sleep) {
                intervals.append(candidate)
            }
            reset()
        }

        func reset() {
            currentStart = nil
            currentEnd = nil
            totalSteps = 0
        }

        var previousEnd: Date?
        for bucket in sorted {
            if currentStart == nil { currentStart = bucket.start }
            if let prev = previousEnd, bucket.start.timeIntervalSince(prev) > 300 {
                finalize()
                currentStart = bucket.start
            }
            previousEnd = bucket.end
            currentEnd = max(currentEnd ?? bucket.end, bucket.end)
            totalSteps += bucket.steps
        }
        finalize()
        return intervals
    }

    func sleepDurations() -> Double? {
        if let aggregatedSleepDurationSeconds {
            return aggregatedSleepDurationSeconds
        }
        let asleep = sleepSegments.filter { $0.stage.isAsleep }
        guard !asleep.isEmpty else { return nil }
        return asleep.reduce(0) { $0 + $1.duration }
    }

    func medianHRV(in intervals: [DateInterval],
                   fallback: [DateInterval],
                   previous: Double?,
                   imputed: inout [String: Bool]) -> Double? {
        if let median = median(samples: hrvSamples, within: intervals) {
            return median
        }
        if let median = median(samples: hrvSamples, within: fallback) {
            return median
        }
        if let previous { imputed["hrv"] = true; return previous }
        return nil
    }

    func nocturnalHeartRate(in intervals: [DateInterval],
                            fallback: [DateInterval],
                            previous: Double?,
                            imputed: inout [String: Bool]) -> Double? {
        if let aggregatedNocturnalAverage {
            return aggregatedNocturnalAverage
        }
        if let percentile = percentile(samples: heartRateSamples, within: intervals, percentile: 0.10) {
            return percentile
        }
        if let percentile = percentile(samples: heartRateSamples, within: fallback, percentile: 0.10) {
            return percentile
        }
        if let previous { imputed["nocturnalHR"] = true; return previous }
        return nil
    }

    func restingHeartRate(fallback: [DateInterval],
                          previous: Double?,
                          imputed: inout [String: Bool]) -> Double? {
        if let latest = heartRateSamples.last(where: { $0.context == .resting }) {
            return latest.value
        }
        if let average = average(samples: heartRateSamples, within: fallback) {
            return average
        }
        if let previous { imputed["restingHR"] = true; return previous }
        return nil
    }

    func averageRespiratoryRate(in intervals: [DateInterval]) -> Double? {
        guard !respiratorySamples.isEmpty else { return nil }
        if intervals.isEmpty { return respiratorySamples.map { $0.value }.mean }
        let filtered = respiratorySamples.filter { sample in intervals.contains { $0.contains(sample.time) } }
        guard !filtered.isEmpty else { return nil }
        return filtered.map { $0.value }.mean
    }

    func totalSteps() -> Double? {
        if let aggregatedStepTotal {
            return aggregatedStepTotal
        }
        guard !stepBuckets.isEmpty else { return nil }
        return stepBuckets.reduce(0) { $0 + $1.steps }
    }

    // MARK: - Statistics helpers

    private func median<T: TimedSample>(samples: [T], within intervals: [DateInterval]) -> Double? {
        guard !samples.isEmpty else { return nil }
        let filtered = samples.filter { sample in intervals.contains { $0.contains(sample.time) } }
        guard !filtered.isEmpty else { return nil }
        let values = filtered.map { $0.value }.sorted()
        let mid = values.count / 2
        if values.count % 2 == 0 { return (values[mid - 1] + values[mid]) / 2 }
        return values[mid]
    }

    private func percentile<T: TimedSample>(samples: [T], within intervals: [DateInterval], percentile: Double) -> Double? {
        guard !samples.isEmpty else { return nil }
        let filtered = samples.filter { sample in intervals.contains { $0.contains(sample.time) } }
        guard !filtered.isEmpty else { return nil }
        let sorted = filtered.map { $0.value }.sorted()
        let index = max(0, Int(Double(sorted.count - 1) * percentile))
        return sorted[index]
    }

    private func average<T: TimedSample>(samples: [T], within intervals: [DateInterval]) -> Double? {
        guard !samples.isEmpty else { return nil }
        let filtered = samples.filter { sample in intervals.contains { $0.contains(sample.time) } }
        guard !filtered.isEmpty else { return nil }
        return filtered.map { $0.value }.mean
    }
}

// MARK: - Sample Models

private protocol TimedSample {
    var id: UUID { get }
    var time: Date { get }
    var value: Double { get }
}

private struct HRVSample: Codable, TimedSample {
    let id: UUID
    let time: Date
    let value: Double

    init(_ sample: HKQuantitySample) {
        id = sample.uuid
        time = sample.startDate
        value = sample.quantity.doubleValue(for: HKUnit.secondUnit(with: .milli))
    }
}

private struct HeartRateSample: Codable, TimedSample {
    enum Context: String, Codable { case normal, resting }
    let id: UUID
    let time: Date
    let value: Double
    let context: Context

    init(_ sample: HKQuantitySample, context: Context = .normal) {
        id = sample.uuid
        time = sample.startDate
        value = sample.quantity.doubleValue(for: HKUnit.count().unitDivided(by: HKUnit.minute()))
        self.context = context
    }
}

private struct RespiratorySample: Codable, TimedSample {
    let id: UUID
    let time: Date
    let value: Double

    init(_ sample: HKQuantitySample) {
        id = sample.uuid
        time = sample.startDate
        value = sample.quantity.doubleValue(for: HKUnit.count().unitDivided(by: HKUnit.minute()))
    }
}

private struct SleepSegment: Codable {
    enum Stage: String, Codable {
        case inBed
        case asleepCore
        case asleepDeep
        case asleepREM
        case asleepUnspecified
        case awake

        var isAsleep: Bool {
            switch self {
            case .asleepCore, .asleepDeep, .asleepREM, .asleepUnspecified:
                return true
            default:
                return false
            }
        }
    }

    let id: UUID
    let start: Date
    let end: Date
    let stage: Stage

    var duration: TimeInterval { max(0, end.timeIntervalSince(start)) }

    init(_ sample: HKCategorySample) {
        id = sample.uuid
        start = sample.startDate
        end = sample.endDate
        let value = HKCategoryValueSleepAnalysis(rawValue: sample.value) ?? .inBed
        switch value {
        case .inBed: stage = .inBed
        case .asleepUnspecified: stage = .asleepUnspecified
        case .awake: stage = .awake
        case .asleepCore: stage = .asleepCore
        case .asleepDeep: stage = .asleepDeep
        case .asleepREM: stage = .asleepREM
        @unknown default: stage = .asleepUnspecified
        }
    }
}

private struct StepBucket: Codable {
    let id: UUID
    let start: Date
    let end: Date
    let steps: Double

    init(_ sample: HKQuantitySample) {
        id = sample.uuid
        start = sample.startDate
        end = sample.endDate
        steps = sample.quantity.doubleValue(for: HKUnit.count())
    }
}

// MARK: - Utilities

private extension Array {
    mutating func trim(to limit: Int) {
        guard count > limit else { return }
        removeFirst(count - limit)
    }
}

private extension Array where Element == Double {
    var mean: Double {
        guard !isEmpty else { return 0 }
        return reduce(0, +) / Double(count)
    }
}

private extension Array where Element == DateInterval {
    func contains(where predicate: (DateInterval) -> Bool) -> Bool {
        for interval in self where predicate(interval) { return true }
        return false
    }

    func contains(_ date: Date) -> Bool {
        contains { $0.contains(date) }
    }

    func intersectsAny(of other: [DateInterval]) -> Bool {
        for interval in self {
            if other.contains(where: { $0.intersects(interval) }) { return true }
        }
        return false
    }
}

private extension DateInterval {
    func intersectsAny(of intervals: [DateInterval]) -> Bool {
        intervals.contains { $0.intersects(self) }
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/DataAgent.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/EstimatorStateStore.swift
- bytes: 3955
- lines: 103
- sha256: 89b47e2d8e547a66b4291149bfb0457db11fd0458557e0ff900384b4249b5cd9
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/EstimatorStateStore.swift -->
```swift
import Foundation
import os.log
import PulsumData
import PulsumML

protocol EstimatorStateStoring: Sendable {
    func loadState() -> StateEstimatorState?
    func saveState(_ state: StateEstimatorState)
}

final class EstimatorStateStore: EstimatorStateStoring, @unchecked Sendable {
    static let schemaVersion = 1

    private let fileURL: URL
    private let fileManager: FileManager
    private let logger = Logger(subsystem: "ai.pulsum", category: "EstimatorStateStore")
    private func logError(_ message: String, error: Error) {
        let nsError = error as NSError
        logger.error("\(message) domain=\(nsError.domain, privacy: .public) code=\(nsError.code, privacy: .public)")
    }

    init(baseDirectory: URL = PulsumData.applicationSupportDirectory,
         fileManager: FileManager = .default) {
        self.fileManager = fileManager
        let directory = baseDirectory.appendingPathComponent("EstimatorState", isDirectory: true)
        self.fileURL = directory.appendingPathComponent("state_v\(Self.schemaVersion).json")
        prepareDirectory(at: directory)
    }

    func loadState() -> StateEstimatorState? {
        guard fileManager.fileExists(atPath: fileURL.path) else { return nil }
        do {
            let data = try Data(contentsOf: fileURL)
            let state = try JSONDecoder().decode(StateEstimatorState.self, from: data)
            guard state.version == Self.schemaVersion else {
                logger.warning("Estimator state version mismatch. Expected \(Self.schemaVersion), found \(state.version). Ignoring persisted state.")
                return nil
            }
            return state
        } catch {
            logError("Failed to load estimator state.", error: error)
            return nil
        }
    }

    func saveState(_ state: StateEstimatorState) {
        guard state.version == Self.schemaVersion else {
            logger.error("Refusing to persist estimator state: version mismatch (expected \(Self.schemaVersion), found \(state.version)).")
            return
        }
        do {
            let data = try JSONEncoder().encode(state)
            try data.write(to: fileURL, options: .atomic)
            applyFileProtection()
            excludeFromBackup()
        } catch {
            logError("Failed to persist estimator state.", error: error)
        }
    }

    private func prepareDirectory(at url: URL) {
        if !fileManager.fileExists(atPath: url.path) {
            do {
                #if os(iOS)
                try fileManager.createDirectory(at: url, withIntermediateDirectories: true, attributes: [.protectionKey: FileProtectionType.complete])
                #else
                try fileManager.createDirectory(at: url, withIntermediateDirectories: true, attributes: nil)
                #endif
            } catch {
                logError("Failed to prepare estimator state directory.", error: error)
            }
        } else {
            #if os(iOS)
            do {
                try fileManager.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: url.path)
            } catch {
                logError("Failed to update estimator state directory protection.", error: error)
            }
            #endif
        }
    }

    private func applyFileProtection() {
        #if os(iOS)
        do {
            try fileManager.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: fileURL.path)
        } catch {
            logError("Failed to set file protection on estimator state.", error: error)
        }
        #endif
    }

    private func excludeFromBackup() {
        var values = URLResourceValues()
        values.isExcludedFromBackup = true
        var mutableURL = fileURL
        do {
            try mutableURL.setResourceValues(values)
        } catch {
            logError("Failed to mark estimator state as backup-excluded.", error: error)
        }
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/EstimatorStateStore.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/HealthAccessStatus.swift
- bytes: 1451
- lines: 43
- sha256: 801cd606dc84e0c00c7b7838963230e4822949ea3d26985eb60f9ec1449c6a9f
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/HealthAccessStatus.swift -->
```swift
import Foundation
@preconcurrency import HealthKit

/// Consolidated authorization surface for Pulsum's HealthKit ingestion.
/// `HKSampleType` is not marked `Sendable`, so the struct uses `@unchecked Sendable`.
public struct HealthAccessStatus: @unchecked Sendable {
    public enum Availability: Equatable, Sendable {
        case available
        case unavailable(reason: String)
    }

    public let required: [HKSampleType]
    public let granted: Set<HKSampleType>
    public let denied: Set<HKSampleType>
    public let notDetermined: Set<HKSampleType>
    public let availability: Availability
    public let timestamp: Date

    public init(required: [HKSampleType],
                granted: Set<HKSampleType>,
                denied: Set<HKSampleType>,
                notDetermined: Set<HKSampleType>,
                availability: Availability,
                timestamp: Date = Date()) {
        self.required = required
        self.granted = granted
        self.denied = denied
        self.notDetermined = notDetermined
        self.availability = availability
        self.timestamp = timestamp
    }

    public var grantedCount: Int { granted.count }
    public var totalRequired: Int { required.count }

    public var missingTypes: [HKSampleType] {
        Array(denied) + Array(notDetermined)
    }

    public var isFullyGranted: Bool {
        availability == .available && missingTypes.isEmpty && !required.isEmpty
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/HealthAccessStatus.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/PulsumAgents.swift
- bytes: 855
- lines: 37
- sha256: 919b178b1f5e8efd91958bce82d3fd0b7cbf9e36a67258fca205719d9ebf58ca
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/PulsumAgents.swift -->
```swift
import Foundation
#if canImport(FoundationModels)
import FoundationModels
#endif
import PulsumData
import PulsumServices
import PulsumML

public enum PulsumAgents {
    @MainActor
    public static func makeOrchestrator() throws -> AgentOrchestrator {
        try AgentOrchestrator()
    }

    public static func healthCheck() -> Bool {
        let metadata = PulsumServices.storageMetadata()
        return !metadata.storeURL.path.isEmpty && !metadata.anchorsDirectory.path.isEmpty
    }
    
    public static func foundationModelsStatus() -> String {
        if #available(iOS 26.0, *) {
            let status = FoundationModelsAvailability.checkAvailability()
            return FoundationModelsAvailability.availabilityMessage(for: status)
        } else {
            return "Foundation Models require iOS 26 or later."
        }
    }
}









```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/PulsumAgents.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/RecRankerStateStore.swift
- bytes: 3865
- lines: 103
- sha256: 1fac4bceec7716b914eac72afd961e5f51cfad4f92cc63350a37b74a3356686e
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/RecRankerStateStore.swift -->
```swift
import Foundation
import os.log
import PulsumData
import PulsumML

public protocol RecRankerStateStoring: Sendable {
    func loadState() -> RecRankerState?
    func saveState(_ state: RecRankerState)
}

public final class RecRankerStateStore: RecRankerStateStoring, @unchecked Sendable {
    public static let schemaVersion = 1

    private let fileURL: URL
    private let fileManager: FileManager
    private let logger = Logger(subsystem: "ai.pulsum", category: "RecRankerStateStore")
    private func logError(_ message: String, error: Error) {
        let nsError = error as NSError
        logger.error("\(message) domain=\(nsError.domain, privacy: .public) code=\(nsError.code, privacy: .public)")
    }

    public init(baseDirectory: URL = PulsumData.applicationSupportDirectory,
                fileManager: FileManager = .default) {
        self.fileManager = fileManager
        let directory = baseDirectory.appendingPathComponent("RecRankerState", isDirectory: true)
        self.fileURL = directory.appendingPathComponent("state_v\(Self.schemaVersion).json")
        prepareDirectory(at: directory)
    }

    public func loadState() -> RecRankerState? {
        guard fileManager.fileExists(atPath: fileURL.path) else { return nil }
        do {
            let data = try Data(contentsOf: fileURL)
            let state = try JSONDecoder().decode(RecRankerState.self, from: data)
            guard state.version == Self.schemaVersion else {
                logger.warning("RecRanker state version mismatch. Expected \(Self.schemaVersion), found \(state.version).")
                return nil
            }
            return state
        } catch {
            logError("Failed to load RecRanker state.", error: error)
            return nil
        }
    }

    public func saveState(_ state: RecRankerState) {
        guard state.version == Self.schemaVersion else {
            logger.error("Refusing to persist RecRanker state: version mismatch (expected \(Self.schemaVersion), found \(state.version)).")
            return
        }
        do {
            let data = try JSONEncoder().encode(state)
            try data.write(to: fileURL, options: .atomic)
            applyFileProtection()
            excludeFromBackup()
        } catch {
            logError("Failed to persist RecRanker state.", error: error)
        }
    }

    private func prepareDirectory(at url: URL) {
        if !fileManager.fileExists(atPath: url.path) {
            do {
#if os(iOS)
                try fileManager.createDirectory(at: url, withIntermediateDirectories: true, attributes: [.protectionKey: FileProtectionType.complete])
#else
                try fileManager.createDirectory(at: url, withIntermediateDirectories: true, attributes: nil)
#endif
            } catch {
                logError("Failed to prepare RecRanker state directory.", error: error)
            }
        } else {
#if os(iOS)
            do {
                try fileManager.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: url.path)
            } catch {
                logError("Failed to update RecRanker state directory protection.", error: error)
            }
#endif
        }
    }

    private func applyFileProtection() {
#if os(iOS)
        do {
            try fileManager.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: fileURL.path)
        } catch {
            logError("Failed to set file protection on RecRanker state.", error: error)
        }
#endif
    }

    private func excludeFromBackup() {
        var values = URLResourceValues()
        values.isExcludedFromBackup = true
        var mutableURL = fileURL
        do {
            try mutableURL.setResourceValues(values)
        } catch {
            logError("Failed to mark RecRanker state as backup-excluded.", error: error)
        }
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/RecRankerStateStore.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/SafetyAgent.swift
- bytes: 3376
- lines: 90
- sha256: d836951ecc30e3d38c29a3e344ceb67dc6cf5c1a40d0b3e6ae1b5acc64bcb8c4
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/SafetyAgent.swift -->
```swift
import Foundation
#if canImport(FoundationModels)
import FoundationModels
#endif
import PulsumML
import PulsumTypes

@MainActor
public final class SafetyAgent {
    private let foundationModelsProvider: Any?
    private let fallbackClassifier = SafetyLocal()
    private let crisisKeywords: [String] = [
        "suicide",
        "kill myself",
        "end my life",
        "not worth living",
        "better off dead"
    ]

    public init() {
        if #available(iOS 26.0, *) {
            self.foundationModelsProvider = FoundationModelsSafetyProvider()
        } else {
            self.foundationModelsProvider = nil
        }
    }

    public func evaluate(text: String) async -> SafetyDecision {
        // Try Foundation Models classification first
        if #available(iOS 26.0, *),
           let provider = foundationModelsProvider as? FoundationModelsSafetyProvider {
            do {
                let result = try await provider.classify(text: text)
                let lowered = text.lowercased()
                let adjusted: SafetyClassification
                if case .crisis = result,
                   !crisisKeywords.contains(where: lowered.contains) {
                    adjusted = .caution(reason: "Seeking help (no self-harm language)")
                } else {
                    adjusted = result
                }
                let decision = makeDecision(from: adjusted)
                Diagnostics.log(level: .info,
                                category: .safety,
                                name: "safety.fm.classification",
                                fields: [
                                    "classification": .safeString(.metadata("\(adjusted)")),
                                    "allow_cloud": .bool(decision.allowCloud)
                                ])
                return decision
            } catch {
                Diagnostics.log(level: .warn,
                                category: .safety,
                                name: "safety.fm.error",
                                fields: [:],
                                error: error)
                // Fall back to existing classifier
            }
        }

        // Use existing SafetyLocal as fallback
        let result = fallbackClassifier.classify(text: text)
        let decision = makeDecision(from: result)
        Diagnostics.log(level: .info,
                        category: .safety,
                        name: "safety.local.classification",
                        fields: [
                            "classification": .safeString(.metadata("\(result)")),
                            "allow_cloud": .bool(decision.allowCloud)
                        ])
        return decision
    }

    private func makeDecision(from classification: SafetyClassification) -> SafetyDecision {
        let allowCloud: Bool
        let crisisMessage: String?
        switch classification {
        case .safe:
            allowCloud = true
            crisisMessage = nil
        case .caution:
            allowCloud = false
            crisisMessage = nil
        case .crisis:
            allowCloud = false
            crisisMessage = "If you're in the United States, call 911 right away."
        }
        return SafetyDecision(classification: classification, allowCloud: allowCloud, crisisMessage: crisisMessage)
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/SafetyAgent.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/SentimentAgent.swift
- bytes: 15832
- lines: 385
- sha256: ae3e6bad41f285e7c916f3c6996c82a9cb55a9fde6e932ab7e91e5129f9727cb
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/SentimentAgent.swift -->
```swift
import Foundation
import CoreData
#if canImport(FoundationModels)
import FoundationModels
#endif
import os
import PulsumData
import PulsumML
import PulsumServices
import PulsumTypes

public enum SentimentAgentError: LocalizedError {
    case noActiveRecording
    case noSpeechDetected
    case sessionAlreadyActive
    
    public var errorDescription: String? {
        switch self {
        case .noActiveRecording:
            return "No active recording session found."
        case .noSpeechDetected:
            return "No speech detected. Please try again and speak clearly."
        case .sessionAlreadyActive:
            return "A recording is already in progress."
        }
    }
}

public final class SentimentAgent {
    private let speechService: SpeechService
    private let embeddingService: EmbeddingService
    private let context: NSManagedObjectContext
    private let calendar = Calendar(identifier: .gregorian)
    private let sentimentService: SentimentService
    private let sessionState = JournalSessionState()
    private let logger = Logger(subsystem: "com.pulsum", category: "SentimentAgent")
    
    public var audioLevels: AsyncStream<Float>? {
        sessionState.audioLevels
    }
    
    public var speechStream: AsyncThrowingStream<SpeechSegment, Error>? {
        sessionState.speechStream
    }

    public init(speechService: SpeechService = SpeechService(),
                container: NSPersistentContainer = PulsumData.container,
                sentimentService: SentimentService = SentimentService(),
                embeddingService: EmbeddingService = .shared) {
        self.speechService = speechService
        self.sentimentService = sentimentService
        self.embeddingService = embeddingService
        self.context = container.newBackgroundContext()
        self.context.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
        self.context.name = "Pulsum.SentimentAgent.FoundationModels"
    }

    public func requestAuthorization() async throws {
        try await speechService.requestAuthorization()
    }

    /// Begins voice journal recording and returns immediately after starting audio capture.
    /// Audio levels and speech stream become available synchronously via properties.
    /// The caller should consume the speech stream to get real-time transcription.
    /// Call `finishVoiceJournal(transcript:)` to complete recording and persist the result.
    public func beginVoiceJournal(maxDuration: TimeInterval = 30) async throws {
        try await speechService.requestAuthorization()
        let session = try await speechService.startRecording(maxDuration: min(maxDuration, 30))
        do {
            try sessionState.begin(with: session)
        } catch {
            session.stop()
            throw error
        }
    }
    
    /// Updates the latest transcript. Called by the UI as it consumes the speech stream.
    public func updateTranscript(_ transcript: String) {
        sessionState.updateTranscript(transcript)
    }
    
    /// Completes the voice journal recording that was started with `beginVoiceJournal()`.
    /// Uses the provided transcript (from consuming the speech stream) to persist the journal.
    /// Returns the persisted journal result with transcript and sentiment.
    public func finishVoiceJournal(transcript: String? = nil) async throws -> JournalResult {
        guard let (session, cachedTranscript) = sessionState.takeSession() else {
            throw SentimentAgentError.noActiveRecording
        }
        
        defer { session.stop() }
        
        // Use provided transcript or fall back to stored transcript
        let finalTranscript = transcript ?? cachedTranscript
        
        // Check for empty transcript
        let trimmed = finalTranscript.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else {
            throw SentimentAgentError.noSpeechDetected
        }
        
        return try await persistJournal(transcript: trimmed)
    }

    /// Legacy method that combines begin + finish for backward compatibility
    public func recordVoiceJournal(maxDuration: TimeInterval = 30) async throws -> JournalResult {
        try await beginVoiceJournal(maxDuration: maxDuration)
        
        // Consume the speech stream to get the transcript
        var transcript = ""
        if let stream = speechStream {
            do {
                for try await segment in stream {
                    transcript = segment.transcript
                    sessionState.updateTranscript(transcript)
                }
            } catch {
                sessionState.stopActiveSession()
                throw error
            }
        }
        
        return try await finishVoiceJournal(transcript: transcript)
    }

    public func stopRecording() {
        sessionState.stopActiveSession()
    }

    func latestTranscriptSnapshot() -> String {
        sessionState.latestTranscriptSnapshot()
    }

    public func importTranscript(_ transcript: String) async throws -> JournalResult {
        try await persistJournal(transcript: transcript)
    }

    public func pendingEmbeddingCount() async -> Int {
        await context.perform { @Sendable [context] in
            let request = JournalEntry.fetchRequest()
            request.predicate = NSPredicate(format: "embeddedVectorURL == nil")
            return (try? context.count(for: request)) ?? 0
        }
    }

    public func reprocessPendingJournals(traceId: UUID? = nil) async {
        let pending: [(objectID: NSManagedObjectID, entryID: UUID, transcript: String)] = (try? await context.perform { @Sendable [context] in
            let request = JournalEntry.fetchRequest()
            request.predicate = NSPredicate(format: "embeddedVectorURL == nil")
            return try context.fetch(request).map { entry in
                (entry.objectID, entry.id, entry.transcript)
            }
        }) ?? []

        guard !pending.isEmpty else { return }

        let monitor = DiagnosticsStallMonitor(category: .sentiment,
                                              name: "sentiment.reprocessPending",
                                              traceId: traceId,
                                              thresholdSeconds: 30,
                                              initialFields: ["pending_count": .int(pending.count)])
        await monitor.start()
        Diagnostics.log(level: .info,
                        category: .sentiment,
                        name: "sentiment.reprocessPending.begin",
                        fields: ["pending_count": .int(pending.count)],
                        traceId: traceId)

        var updates: [(objectID: NSManagedObjectID, vectorURL: URL)] = []
        var succeeded = 0
        var failed = 0

        for item in pending {
            do {
                let vector = try embeddingService.embedding(for: item.transcript)
                let url = try persistVector(vector: vector, id: item.entryID)
                updates.append((objectID: item.objectID, vectorURL: url))
                succeeded += 1
            } catch {
                failed += 1
                Diagnostics.log(level: .warn,
                                category: .sentiment,
                                name: "sentiment.embedding.pending",
                                fields: [
                                    "pending_count": .int(pending.count),
                                    "succeeded": .int(succeeded),
                                    "failed": .int(failed)
                                ],
                                traceId: traceId,
                                error: error)
#if DEBUG
                logger.error("Failed to reprocess pending journal embedding: \(error.localizedDescription, privacy: .public)")
#endif
            }
            await monitor.heartbeat(progressFields: ["succeeded": .int(succeeded), "failed": .int(failed)])
        }

        guard !updates.isEmpty else { return }
        let updatesToApply = updates

        do {
            try await context.perform { @Sendable [context] in
                for update in updatesToApply {
                    guard let entry = try? context.existingObject(with: update.objectID) as? JournalEntry else { continue }
                    entry.embeddedVectorURL = update.vectorURL.lastPathComponent
                    entry.sensitiveFlags = SentimentAgent.encodeSensitiveFlags(embeddingPending: false)
                }
                if context.hasChanges {
                    try context.save()
                }
            }
        } catch {
#if DEBUG
            logger.error("Failed to save reprocessed journal embeddings: \(error.localizedDescription, privacy: .public)")
#endif
        }

        await monitor.stop(finalFields: ["succeeded": .int(succeeded), "failed": .int(failed)])
        Diagnostics.log(level: .info,
                        category: .sentiment,
                        name: "sentiment.reprocessPending.end",
                        fields: [
                            "pending_count": .int(pending.count),
                            "succeeded": .int(succeeded),
                            "failed": .int(failed)
                        ],
                        traceId: traceId)
    }

    private func persistJournal(transcript: String) async throws -> JournalResult {
        let sanitized = PIIRedactor.redact(transcript)
        let charCount = sanitized.count
        let span = Diagnostics.span(category: .sentiment,
                                    name: "sentiment.persistJournal",
                                    fields: [
                                        "transcript_chars": .int(charCount)
                                    ])
        
        // Use async Foundation Models sentiment analysis
        let sentiment = await sentimentService.sentiment(for: sanitized)

        let entryID = UUID()
        var vectorURL: URL?
        var embeddingPending = false

        do {
            let vector = try embeddingService.embedding(for: sanitized)
            do {
                vectorURL = try persistVector(vector: vector, id: entryID)
            } catch {
                embeddingPending = true
#if DEBUG
                logger.error("Failed to persist journal embedding: \(error.localizedDescription, privacy: .public)")
#endif
                Diagnostics.log(level: .warn,
                                category: .sentiment,
                                name: "sentiment.embedding.pending",
                                fields: [
                                    "pending": .bool(true),
                                    "transcript_chars": .int(charCount)
                                ],
                                error: error)
            }
        } catch {
            embeddingPending = true
#if DEBUG
            logger.error("Embedding unavailable for journal: \(error.localizedDescription, privacy: .public)")
#endif
            Diagnostics.log(level: .warn,
                            category: .sentiment,
                            name: "sentiment.embedding.pending",
                            fields: [
                                "pending": .bool(true),
                                "transcript_chars": .int(charCount)
                            ],
                            error: error)
        }

        let pendingFlag = embeddingPending
        let finalVectorURL = vectorURL

        let result = try await context.perform { @Sendable [context, calendar] () throws -> JournalResult in
            let entry = JournalEntry(context: context)
            entry.id = entryID
            entry.date = Date()
            entry.transcript = sanitized
            entry.sentiment = NSNumber(value: sentiment)
            entry.sensitiveFlags = SentimentAgent.encodeSensitiveFlags(embeddingPending: pendingFlag)
            entry.embeddedVectorURL = finalVectorURL?.lastPathComponent

            let day = calendar.startOfDay(for: entry.date)
            let request = FeatureVector.fetchRequest()
            request.predicate = NSPredicate(format: "date == %@", day as NSDate)
            request.fetchLimit = 1
            let featureVector = try context.fetch(request).first ?? FeatureVector(context: context)
            featureVector.date = day
            featureVector.sentiment = NSNumber(value: sentiment)

            try context.save()

            return JournalResult(entryID: entry.objectID,
                                 date: entry.date,
                                 transcript: sanitized,
                                 sentimentScore: sentiment,
                                 vectorURL: finalVectorURL,
                                 embeddingPending: pendingFlag)
        }
        span.end(additionalFields: [
            "embedding_pending": .bool(embeddingPending)
        ], error: nil)
        return result
    }

    nonisolated private static func encodeSensitiveFlags(embeddingPending: Bool) -> String? {
        guard embeddingPending else { return "{}" }
        let payload: [String: Any] = ["embedding_pending": true]
        guard let data = try? JSONSerialization.data(withJSONObject: payload, options: []) else { return "{}" }
        return String(data: data, encoding: .utf8) ?? "{}"
    }

    nonisolated private func persistVector(vector: [Float], id: UUID) throws -> URL {
        let directory = PulsumData.vectorIndexDirectory.appendingPathComponent("JournalEntries", isDirectory: true)
        if !FileManager.default.fileExists(atPath: directory.path) {
            try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true, attributes: [.protectionKey: FileProtectionType.complete])
        }
        let url = directory.appendingPathComponent("\(id.uuidString).vec")
        var data = Data(capacity: vector.count * MemoryLayout<Float>.size)
        for value in vector {
            var bits = value.bitPattern.littleEndian
            withUnsafeBytes(of: &bits) { buffer in
                data.append(buffer.bindMemory(to: UInt8.self))
            }
        }
        try data.write(to: url, options: .atomic)
        try FileManager.default.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: url.path)
        return url
    }
}

final class JournalSessionState: @unchecked Sendable {
    private var activeSession: SpeechService.Session?
    private var latestTranscript: String = ""
    private let queue = DispatchQueue(label: "ai.pulsum.sentimentAgent.session", qos: .userInitiated)

    var audioLevels: AsyncStream<Float>? {
        queue.sync { activeSession?.audioLevels }
    }

    var speechStream: AsyncThrowingStream<SpeechSegment, Error>? {
        queue.sync { activeSession?.stream }
    }

    func begin(with session: SpeechService.Session) throws {
        try queue.sync {
            guard activeSession == nil else { throw SentimentAgentError.sessionAlreadyActive }
            activeSession = session
            latestTranscript = ""
        }
    }

    func updateTranscript(_ transcript: String) {
        queue.async { self.latestTranscript = transcript }
    }

    func takeSession() -> (SpeechService.Session, String)? {
        queue.sync {
            guard let session = activeSession else { return nil }
            let transcript = latestTranscript
            activeSession = nil
            latestTranscript = ""
            return (session, transcript)
        }
    }

    func stopActiveSession() {
        queue.sync {
            activeSession?.stop()
            activeSession = nil
            latestTranscript = ""
        }
    }

    func latestTranscriptSnapshot() -> String {
        queue.sync { latestTranscript }
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/SentimentAgent.swift -->

### Packages/PulsumAgents/Sources/PulsumAgents/WellbeingScoreState.swift
- bytes: 383
- lines: 14
- sha256: a75106b11812f15f6d118e8e64a6f987f6160fc93a4a90c8e9ef459153c254b1
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Sources/PulsumAgents/WellbeingScoreState.swift -->
```swift
import Foundation

public enum WellbeingNoDataReason: Equatable, Sendable {
    case healthDataUnavailable
    case permissionsDeniedOrPending
    case insufficientSamples
}

public enum WellbeingScoreState: Equatable, Sendable {
    case loading
    case ready(score: Double, contributions: [String: Double])
    case noData(WellbeingNoDataReason)
    case error(message: String)
}
```
<!-- END_FILE: Packages/PulsumAgents/Sources/PulsumAgents/WellbeingScoreState.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/AgentSystemTests.swift
- bytes: 2866
- lines: 86
- sha256: 72fd65a6bb3f7805f0373c2a1d28f0fc1e716f290432aa03c8d704fcfc9e5460
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/AgentSystemTests.swift -->
```swift
import XCTest
import CoreData
@testable import PulsumAgents
@testable import PulsumData
@testable import PulsumServices
@testable import PulsumML
@preconcurrency import HealthKit

@MainActor
final class AgentSystemTests: XCTestCase {
    
    func testFoundationModelsAvailability() async throws {
        guard #available(iOS 26.0, *) else {
            throw XCTSkip("Foundation Models require iOS 26")
        }
        let status = FoundationModelsAvailability.checkAvailability()
        let message = FoundationModelsAvailability.availabilityMessage(for: status)
        XCTAssertFalse(message.isEmpty)
    }
    
    func testSafetyAgentFlagsCrisis() async throws {
#if !os(iOS)
        throw XCTSkip("Safety agent FM classification validated on iOS 26+ only")
#else
        guard #available(iOS 26.0, *) else {
            throw XCTSkip("Safety agent FM classification validated on iOS 26+ only")
        }
        let safety = SafetyAgent()
        let decision = await safety.evaluate(text: "I might hurt myself tonight")
        switch decision.classification {
        case .crisis:
            XCTAssertFalse(decision.allowCloud)
        default:
            XCTFail("Expected crisis classification")
        }
#endif
    }

    func testAgentOrchestrationFlow() async throws {
#if !os(iOS)
        throw XCTSkip("HealthKit orchestration only available on iOS")
#else
        let orchestrator = try AgentOrchestrator()
        try await orchestrator.start()
        
        // Test that orchestrator initializes without throwing
        XCTAssertNotNil(orchestrator)
        
        // Test Foundation Models status reporting
        let status = orchestrator.foundationModelsStatus
        XCTAssertFalse(status.isEmpty)
#endif
    }

    func testPIIRedactionInSentimentPipeline() async throws {
#if !os(iOS)
        throw XCTSkip("Sentiment journal pipeline only validated on iOS")
#else
        let container = makeInMemoryContainer()
        let agent = SentimentAgent(container: container)
        let result = try await agent.importTranscript("Contact me at sample@example.com about the plan.")
        XCTAssertFalse(result.transcript.contains("example.com"))
        XCTAssertTrue(result.transcript.contains("[redacted]"))
#endif
    }

    private func makeInMemoryContainer() -> NSPersistentContainer {
        let container = NSPersistentContainer(name: "Pulsum")
        let description = NSPersistentStoreDescription()
        description.type = NSInMemoryStoreType
        description.shouldAddStoreAsynchronously = false
        container.persistentStoreDescriptions = [description]
        container.loadPersistentStores { _, error in
            if let error { fatalError("In-memory store error: \(error)") }
        }
        container.viewContext.automaticallyMergesChangesFromParent = true
        return container
    }
}







```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/AgentSystemTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailAcceptanceTests.swift
- bytes: 10884
- lines: 271
- sha256: 5aff0b4860f1ec2ad64b994bfc3fa42f5a2fceb814990b588798742df100c372
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailAcceptanceTests.swift -->
```swift
import Testing
import CoreData
@testable import PulsumAgents
@testable import PulsumServices
@testable import PulsumData
@testable import PulsumML

#if DEBUG
@MainActor
struct ChatGuardrailAcceptanceTests {

    @Test("Greeting routes on-device when consent is OFF")
    func greetingRoutesOnDevice() async throws {
        let harness = try await ChatHarness()
        harness.reset()
        let reply = await harness.chat("Hello", consentGranted: false)
        #expect(!reply.isEmpty)
        #expect(harness.cloudClient.callCount == 0)
        #expect(harness.localGenerator.callCount == 1)
    }

    @Test("Sleep question with consent ON goes to cloud")
    func sleepQuestionRoutesToCloud() async throws {
        let harness = try await ChatHarness()
        harness.reset()
        let reply = await harness.chat("How is my sleep?", consentGranted: true)
        #expect(reply.contains("Cloud response"))
        #expect(harness.cloudClient.callCount == 1)
        #expect(harness.localGenerator.callCount == 0)
    }

    @Test("Sleep question with consent OFF uses on-device AFM")
    func sleepQuestionRoutesOnDeviceWhenConsentOff() async throws {
        let harness = try await ChatHarness()
        harness.reset()
        let reply = await harness.chat("How to improve sleep", consentGranted: false)
        #expect(reply.contains("Local response"))
        #expect(harness.cloudClient.callCount == 0)
        #expect(harness.localGenerator.callCount == 1)
    }

    @Test("Motivation prompt remains on-topic")
    func motivationPromptOnTopic() async throws {
        let harness = try await ChatHarness()
        harness.reset()
        let reply = await harness.chat("How to keep motivated", consentGranted: true)
        #expect(!reply.isEmpty)
        #expect(harness.cloudClient.callCount == 1)
    }

    @Test("Out-of-domain prompt redirects safely")
    func primeFactorsRedirects() async throws {
        let harness = try await ChatHarness()
        harness.reset()
        let reply = await harness.chat("Calculate the prime factors of 512", consentGranted: true)
        #expect(reply == "Let's keep Pulsum focused on your wellbeing data. Ask me about stress, sleep, energy, or today's recommendations.")
        #expect(harness.cloudClient.callCount == 0)
        #expect(harness.localGenerator.callCount == 0)
    }
}

// MARK: - Harness

@MainActor
final class ChatHarness {
    let orchestrator: AgentOrchestrator
    let snapshot: FeatureVectorSnapshot
    let cloudClient: AcceptanceCloudClient
    let localGenerator: AcceptanceLocalGenerator
    let embeddingService: EmbeddingService
    private let dataAgent: StubDataAgent

    init() async throws {
        let container = TestCoreDataStack.makeContainer()
        snapshot = try await ChatHarness.makeSnapshot(in: container)
        dataAgent = StubDataAgent(snapshot: snapshot)
        embeddingService = EmbeddingService.debugInstance(primary: DeterministicEmbeddingProvider(),
                                                          fallback: nil,
                                                          dimension: 16,
                                                          reprobeInterval: 0,
                                                          dateProvider: Date.init)

        cloudClient = AcceptanceCloudClient()
        localGenerator = AcceptanceLocalGenerator()
        let gateway = LLMGateway(cloudClient: cloudClient,
                                 localGenerator: localGenerator)
        try? gateway.setAPIKey("stub-acceptance-key")
        let coachAgent: CoachAgent = try CoachAgent(container: container,
                                                    vectorIndex: StubVectorIndex(),
                                                    libraryImporter: LibraryImporter(configuration: LibraryImporterConfiguration(),
                                                                                    vectorIndex: VectorIndexManager.shared),
                                                    llmGateway: gateway,
                                                    shouldIngestLibrary: false)

        let sentimentAgent = SentimentAgent()
        let safetyAgent = SafetyAgent()
        let cheerAgent = CheerAgent()
        let topicGate = AcceptanceTopicGate()

        self.orchestrator = AgentOrchestrator(dataAgent: dataAgent,
                                              sentimentAgent: sentimentAgent,
                                              coachAgent: coachAgent,
                                              safetyAgent: safetyAgent,
                                              cheerAgent: cheerAgent,
                                              topicGate: topicGate,
                                              embeddingService: embeddingService,
                                              afmAvailable: false)
    }

    func reset() {
        cloudClient.reset()
        localGenerator.reset()
    }

    func chat(_ text: String, consentGranted: Bool) async -> String {
        await orchestrator.chat(userInput: text, consentGranted: consentGranted, snapshotOverride: snapshot)
    }

    private static func makeSnapshot(in container: NSPersistentContainer) async throws -> FeatureVectorSnapshot {
        let context = container.newBackgroundContext()
        return try await context.perform { () throws -> FeatureVectorSnapshot in
            let feature = FeatureVector(context: context)
            try context.obtainPermanentIDs(for: [feature])
            return FeatureVectorSnapshot(date: Date(),
                                         wellbeingScore: 0.6,
                                         contributions: ["z_sleepDebt": -0.4, "z_hrv": 0.3, "subj_energy": 0.2],
                                         imputedFlags: ["hrv": false, "restingHR": false, "steps_missing": false],
                                         featureVectorObjectID: feature.objectID,
                                         features: ["z_sleepDebt": -0.4, "z_hrv": 0.3, "subj_energy": 0.2])
        }
    }
}

private actor StubDataAgent: DataAgentProviding {
    private let snapshot: FeatureVectorSnapshot?

    init(snapshot: FeatureVectorSnapshot) {
        self.snapshot = snapshot
    }

    func setDiagnosticsTraceId(_ traceId: UUID?) async {}

    func start() async throws {}

    func latestFeatureVector() async throws -> FeatureVectorSnapshot? {
        snapshot
    }

    func recordSubjectiveInputs(date: Date, stress: Double, energy: Double, sleepQuality: Double) async throws {}

    func scoreBreakdown() async throws -> ScoreBreakdown? { nil }

    func reprocessDay(date: Date) async throws {}

    func currentHealthAccessStatus() async -> HealthAccessStatus {
        HealthAccessStatus(required: [],
                           granted: [],
                           denied: [],
                           notDetermined: [],
                           availability: .available)
    }

    func requestHealthAccess() async throws -> HealthAccessStatus {
        await currentHealthAccessStatus()
    }

    func restartIngestionAfterPermissionsChange() async throws -> HealthAccessStatus {
        await currentHealthAccessStatus()
    }

    func diagnosticsBackfillCounts() async -> (warmCompleted: Int, fullCompleted: Int) {
        (warmCompleted: 0, fullCompleted: 0)
    }

    func latestSnapshotMetadata() async -> (dayString: String?, score: Double?) {
        (dayString: nil, score: snapshot?.wellbeingScore)
    }

    func reset() {}
}

actor StubVectorIndex: VectorIndexProviding {
    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] { [] }
    func removeMicroMoment(id: String) async throws {}

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] {
        switch query.lowercased() {
        case let text where text.contains("sleep"):
            return Self.matches(similarities: [0.75, 0.68, 0.61])
        case let text where text.contains("motivated"):
            return Self.matches(similarities: [0.74, 0.66, 0.60])
        case let text where text.contains("stress"):
            return Self.matches(similarities: [0.72, 0.65, 0.58])
        default:
            return []
        }
    }

    private static func matches(similarities: [Double]) -> [VectorMatch] {
        similarities.enumerated().map { index, similarity in
            let distance = max((1.0 / similarity) - 1.0, 0.0)
            return VectorMatch(id: "stub-\(index)", score: Float(distance))
        }
    }
}

final class AcceptanceCloudClient: CloudLLMClient {
    private(set) var callCount = 0
    var cannedReply: String = "Cloud response"

    func generateResponse(context: CoachLLMContext,
                          intentTopic: String?,
                          candidateMoments: [CandidateMoment],
                          apiKey: String,
                          keySource: String) async throws -> CoachPhrasing {
        callCount += 1
        return CoachPhrasing(coachReply: cannedReply,
                             isOnTopic: true,
                             groundingScore: 0.78,
                             intentTopic: intentTopic ?? "none",
                             nextAction: "3-minute box breathing")
    }

    func reset() {
        callCount = 0
    }
}

final class AcceptanceLocalGenerator: OnDeviceCoachGenerator {
    private(set) var callCount = 0

    func generate(context: CoachLLMContext) async -> CoachReplyPayload {
        callCount += 1
        return CoachReplyPayload(coachReply: "Local response for \(context.topSignal)")
    }

    func reset() {
        callCount = 0
    }
}
#endif
final class AcceptanceTopicGate: TopicGateProviding {
    func classify(_ text: String) async throws -> GateDecision {
        let lower = text.lowercased()
        let topic: String?
        if lower.contains("sleep") {
            topic = "sleep"
        } else if lower.contains("stress") {
            topic = "stress"
        } else if lower.contains("energy") || lower.contains("motivation") || lower.contains("motivat") {
            topic = "energy"
        } else if lower.contains("walk") || lower.contains("steps") {
            topic = "movement"
        } else if lower.contains("hrv") {
            topic = "hrv"
        } else {
            topic = nil
        }
        return GateDecision(isOnTopic: topic != nil,
                            reason: "stub",
                            confidence: 0.95,
                            topic: topic)
    }
}

private struct DeterministicEmbeddingProvider: TextEmbeddingProviding {
    func embedding(for text: String) throws -> [Float] {
        // Small deterministic vector with non-zero values to satisfy availability checks.
        Array(repeating: Float((text.count % 5) + 1) * 0.01, count: 16)
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailAcceptanceTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailTests.swift
- bytes: 9152
- lines: 216
- sha256: 67cd46ed0157dc558c0f5412f1bbd850b53b2093b652817f212a2d77aff0cbc7
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailTests.swift -->
```swift
import Testing
import Foundation
@testable import PulsumAgents
@testable import PulsumML
@testable import PulsumData
@testable import PulsumServices

/// Integration tests for two-wall chat guardrail system
struct ChatGuardrailTests {

    @Test("Off-topic prompt blocked by topic gate returns redirect")
    func offTopicBlocked() async throws {
        // This test requires a test Core Data stack
        // For now, we verify the logic is in place by checking redirect message

        let offTopicPrompts = [
            "What's the weather today?",
            "Tell me a joke",
            "Who won the game last night?",
            "How do I make pizza?"
        ]

        // Expected redirect message from AgentOrchestrator
        let expectedRedirect = "Let's keep Pulsum focused on your wellbeing data. Ask me about stress, sleep, energy, or today's recommendations."

        for _ in offTopicPrompts {
            // Test would require full orchestrator initialization
            // Integration harness stubbed out; this assertion documents the expected redirect
            #expect(expectedRedirect.contains("wellbeing"), "Redirect message should mention wellbeing")
        }
    }

    @Test("On-topic wellbeing prompt passes guardrails")
    func onTopicPasses() async throws {
        let onTopicPrompts = [
            "I'm feeling stressed, what should I do?",
            "My sleep has been poor lately",
            "How can I improve my energy?",
            "I'm anxious about my health metrics"
        ]

        // These prompts should pass through:
        // 1. Safety gate (safe classification)
        // 2. Topic gate (high wellbeing similarity)
        // 3. Coverage gate (matches vector index content)
        for prompt in onTopicPrompts {
            #expect(prompt.lowercased().contains("stress") ||
                   prompt.lowercased().contains("sleep") ||
                   prompt.lowercased().contains("energy") ||
                   prompt.lowercased().contains("health"),
                   "On-topic prompt should contain wellbeing keywords")
        }
    }

    @Test("Crisis content blocks all processing")
    func crisisContentBlocked() async throws {
        // Crisis keywords should trigger SafetyAgent block
        // and prevent any cloud calls
        let crisisKeywords = ["suicide", "kill myself", "end my life"]

        for keyword in crisisKeywords {
            let input = "I'm thinking about \(keyword)"
            // SafetyAgent should classify as crisis
            // Expected behavior: return crisis message, no cloud call
            #expect(input.contains(keyword))
        }
    }

    @Test("Retrieval coverage threshold enforced")
    func coverageThresholdEnforced() async throws {
        // Test that coverage threshold (τ = 0.62) is applied
        let threshold = 0.62

        // Mock coverage scores
        let belowThreshold = 0.50
        let aboveThreshold = 0.75

        #expect(belowThreshold < threshold, "Score below threshold should be blocked")
        #expect(aboveThreshold >= threshold, "Score above threshold should pass")
    }

    @Test("Redirect message is consistent")
    func redirectMessageConsistent() {
        let redirectMessage = "Let's keep Pulsum focused on your wellbeing data. Ask me about stress, sleep, energy, or today's recommendations."

        // Verify message structure
        #expect(redirectMessage.count <= 280, "Redirect should be concise (≤280 chars)")
        #expect(redirectMessage.split(separator: ".").count <= 2, "Redirect should be ≤2 sentences")
        #expect(redirectMessage.contains("wellbeing"), "Redirect should mention wellbeing")
    }

    @Test("Coverage strong pass when similarity is robust")
    func coverageStrongPass() {
        let sims = [0.65, 0.60, 0.45].map { (1.0 / $0) - 1.0 }
        let matches = sims.map { VectorMatch(id: UUID().uuidString, score: Float($0)) }
        let decision = decideCoverage(CoverageInputs(l2Matches: matches, canonicalTopic: "sleep", snapshot: nil))
        #expect(decision.kind == .strong)
        #expect(decision.reason == "strong-pass")
    }

    @Test("Coverage soft pass when on-topic median meets floor")
    func coverageSoftOnTopic() {
        let sims = [0.50, 0.36, 0.33].map { (1.0 / $0) - 1.0 }
        let matches = sims.map { VectorMatch(id: UUID().uuidString, score: Float($0)) }
        let decision = decideCoverage(CoverageInputs(l2Matches: matches, canonicalTopic: "sleep", snapshot: nil))
        #expect(decision.kind == .soft)
        #expect(decision.reason == "on-topic-median")
    }

    @Test("Soft pass with consent routes to cloud")
    func softPassRoutesToCloud() async {
        let cloud = CountingCloudClient()
        let local = CountingLocalGenerator()
        let gateway = LLMGateway(keychain: KeychainService(),
                                 cloudClient: cloud,
                                 localGenerator: local)
        let context = CoachLLMContext(userToneHints: "How to improve sleep",
                                      topSignal: "topic=sleep",
                                      topMomentId: nil,
                                      rationale: "soft-pass",
                                      zScoreSummary: "z_sleepDebt:+0.8")
        _ = await gateway.generateCoachResponse(context: context,
                                                intentTopic: "sleep",
                                                candidateMoments: [],
                                                consentGranted: true,
                                                groundingFloor: 0.40)
        #expect(cloud.callCount == 1)
        #expect(local.callCount == 0)
    }

    @Test("Soft pass without consent routes on-device")
    func softPassRoutesOnDeviceWithoutConsent() async {
        let cloud = CountingCloudClient()
        let local = CountingLocalGenerator()
        let gateway = LLMGateway(keychain: KeychainService(),
                                 cloudClient: cloud,
                                 localGenerator: local)
        let context = CoachLLMContext(userToneHints: "How to improve sleep",
                                      topSignal: "topic=sleep",
                                      topMomentId: nil,
                                      rationale: "soft-pass",
                                      zScoreSummary: "z_sleepDebt:+0.8")
        _ = await gateway.generateCoachResponse(context: context,
                                                intentTopic: "sleep",
                                                candidateMoments: [],
                                                consentGranted: false,
                                                groundingFloor: 0.40)
        #expect(cloud.callCount == 0)
        #expect(local.callCount == 1)
    }

    @Test("Sleep synonym classified on-topic")
    func sleepSynonymOnTopic() async throws {
        let provider = KeywordTopicGate()
        let decision = try await provider.classify("How to improve sleep")
        #expect(decision.isOnTopic)
        #expect(decision.topic == "sleep")
        #expect(decision.confidence >= 0.59)
    }

    @Test("Motivation synonym maps to goals domain")
    func motivationSynonymOnTopic() async throws {
        let provider = KeywordTopicGate()
        let decision = try await provider.classify("How do I keep motivated this week?")
        #expect(decision.isOnTopic)
        #expect(decision.topic == "goals" || decision.topic == "energy")
        #expect(decision.confidence >= 0.59)
    }
}

// MARK: - Test doubles

final class CountingCloudClient: CloudLLMClient {
    var callCount = 0

    func generateResponse(context: CoachLLMContext,
                          intentTopic: String?,
                          candidateMoments: [CandidateMoment],
                          apiKey: String,
                          keySource: String) async throws -> CoachPhrasing {
        callCount += 1
        return CoachPhrasing(
            coachReply: "Cloud response referencing \(context.topSignal).",
            isOnTopic: true,
            groundingScore: 0.95,
            intentTopic: intentTopic ?? "none"
        )
    }
}

final class CountingLocalGenerator: OnDeviceCoachGenerator {
    var callCount = 0

    func generate(context: CoachLLMContext) async -> CoachReplyPayload {
        callCount += 1
        return CoachReplyPayload(coachReply: "Local fallback for \(context.topSignal)", nextAction: nil)
    }
}

private final class KeywordTopicGate: TopicGateProviding {
    func classify(_ text: String) async throws -> GateDecision {
        let lower = text.lowercased()
        let topic: String?
        if lower.contains("sleep") {
            topic = "sleep"
        } else if lower.contains("motivat") || lower.contains("energy") {
            topic = "goals"
        } else {
            topic = nil
        }
        return GateDecision(isOnTopic: topic != nil,
                            reason: "keyword",
                            confidence: topic == nil ? 0.5 : 0.95,
                            topic: topic)
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/CoachAgentKeywordFallbackTests.swift
- bytes: 2403
- lines: 58
- sha256: 7b9dc7589193031182c937d034bb955166fddca8bdae824f2e5100e5d9d43fe9
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/CoachAgentKeywordFallbackTests.swift -->
```swift
@testable import PulsumAgents
@testable import PulsumData
@testable import PulsumML
import XCTest

@MainActor
final class CoachAgentKeywordFallbackTests: XCTestCase {
    func testKeywordFallbackMatchesTitleAndTagsWhenEmbeddingsUnavailable() async throws {
        let container = TestCoreDataStack.makeContainer()
        let viewContext = container.viewContext

        viewContext.performAndWait {
            let titleMatch = MicroMoment(context: viewContext)
            titleMatch.id = "energy-walk"
            titleMatch.title = "Energy Reset Walk"
            titleMatch.shortDescription = "Take a short walk to restore energy."
            titleMatch.detail = "A quick walk outside can raise energy without overexertion."

            let tagMatch = MicroMoment(context: viewContext)
            tagMatch.id = "focus-routine"
            tagMatch.title = "Focus Routine"
            tagMatch.shortDescription = "Tighten focus with a brief cadence."
            tagMatch.detail = "Alternate between short breathing drills and light movement."
            tagMatch.tags = ["ENERGY boost", "focus"]

            let nonMatch = MicroMoment(context: viewContext)
            nonMatch.id = "calm-breath"
            nonMatch.title = "Calm Breathing"
            nonMatch.shortDescription = "Slow breathing to reduce stress."
            nonMatch.detail = "A calming pattern for winding down."
            nonMatch.tags = ["calm"]

            try? viewContext.save()
        }

        let coach = try CoachAgent(container: container,
                                   vectorIndex: UnavailableKeywordIndexStub(),
                                   shouldIngestLibrary: false)

        let moments = await coach.candidateMoments(for: "energy", limit: 3)
        let ids = moments.map(\.id)

        XCTAssertEqual(ids, ["energy-walk", "focus-routine"])
        XCTAssertFalse(ids.contains("calm-breath"), "Non-matching moments should not be returned.")
    }
}

private actor UnavailableKeywordIndexStub: VectorIndexProviding {
    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        throw EmbeddingError.generatorUnavailable
    }

    func removeMicroMoment(id: String) async throws {}

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] {
        throw EmbeddingError.generatorUnavailable
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/CoachAgentKeywordFallbackTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/DebugLogBufferTests.swift
- bytes: 901
- lines: 27
- sha256: eb89ce6362f24df07580d701bc02e72c0f4efa616e358a3030696198534ba0ef
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/DebugLogBufferTests.swift -->
```swift
@testable import PulsumAgents
import PulsumTypes
import XCTest

final class DebugLogBufferTests: XCTestCase {
    func testRingBufferEvictsOldEntries() async {
        let buffer = DebugLogBuffer.shared
        await buffer._testReset()

        for index in 0..<100 {
            await buffer.append("seed-line-\(index)")
        }
        let initialFirst = await buffer.snapshot().split(separator: "\n").first

        for index in 0..<35_000 {
            await buffer.append("test-line-\(index)")
        }

        let snapshot = await buffer.snapshot()
        let lines = snapshot.split(separator: "\n")
        XCTAssertLessThan(lines.count, 35_100)
        XCTAssertTrue(lines.last?.contains("test-line-34999") ?? false)
        if let initialFirst {
            XCTAssertFalse(lines.contains(initialFirst), "Old seed entries should be evicted when capacity is exceeded.")
        }
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/DebugLogBufferTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_JournalSessionTests.swift
- bytes: 1347
- lines: 39
- sha256: 5057a68461d837b0e7c9f90581f15090f02c29b7a5146e727ab7f4e9683cdbce
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_JournalSessionTests.swift -->
```swift
import XCTest
@testable import PulsumAgents
@testable import PulsumServices
import PulsumTypes

final class Gate2_JournalSessionTests: XCTestCase {
    func testBeginRejectsDuplicateSessions() throws {
        let state = JournalSessionState()
        try state.begin(with: makeSession())
        XCTAssertThrowsError(try state.begin(with: makeSession())) { error in
            guard let sentimentError = error as? SentimentAgentError else {
                return XCTFail("Expected SentimentAgentError, got \(error)")
            }
            XCTAssertEqual(sentimentError, .sessionAlreadyActive)
        }
    }

    func testTakeSessionClearsState() throws {
        let state = JournalSessionState()
        try state.begin(with: makeSession())
        state.updateTranscript("hello world")

        let result = state.takeSession()
        XCTAssertNotNil(result)
        XCTAssertEqual(result?.1, "hello world")

        XCTAssertNil(state.takeSession())
    }

    private func makeSession() -> SpeechService.Session {
        let stream = AsyncThrowingStream<SpeechSegment, Error> { continuation in
            continuation.finish()
        }
        let levels = AsyncStream<Float> { continuation in
            continuation.finish()
        }
        return SpeechService.Session(stream: stream, stop: {}, audioLevels: levels)
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_JournalSessionTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_OrchestratorLLMKeyAPITests.swift
- bytes: 6112
- lines: 172
- sha256: cf76f8edaad20e6be9eac9ce4b604bd5a2f479a9973601c487089f6b6d0e8c7e
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_OrchestratorLLMKeyAPITests.swift -->
```swift
#if DEBUG
import Foundation
import XCTest
@testable import PulsumAgents
@testable import PulsumServices
import PulsumML
import PulsumTypes

@MainActor
final class Gate2_OrchestratorLLMKeyAPITests: XCTestCase {
    override func tearDown() {
        super.tearDown()
        StubURLProtocol.handler = nil
    }

    func testLLMKeyRoundTripAndConnectivity() async throws {
        StubURLProtocol.handler = { request in
            let response = HTTPURLResponse(url: request.url!,
                                           statusCode: 200,
                                           httpVersion: nil,
                                           headerFields: ["Content-Type": "application/json"])!
            let payload = #"{"id":"stub","object":"response","output":[]}"#.data(using: .utf8)!
            return (response, payload)
        }

        let orchestrator = try makeOrchestrator()

        XCTAssertNil(orchestrator.currentLLMAPIKey())

        try orchestrator.setLLMAPIKey("ci-test-valid")
        XCTAssertEqual(orchestrator.currentLLMAPIKey(), "ci-test-valid")

        let ping = try await orchestrator.testLLMAPIConnection()
        XCTAssertTrue(ping)
    }

    private func makeOrchestrator() throws -> AgentOrchestrator {
        let coachAgent = try makeCoachAgent()
        return AgentOrchestrator(
            dataAgent: DataAgentStub(),
            sentimentAgent: SentimentAgentStub(),
            coachAgent: coachAgent,
            safetyAgent: SafetyAgent(),
            cheerAgent: CheerAgent(),
            topicGate: TopicGateStub(),
            afmAvailable: false
        )
    }

    private func makeCoachAgent() throws -> CoachAgent {
        let configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [StubURLProtocol.self]
        let session = URLSession(configuration: configuration)
        let gateway = LLMGateway(keychain: InMemoryKeychain(), session: session)
        return try CoachAgent(llmGateway: gateway, shouldIngestLibrary: false)
    }
}

// MARK: - Test doubles

private actor DataAgentStub: DataAgentProviding {
    func setDiagnosticsTraceId(_ traceId: UUID?) async {}
    func start() async throws {}
    func latestFeatureVector() async throws -> FeatureVectorSnapshot? { nil }
    func recordSubjectiveInputs(date: Date,
                                stress: Double,
                                energy: Double,
                                sleepQuality: Double) async throws {}
    func scoreBreakdown() async throws -> ScoreBreakdown? { nil }
    func reprocessDay(date: Date) async throws {}
    func currentHealthAccessStatus() async -> HealthAccessStatus {
        HealthAccessStatus(required: [],
                           granted: [],
                           denied: [],
                           notDetermined: [],
                           availability: .available)
    }
    func requestHealthAccess() async throws -> HealthAccessStatus {
        await currentHealthAccessStatus()
    }
    func restartIngestionAfterPermissionsChange() async throws -> HealthAccessStatus {
        await currentHealthAccessStatus()
    }
    func diagnosticsBackfillCounts() async -> (warmCompleted: Int, fullCompleted: Int) {
        (warmCompleted: 0, fullCompleted: 0)
    }
    func latestSnapshotMetadata() async -> (dayString: String?, score: Double?) {
        (dayString: nil, score: nil)
    }
}

@MainActor
private final class SentimentAgentStub: SentimentAgentProviding {
    var audioLevels: AsyncStream<Float>? { nil }
    var speechStream: AsyncThrowingStream<SpeechSegment, Error>? { nil }

    func beginVoiceJournal(maxDuration: TimeInterval) async throws {}
    func finishVoiceJournal(transcript: String?) async throws -> JournalResult {
        throw SentimentAgentError.noActiveRecording
    }

    func recordVoiceJournal(maxDuration: TimeInterval) async throws -> JournalResult {
        throw SentimentAgentError.noActiveRecording
    }

    func importTranscript(_ transcript: String) async throws -> JournalResult {
        throw SentimentAgentError.noActiveRecording
    }

    func requestAuthorization() async throws {}
    func stopRecording() {}
    func updateTranscript(_ transcript: String) {}
    func latestTranscriptSnapshot() -> String { "" }
    func reprocessPendingJournals(traceId: UUID?) async {}
    func pendingEmbeddingCount() async -> Int { 0 }
}

private struct TopicGateStub: TopicGateProviding {
    func classify(_ text: String) async throws -> GateDecision {
        GateDecision(isOnTopic: true, reason: "stub", confidence: 0.99, topic: nil)
    }
}

private final class InMemoryKeychain: KeychainStoring, @unchecked Sendable {
    private var storage: [String: Data] = [:]
    private let lock = NSLock()

    func setSecret(_ value: Data, for key: String) throws {
        lock.lock()
        storage[key] = value
        lock.unlock()
    }

    func secret(for key: String) throws -> Data? {
        lock.lock()
        let value = storage[key]
        lock.unlock()
        return value
    }

    func removeSecret(for key: String) throws {
        lock.lock()
        storage.removeValue(forKey: key)
        lock.unlock()
    }
}

private final class StubURLProtocol: URLProtocol {
    nonisolated(unsafe) static var handler: ((URLRequest) throws -> (HTTPURLResponse, Data))?

    override class func canInit(with request: URLRequest) -> Bool { true }
    override class func canonicalRequest(for request: URLRequest) -> URLRequest { request }

    override func startLoading() {
        guard let handler = Self.handler else {
            client?.urlProtocol(self, didFailWithError: URLError(.badURL))
            return
        }

        do {
            let (response, data) = try handler(request)
            client?.urlProtocol(self, didReceive: response, cacheStoragePolicy: .notAllowed)
            client?.urlProtocol(self, didLoad: data)
            client?.urlProtocolDidFinishLoading(self)
        } catch {
            client?.urlProtocol(self, didFailWithError: error)
        }
    }

    override func stopLoading() {}
}
#endif
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_OrchestratorLLMKeyAPITests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_TypesWiringTests.swift
- bytes: 354
- lines: 11
- sha256: 556d7d80fd6c22b52bdd8e16f290e2a7c59d9fd16fd01f18ad9d6748d47cd4e0
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_TypesWiringTests.swift -->
```swift
import XCTest
import PulsumTypes

final class Gate2_TypesWiringTests: XCTestCase {
    func testSpeechSegmentInit() {
        let segment = SpeechSegment(transcript: "hello", isFinal: true, confidence: 0.9)
        XCTAssertEqual(segment.transcript, "hello")
        XCTAssertTrue(segment.isFinal)
        XCTAssertEqual(segment.confidence, 0.9)
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_TypesWiringTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_FreshnessBusTests.swift
- bytes: 2654
- lines: 66
- sha256: b360f19b6ece1160b3072b149a457945b835449d3aeacff911bdf3bbb22b20f3
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_FreshnessBusTests.swift -->
```swift
@testable import PulsumAgents
@testable import PulsumData
import PulsumTypes
import XCTest

final class Gate3_FreshnessBusTests: XCTestCase {
    func testReprocessDayPostsSingleNotification() async throws {
        let stub = HealthKitServiceStub()
        let center = RecordingNotificationCenter()
        let agent = DataAgent(healthKit: stub,
                              container: TestCoreDataStack.makeContainer(),
                              notificationCenter: center)

        let today = Date()
        try await agent.reprocessDay(date: today)

        try await Task.sleep(nanoseconds: 700_000_000)
        let posts = center.notifications(named: .pulsumScoresUpdated)
        XCTAssertEqual(posts.count, 1)
        let expectedDay = Calendar(identifier: .gregorian).startOfDay(for: today)
        let postedDay = posts.first?.userInfo?[AgentNotificationKeys.date] as? Date
        XCTAssertEqual(postedDay, expectedDay)
    }

    func testDebouncedNotificationsCoalesceBursts() async throws {
        let center = RecordingNotificationCenter()
        let agent = DataAgent(notificationCenter: center)
        let day = Date()
        await agent._testPublishSnapshotUpdate(for: day)
        await agent._testPublishSnapshotUpdate(for: day)
        await agent._testPublishSnapshotUpdate(for: day)

        try await Task.sleep(nanoseconds: 1_000_000_000)
        let posts = center.notifications(named: .pulsumScoresUpdated)
        XCTAssertGreaterThan(posts.count, 0)
        let expectedDay = Calendar(identifier: .gregorian).startOfDay(for: day)
        let postedDay = posts.first?.userInfo?[AgentNotificationKeys.date] as? Date
        XCTAssertEqual(postedDay, expectedDay)
        XCTAssertLessThanOrEqual(posts.count, 2)
    }
}

private struct PostedNotification {
    let name: Notification.Name
    let object: Any?
    let userInfo: [AnyHashable: Any]?
}

private final class RecordingNotificationCenter: NotificationCenter, @unchecked Sendable {
    private let lock = NSLock()
    private(set) var postedNotifications: [PostedNotification] = []

    override func post(name aName: Notification.Name, object anObject: Any?, userInfo aUserInfo: [AnyHashable: Any]? = nil) {
        lock.lock()
        postedNotifications.append(PostedNotification(name: aName, object: anObject, userInfo: aUserInfo))
        lock.unlock()
        super.post(name: aName, object: anObject, userInfo: aUserInfo)
    }

    func notifications(named name: Notification.Name) -> [PostedNotification] {
        lock.lock()
        let result = postedNotifications.filter { $0.name == name }
        lock.unlock()
        return result
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_FreshnessBusTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_HealthAccessStatusTests.swift
- bytes: 4613
- lines: 93
- sha256: d3d19cfa69e92076e79106611155210521561443bef5dec6183c34b71326ec3f
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_HealthAccessStatusTests.swift -->
```swift
@testable import PulsumAgents
@testable import PulsumData
@testable import PulsumServices
import HealthKit
import XCTest

final class Gate3_HealthAccessStatusTests: XCTestCase {
    func testDeniedTypesAreExcludedFromObservation() async throws {
        let stub = HealthKitServiceStub()
        let sleepIdentifier = HKCategoryTypeIdentifier.sleepAnalysis.rawValue
        for type in HealthKitService.orderedReadSampleTypes {
            stub.readProbeResults[type.identifier] = type.identifier == sleepIdentifier ? .denied : .authorized
        }
        let agent = DataAgent(healthKit: stub, container: TestCoreDataStack.makeContainer())

        let status = await agent.currentHealthAccessStatus()

        XCTAssertTrue(status.denied.contains { $0.identifier == sleepIdentifier })
        XCTAssertFalse(status.granted.contains { $0.identifier == sleepIdentifier })

        try await agent.startIngestionIfAuthorized()

        XCTAssertFalse(stub.observedIdentifiers.contains(sleepIdentifier), "Denied type should not start observation.")

        let grantedIdentifiers = Set(stub.observedIdentifiers)
        XCTAssertEqual(grantedIdentifiers.count, HealthKitService.orderedReadSampleTypes.count - 1)

        stub.readProbeResults[sleepIdentifier] = .authorized

        try await agent.restartIngestionAfterPermissionsChange()

        let counts = Dictionary(grouping: stub.observedIdentifiers, by: { $0 }).mapValues(\.count)
        XCTAssertEqual(counts[sleepIdentifier], 1, "Sleep type should be observed exactly once after grant.")
        for type in HealthKitService.orderedReadSampleTypes where type.identifier != sleepIdentifier {
            XCTAssertEqual(counts[type.identifier], 1, "Already granted types should not duplicate observers.")
        }
    }

    func testReadOnlyAuthorizationDoesNotMarkGrantedAsDenied() async throws {
        let stub = HealthKitServiceStub()
        stub.requestAuthorizationStatus = .unnecessary
        for type in HealthKitService.orderedReadSampleTypes {
            stub.authorizationStatuses[type.identifier] = .sharingDenied
            stub.readProbeResults[type.identifier] = .authorized
        }
        let agent = DataAgent(healthKit: stub, container: TestCoreDataStack.makeContainer())

        let status = await agent.currentHealthAccessStatus()
        XCTAssertEqual(status.granted.count, HealthKitService.orderedReadSampleTypes.count)
        XCTAssertTrue(status.denied.isEmpty)
        XCTAssertTrue(status.notDetermined.isEmpty)

        try await agent.startIngestionIfAuthorized()
        let observed = Set(stub.observedIdentifiers)
        XCTAssertEqual(observed.count, HealthKitService.orderedReadSampleTypes.count, "All granted types should start observation even when sharing is denied.")
    }

    func testMixedProbeResultsClassifyPerType() async throws {
        let stub = HealthKitServiceStub()
        stub.requestAuthorizationStatus = .unnecessary
        let types = HealthKitService.orderedReadSampleTypes
        guard let deniedType = types.first, let pendingType = types.last, deniedType.identifier != pendingType.identifier else {
            XCTFail("Expected at least two HealthKit types for classification test.")
            return
        }

        for type in types {
            if type.identifier == deniedType.identifier {
                stub.readProbeResults[type.identifier] = .denied
            } else if type.identifier == pendingType.identifier {
                stub.readProbeResults[type.identifier] = .notDetermined
            } else {
                stub.readProbeResults[type.identifier] = .authorized
            }
        }

        let agent = DataAgent(healthKit: stub, container: TestCoreDataStack.makeContainer())

        let status = await agent.currentHealthAccessStatus()
        XCTAssertTrue(status.denied.contains { $0.identifier == deniedType.identifier })
        XCTAssertTrue(status.notDetermined.contains { $0.identifier == pendingType.identifier })
        XCTAssertFalse(status.granted.contains { $0.identifier == deniedType.identifier })
        XCTAssertFalse(status.granted.contains { $0.identifier == pendingType.identifier })
        XCTAssertEqual(status.granted.count, HealthKitService.orderedReadSampleTypes.count - 2)

        try await agent.startIngestionIfAuthorized()

        let observed = Set(stub.observedIdentifiers)
        XCTAssertFalse(observed.contains(deniedType.identifier))
        XCTAssertFalse(observed.contains(pendingType.identifier))
        XCTAssertEqual(observed.count, HealthKitService.orderedReadSampleTypes.count - 2)
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_HealthAccessStatusTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_IngestionIdempotenceTests.swift
- bytes: 2104
- lines: 50
- sha256: 8110395cbad75d44645b7523dd0187c83261e58f31bb67dfa3e917f968ca1e48
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_IngestionIdempotenceTests.swift -->
```swift
@testable import PulsumAgents
@testable import PulsumData
@testable import PulsumServices
import XCTest

final class Gate3_IngestionIdempotenceTests: XCTestCase {
    func testRestartDoesNotDuplicateObserversAndStopsRevokedTypes() async throws {
        let stub = HealthKitServiceStub()
        let identifiers = HealthKitService.orderedReadSampleTypes.map { $0.identifier }
        identifiers.forEach {
            stub.authorizationStatuses[$0] = .sharingAuthorized
            stub.readProbeResults[$0] = .authorized
        }
        let agent = DataAgent(healthKit: stub, container: TestCoreDataStack.makeContainer())

        try await agent.startIngestionIfAuthorized()

        var counts = Dictionary(grouping: stub.observedIdentifiers, by: { $0 }).mapValues(\.count)
        for identifier in identifiers {
            XCTAssertEqual(counts[identifier], 1, "Each type should be observed exactly once on start.")
        }

        try await agent.startIngestionIfAuthorized()

        counts = Dictionary(grouping: stub.observedIdentifiers, by: { $0 }).mapValues(\.count)
        for identifier in identifiers {
            XCTAssertEqual(counts[identifier], 1, "Repeated start should not duplicate observers.")
        }

        guard let firstIdentifier = identifiers.first else {
            XCTFail("Expected at least one HealthKit type.")
            return
        }

        stub.authorizationStatuses[firstIdentifier] = .sharingDenied
        stub.readProbeResults[firstIdentifier] = .denied

        try await agent.restartIngestionAfterPermissionsChange()

        XCTAssertTrue(stub.stoppedIdentifiers.contains(firstIdentifier), "Revoked type should be stopped.")

        stub.authorizationStatuses[firstIdentifier] = .sharingAuthorized
        stub.readProbeResults[firstIdentifier] = .authorized

        try await agent.restartIngestionAfterPermissionsChange()

        counts = Dictionary(grouping: stub.observedIdentifiers, by: { $0 }).mapValues(\.count)
        XCTAssertEqual(counts[firstIdentifier], 2, "Revoked then re-granted type should be re-observed once.")
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_IngestionIdempotenceTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_ConsentRoutingTests.swift
- bytes: 3851
- lines: 92
- sha256: 1f56dda4f57055dcf15c38885c5c78a9437d176af43d56189baded0fc52fbbdf
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_ConsentRoutingTests.swift -->
```swift
import Foundation
import Testing
@testable import PulsumServices

struct Gate4_ConsentRoutingTests {

    @Test("Consent OFF forces on-device generator")
    func consentOffFallsBackLocal() async {
        let keyStore = InMemoryAPIKeyStoreStub()
        let cloud = ConsentCloudClientStub()
        let local = ConsentLocalGeneratorStub()
        let gateway = LLMGateway(keychain: keyStore,
                                 cloudClient: cloud,
                                 localGenerator: local)
        let context = CoachLLMContext(userToneHints: "How can I improve my sleep?",
                                      topSignal: "topic=sleep",
                                      topMomentId: nil,
                                      rationale: "soft-pass",
                                      zScoreSummary: "z_sleepDebt:+0.8")
        _ = await gateway.generateCoachResponse(context: context,
                                                intentTopic: "sleep",
                                                candidateMoments: [],
                                                consentGranted: false,
                                                groundingFloor: 0.40)
        #expect(cloud.callCount == 0)
        #expect(local.callCount == 1)
    }

    @Test("Consent ON routes to cloud when coverage strong")
    func consentOnUsesCloud() async {
        let keyStore = InMemoryAPIKeyStoreStub()
        let cloud = ConsentCloudClientStub()
        let local = ConsentLocalGeneratorStub()
        let gateway = LLMGateway(keychain: keyStore,
                                 cloudClient: cloud,
                                 localGenerator: local)
        let context = CoachLLMContext(userToneHints: "Give me a stress reset.",
                                      topSignal: "topic=stress",
                                      topMomentId: nil,
                                      rationale: "strong-pass",
                                      zScoreSummary: "z_hrv:-0.9")
        _ = await gateway.generateCoachResponse(context: context,
                                                intentTopic: "stress",
                                                candidateMoments: [],
                                                consentGranted: true,
                                                groundingFloor: 0.40)
        #expect(cloud.callCount == 1)
        #expect(local.callCount == 0)
    }
}

/// Hermetic API key store so consent routing never depends on macOS keychain or HOME.
private final class InMemoryAPIKeyStoreStub: APIKeyProviding, @unchecked Sendable {
    private var storedKey = Data("test-key".utf8)

    func storeAPIKeyData(_ value: Data, identifier: String) throws {
        storedKey = value
    }

    func fetchAPIKeyData(for identifier: String) throws -> Data? {
        storedKey
    }

    func removeAPIKey(for identifier: String) throws {
        storedKey = Data()
    }
}

private final class ConsentCloudClientStub: CloudLLMClient {
    var callCount = 0

    func generateResponse(context: CoachLLMContext,
                          intentTopic: String?,
                          candidateMoments: [CandidateMoment],
                          apiKey: String,
                          keySource: String) async throws -> CoachPhrasing {
        callCount += 1
        return CoachPhrasing(coachReply: "Cloud response",
                             isOnTopic: true,
                             groundingScore: 0.9,
                             intentTopic: intentTopic ?? "none")
    }
}

private final class ConsentLocalGeneratorStub: OnDeviceCoachGenerator {
    var callCount = 0

    func generate(context: CoachLLMContext) async -> CoachReplyPayload {
        callCount += 1
        return CoachReplyPayload(coachReply: "Local response for \(context.topSignal).")
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_ConsentRoutingTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_LLMKeyTests.swift
- bytes: 1489
- lines: 52
- sha256: ea5bb3367699c95f9b868310a363ee9f99428871fd678d6284ff5540f43c4517
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_LLMKeyTests.swift -->
```swift
#if DEBUG
import Foundation
import XCTest
@testable import PulsumAgents
@testable import PulsumServices

final class Gate4_LLMKeyTests: XCTestCase {
    func testSetAndGetKeyRoundtripUsesKeychainStub() throws {
        let keychain = EphemeralKeychain()
        let gateway = LLMGateway(keychain: keychain)

        XCTAssertNil(gateway.currentAPIKey())
        try gateway.setAPIKey("  demo-key  ")
        XCTAssertEqual(gateway.currentAPIKey(), "demo-key")
        XCTAssertEqual(String(data: keychain.storage["openai.api.key"] ?? Data(), encoding: .utf8), "demo-key")
    }

    func testPingAcceptsExpectedVariants() {
        var body = LLMGateway.makePingRequestBody()
        if var input = body["input"] as? [[String: Any]] {
            input[0]["content"] = "PING"
            body["input"] = input
        }

        XCTAssertTrue(LLMGateway.validatePingPayload(body))
    }
}

private final class EphemeralKeychain: KeychainStoring, @unchecked Sendable {
    fileprivate var storage: [String: Data] = [:]
    private let lock = NSLock()

    func setSecret(_ value: Data, for key: String) throws {
        lock.lock()
        storage[key] = value
        lock.unlock()
    }

    func secret(for key: String) throws -> Data? {
        lock.lock()
        let value = storage[key]
        lock.unlock()
        return value
    }

    func removeSecret(for key: String) throws {
        lock.lock()
        storage.removeValue(forKey: key)
        lock.unlock()
    }
}
#endif
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_LLMKeyTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_RoutingTests.swift
- bytes: 4119
- lines: 115
- sha256: d49ce7048ea1f4bab336d9fc2dc68c9f206d1d0f8890d161a878a58945d4aec6
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_RoutingTests.swift -->
```swift
import Testing
import CoreData
@testable import PulsumAgents
@testable import PulsumData

struct Gate4_RoutingTests {

    @Test("Fallback picks the max absolute z-score")
    func fallbackUsesMaximumMagnitude() throws {
        let snapshot = try makeSnapshot(features: [
            "z_hrv": -0.4,
            "subj_stress": 0.25,
            "z_sleepDebt": 1.3,
            "subj_energy": 0.1
        ])
        let signal = TopicSignalResolver.dataDominantSignal(from: snapshot)
        #expect(signal == "z_sleepDebt")
    }

    @Test("Fallback ignores unknown feature keys")
    func fallbackIgnoresUnknownKeys() throws {
        let snapshot = try makeSnapshot(features: [
            "custom_window": 9.9,
            "subj_energy": 0.2,
            "z_rr": 0.3
        ])
        let signal = TopicSignalResolver.dataDominantSignal(from: snapshot)
        #expect(signal == "z_rr")
    }

    @Test("Topic override pipeline remains deterministic")
    func topicOverrideDeterministic() throws {
        let snapshot = try makeSnapshot(features: [
            "z_hrv": 0.6,
            "z_rr": 0.6,
            "subj_sleepQuality": -0.1
        ])
        let mapped = TopicSignalResolver.mapTopicToSignalOrDataDominant(topic: "sleep", snapshot: snapshot)
        #expect(mapped == "subj_sleepQuality")

        let fallback = TopicSignalResolver.mapTopicToSignalOrDataDominant(topic: nil, snapshot: snapshot)
        #expect(fallback == "z_hrv")
    }

    @Test("candidateMoments omit detail when source is nil")
    func candidateMomentsHandleNilDetail() async throws {
        let container = TestCoreDataStack.makeContainer()
        let context = container.newBackgroundContext()
        try context.performAndWait {
            let moment = MicroMoment(context: context)
            moment.id = "moment-1"
            moment.title = "Breathing reset"
            moment.shortDescription = "Take three calm breaths."
            moment.detail = nil
            moment.evidenceBadge = "Strong"
            try context.save()
        }

        let stubIndex = RoutingVectorIndexStub(matches: [VectorMatch(id: "moment-1", score: 0.1)])
        let agent = try await MainActor.run {
            try CoachAgent(container: container,
                           vectorIndex: stubIndex,
                           libraryImporter: LibraryImporter(),
                           shouldIngestLibrary: false)
        }
        let candidates = await agent.candidateMoments(for: "stress", limit: 1)
        #expect(candidates.count == 1)
        #expect(candidates.first?.detail == nil)
    }
}

private func makeSnapshot(features: [String: Double]) throws -> FeatureVectorSnapshot {
    let container = TestCoreDataStack.makeContainer()
    let context = container.newBackgroundContext()

    return try context.performAndWaitThrowing {
        let vector = FeatureVector(context: context)
        try context.obtainPermanentIDs(for: [vector])
        return FeatureVectorSnapshot(date: Date(),
                                     wellbeingScore: 0,
                                     contributions: [:],
                                     imputedFlags: [:],
                                     featureVectorObjectID: vector.objectID,
                                     features: features)
    }
}

private extension NSManagedObjectContext {
    func performAndWaitThrowing<T: Sendable>(_ block: @Sendable () throws -> T) throws -> T {
        var result: Result<T, Error>!
        performAndWait {
            result = Result { try block() }
        }
        return try result.get()
    }
}

private actor RoutingVectorIndexStub: VectorIndexProviding {
    private let storedMatches: [VectorMatch]

    init(matches: [VectorMatch]) {
        self.storedMatches = matches
    }

    @discardableResult
    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        []
    }

    func removeMicroMoment(id: String) async throws {}

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] {
        storedMatches
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_RoutingTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_EmbeddingAvailabilityDegradationTests.swift
- bytes: 2835
- lines: 61
- sha256: 0d4efa5cdf9b936300ba9eae06077bee15851a956ea64694d00870178167fbcc
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_EmbeddingAvailabilityDegradationTests.swift -->
```swift
@testable import PulsumAgents
@testable import PulsumData
@testable import PulsumML
import XCTest

@MainActor
// swiftlint:disable:next type_name
final class Gate6_EmbeddingAvailabilityDegradationTests: XCTestCase {
    func testRecommendationsFallbackWhenEmbeddingsUnavailable() async throws {
        let container = TestCoreDataStack.makeContainer()

        // Seed one MicroMoment so keyword fallback has content.
        let viewContext = container.viewContext
        viewContext.performAndWait {
            let moment = MicroMoment(context: viewContext)
            moment.id = "fallback-1"
            moment.title = "Wellbeing reset walk"
            moment.shortDescription = "Take a gentle 10-minute walk to reset."
            moment.detail = "A simple outdoor walk to refresh energy."
            moment.tags = ["wellbeing", "movement"]
            moment.evidenceBadge = "Medium"
            try? viewContext.save()
        }

        let vector = FeatureVector(context: viewContext)
        vector.date = Date()
        try viewContext.save()

        let snapshot = FeatureVectorSnapshot(date: Date(),
                                             wellbeingScore: 0.2,
                                             contributions: ["z_hrv": 0.5],
                                             imputedFlags: [:],
                                             featureVectorObjectID: vector.objectID,
                                             features: ["z_hrv": 0.5])

        let index = UnavailableIndexStub()
        let importer = LibraryImporter(configuration: LibraryImporterConfiguration(bundle: Bundle.pulsumDataResources,
                                                                                  subdirectory: "PulsumDataTests/Resources"),
                                       vectorIndex: index)
        let coach = try CoachAgent(container: container,
                                   vectorIndex: index,
                                   libraryImporter: importer,
                                   shouldIngestLibrary: false)

        let cards = try await coach.recommendationCards(for: snapshot, consentGranted: false)
        XCTAssertFalse(cards.isEmpty, "Fallback recommendations should be returned when embeddings are unavailable.")
        XCTAssertNotNil(coach.recommendationNotice, "A notice should be surfaced when embeddings are unavailable.")
    }
}

private actor UnavailableIndexStub: VectorIndexProviding {
    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        throw EmbeddingError.generatorUnavailable
    }

    func removeMicroMoment(id: String) async throws {}

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] {
        throw EmbeddingError.generatorUnavailable
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_EmbeddingAvailabilityDegradationTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_RecRankerLearningTests.swift
- bytes: 2945
- lines: 76
- sha256: f48fc9710ac617b46050d6fec5e7d684853602339fb6fafe8dadf737f427200b
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_RecRankerLearningTests.swift -->
```swift
import XCTest
@testable import PulsumAgents
@testable import PulsumData
@testable import PulsumML
@testable import PulsumServices

@MainActor
// swiftlint:disable:next type_name
final class Gate6_RecRankerLearningTests: XCTestCase {
    func testCoachAgentAppliesFeedbackToRanking() async throws {
        let container = TestCoreDataStack.makeContainer()
        let vectorIndex = Gate6VectorIndexStub(matches: [
            VectorMatch(id: "A", score: 0.1),
            VectorMatch(id: "B", score: 2.0)
        ])

        let agent = try CoachAgent(container: container,
                                   vectorIndex: vectorIndex,
                                   libraryImporter: LibraryImporter(),
                                   llmGateway: LLMGateway(),
                                   shouldIngestLibrary: false)

        let context = container.viewContext
        let momentA = MicroMoment(context: context)
        momentA.id = "A"
        momentA.title = "Stretch and breathe"
        momentA.shortDescription = "Quick stretch with deep breathing."
        let momentB = MicroMoment(context: context)
        momentB.id = "B"
        momentB.title = "Take a brisk walk"
        momentB.shortDescription = "10-minute outdoor walk."
        try context.save()

        let featureVector = FeatureVector(context: context)
        featureVector.date = Date()
        try context.save()

        let snapshot = FeatureVectorSnapshot(date: Date(),
                                             wellbeingScore: 0.1,
                                             contributions: ["z_hrv": 0.2, "z_sleepDebt": 0.1],
                                             imputedFlags: [:],
                                             featureVectorObjectID: featureVector.objectID,
                                             features: ["z_hrv": 0.6, "z_sleepDebt": -0.4, "subj_energy": 6.0])

        _ = try await agent.recommendationCards(for: snapshot, consentGranted: false)

        try await agent.logEvent(momentId: "A", accepted: false)
        try await agent.logEvent(momentId: "B", accepted: true)
        try await agent.logEvent(momentId: "B", accepted: true)

        let reranked = try await agent.recommendationCards(for: snapshot, consentGranted: false)
        XCTAssertEqual(reranked.first?.id, "B")

        let metrics = agent._testRankerMetrics()
        XCTAssertNotEqual(metrics.weights["bias"], 0)
    }
}

private final class Gate6VectorIndexStub: VectorIndexProviding, @unchecked Sendable {
    var matches: [VectorMatch]

    init(matches: [VectorMatch]) {
        self.matches = matches
    }

    @discardableResult
    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        []
    }

    func removeMicroMoment(id: String) async throws {}

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] {
        matches
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_RecRankerLearningTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_RecRankerPersistenceTests.swift
- bytes: 3207
- lines: 75
- sha256: 4cea9e70e0589a11abc5a9a4cf64135efe2eb1d80e8bbac27b60bb7c0695a7e3
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_RecRankerPersistenceTests.swift -->
```swift
@testable import PulsumAgents
@testable import PulsumData
import PulsumML
import PulsumServices
import XCTest

@MainActor
// swiftlint:disable:next type_name
final class Gate6_RecRankerPersistenceTests: XCTestCase {
    func testRankerStatePersistsAcrossAgentRestarts() async throws {
        let tempDirectory = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        defer { try? FileManager.default.removeItem(at: tempDirectory) }
        let rankerStore = RecRankerStateStore(baseDirectory: tempDirectory)
        let container = TestCoreDataStack.makeContainer()

        let agent = try makeCoachAgent(container: container, rankerStore: rankerStore)

        let initialMetrics = agent._testRankerMetrics()

        let features = [
            RecommendationFeatures(id: "a",
                                   wellbeingScore: 0.2,
                                   evidenceStrength: 0.8,
                                   novelty: 0.5,
                                   cooldown: 0.1,
                                   acceptanceRate: 0.9,
                                   timeCostFit: 0.4,
                                   zScores: ["z_hrv": 0.3]),
            RecommendationFeatures(id: "b",
                                   wellbeingScore: -0.1,
                                   evidenceStrength: 0.4,
                                   novelty: 0.2,
                                   cooldown: 0.2,
                                   acceptanceRate: 0.1,
                                   timeCostFit: 0.6,
                                   zScores: ["z_hrv": -0.4])
        ]

        agent._injectRankedFeaturesForTesting(features)
        try await agent.logEvent(momentId: "a", accepted: true)

        let updatedMetrics = agent._testRankerMetrics()
        XCTAssertNotEqual(updatedMetrics.weights, initialMetrics.weights, "Weights should update after feedback.")

        let restarted = try makeCoachAgent(container: container, rankerStore: rankerStore)
        let restoredMetrics = restarted._testRankerMetrics()

        XCTAssertEqual(restoredMetrics.weights, updatedMetrics.weights)
        XCTAssertEqual(restoredMetrics.learningRate, updatedMetrics.learningRate)
    }

    @MainActor
    private func makeCoachAgent(container: NSPersistentContainer,
                                rankerStore: RecRankerStateStoring) throws -> CoachAgent {
        let vectorIndex = VectorIndexStub()
        return try CoachAgent(container: container,
                              vectorIndex: vectorIndex,
                              libraryImporter: LibraryImporter(),
                              llmGateway: LLMGateway(),
                              shouldIngestLibrary: false,
                              rankerStore: rankerStore)
    }
}

private final class VectorIndexStub: VectorIndexProviding, @unchecked Sendable {
    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        []
    }

    func removeMicroMoment(id: String) async throws {}

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] {
        []
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_RecRankerPersistenceTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_SentimentJournalingFallbackTests.swift
- bytes: 1532
- lines: 41
- sha256: 4194cef5d89dada2fa959e69a9581f34ba15dd8fdf9b0115891ba60b00219cef
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_SentimentJournalingFallbackTests.swift -->
```swift
@testable import PulsumAgents
@testable import PulsumData
import PulsumML
import XCTest

@MainActor
// swiftlint:disable:next type_name
final class Gate6_SentimentJournalingFallbackTests: XCTestCase {
    func testJournalPersistsWhenEmbeddingUnavailable() async throws {
        let container = TestCoreDataStack.makeContainer()
        let embeddingService = EmbeddingService.debugInstance(primary: AlwaysFailEmbeddingProvider())
        let sentimentService = SentimentService(providers: [StubSentimentProvider(score: 0.35)])
        let agent = SentimentAgent(container: container,
                                   sentimentService: sentimentService,
                                   embeddingService: embeddingService)

        let result = try await agent.importTranscript("Testing journal text")

        XCTAssertTrue(result.embeddingPending)
        XCTAssertNil(result.vectorURL)

        let entries = try container.viewContext.fetch(JournalEntry.fetchRequest())
        XCTAssertEqual(entries.count, 1)
        XCTAssertEqual(entries.first?.transcript, PIIRedactor.redact("Testing journal text"))
        XCTAssertNil(entries.first?.embeddedVectorURL)
    }
}

private struct AlwaysFailEmbeddingProvider: TextEmbeddingProviding {
    func embedding(for text: String) throws -> [Float] {
        throw EmbeddingError.generatorUnavailable
    }
}

private struct StubSentimentProvider: SentimentProviding {
    let score: Double

    func sentimentScore(for text: String) async throws -> Double {
        score
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_SentimentJournalingFallbackTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_StateEstimatorPersistenceTests.swift
- bytes: 1887
- lines: 45
- sha256: 96c57f7dd4d32e4f1bf7753fa75ad82fbca44d25adf6cfc601e9eee1be7d6143
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_StateEstimatorPersistenceTests.swift -->
```swift
import XCTest
@testable import PulsumAgents
@testable import PulsumML

// swiftlint:disable:next type_name
final class Gate6_StateEstimatorPersistenceTests: XCTestCase {
    func testEstimatorStatePersistsAcrossInstances() async throws {
        let tempDirectory = FileManager.default.temporaryDirectory
            .appendingPathComponent("gate6-estimator-\(UUID().uuidString)", isDirectory: true)
        try FileManager.default.createDirectory(at: tempDirectory, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: tempDirectory) }

        let estimatorStore = EstimatorStateStore(baseDirectory: tempDirectory)
        let container = TestCoreDataStack.makeContainer()
        let agent = DataAgent(healthKit: HealthKitServiceStub(),
                              container: container,
                              estimatorStore: estimatorStore)

        let featureInput: [String: Double] = [
            "z_hrv": 1.0,
            "z_sleepDebt": -0.8,
            "z_steps": 0.9,
            "subj_energy": 6.0,
            "subj_stress": 2.5,
            "sentiment": 0.4
        ]

        let snapshot = await agent._testUpdateEstimator(features: featureInput)

        guard let persisted = estimatorStore.loadState() else {
            XCTFail("Expected persisted estimator state")
            return
        }

        XCTAssertNotEqual(persisted.weights, StateEstimator.defaultWeights)
        XCTAssertEqual(persisted.bias, snapshot.bias)

        let restarted = DataAgent(healthKit: HealthKitServiceStub(),
                                  container: container,
                                  estimatorStore: estimatorStore)
        let restartedState = await restarted._testEstimatorState()
        XCTAssertEqual(restartedState.weights, persisted.weights)
        XCTAssertEqual(restartedState.bias, persisted.bias)
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_StateEstimatorPersistenceTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_StateEstimatorWeightsAndLabelsTests.swift
- bytes: 2798
- lines: 71
- sha256: eb9741b19e24f56847f1ef91e2739fb1495715c4fa8fac979db3755f9b94e485
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_StateEstimatorWeightsAndLabelsTests.swift -->
```swift
import XCTest
@testable import PulsumAgents
@testable import PulsumML

// swiftlint:disable:next type_name
final class Gate6_StateEstimatorWeightsAndLabelsTests: XCTestCase {
    func testRecoverySignalsLiftScore() {
        let goodRaw: [String: Double] = [
            "z_hrv": 1.5,
            "z_sleepDebt": -1.0,
            "z_steps": 1.1,
            "z_nocthr": -0.8,
            "z_resthr": -0.6,
            "subj_stress": 2.0,
            "subj_energy": 6.5,
            "subj_sleepQuality": 6.0,
            "sentiment": 0.7
        ]
        let badRaw: [String: Double] = [
            "z_hrv": -1.4,
            "z_sleepDebt": 1.2,
            "z_steps": -0.8,
            "z_nocthr": 0.9,
            "z_resthr": 0.7,
            "subj_stress": 6.5,
            "subj_energy": 2.0,
            "subj_sleepQuality": 2.5,
            "sentiment": -0.6
        ]

        let goodFeatures = WellbeingModeling.normalize(features: goodRaw, imputedFlags: [:])
        let badFeatures = WellbeingModeling.normalize(features: badRaw, imputedFlags: [:])

        let estimator = StateEstimator()
        let goodTarget = WellbeingModeling.target(for: goodFeatures)
        let badTarget = WellbeingModeling.target(for: badFeatures)

        let goodSnapshot = estimator.update(features: goodFeatures, target: goodTarget)
        let badSnapshot = estimator.update(features: badFeatures, target: badTarget)

        XCTAssertGreaterThan(goodSnapshot.wellbeingScore, badSnapshot.wellbeingScore)
        XCTAssertGreaterThan(goodSnapshot.contributions["z_hrv"] ?? 0, 0)
        XCTAssertLessThan(badSnapshot.contributions["z_hrv"] ?? 0, 0)
        XCTAssertGreaterThan(goodSnapshot.contributions["z_steps"] ?? 0, badSnapshot.contributions["z_steps"] ?? 0)
        XCTAssertGreaterThan(goodSnapshot.contributions["z_sleepDebt"] ?? 0, 0)
        XCTAssertLessThan(badSnapshot.contributions["z_sleepDebt"] ?? 0, 0)
        XCTAssertGreaterThan(goodSnapshot.contributions["sentiment"] ?? 0, badSnapshot.contributions["sentiment"] ?? 0)
    }

    func testImputedSignalsClampToNeutralContribution() {
        let raw: [String: Double] = [
            "z_hrv": 1.2,
            "z_steps": 1.5,
            "subj_energy": 6.0
        ]
        let imputed = [
            "steps_missing": true,
            "sedentary_missing": true
        ]
        let normalized = WellbeingModeling.normalize(features: raw, imputedFlags: imputed)

        XCTAssertEqual(normalized["z_steps"], 0)
        XCTAssertLessThan(normalized["z_hrv"] ?? 0, 1.2)

        let estimator = StateEstimator()
        let target = WellbeingModeling.target(for: normalized)
        let snapshot = estimator.update(features: normalized, target: target)

        XCTAssertEqual(snapshot.contributions["z_steps"] ?? -1, 0)
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_StateEstimatorWeightsAndLabelsTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_WellbeingBackfillPhasingTests.swift
- bytes: 15443
- lines: 318
- sha256: 7a197bddb51e09ce6fd4b7fcd643dda82866dfbed08c4fc70e35cddfaa7bbe6a
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_WellbeingBackfillPhasingTests.swift -->
```swift
@testable import PulsumAgents
@testable import PulsumData
@testable import PulsumServices
import CoreData
import HealthKit
import XCTest

// swiftlint:disable:next type_name
final class Gate6_WellbeingBackfillPhasingTests: XCTestCase {
    private let calendar = Calendar(identifier: .gregorian)

    func testWarmStartBackfillsFastWindowAndProducesSnapshot() async throws {
        let stub = HealthKitServiceStub()
        TestHealthKitSampleSeeder.authorizeAllTypes(stub)
        TestHealthKitSampleSeeder.populateSamples(stub, days: 35, calendar: calendar)
        let store = BackfillStateStoreSpy()
        let agent = DataAgent(healthKit: stub,
                              container: TestCoreDataStack.makeContainer(),
                              estimatorStore: EstimatorStateStore(),
                              backfillStore: store)

        try await agent.start()

        let today = calendar.startOfDay(for: Date())
        let expectedBootstrapStart = calendar.date(byAdding: .day, value: -1, to: today)!
        var firstRequestByType: [String: (Date, Date)] = [:]
        for request in stub.fetchRequests where firstRequestByType[request.identifier] == nil {
            firstRequestByType[request.identifier] = (request.start, request.end)
        }
        if let steps = stub.dailyStepTotalsRequests.first {
            firstRequestByType[HKQuantityTypeIdentifier.stepCount.rawValue] = (steps.start, steps.end)
        }
        if let nocturnal = stub.nocturnalStatsRequests.first {
            firstRequestByType[HKQuantityTypeIdentifier.heartRate.rawValue] = (nocturnal.start, nocturnal.end)
        }
        XCTAssertEqual(firstRequestByType.count, HealthKitService.orderedReadSampleTypes.count, "Bootstrap should touch each granted type once.")
        for (_, window) in firstRequestByType {
            XCTAssertEqual(calendar.startOfDay(for: window.0), expectedBootstrapStart)
        }

        let snapshot = try await agent.latestFeatureVector()
        XCTAssertNotNil(snapshot, "Warm-start should materialize a feature vector when samples exist in-window.")

        // Allow background warm-start to finish and persist progress.
        let progress = await waitForWarmStart(store: store, agent: agent)
        XCTAssertEqual(progress.warmStartCompletedTypes.count, HealthKitService.orderedReadSampleTypes.count)
        XCTAssertTrue(progress.fullBackfillCompletedTypes.isEmpty, "Background backfill has not completed yet.")
    }

    func testAggregatedStepsAndNocturnalHRUseStatisticsQueries() async throws {
        let stub = HealthKitServiceStub()
        TestHealthKitSampleSeeder.authorizeAllTypes(stub)
        TestHealthKitSampleSeeder.populateSamples(stub, days: 10, calendar: calendar)
        let store = BackfillStateStoreSpy()

        let agent = DataAgent(healthKit: stub,
                              container: TestCoreDataStack.makeContainer(),
                              estimatorStore: EstimatorStateStore(),
                              backfillStore: store)

        try await agent.start()

        XCTAssertGreaterThan(stub.dailyStepTotalsRequests.count, 0, "Step totals should be fetched via HKStatisticsCollectionQuery.")
        XCTAssertGreaterThan(stub.nocturnalStatsRequests.count, 0, "Nocturnal HR should be fetched via HKStatisticsQuery.")
        XCTAssertEqual(stub.fetchRequests.filter { $0.identifier == HKQuantityTypeIdentifier.stepCount.rawValue }.count, 0, "Raw stepCount samples should not be fetched for backfill.")
        XCTAssertEqual(stub.fetchRequests.filter { $0.identifier == HKQuantityTypeIdentifier.heartRate.rawValue }.count, 0, "Raw heartRate samples should not be fetched for nocturnal HR backfill.")
    }

    func testRequestHealthAccessReturnsBeforeWarmStartCompletes() async throws {
        let stub = HealthKitServiceStub()
        stub.fetchDelayNanoseconds = 200_000_000
        TestHealthKitSampleSeeder.authorizeAllTypes(stub)
        TestHealthKitSampleSeeder.populateSamples(stub, days: 35, calendar: calendar)
        let store = BackfillStateStoreSpy()

        let agent = DataAgent(healthKit: stub,
                              container: TestCoreDataStack.makeContainer(),
                              estimatorStore: EstimatorStateStore(),
                              backfillStore: store)

        _ = try await agent.requestHealthAccess()

        let immediateProgress: BackfillProgress
        if let saved = store.loadState() {
            immediateProgress = saved
        } else {
            immediateProgress = await agent._testBackfillProgress()
        }
        XCTAssertLessThan(immediateProgress.warmStartCompletedTypes.count,
                          HealthKitService.orderedReadSampleTypes.count,
                          "Warm start should run in background after requestHealthAccess returns.")

        let snapshot = try await agent.latestFeatureVector()
        XCTAssertNotNil(snapshot, "Bootstrap should materialize a snapshot even while warm start continues.")

        let progress = await waitForWarmStart(store: store, agent: agent)
        XCTAssertEqual(progress.warmStartCompletedTypes.count, HealthKitService.orderedReadSampleTypes.count)
    }

    func testBackgroundBackfillExpandsCoverageAndPersistsAcrossSessions() async throws {
        let stub = HealthKitServiceStub()
        TestHealthKitSampleSeeder.authorizeAllTypes(stub)
        TestHealthKitSampleSeeder.populateSamples(stub, days: 35, calendar: calendar)
        let store = BackfillStateStoreSpy()

        let agent = DataAgent(healthKit: stub,
                              container: TestCoreDataStack.makeContainer(),
                              estimatorStore: EstimatorStateStore(),
                              backfillStore: store)
        try await agent.start()

        _ = await waitForWarmStart(store: store, agent: agent)
        await agent._testRunFullBackfillNow()

        let progress: BackfillProgress
        if let saved = store.loadState() {
            progress = saved
        } else {
            progress = await agent._testBackfillProgress()
        }
        let targetStart = calendar.date(byAdding: .day, value: -(30 - 1), to: calendar.startOfDay(for: Date()))!
        for identifier in HealthKitService.orderedReadSampleTypes.map(\.identifier) {
            XCTAssertTrue(progress.fullBackfillCompletedTypes.contains(identifier), "Full backfill should mark \(identifier) complete.")
            if let earliest = progress.earliestProcessedByType[identifier] {
                XCTAssertLessThanOrEqual(calendar.startOfDay(for: earliest), targetStart)
            }
        }

        let fetchesAfterFullBackfill = totalRequests(for: stub)

        // Simulate app restart; backfill progress should prevent re-running warm start.
        let restartedAgent = DataAgent(healthKit: stub,
                                       container: TestCoreDataStack.makeContainer(),
                                       estimatorStore: EstimatorStateStore(),
                                       backfillStore: store)
        try await restartedAgent.start()

        let bootstrapFetchAllowance = HealthKitService.orderedReadSampleTypes.count
        XCTAssertLessThanOrEqual(totalRequests(for: stub), fetchesAfterFullBackfill + bootstrapFetchAllowance, "Restart should only perform a bootstrap window fetch per type.")
    }

    func testBootstrapFallbackFindsOlderDataWhenRecentWindowIsEmpty() async throws {
        let stub = HealthKitServiceStub()
        TestHealthKitSampleSeeder.authorizeAllTypes(stub)
        TestHealthKitSampleSeeder.populateSamples(stub, days: 5, calendar: calendar)

        // Remove samples from the last two days so the 2-day bootstrap window is empty.
        let today = calendar.startOfDay(for: Date())
        let cutoff = calendar.date(byAdding: .day, value: -2, to: today)!
        for (key, samples) in stub.fetchedSamples {
            let filtered = samples.filter { $0.startDate < cutoff }
            stub.fetchedSamples[key] = filtered
        }

        let store = BackfillStateStoreSpy()
        let agent = DataAgent(healthKit: stub,
                              container: TestCoreDataStack.makeContainer(),
                              estimatorStore: EstimatorStateStore(),
                              backfillStore: store)

        try await agent.start()

        let snapshot = try await agent.latestFeatureVector()
        XCTAssertNotNil(snapshot, "Fallback bootstrap should materialize a snapshot even when the 2-day window is empty.")
        if let snapshot {
            XCTAssertLessThan(snapshot.date, cutoff, "Snapshot should come from the most recent day with data before the bootstrap window.")
        }
    }

    func testSleepDebtMissingDataIsImputedButScoreStillComputes() async throws {
        let stub = HealthKitServiceStub()
        TestHealthKitSampleSeeder.authorizeAllTypes(stub)
        TestHealthKitSampleSeeder.populateSamples(stub, days: 5, calendar: calendar)
        stub.fetchedSamples[HKCategoryTypeIdentifier.sleepAnalysis.rawValue] = []
        let store = BackfillStateStoreSpy()

        let agent = DataAgent(healthKit: stub,
                              container: TestCoreDataStack.makeContainer(),
                              estimatorStore: EstimatorStateStore(),
                              backfillStore: store)
        try await agent.start()

        let snapshot = try await agent.latestFeatureVector()
        XCTAssertNotNil(snapshot)
        XCTAssertEqual(snapshot?.imputedFlags["sleepDebt_missing"], true)
    }

    @MainActor
    func testOverlappingBackfillDoesNotInflateSleepTotals() async throws {
        let stub = HealthKitServiceStub()
        TestHealthKitSampleSeeder.authorizeAllTypes(stub)
        let container = TestCoreDataStack.makeContainer()
        let store = BackfillStateStoreSpy()
        let agent = DataAgent(healthKit: stub,
                              container: container,
                              estimatorStore: EstimatorStateStore(),
                              backfillStore: store)

        let day = calendar.startOfDay(for: Date())
        let sleepType = HKObjectType.categoryType(forIdentifier: .sleepAnalysis)!
        let sleepStart = calendar.date(byAdding: .hour, value: 22, to: day)!
        let sleepEnd = calendar.date(byAdding: .hour, value: 30, to: day)!
        let sample = HKCategorySample(type: sleepType,
                                      value: HKCategoryValueSleepAnalysis.asleepCore.rawValue,
                                      start: sleepStart,
                                      end: sleepEnd)

        try await agent._testProcessCategorySamples([sample], type: sleepType)
        let firstSnapshotValue = try await agent.latestFeatureVector()
        let firstSnapshot = try XCTUnwrap(firstSnapshotValue)
        let firstMetricsValue = try fetchMetrics(for: day, container: container)
        let firstMetrics = try XCTUnwrap(firstMetricsValue)
        let firstFlags = try XCTUnwrap(decodeFlags(from: firstMetrics))

        try await agent._testProcessCategorySamples([sample], type: sleepType)
        let secondSnapshotValue = try await agent.latestFeatureVector()
        let secondSnapshot = try XCTUnwrap(secondSnapshotValue)
        let secondMetricsValue = try fetchMetrics(for: day, container: container)
        let secondMetrics = try XCTUnwrap(secondMetricsValue)
        let secondFlags = try XCTUnwrap(decodeFlags(from: secondMetrics))

        let expectedDuration = sleepEnd.timeIntervalSince(sleepStart)
        let firstAggregated = try XCTUnwrap(firstFlags.aggregatedSleepDurationSeconds)
        let secondAggregated = try XCTUnwrap(secondFlags.aggregatedSleepDurationSeconds)
        XCTAssertEqual(firstAggregated, expectedDuration, accuracy: 0.5)
        XCTAssertEqual(secondAggregated, expectedDuration, accuracy: 0.5)
        XCTAssertEqual(firstFlags.sleepSegments.count, 1)
        XCTAssertEqual(secondFlags.sleepSegments.count, 1)
        XCTAssertEqual(Set(firstFlags.sleepSegments.map(\.id)).count, 1)
        XCTAssertEqual(Set(secondFlags.sleepSegments.map(\.id)).count, 1)

        let firstTotal = try XCTUnwrap(firstMetrics.totalSleepTime?.doubleValue)
        let secondTotal = try XCTUnwrap(secondMetrics.totalSleepTime?.doubleValue)
        XCTAssertEqual(firstTotal, expectedDuration, accuracy: 0.5)
        XCTAssertEqual(secondTotal, expectedDuration, accuracy: 0.5)
        XCTAssertEqual(firstMetrics.sleepDebt?.doubleValue, secondMetrics.sleepDebt?.doubleValue)
        XCTAssertEqual(firstSnapshot.features, secondSnapshot.features)
        XCTAssertEqual(firstSnapshot.wellbeingScore, secondSnapshot.wellbeingScore, accuracy: 0.0001)
    }

    // MARK: - Helpers

    @MainActor
    private func fetchMetrics(for day: Date, container: NSPersistentContainer) throws -> DailyMetrics? {
        let request = DailyMetrics.fetchRequest()
        request.predicate = NSPredicate(format: "date == %@", day as NSDate)
        request.fetchLimit = 1
        return try container.viewContext.fetch(request).first
    }

    private func decodeFlags(from metrics: DailyMetrics) -> TestDailyFlags? {
        guard let payload = metrics.flags?.data(using: .utf8) else { return nil }
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        return try? decoder.decode(TestDailyFlags.self, from: payload)
    }


    private func totalRequests(for stub: HealthKitServiceStub) -> Int {
        stub.fetchRequests.count + stub.dailyStepTotalsRequests.count + stub.nocturnalStatsRequests.count
    }

    private func waitForWarmStart(store: BackfillStateStoreSpy, agent: DataAgent) async -> BackfillProgress {
        let requiredCount = HealthKitService.orderedReadSampleTypes.count
        for _ in 0..<40 {
            if let saved = store.loadState(), saved.warmStartCompletedTypes.count == requiredCount {
                return saved
            }
            let progress = await agent._testBackfillProgress()
            if progress.warmStartCompletedTypes.count == requiredCount {
                return progress
            }
            try? await Task.sleep(nanoseconds: 50_000_000)
        }
        if let saved = store.loadState() {
            return saved
        }
        return await agent._testBackfillProgress()
    }
}

final class BackfillStateStoreSpy: BackfillStateStoring, @unchecked Sendable {
    private let lock = NSLock()
    private var _savedState: BackfillProgress?
    private var _loadStateReturn: BackfillProgress?

    var savedState: BackfillProgress? {
        lock.lock(); defer { lock.unlock() }
        return _savedState
    }

    var loadStateReturn: BackfillProgress? {
        get { lock.lock(); defer { lock.unlock() }; return _loadStateReturn }
        set { lock.lock(); defer { lock.unlock() }; _loadStateReturn = newValue }
    }

    func loadState() -> BackfillProgress? {
        lock.lock(); defer { lock.unlock() }
        return _loadStateReturn ?? _savedState
    }

    func saveState(_ state: BackfillProgress) {
        lock.lock(); defer { lock.unlock() }
        _savedState = state
    }
}

private struct TestDailyFlags: Codable {
    let aggregatedSleepDurationSeconds: Double?
    let sleepSegments: [TestSleepSegment]
}

private struct TestSleepSegment: Codable, Hashable {
    let id: UUID
    let start: Date
    let end: Date
    let stage: String
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_WellbeingBackfillPhasingTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_WellbeingStateMappingTests.swift
- bytes: 2119
- lines: 42
- sha256: 54596204bf31b12cadca4ad260b1ae2a382413f849b0d3dcddef42c89e29f38e
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_WellbeingStateMappingTests.swift -->
```swift
@testable import PulsumAgents
@testable import PulsumServices
import HealthKit
import XCTest

// swiftlint:disable:next type_name
final class Gate6_WellbeingStateMappingTests: XCTestCase {
    func testComputeWellbeingStateMatchesHealthAccess() {
        let required = HealthKitService.orderedReadSampleTypes
        let unavailable = HealthAccessStatus(required: required,
                                             granted: [],
                                             denied: [],
                                             notDetermined: [],
                                             availability: .unavailable(reason: "simulator"))
        XCTAssertEqual(AgentOrchestrator.computeWellbeingState(for: unavailable),
                       .noData(.healthDataUnavailable))

        let pending = HealthAccessStatus(required: required,
                                         granted: [],
                                         denied: [],
                                         notDetermined: Set(required),
                                         availability: .available)
        XCTAssertEqual(AgentOrchestrator.computeWellbeingState(for: pending),
                       .noData(.permissionsDeniedOrPending))

        let denied = HealthAccessStatus(required: required,
                                        granted: [],
                                        denied: Set(required),
                                        notDetermined: [],
                                        availability: .available)
        XCTAssertEqual(AgentOrchestrator.computeWellbeingState(for: denied),
                       .noData(.permissionsDeniedOrPending))

        let granted = HealthAccessStatus(required: required,
                                         granted: Set(required),
                                         denied: [],
                                         notDetermined: [],
                                         availability: .available)
        XCTAssertEqual(AgentOrchestrator.computeWellbeingState(for: granted),
                       .noData(.insufficientSamples))
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_WellbeingStateMappingTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate7_FirstRunWatchdogTests.swift
- bytes: 4542
- lines: 93
- sha256: e29e52e0a3e647c1e7478cfb611c72d3807bb2244b940977e3ed07991328036b
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate7_FirstRunWatchdogTests.swift -->
```swift
@testable import PulsumAgents
@testable import PulsumData
import PulsumTypes
import XCTest

final class Gate7_FirstRunWatchdogTests: XCTestCase {
    func testWatchdogPublishesPlaceholderWhenBootstrapTimesOut() async throws {
        let stub = HealthKitServiceStub()
        TestHealthKitSampleSeeder.authorizeAllTypes(stub)
        stub.fetchDelayNanoseconds = 300_000_000

        let policy = DataAgentBootstrapPolicy(bootstrapTimeoutSeconds: 0.05,
                                              heartRateTimeoutSeconds: 0.05,
                                              backfillTimeoutSeconds: 0.05,
                                              placeholderDeadlineSeconds: 0.2,
                                              retryDelaySeconds: 0.1,
                                              retryTimeoutSeconds: 0.3,
                                              retryMaxAttempts: 1,
                                              retryMaxElapsedSeconds: 1)
        let agent = DataAgent(healthKit: stub,
                              container: TestCoreDataStack.makeContainer(),
                              estimatorStore: EstimatorStateStore(),
                              backfillStore: BackfillStateStore(),
                              bootstrapPolicy: policy)

        let startTask = Task { try await agent.start() }

        let placeholderSnapshot = await waitForSnapshot(agent: agent,
                                                        timeout: 0.6,
                                                        predicate: { SnapshotPlaceholder.isPlaceholder($0) })
        XCTAssertNotNil(placeholderSnapshot, "Placeholder snapshot should be created within the watchdog deadline.")

        let startResult = try await withHardTimeout(seconds: 1.0) {
            try await startTask.value
            return true
        }
        switch startResult {
        case .timedOut:
            XCTFail("DataAgent.start should return without hanging.")
        case .value:
            break
        }
    }

    func testRetryPublishesRealSnapshotAfterTimeout() async throws {
        let stub = HealthKitServiceStub()
        TestHealthKitSampleSeeder.authorizeAllTypes(stub)
        TestHealthKitSampleSeeder.populateSamples(stub, days: 2)
        stub.fetchDelayNanoseconds = 50_000_000

        let policy = DataAgentBootstrapPolicy(bootstrapTimeoutSeconds: 0.03,
                                              heartRateTimeoutSeconds: 0.03,
                                              backfillTimeoutSeconds: 0.03,
                                              placeholderDeadlineSeconds: 0.05,
                                              retryDelaySeconds: 0.1,
                                              retryTimeoutSeconds: 0.3,
                                              retryMaxAttempts: 1,
                                              retryMaxElapsedSeconds: 1)
        let agent = DataAgent(healthKit: stub,
                              container: TestCoreDataStack.makeContainer(),
                              estimatorStore: EstimatorStateStore(),
                              backfillStore: BackfillStateStore(),
                              bootstrapPolicy: policy)

        let startTask = Task { try await agent.start() }

        let placeholderSnapshot = await waitForSnapshot(agent: agent,
                                                        timeout: 0.4,
                                                        predicate: { SnapshotPlaceholder.isPlaceholder($0) })
        XCTAssertNotNil(placeholderSnapshot, "Placeholder should publish after the initial timeout.")

        let realSnapshot = await waitForSnapshot(agent: agent,
                                                 timeout: 1.2,
                                                 predicate: { !SnapshotPlaceholder.isPlaceholder($0) })
        XCTAssertNotNil(realSnapshot, "Retry should materialize a real snapshot.")

        _ = try await startTask.value
    }

    private func waitForSnapshot(agent: DataAgent,
                                 timeout: TimeInterval,
                                 predicate: @escaping (FeatureVectorSnapshot) -> Bool) async -> FeatureVectorSnapshot? {
        let deadline = Date().addingTimeInterval(timeout)
        while Date() < deadline {
            if let snapshot = try? await agent.latestFeatureVector(), predicate(snapshot) {
                return snapshot
            }
            try? await Task.sleep(nanoseconds: 20_000_000)
        }
        return nil
    }

}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate7_FirstRunWatchdogTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/HealthKitServiceStub.swift
- bytes: 5672
- lines: 123
- sha256: 041bf10264a57b1b8cb1c75f9c33b56b23869349d0c61f90cdc48eb1207f4a5c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/HealthKitServiceStub.swift -->
```swift
import Foundation
import HealthKit
@testable import PulsumServices

final class HealthKitServiceStub: HealthKitServicing, @unchecked Sendable {
    var isHealthDataAvailable: Bool = true
    private(set) var observedIdentifiers: [String] = []
    private(set) var stoppedIdentifiers: [String] = []
    private(set) var backgroundRequests: [Set<String>] = []
    var authorizationStatuses: [String: HKAuthorizationStatus] = [:]
    var requestAuthorizationStatus: HKAuthorizationRequestStatus? = .unnecessary
    var availabilityReason: String = "Unavailable"
    var fetchedSamples: [String: [HKSample]] = [:]
    private(set) var fetchRequests: [(identifier: String, start: Date, end: Date)] = []
    private(set) var dailyStepTotalsRequests: [(start: Date, end: Date)] = []
    private(set) var nocturnalStatsRequests: [(start: Date, end: Date)] = []
    var fetchDelayNanoseconds: UInt64 = 0
    var readProbeResults: [String: ReadAuthorizationProbeResult] = [:]

    func requestAuthorization() async throws {}

    func requestStatusForAuthorization(readTypes: Set<HKSampleType>) async -> HKAuthorizationRequestStatus? {
        requestAuthorizationStatus
    }

    func probeReadAuthorization(for type: HKSampleType) async -> ReadAuthorizationProbeResult {
        readProbeResults[type.identifier] ?? .authorized
    }

    func probeReadAuthorization(for types: [HKSampleType]) async -> [HKSampleType: ReadAuthorizationProbeResult] {
        var results: [HKSampleType: ReadAuthorizationProbeResult] = [:]
        for type in types {
            results[type] = await probeReadAuthorization(for: type)
        }
        return results
    }

    func fetchDailyStepTotals(startDate: Date, endDate: Date) async throws -> [Date: Int] {
        dailyStepTotalsRequests.append((startDate, endDate))
        if fetchDelayNanoseconds > 0 {
            try await Task.sleep(nanoseconds: fetchDelayNanoseconds)
        }

        let calendar = Calendar(identifier: .gregorian)
        let samples = fetchedSamples[HKQuantityTypeIdentifier.stepCount.rawValue] ?? []
        let quantitySamples = samples.compactMap { $0 as? HKQuantitySample }
        var totals: [Date: Int] = [:]
        for sample in quantitySamples where sample.startDate >= startDate && sample.startDate < endDate {
            let day = calendar.startOfDay(for: sample.startDate)
            let value = sample.quantity.doubleValue(for: HKUnit.count())
            totals[day, default: 0] += Int(value)
        }
        return totals
    }

    func fetchNocturnalHeartRateStats(startDate: Date, endDate: Date) async throws -> [Date: (avgBPM: Double, minBPM: Double?)] {
        nocturnalStatsRequests.append((startDate, endDate))
        if fetchDelayNanoseconds > 0 {
            try await Task.sleep(nanoseconds: fetchDelayNanoseconds)
        }

        let calendar = Calendar(identifier: .gregorian)
        let samples = fetchedSamples[HKQuantityTypeIdentifier.heartRate.rawValue] ?? []
        let quantitySamples = samples
            .compactMap { $0 as? HKQuantitySample }
            .filter { $0.startDate >= startDate && $0.startDate < endDate }
        var result: [Date: (avgBPM: Double, minBPM: Double?)] = [:]

        var day = calendar.startOfDay(for: startDate)
        let endDay = calendar.startOfDay(for: endDate)
        while day < endDay {
            guard let nextDay = calendar.date(byAdding: .day, value: 1, to: day) else { break }
            let nightStart = calendar.date(bySettingHour: 22, minute: 0, second: 0, of: day) ?? day
            let nightEnd = calendar.date(bySettingHour: 8, minute: 0, second: 0, of: nextDay) ?? nextDay
            let values = quantitySamples.compactMap { sample -> Double? in
                guard sample.startDate >= nightStart && sample.startDate < nightEnd else { return nil }
                return sample.quantity.doubleValue(for: HKUnit.count().unitDivided(by: .minute()))
            }
            if !values.isEmpty {
                let avg = values.reduce(0, +) / Double(values.count)
                result[day] = (avgBPM: avg, minBPM: values.min())
            }
            day = nextDay
        }

        return result
    }

    func fetchSamples(for sampleType: HKSampleType, startDate: Date, endDate: Date) async throws -> [HKSample] {
        fetchRequests.append((sampleType.identifier, startDate, endDate))
        if fetchDelayNanoseconds > 0 {
            try await Task.sleep(nanoseconds: fetchDelayNanoseconds)
        }
        let samples = fetchedSamples[sampleType.identifier] ?? []
        return samples.filter { $0.startDate >= startDate && $0.startDate < endDate }
    }

    func enableBackgroundDelivery(for types: Set<HKSampleType>) async throws {
        backgroundRequests.append(Set(types.map(\.identifier)))
    }

    func enableBackgroundDelivery() async throws {
        try await enableBackgroundDelivery(for: HealthKitService.readSampleTypes)
    }

    @discardableResult
    func observeSampleType(_ sampleType: HKSampleType,
                           predicate: NSPredicate? = nil,
                           updateHandler: @escaping HealthKitService.AnchoredUpdateHandler) throws -> HealthKitObservationToken {
        observedIdentifiers.append(sampleType.identifier)
        return StubObservationToken()
    }

    func stopObserving(sampleType: HKSampleType, resetAnchor: Bool) {
        stoppedIdentifiers.append(sampleType.identifier)
    }

    func authorizationStatus(for sampleType: HKSampleType) -> HKAuthorizationStatus {
        authorizationStatuses[sampleType.identifier] ?? .notDetermined
    }

    final class StubObservationToken: HealthKitObservationToken {}
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/HealthKitServiceStub.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/LibraryImportRetryTests.swift
- bytes: 2206
- lines: 61
- sha256: 8c1978fd27c9d00c9d7803e8c903005d4658a4a250f07e0221b9c16853f1fd21
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/LibraryImportRetryTests.swift -->
```swift
import CoreData
import XCTest
import PulsumData
import PulsumML
@testable import PulsumAgents

@MainActor
final class LibraryImportRetryTests: XCTestCase {
    func testRetryDeferredLibraryImportSkipsWhenNotDeferred() async throws {
        let sourceName = "library_retry_test.json"
        try await purgeLibraryIngestRecords(source: sourceName)

        let vectorIndex = CountingVectorIndex()
        let config = LibraryImporterConfiguration(bundle: Bundle.module,
                                                  subdirectory: nil,
                                                  fileExtension: "json")
        let importer = LibraryImporter(configuration: config,
                                       vectorIndex: vectorIndex)
        let container = TestCoreDataStack.makeContainer()
        let coachAgent = try CoachAgent(container: container,
                                        vectorIndex: vectorIndex,
                                        libraryImporter: importer,
                                        shouldIngestLibrary: true)

        await coachAgent.retryDeferredLibraryImport()

        let count = await vectorIndex.upsertCount
        XCTAssertEqual(count, 0)
    }
}

private actor CountingVectorIndex: VectorIndexProviding {
    private(set) var upsertCount = 0

    @discardableResult
    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        upsertCount += 1
        return []
    }

    func removeMicroMoment(id: String) async throws {}

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] {
        []
    }
}

private func purgeLibraryIngestRecords(source: String) async throws {
    let context = PulsumData.newBackgroundContext(name: "Pulsum.Tests.LibraryImportRetry")
    try await context.perform {
        let request: NSFetchRequest<LibraryIngest> = LibraryIngest.fetchRequest()
        request.predicate = NSPredicate(format: "source == %@", source)
        let results = try context.fetch(request)
        for ingest in results {
            context.delete(ingest)
        }
        if context.hasChanges {
            try context.save()
        }
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/LibraryImportRetryTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/RecommendationsTimeoutTests.swift
- bytes: 5795
- lines: 134
- sha256: 5394680057c795434d9eb4886bac34728d1ccbec256f0bbc20b2b3021edc0cff
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/RecommendationsTimeoutTests.swift -->
```swift
import CoreData
import XCTest
import HealthKit
import PulsumData
import PulsumML
import PulsumTypes
@testable import PulsumAgents

@MainActor
final class RecommendationsTimeoutTests: XCTestCase {
    func testRecommendationsTimeoutReturnsFallback() async throws {
        let container = TestCoreDataStack.makeContainer()
        let snapshot = try makeSnapshot(container: container)
        let dataAgent = DataAgentStub(snapshot: snapshot)
        let slowIndex = SlowVectorIndex(delayNanoseconds: 200_000_000)
        let coachAgent = try CoachAgent(container: container,
                                        vectorIndex: slowIndex,
                                        shouldIngestLibrary: false)
        let orchestrator = AgentOrchestrator(dataAgent: dataAgent,
                                             sentimentAgent: SentimentAgentStub(),
                                             coachAgent: coachAgent,
                                             safetyAgent: SafetyAgent(),
                                             cheerAgent: CheerAgent(),
                                             topicGate: TopicGateStub(),
                                             afmAvailable: false,
                                             recommendationsTimeoutSeconds: 0.05)

        let response = try await orchestrator.recommendations(consentGranted: false)

        XCTAssertTrue(response.cards.isEmpty)
        XCTAssertEqual(response.notice,
                       "Recommendations are taking longer than expected. Try refreshing again soon.")
        XCTAssertEqual(response.wellbeingScore, snapshot.wellbeingScore, accuracy: 0.0001)
        if case .ready = response.wellbeingState {
        } else {
            XCTFail("Expected wellbeing state to remain ready on timeout.")
        }
    }

    private func makeSnapshot(container: NSPersistentContainer) throws -> FeatureVectorSnapshot {
        let context = container.viewContext
        let feature = FeatureVector(context: context)
        feature.date = Date()
        feature.zSteps = 0.1
        try context.save()

        return FeatureVectorSnapshot(date: feature.date,
                                     wellbeingScore: 0.55,
                                     contributions: ["z_steps": 0.1],
                                     imputedFlags: [:],
                                     featureVectorObjectID: feature.objectID,
                                     features: ["z_steps": 0.1])
    }
}

// MARK: - Test doubles

private actor DataAgentStub: DataAgentProviding {
    private let snapshot: FeatureVectorSnapshot?
    private let healthStatus: HealthAccessStatus

    init(snapshot: FeatureVectorSnapshot?) {
        self.snapshot = snapshot
        self.healthStatus = HealthAccessStatus(required: [] as [HKSampleType],
                                               granted: [],
                                               denied: [],
                                               notDetermined: [],
                                               availability: .available)
    }

    func start() async throws {}
    func setDiagnosticsTraceId(_ traceId: UUID?) async {}
    func latestFeatureVector() async throws -> FeatureVectorSnapshot? { snapshot }
    func recordSubjectiveInputs(date: Date, stress: Double, energy: Double, sleepQuality: Double) async throws {}
    func scoreBreakdown() async throws -> ScoreBreakdown? { nil }
    func reprocessDay(date: Date) async throws {}
    func currentHealthAccessStatus() async -> HealthAccessStatus { healthStatus }
    func requestHealthAccess() async throws -> HealthAccessStatus { healthStatus }
    func restartIngestionAfterPermissionsChange() async throws -> HealthAccessStatus { healthStatus }
    func diagnosticsBackfillCounts() async -> (warmCompleted: Int, fullCompleted: Int) {
        (warmCompleted: 0, fullCompleted: 0)
    }
    func latestSnapshotMetadata() async -> (dayString: String?, score: Double?) {
        (dayString: nil, score: snapshot?.wellbeingScore)
    }
}

@MainActor
private final class SentimentAgentStub: SentimentAgentProviding {
    var audioLevels: AsyncStream<Float>? { nil }
    var speechStream: AsyncThrowingStream<SpeechSegment, Error>? { nil }

    func beginVoiceJournal(maxDuration: TimeInterval) async throws {}
    func finishVoiceJournal(transcript: String?) async throws -> JournalResult {
        throw SentimentAgentError.noActiveRecording
    }
    func recordVoiceJournal(maxDuration: TimeInterval) async throws -> JournalResult {
        throw SentimentAgentError.noActiveRecording
    }
    func importTranscript(_ transcript: String) async throws -> JournalResult {
        throw SentimentAgentError.noActiveRecording
    }
    func requestAuthorization() async throws {}
    func stopRecording() {}
    func updateTranscript(_ transcript: String) {}
    func latestTranscriptSnapshot() -> String { "" }
    func reprocessPendingJournals(traceId: UUID?) async {}
    func pendingEmbeddingCount() async -> Int { 0 }
}

private struct TopicGateStub: TopicGateProviding {
    func classify(_ text: String) async throws -> GateDecision {
        GateDecision(isOnTopic: true, reason: "stub", confidence: 0.99, topic: nil)
    }
}

private actor SlowVectorIndex: VectorIndexProviding {
    private let delayNanoseconds: UInt64

    init(delayNanoseconds: UInt64) {
        self.delayNanoseconds = delayNanoseconds
    }

    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        []
    }

    func removeMicroMoment(id: String) async throws {}

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] {
        try await Task.sleep(nanoseconds: delayNanoseconds)
        return []
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/RecommendationsTimeoutTests.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/Resources/library_retry_test.json
- bytes: 513
- lines: 20
- sha256: d62f66ae6ad5b1f4a2a9c59217afad86b11d3d54d231ddabc2d1aff588b618fe
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Resources/library_retry_test.json -->
```text
[
  {
    "episodeNumber": "0",
    "episodeTitle": "Test Episode",
    "recommendations": [
      {
        "recommendation": "Test recommendation",
        "shortDescription": "Short description",
        "detailedDescription": "Detailed description",
        "microActivity": "Test activity",
        "researchLink": "https://example.com",
        "difficultyLevel": "easy",
        "timeToComplete": "5 min",
        "tags": ["test"],
        "category": "test",
        "cooldownSec": 60
      }
    ]
  }
]
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/Resources/library_retry_test.json -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/TestCoreDataStack.swift
- bytes: 904
- lines: 32
- sha256: 1a9915c3b7605ab3d33c2c91eeb4f00ed83adedfb8eadedaa0db15c268d65944
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/TestCoreDataStack.swift -->
```swift
import Foundation
import CoreData
@testable import PulsumData

public final class TestCoreDataStack {
    public static func makeContainer() -> NSPersistentContainer {
        let container = NSPersistentContainer(name: "Pulsum", managedObjectModel: PulsumManagedObjectModel.shared)
        
        let description = NSPersistentStoreDescription()
        description.type = NSInMemoryStoreType
        description.shouldAddStoreAsynchronously = false
        container.persistentStoreDescriptions = [description]
        
        container.loadPersistentStores { _, error in
            if let error {
                fatalError("Test Core Data store error: \(error)")
            }
        }
        
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
        return container
    }
}








```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/TestCoreDataStack.swift -->

### Packages/PulsumAgents/Tests/PulsumAgentsTests/TestHealthKitSampleSeeder.swift
- bytes: 5333
- lines: 92
- sha256: da5a0a61d168d4bbac16ba0381a98c8a8c9613dde8f10ca7e59e8e40d378d7fb
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/TestHealthKitSampleSeeder.swift -->
```swift
@testable import PulsumServices
import HealthKit

enum TestHealthKitSampleSeeder {
    static func authorizeAllTypes(_ stub: HealthKitServiceStub) {
        for type in HealthKitService.orderedReadSampleTypes {
            stub.authorizationStatuses[type.identifier] = .sharingAuthorized
            stub.readProbeResults[type.identifier] = .authorized
        }
    }

    static func populateSamples(_ stub: HealthKitServiceStub,
                                days: Int,
                                calendar: Calendar = Calendar(identifier: .gregorian)) {
        let today = calendar.startOfDay(for: Date())
        for offset in 0..<days {
            let dayStart = calendar.date(byAdding: .day, value: -offset, to: today) ?? today
            let sleepStart = calendar.date(byAdding: .hour, value: 22, to: dayStart) ?? dayStart
            let sleepEnd = calendar.date(byAdding: .hour, value: 32, to: dayStart) ?? dayStart.addingTimeInterval(32 * 3600)
            for type in HealthKitService.orderedReadSampleTypes {
                switch type {
                case let quantity as HKQuantityType:
                    appendQuantitySample(type: quantity,
                                         dayStart: dayStart,
                                         sleepStart: sleepStart,
                                         sleepEnd: sleepEnd,
                                         offset: offset,
                                         stub: stub)
                case let category as HKCategoryType:
                    let sleep = HKCategorySample(type: category,
                                                 value: HKCategoryValueSleepAnalysis.asleepCore.rawValue,
                                                 start: sleepStart,
                                                 end: sleepEnd)
                    append(sample: sleep, to: stub, identifier: category.identifier)
                default:
                    break
                }
            }
        }
    }

    private static func appendQuantitySample(type: HKQuantityType,
                                             dayStart: Date,
                                             sleepStart: Date,
                                             sleepEnd: Date,
                                             offset: Int,
                                             stub: HealthKitServiceStub) {
        let identifier = type.identifier
        switch identifier {
        case HKQuantityTypeIdentifier.heartRateVariabilitySDNN.rawValue:
            let quantity = HKQuantity(unit: HKUnit.secondUnit(with: .milli), doubleValue: 50 + Double(offset % 5))
            let sample = HKQuantitySample(type: type, quantity: quantity, start: sleepStart, end: sleepStart.addingTimeInterval(60))
            append(sample: sample, to: stub, identifier: identifier)
        case HKQuantityTypeIdentifier.heartRate.rawValue:
            let quantity = HKQuantity(unit: HKUnit.count().unitDivided(by: HKUnit.minute()), doubleValue: 58 + Double(offset % 3))
            let sample = HKQuantitySample(type: type,
                                          quantity: quantity,
                                          start: sleepStart.addingTimeInterval(3600),
                                          end: sleepStart.addingTimeInterval(3660))
            append(sample: sample, to: stub, identifier: identifier)
        case HKQuantityTypeIdentifier.restingHeartRate.rawValue:
            let quantity = HKQuantity(unit: HKUnit.count().unitDivided(by: HKUnit.minute()), doubleValue: 55 + Double(offset % 2))
            let sample = HKQuantitySample(type: type,
                                          quantity: quantity,
                                          start: dayStart.addingTimeInterval(9 * 3600),
                                          end: dayStart.addingTimeInterval(9 * 3600 + 60))
            append(sample: sample, to: stub, identifier: identifier)
        case HKQuantityTypeIdentifier.respiratoryRate.rawValue:
            let quantity = HKQuantity(unit: HKUnit.count().unitDivided(by: HKUnit.minute()), doubleValue: 14 + Double(offset % 2))
            let sample = HKQuantitySample(type: type,
                                          quantity: quantity,
                                          start: sleepStart.addingTimeInterval(7200),
                                          end: sleepStart.addingTimeInterval(7260))
            append(sample: sample, to: stub, identifier: identifier)
        case HKQuantityTypeIdentifier.stepCount.rawValue:
            let quantity = HKQuantity(unit: HKUnit.count(), doubleValue: 6000 + Double(offset * 10))
            let sample = HKQuantitySample(type: type,
                                          quantity: quantity,
                                          start: dayStart.addingTimeInterval(12 * 3600),
                                          end: dayStart.addingTimeInterval(13 * 3600))
            append(sample: sample, to: stub, identifier: identifier)
        default:
            break
        }
    }

    private static func append(sample: HKSample, to stub: HealthKitServiceStub, identifier: String) {
        var existing = stub.fetchedSamples[identifier] ?? []
        existing.append(sample)
        stub.fetchedSamples[identifier] = existing
    }
}
```
<!-- END_FILE: Packages/PulsumAgents/Tests/PulsumAgentsTests/TestHealthKitSampleSeeder.swift -->

### Packages/PulsumData/Package.swift
- bytes: 1075
- lines: 43
- sha256: 2a77681c4a020e32825574b060b9b37bf45e13f2cd6da639cc3a7cb2b23c3491
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Package.swift -->
```swift
// swift-tools-version: 6.1
import PackageDescription

let package = Package(
    name: "PulsumData",
    platforms: [
        .iOS("26.0"),
        .macOS(.v14)
    ],
    products: [
        .library(
            name: "PulsumData",
            targets: ["PulsumData"]
        )
    ],
    dependencies: [
        .package(path: "../PulsumML"),
        .package(path: "../PulsumTypes")
    ],
    targets: [
        .target(
            name: "PulsumData",
            dependencies: [
                "PulsumML",
                "PulsumTypes"
            ],
            path: "Sources",
            resources: [
                .process("PulsumData/PrivacyInfo.xcprivacy"),
                .process("PulsumData/Resources/Pulsum.xcdatamodeld"),
                .process("PulsumData/Resources/PulsumCompiled.momd")
            ]
        ),
        .testTarget(
            name: "PulsumDataTests",
            dependencies: ["PulsumData"],
            path: "Tests",
            resources: [
                .copy("PulsumDataTests/Resources")
            ]
        )
    ]
)
```
<!-- END_FILE: Packages/PulsumData/Package.swift -->

### Packages/PulsumData/Sources/PulsumData/Bundle+PulsumDataResources.swift
- bytes: 295
- lines: 14
- sha256: b32d5928b631458b4653196231818ab014c64b661427abbab75591cdd6b90093
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Sources/PulsumData/Bundle+PulsumDataResources.swift -->
```swift
import Foundation

#if SWIFT_PACKAGE
extension Bundle {
    static var pulsumDataResources: Bundle { .module }
}
#else
private final class PulsumDataBundleLocator {}
extension Bundle {
    static var pulsumDataResources: Bundle {
        Bundle(for: PulsumDataBundleLocator.self)
    }
}
#endif
```
<!-- END_FILE: Packages/PulsumData/Sources/PulsumData/Bundle+PulsumDataResources.swift -->

### Packages/PulsumData/Sources/PulsumData/DataStack.swift
- bytes: 7193
- lines: 174
- sha256: 10d94160b6bc35355d55a20af5dae66eb8ad1fb5587caa2c13f864b83fbe5648
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Sources/PulsumData/DataStack.swift -->
```swift
import Foundation
import CoreData
import os.log

public enum PulsumDataError: LocalizedError {
    case storeInitializationFailed(underlying: Error)
    case directoryCreationFailed(url: URL, underlying: Error)

    public var errorDescription: String? {
        switch self {
        case let .storeInitializationFailed(underlying):
            return "Failed to initialize persistent stores: \(underlying.localizedDescription)"
        case let .directoryCreationFailed(url, underlying):
            return "Unable to create directory at \(url.path): \(underlying.localizedDescription)"
        }
    }
}

public struct BackupSecurityIssue: Equatable, Sendable {
    public let url: URL
    public let reason: String
}

public struct StoragePaths {
    public let applicationSupport: URL
    public let sqliteStoreURL: URL
    public let vectorIndexDirectory: URL
    public let healthAnchorsDirectory: URL

    public init(appGroup: String? = nil) throws {
        let fileManager = FileManager.default
        #if os(iOS)
        let baseURL: URL
        if let appGroup, let containerURL = fileManager.containerURL(forSecurityApplicationGroupIdentifier: appGroup) {
            baseURL = containerURL
        } else {
            guard let url = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask).first else {
                throw PulsumDataError.directoryCreationFailed(url: URL(fileURLWithPath: "ApplicationSupport"), underlying: CocoaError(.fileNoSuchFile))
            }
            baseURL = url
        }
        #else
        guard let baseURL = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask).first else {
            throw PulsumDataError.directoryCreationFailed(url: URL(fileURLWithPath: "ApplicationSupport"), underlying: CocoaError(.fileNoSuchFile))
        }
        #endif

        applicationSupport = baseURL.appendingPathComponent("Pulsum", isDirectory: true)
        sqliteStoreURL = applicationSupport.appendingPathComponent("Pulsum.sqlite")
        vectorIndexDirectory = applicationSupport.appendingPathComponent("VectorIndex", isDirectory: true)
        healthAnchorsDirectory = applicationSupport.appendingPathComponent("Anchors", isDirectory: true)
    }
}

public final class DataStack {
    public static let shared = DataStack()

    public let container: NSPersistentContainer
    public let storagePaths: StoragePaths
    public private(set) var backupSecurityIssue: BackupSecurityIssue?

    private let fileManager: FileManager
    private static let logger = Logger(subsystem: "ai.pulsum", category: "DataStack")

    public init(fileManager: FileManager = .default, appGroupIdentifier: String? = nil) {
        self.fileManager = fileManager
        do {
            storagePaths = try StoragePaths(appGroup: appGroupIdentifier)
        } catch {
            fatalError("Pulsum data directories could not be resolved: \(error)")
        }

        do {
            try DataStack.prepareDirectories(paths: storagePaths, fileManager: fileManager)
        } catch {
            fatalError("Pulsum data directories could not be created: \(error)")
        }

        let managedObjectModel = DataStack.loadManagedObjectModel()
        container = NSPersistentContainer(name: "Pulsum", managedObjectModel: managedObjectModel)
        let description = NSPersistentStoreDescription(url: storagePaths.sqliteStoreURL)
        description.type = NSSQLiteStoreType
#if os(iOS)
        description.setOption(FileProtectionType.complete as NSObject, forKey: NSPersistentStoreFileProtectionKey)
#endif
        description.shouldMigrateStoreAutomatically = true
        description.shouldInferMappingModelAutomatically = true
        description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)

        // Exclude PHI from iCloud backups
        backupSecurityIssue = DataStack.applyBackupExclusion(to: [
            storagePaths.applicationSupport,
            storagePaths.vectorIndexDirectory,
            storagePaths.healthAnchorsDirectory
        ])

        container.persistentStoreDescriptions = [description]

        container.loadPersistentStores { _, error in
            if let error {
                fatalError("Unresolved Core Data error: \(error)")
            }
        }

        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
        container.viewContext.transactionAuthor = "PulsumApp"
    }

    public func newBackgroundContext(name: String = "Pulsum.Background") -> NSManagedObjectContext {
        let context = container.newBackgroundContext()
        context.name = name
        context.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
        context.transactionAuthor = name
        return context
    }

    public func performBackgroundTask(_ block: @Sendable @escaping (NSManagedObjectContext) -> Void) {
        container.performBackgroundTask(block)
    }

    private static func prepareDirectories(paths: StoragePaths, fileManager: FileManager) throws {
        #if os(iOS)
        let protectionAttributes: [FileAttributeKey: Any] = [
            .protectionKey: FileProtectionType.complete
        ]
        #else
        let protectionAttributes: [FileAttributeKey: Any] = [:]
        #endif

        for directory in [paths.applicationSupport, paths.vectorIndexDirectory, paths.healthAnchorsDirectory] {
            if !fileManager.fileExists(atPath: directory.path) {
                do {
                    let attributes = protectionAttributes.isEmpty ? nil : protectionAttributes
                    try fileManager.createDirectory(at: directory, withIntermediateDirectories: true, attributes: attributes)
                } catch {
                    throw PulsumDataError.directoryCreationFailed(url: directory, underlying: error)
                }
            } else if !protectionAttributes.isEmpty {
                try fileManager.setAttributes(protectionAttributes, ofItemAtPath: directory.path)
            }
        }
    }

    private static func applyBackupExclusion(to urls: [URL]) -> BackupSecurityIssue? {
        var issue: BackupSecurityIssue?
        var resourceValues = URLResourceValues()
        resourceValues.isExcludedFromBackup = true
        for var url in urls {
            do {
                try url.setResourceValues(resourceValues)
            } catch {
                let nsError = error as NSError
                logger.error("Failed to exclude \(url.path, privacy: .public) from backup. domain=\(nsError.domain, privacy: .public) code=\(nsError.code, privacy: .public)")
                if issue == nil {
                    issue = BackupSecurityIssue(url: url, reason: "domain=\(nsError.domain) code=\(nsError.code)")
                }
            }
        }
        return issue
    }

#if DEBUG
    static func debugApplyBackupExclusion(to urls: [URL]) -> BackupSecurityIssue? {
        applyBackupExclusion(to: urls)
    }
#endif

    private static func loadManagedObjectModel() -> NSManagedObjectModel {
        PulsumManagedObjectModel.shared
    }
}

extension DataStack: @unchecked Sendable {}
```
<!-- END_FILE: Packages/PulsumData/Sources/PulsumData/DataStack.swift -->

### Packages/PulsumData/Sources/PulsumData/EvidenceScorer.swift
- bytes: 957
- lines: 41
- sha256: 0553ee1210ce86cfaaa494177ce1f3f4fc940f30fe660d9efcf787433f9673f0
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Sources/PulsumData/EvidenceScorer.swift -->
```swift
import Foundation

public enum EvidenceBadge: String {
    case strong = "Strong"
    case medium = "Medium"
    case weak = "Weak"
}

struct EvidenceScorer {
    private static let strongDomains: [String] = [
        "pubmed",
        "nih.gov",
        ".gov",
        ".edu",
        "who.int",
        "cochrane.org"
    ]

    private static let mediumDomains: [String] = [
        "nature.com",
        "sciencedirect.com",
        "mayoclinic.org",
        "harvard.edu"
    ]

    static func badge(for urlString: String?) -> EvidenceBadge {
        guard let urlString, let url = URL(string: urlString), let host = url.host?.lowercased() else {
            return .weak
        }

        if strongDomains.contains(where: { host == $0 || host.hasSuffix($0) }) {
            return .strong
        }

        if mediumDomains.contains(where: { host == $0 || host.hasSuffix($0) }) {
            return .medium
        }

        return .weak
    }
}
```
<!-- END_FILE: Packages/PulsumData/Sources/PulsumData/EvidenceScorer.swift -->

### Packages/PulsumData/Sources/PulsumData/LibraryImporter.swift
- bytes: 17078
- lines: 396
- sha256: 4a0f28cee21a65e9386abda97beccf905c430fb1bf38d803f3568df5282244a2
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Sources/PulsumData/LibraryImporter.swift -->
```swift
import Foundation
import CoreData
import CryptoKit
import PulsumML
import PulsumTypes

public struct LibraryImporterConfiguration {
    public let bundle: Bundle
    public let subdirectory: String?
    public let fileExtension: String

    public init(bundle: Bundle = .main, subdirectory: String? = "json database", fileExtension: String = "json") {
        self.bundle = bundle
        self.subdirectory = subdirectory
        self.fileExtension = fileExtension
    }
}

public enum LibraryImporterError: LocalizedError {
    case missingResources
    case decodingFailed(underlying: Error)
    case indexingFailed(underlying: Error)

    public var errorDescription: String? {
        switch self {
        case .missingResources:
            return "No recommendation library resources were found in the application bundle."
        case let .decodingFailed(underlying):
            return "Unable to parse recommendation library: \(underlying.localizedDescription)"
        case let .indexingFailed(underlying):
            return "Unable to index recommendation library: \(underlying.localizedDescription)"
        }
    }
}

public final class LibraryImporter {
    private let configuration: LibraryImporterConfiguration
    private let vectorIndex: VectorIndexProviding
    private let persistentContainer: NSPersistentContainer
    public private(set) var lastImportHadDeferredEmbeddings = false

    public init(configuration: LibraryImporterConfiguration = LibraryImporterConfiguration(),
                vectorIndex: VectorIndexProviding = VectorIndexManager.shared,
                persistentContainer: NSPersistentContainer = PulsumData.container) {
        self.configuration = configuration
        self.vectorIndex = vectorIndex
        self.persistentContainer = persistentContainer
    }

    public func ingestIfNeeded() async throws {
        lastImportHadDeferredEmbeddings = false
        let urls = discoverLibraryURLs()
        guard !urls.isEmpty else {
            Diagnostics.log(level: .info,
                            category: .library,
                            name: "library.import.skip",
                            fields: ["reason": .safeString(.stage("missing_resources", allowed: ["missing_resources"]))])
            return
        }

        var decodedCount = 0
        var indexedCount = 0
        var payloadCount = 0
        let span = Diagnostics.span(category: .library,
                                    name: "library.import",
                                    fields: ["resource_count": .int(urls.count)],
                                    level: .info)
        let monitor = DiagnosticsStallMonitor(category: .library,
                                              name: "library.import",
                                              traceId: nil,
                                              thresholdSeconds: 20,
                                              initialFields: ["resource_count": .int(urls.count)])
        await monitor.start()

        do {
            let resources = try await Self.loadResourcesAsync(from: urls)
            decodedCount = resources.count
            await monitor.heartbeat(progressFields: ["decoded_count": .int(decodedCount)])
            guard !resources.isEmpty else {
                await monitor.stop(finalFields: ["decoded_count": .int(decodedCount)])
                span.end(additionalFields: [
                    "decoded_count": .int(decodedCount),
                    "inserted_count": .int(0),
                    "indexed_count": .int(0)
                ], error: nil)
                return
            }

            let context = persistentContainer.newBackgroundContext()
            context.name = "Pulsum.LibraryImporter"
            context.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
            context.transactionAuthor = "Pulsum.LibraryImporter"

            let result = try await context.perform {
                var payloads: [MicroMomentIndexPayload] = []
                var updates: [LibraryIngestUpdate] = []
                for resource in resources {
                    let outcome = try self.process(resource: resource, context: context)
                    payloads.append(contentsOf: outcome.payloads)
                    if let update = outcome.ingestUpdate {
                        updates.append(update)
                    }
                }

                if context.hasChanges {
                    try context.save()
                }
                return (payloads, updates)
            }

            payloadCount = result.0.count
            await monitor.heartbeat(progressFields: ["payload_count": .int(payloadCount)])

            if !result.0.isEmpty {
                do {
                    try await upsertIndexEntries(result.0)
                    indexedCount = payloadCount
                } catch {
                    if let embeddingError = error as? EmbeddingError, case .generatorUnavailable = embeddingError {
                        lastImportHadDeferredEmbeddings = true
                        Diagnostics.log(level: .warn,
                                        category: .library,
                                        name: "library.import.deferred",
                                        fields: [
                                            "reason": .safeString(.stage("embeddings_unavailable", allowed: ["embeddings_unavailable"])),
                                            "decoded_count": .int(decodedCount),
                                            "payload_count": .int(payloadCount)
                                        ])
                        await monitor.stop(finalFields: [
                            "payload_count": .int(payloadCount),
                            "indexed_count": .int(0)
                        ])
                        span.end(additionalFields: [
                            "decoded_count": .int(decodedCount),
                            "inserted_count": .int(payloadCount),
                            "indexed_count": .int(0),
                            "deferred": .bool(true)
                        ], error: nil)
                        return
                    }
                    await monitor.stop(finalFields: ["payload_count": .int(payloadCount)])
                    span.end(additionalFields: [
                        "decoded_count": .int(decodedCount),
                        "inserted_count": .int(payloadCount),
                        "indexed_count": .int(indexedCount)
                    ], error: error)
                    throw LibraryImporterError.indexingFailed(underlying: error)
                }
            }

            if !result.1.isEmpty {
                try await context.perform {
                    for update in result.1 {
                        let fetchRequest: NSFetchRequest<LibraryIngest> = LibraryIngest.fetchRequest()
                        fetchRequest.predicate = NSPredicate(format: "source == %@", update.source)
                        fetchRequest.fetchLimit = 1
                        let ingest: LibraryIngest
                        if let existing = try context.fetch(fetchRequest).first {
                            ingest = existing
                        } else {
                            let newIngest = LibraryIngest(context: context)
                            newIngest.id = UUID()
                            ingest = newIngest
                        }
                        ingest.source = update.source
                        ingest.checksum = update.checksum
                        ingest.version = "1"
                        ingest.ingestedAt = Date()
                    }
                    if context.hasChanges {
                        try context.save()
                    }
                }
            }

            let stats = await vectorIndex.stats()
            Diagnostics.log(level: .info,
                            category: .vectorIndex,
                            name: "vectorIndex.stats",
                            fields: [
                                "shards": .int(stats.shards),
                                "items": .int(stats.items)
                            ])
            await monitor.stop(finalFields: [
                "decoded_count": .int(decodedCount),
                "indexed_count": .int(indexedCount)
            ])
            span.end(additionalFields: [
                "decoded_count": .int(decodedCount),
                "inserted_count": .int(payloadCount),
                "indexed_count": .int(indexedCount)
            ], error: nil)
        } catch {
            await monitor.stop(finalFields: [
                "decoded_count": .int(decodedCount),
                "indexed_count": .int(indexedCount)
            ])
            span.end(additionalFields: [
                "decoded_count": .int(decodedCount),
                "inserted_count": .int(payloadCount),
                "indexed_count": .int(indexedCount)
            ], error: error)
            throw error
        }
    }

    private func process(resource: LibraryResourcePayload, context: NSManagedObjectContext) throws -> LibraryProcessOutcome {
        let fetchRequest: NSFetchRequest<LibraryIngest> = LibraryIngest.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: "source == %@", resource.filename)
        fetchRequest.fetchLimit = 1

        let existing = try context.fetch(fetchRequest).first
        if let existing, existing.checksum == resource.checksum {
            return LibraryProcessOutcome(payloads: [], ingestUpdate: nil)
        }

        var payloads: [MicroMomentIndexPayload] = []
        for episode in resource.episodes {
            for recommendation in episode.recommendations {
                let payload = try upsertMicroMoment(episode: episode,
                                                    recommendation: recommendation,
                                                    context: context)
                payloads.append(payload)
            }
        }

        return LibraryProcessOutcome(payloads: payloads,
                                     ingestUpdate: LibraryIngestUpdate(source: resource.filename,
                                                                        checksum: resource.checksum))
    }

    private func upsertMicroMoment(episode: PodcastEpisode,
                                   recommendation: PodcastRecommendation,
                                   context: NSManagedObjectContext) throws -> MicroMomentIndexPayload {
        let identifier = recommendationIdentifier(episode: episode, recommendation: recommendation)
        let fetch: NSFetchRequest<MicroMoment> = MicroMoment.fetchRequest()
        fetch.predicate = NSPredicate(format: "id == %@", identifier)
        fetch.fetchLimit = 1

        let microMoment = try context.fetch(fetch).first ?? MicroMoment(context: context)
        microMoment.id = identifier
        microMoment.title = recommendation.recommendation
        microMoment.shortDescription = recommendation.shortDescription
        microMoment.detail = buildDetail(episode: episode, recommendation: recommendation)
        microMoment.tags = recommendation.tags
        microMoment.difficulty = recommendation.difficultyLevel
        microMoment.category = recommendation.category
        microMoment.sourceURL = recommendation.researchLink
        microMoment.evidenceBadge = EvidenceScorer.badge(for: recommendation.researchLink).rawValue
        microMoment.estimatedTimeSec = NSNumber(value: parseTimeInterval(from: recommendation.timeToComplete))
        microMoment.cooldownSec = recommendation.cooldownSec.map { NSNumber(value: $0) }
        let title = microMoment.title
        return MicroMomentIndexPayload(id: identifier,
                                       title: title,
                                       detail: microMoment.detail,
                                       tags: microMoment.tags)
    }

    private func recommendationIdentifier(episode: PodcastEpisode, recommendation: PodcastRecommendation) -> String {
        let base = "episode-\(episode.episodeNumber)-\(recommendation.recommendation)"
        return base.replacingOccurrences(of: "[^A-Za-z0-9]+", with: "-", options: .regularExpression)
    }

    private func parseTimeInterval(from string: String?) -> Int {
        guard let string else { return 300 }
        let lower = string.lowercased()
        if lower.contains("day") {
            let value = extractLeadingNumber(from: lower)
            return value * 24 * 60 * 60
        }
        if lower.contains("hour") {
            return extractLeadingNumber(from: lower) * 60 * 60
        }
        if lower.contains("min") {
            return max(extractLeadingNumber(from: lower) * 60, 60)
        }
        if lower.contains("sec") {
            return max(extractLeadingNumber(from: lower), 10)
        }
        return 300
    }

    private func extractLeadingNumber(from string: String) -> Int {
        if let match = string.range(of: "\\d+", options: .regularExpression) {
            return Int(string[match]) ?? 1
        }
        return 1
    }

    private func buildDetail(episode: PodcastEpisode, recommendation: PodcastRecommendation) -> String {
        var detailComponents: [String] = []
        detailComponents.append(recommendation.detailedDescription)
        if let microActivity = recommendation.microActivity {
            detailComponents.append("Try this: \(microActivity)")
        }
        return detailComponents.joined(separator: "\n\n")
    }

    private func discoverLibraryURLs() -> [URL] {
        var urls = configuration.bundle.urls(forResourcesWithExtension: configuration.fileExtension,
                                             subdirectory: configuration.subdirectory) ?? []
        if urls.isEmpty, configuration.subdirectory != nil {
            urls = configuration.bundle.urls(forResourcesWithExtension: configuration.fileExtension,
                                             subdirectory: nil) ?? []
        }
        return urls
    }

    private static func loadResourcesAsync(from urls: [URL]) async throws -> [LibraryResourcePayload] {
        try await Task.detached(priority: .userInitiated) {
            try loadResources(from: urls)
        }.value
    }

    private static func loadResources(from urls: [URL]) throws -> [LibraryResourcePayload] {
        guard !urls.isEmpty else { return [] }
        let decoder = JSONDecoder()
        return try urls.map { url in
            let data = try Data(contentsOf: url)
            let checksum = sha256Hex(for: data)
            let episodes: [PodcastEpisode]
            do {
                episodes = try decoder.decode([PodcastEpisode].self, from: data)
            } catch {
                throw LibraryImporterError.decodingFailed(underlying: error)
            }
            return LibraryResourcePayload(filename: url.lastPathComponent,
                                          checksum: checksum,
                                          episodes: episodes)
        }
    }

    private func upsertIndexEntries(_ payloads: [MicroMomentIndexPayload]) async throws {
        try await withThrowingTaskGroup(of: Void.self) { group in
            for payload in payloads {
                group.addTask { [vectorIndex] in
                    _ = try await vectorIndex.upsertMicroMoment(id: payload.id,
                                                                title: payload.title,
                                                                detail: payload.detail,
                                                                tags: payload.tags)
                }
            }
            try await group.waitForAll()
        }
    }

    private static func sha256Hex(for data: Data) -> String {
        SHA256.hash(data: data).map { String(format: "%02x", $0) }.joined()
    }
}

// MARK: - Codable structures

private struct LibraryResourcePayload: Sendable {
    let filename: String
    let checksum: String
    let episodes: [PodcastEpisode]
}

private struct MicroMomentIndexPayload: Sendable {
    let id: String
    let title: String
    let detail: String?
    let tags: [String]?
}

private struct LibraryIngestUpdate: Sendable {
    let source: String
    let checksum: String
}

private struct LibraryProcessOutcome: Sendable {
    let payloads: [MicroMomentIndexPayload]
    let ingestUpdate: LibraryIngestUpdate?
}

private struct PodcastEpisode: Decodable {
    let episodeNumber: String
    let episodeTitle: String
    let recommendations: [PodcastRecommendation]
}

private struct PodcastRecommendation: Decodable {
    let recommendation: String
    let shortDescription: String
    let detailedDescription: String
    let microActivity: String?
    let researchLink: String?
    let difficultyLevel: String?
    let timeToComplete: String?
    let tags: [String]?
    let category: String?
    let cooldownSec: Int?
}

extension LibraryImporter: @unchecked Sendable {}
```
<!-- END_FILE: Packages/PulsumData/Sources/PulsumData/LibraryImporter.swift -->

### Packages/PulsumData/Sources/PulsumData/Model/ManagedObjects.swift
- bytes: 5027
- lines: 153
- sha256: c668eb983b01fca16b00fe51ab395c8234b820a8f91e04099cab7a03b87f10da
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Sources/PulsumData/Model/ManagedObjects.swift -->
```swift
import CoreData

@objc(JournalEntry)
public final class JournalEntry: NSManagedObject {
    @NSManaged public var id: UUID
    @NSManaged public var date: Date
    @NSManaged public var transcript: String
    @NSManaged public var sentiment: NSNumber?
    @NSManaged public var embeddedVectorURL: String?
    @NSManaged public var sensitiveFlags: String?
}

@objc(DailyMetrics)
public final class DailyMetrics: NSManagedObject {
    @NSManaged public var date: Date
    @NSManaged public var hrvMedian: NSNumber?
    @NSManaged public var nocturnalHRPercentile10: NSNumber?
    @NSManaged public var restingHR: NSNumber?
    @NSManaged public var totalSleepTime: NSNumber?
    @NSManaged public var sleepDebt: NSNumber?
    @NSManaged public var respiratoryRate: NSNumber?
    @NSManaged public var steps: NSNumber?
    @NSManaged public var flags: String?
}

@objc(Baseline)
public final class Baseline: NSManagedObject {
    @NSManaged public var metric: String
    @NSManaged public var windowDays: Int16
    @NSManaged public var median: NSNumber?
    @NSManaged public var mad: NSNumber?
    @NSManaged public var ewma: NSNumber?
    @NSManaged public var updatedAt: Date?
}

@objc(FeatureVector)
public final class FeatureVector: NSManagedObject {
    @NSManaged public var date: Date
    @NSManaged public var zHrv: NSNumber?
    @NSManaged public var zNocturnalHR: NSNumber?
    @NSManaged public var zRestingHR: NSNumber?
    @NSManaged public var zSleepDebt: NSNumber?
    @NSManaged public var zRespiratoryRate: NSNumber?
    @NSManaged public var zSteps: NSNumber?
    @NSManaged public var subjectiveStress: NSNumber?
    @NSManaged public var subjectiveEnergy: NSNumber?
    @NSManaged public var subjectiveSleepQuality: NSNumber?
    @NSManaged public var sentiment: NSNumber?
    @NSManaged public var imputedFlags: String?
}

@objc(MicroMoment)
public final class MicroMoment: NSManagedObject {
    @NSManaged public var id: String
    @NSManaged public var title: String
    @NSManaged public var shortDescription: String
    @NSManaged public var detail: String?
    @NSManaged public var tags: [String]?
    @NSManaged public var estimatedTimeSec: NSNumber?
    @NSManaged public var difficulty: String?
    @NSManaged public var category: String?
    @NSManaged public var sourceURL: String?
    @NSManaged public var evidenceBadge: String?
    @NSManaged public var cooldownSec: NSNumber?
}

// MARK: - Fetch Request Helpers

public extension JournalEntry {
    @nonobjc class func fetchRequest() -> NSFetchRequest<JournalEntry> {
        NSFetchRequest<JournalEntry>(entityName: "JournalEntry")
    }
}

public extension DailyMetrics {
    @nonobjc class func fetchRequest() -> NSFetchRequest<DailyMetrics> {
        NSFetchRequest<DailyMetrics>(entityName: "DailyMetrics")
    }
}

public extension Baseline {
    @nonobjc class func fetchRequest() -> NSFetchRequest<Baseline> {
        NSFetchRequest<Baseline>(entityName: "Baseline")
    }
}

public extension FeatureVector {
    @nonobjc class func fetchRequest() -> NSFetchRequest<FeatureVector> {
        NSFetchRequest<FeatureVector>(entityName: "FeatureVector")
    }
}

public extension MicroMoment {
    @nonobjc class func fetchRequest() -> NSFetchRequest<MicroMoment> {
        NSFetchRequest<MicroMoment>(entityName: "MicroMoment")
    }
}

public extension RecommendationEvent {
    @nonobjc class func fetchRequest() -> NSFetchRequest<RecommendationEvent> {
        NSFetchRequest<RecommendationEvent>(entityName: "RecommendationEvent")
    }
}

public extension LibraryIngest {
    @nonobjc class func fetchRequest() -> NSFetchRequest<LibraryIngest> {
        NSFetchRequest<LibraryIngest>(entityName: "LibraryIngest")
    }
}

public extension UserPrefs {
    @nonobjc class func fetchRequest() -> NSFetchRequest<UserPrefs> {
        NSFetchRequest<UserPrefs>(entityName: "UserPrefs")
    }
}

public extension ConsentState {
    @nonobjc class func fetchRequest() -> NSFetchRequest<ConsentState> {
        NSFetchRequest<ConsentState>(entityName: "ConsentState")
    }
}

@objc(RecommendationEvent)
public final class RecommendationEvent: NSManagedObject {
    @NSManaged public var momentId: String
    @NSManaged public var date: Date
    @NSManaged public var accepted: Bool
    @NSManaged public var completedAt: Date?
}

@objc(LibraryIngest)
public final class LibraryIngest: NSManagedObject {
    @NSManaged public var id: UUID
    @NSManaged public var source: String
    @NSManaged public var checksum: String?
    @NSManaged public var ingestedAt: Date
    @NSManaged public var version: String?
}

@objc(UserPrefs)
public final class UserPrefs: NSManagedObject {
    @NSManaged public var id: String
    @NSManaged public var consentCloud: Bool
    @NSManaged public var updatedAt: Date
}

@objc(ConsentState)
public final class ConsentState: NSManagedObject {
    @NSManaged public var id: UUID
    @NSManaged public var version: String
    @NSManaged public var grantedAt: Date?
    @NSManaged public var revokedAt: Date?
}
```
<!-- END_FILE: Packages/PulsumData/Sources/PulsumData/Model/ManagedObjects.swift -->

### Packages/PulsumData/Sources/PulsumData/PulsumData.swift
- bytes: 1973
- lines: 40
- sha256: d2de2cefbaf8d9ca29ea83b42dd89299c08bcdf1cdbcf64f037081f5e23fcc63
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Sources/PulsumData/PulsumData.swift -->
```swift
import Foundation
import CoreData

/// Facade exposing Pulsum's persistent data infrastructure.
public enum PulsumData {
    /// Shared Core Data stack configured for on-device only storage.
    public static var dataStack: DataStack { DataStack.shared }

    /// Primary persistent container. Use for dependency injection when needed.
    public static var container: NSPersistentContainer { dataStack.container }

    /// Main-thread view context sourced from the container.
    public static var viewContext: NSManagedObjectContext { dataStack.container.viewContext }

    /// Creates a background context with merge policies configured for Pulsum writes.
    @discardableResult
    public static func newBackgroundContext(name: String = "Pulsum.Background") -> NSManagedObjectContext {
        dataStack.newBackgroundContext(name: name)
    }

    /// Performs an asynchronous background task, delegating to the underlying container helper.
    public static func performBackgroundTask(_ block: @Sendable @escaping (NSManagedObjectContext) -> Void) {
        dataStack.performBackgroundTask(block)
    }

    /// Location of the Application Support directory used for Pulsum persistence.
    public static var applicationSupportDirectory: URL { dataStack.storagePaths.applicationSupport }

    /// Location of the SQLite store backing Core Data.
    public static var sqliteStoreURL: URL { dataStack.storagePaths.sqliteStoreURL }

    /// Directory where vector index shards are stored (file protected, excluded from backup).
    public static var vectorIndexDirectory: URL { dataStack.storagePaths.vectorIndexDirectory }

    /// Directory storing persisted HealthKit query anchors.
    public static var healthAnchorsDirectory: URL { dataStack.storagePaths.healthAnchorsDirectory }

    /// Security issue raised when PHI directories cannot be excluded from backups.
    public static var backupSecurityIssue: BackupSecurityIssue? { dataStack.backupSecurityIssue }
}
```
<!-- END_FILE: Packages/PulsumData/Sources/PulsumData/PulsumData.swift -->

### Packages/PulsumData/Sources/PulsumData/PulsumManagedObjectModel.swift
- bytes: 4539
- lines: 89
- sha256: b6178516af6c347b27e55805862051384f330bd8eb2fe65155098ea55df6025c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Sources/PulsumData/PulsumManagedObjectModel.swift -->
```swift
import CoreData
import Foundation

/// Canonical Pulsum Core Data model loader. Uses the packaged `.momd` from PulsumData resources
/// and exposes a singleton instance so tests and production share the same model pointer.
public enum PulsumManagedObjectModel {
    // NSManagedObjectModel is immutable after loading; safe to reuse across threads for testing/production.
    nonisolated(unsafe) public static let shared: NSManagedObjectModel = {
        let bundle = Bundle.pulsumDataResources
        let candidates = [
            bundle.url(forResource: "Pulsum", withExtension: "momd"),
            bundle.url(forResource: "Pulsum", withExtension: "mom"),
            bundle.url(forResource: "PulsumCompiled", withExtension: "momd"),
            bundle.url(forResource: "PulsumCompiled", withExtension: "mom"),
            Bundle.main.url(forResource: "Pulsum", withExtension: "momd"),
            Bundle.main.url(forResource: "Pulsum", withExtension: "mom"),
            Bundle.main.url(forResource: "PulsumCompiled", withExtension: "momd"),
            Bundle.main.url(forResource: "PulsumCompiled", withExtension: "mom")
        ].compactMap { $0 }

        for url in candidates {
            if let model = NSManagedObjectModel(contentsOf: url) {
                return model
            }
        }

        if let xcdatamodeld = bundle.url(forResource: "Pulsum", withExtension: "xcdatamodeld") {
            if let model = NSManagedObjectModel(contentsOf: xcdatamodeld) {
                return model
            }
            if let versioned = try? FileManager.default.contentsOfDirectory(at: xcdatamodeld,
                                                                            includingPropertiesForKeys: nil)
                .first(where: { $0.pathExtension == "xcdatamodel" }),
               let model = NSManagedObjectModel(contentsOf: versioned) {
                return model
            }
            if let versioned = try? FileManager.default.contentsOfDirectory(at: xcdatamodeld,
                                                                            includingPropertiesForKeys: nil)
                .first(where: { $0.pathExtension == "xcdatamodel" })?
                .appendingPathComponent("contents"),
               let model = NSManagedObjectModel(contentsOf: versioned) {
                return model
            }
        }

        if let merged = NSManagedObjectModel.mergedModel(from: [bundle]) {
            return merged
        }

        for bundle in Bundle.allBundles + Bundle.allFrameworks {
            if let url = bundle.url(forResource: "Pulsum", withExtension: "momd"),
               let model = NSManagedObjectModel(contentsOf: url) {
                return model
            }
            if let url = bundle.url(forResource: "Pulsum", withExtension: "mom"),
               let model = NSManagedObjectModel(contentsOf: url) {
                return model
            }
            if let url = bundle.url(forResource: "PulsumCompiled", withExtension: "momd"),
               let model = NSManagedObjectModel(contentsOf: url) {
                return model
            }
            if let url = bundle.url(forResource: "PulsumCompiled", withExtension: "mom"),
               let model = NSManagedObjectModel(contentsOf: url) {
                return model
            }
            if let url = bundle.url(forResource: "Pulsum", withExtension: "xcdatamodeld") {
                if let model = NSManagedObjectModel(contentsOf: url) {
                    return model
                }
                if let versioned = try? FileManager.default.contentsOfDirectory(at: url,
                                                                                includingPropertiesForKeys: nil)
                    .first(where: { $0.pathExtension == "xcdatamodel" }),
                   let model = NSManagedObjectModel(contentsOf: versioned) {
                    return model
                }
                if let versioned = try? FileManager.default.contentsOfDirectory(at: url,
                                                                                includingPropertiesForKeys: nil)
                    .first(where: { $0.pathExtension == "xcdatamodel" })?
                    .appendingPathComponent("contents"),
                   let model = NSManagedObjectModel(contentsOf: versioned) {
                    return model
                }
            }
        }

        fatalError("PulsumData: NSManagedObjectModel 'Pulsum' not found in bundle resources")
    }()
}
```
<!-- END_FILE: Packages/PulsumData/Sources/PulsumData/PulsumManagedObjectModel.swift -->

### Packages/PulsumData/Sources/PulsumData/VectorIndex.swift
- bytes: 16784
- lines: 436
- sha256: 5d2b0bceb633062aa2be28cd2ebacc68dc8f2dba4b402be605a56950bd44f4c2
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Sources/PulsumData/VectorIndex.swift -->
```swift
import Foundation
import os.log

protocol VectorIndexFileHandle: AnyObject {
    func seekToEnd() throws -> UInt64
    func seek(toOffset offset: UInt64) throws
    func read(upToCount count: Int) throws -> Data?
    func write(_ data: Data)
    func close() throws
}

extension FileHandle: VectorIndexFileHandle {}

protocol VectorIndexFileHandleFactory {
    func updatingHandle(for url: URL) throws -> VectorIndexFileHandle
}

struct SystemVectorIndexFileHandleFactory: VectorIndexFileHandleFactory {
    func updatingHandle(for url: URL) throws -> VectorIndexFileHandle {
        try FileHandle(forUpdating: url)
    }
}

public struct VectorMatch: Equatable, Sendable {
    public let id: String
    public let score: Float
}

enum VectorIndexError: LocalizedError {
    case invalidDimension(expected: Int, actual: Int)
    case corruptShard(String)
    case ioFailure(String)

    var errorDescription: String? {
        switch self {
        case let .invalidDimension(expected, actual):
            return "Vector dimension mismatch. Expected \(expected), got \(actual)."
        case let .corruptShard(shard):
            return "Vector index shard \(shard) is corrupt."
        case let .ioFailure(message):
            return "Vector index I/O error: \(message)"
        }
    }
}

private struct VectorIndexHeader {
    static let magic: UInt32 = 0x50535649 // 'PSVI'
    static let version: UInt16 = 1
    let dimension: UInt16
    let recordCount: UInt64

    static let byteSize = MemoryLayout<UInt32>.size + MemoryLayout<UInt16>.size * 2 + MemoryLayout<UInt64>.size

    func data() -> Data {
        var data = Data()
        data.reserveCapacity(Self.byteSize)
        data.append(Self.magic.littleEndianData)
        data.append(Self.version.littleEndianData)
        data.append(dimension.littleEndianData)
        data.append(recordCount.littleEndianData)
        return data
    }
}

private struct VectorRecordHeader {
    let idLength: UInt16
    let flags: UInt16

    static let byteSize = MemoryLayout<UInt16>.size * 2

    func data() -> Data {
        var data = Data(capacity: Self.byteSize)
        data.append(idLength.littleEndianData)
        data.append(flags.littleEndianData)
        return data
    }
}

private final class VectorIndexShard {
    private(set) var metadata: [String: UInt64]
    private let shardURL: URL
    private let metadataURL: URL
    private let dimension: Int
    private let fileManager: FileManager
    private let fileHandleFactory: VectorIndexFileHandleFactory
    private let queue = DispatchQueue(label: "ai.pulsum.vectorindex.shard", attributes: .concurrent)

    init(baseDirectory: URL,
         name: String,
         shardIdentifier: String,
         dimension: Int,
         fileManager: FileManager = .default,
         fileHandleFactory: VectorIndexFileHandleFactory = SystemVectorIndexFileHandleFactory()) throws {
        self.dimension = dimension
        self.fileManager = fileManager
        self.fileHandleFactory = fileHandleFactory
        let shardDirectory = baseDirectory.appendingPathComponent(name, isDirectory: true)
        if !fileManager.fileExists(atPath: shardDirectory.path) {
            #if os(iOS)
            try fileManager.createDirectory(at: shardDirectory, withIntermediateDirectories: true, attributes: [.protectionKey: FileProtectionType.complete])
            #else
            try fileManager.createDirectory(at: shardDirectory, withIntermediateDirectories: true, attributes: nil)
            #endif
        }
        self.shardURL = shardDirectory.appendingPathComponent("\(shardIdentifier).shard")
        self.metadataURL = shardDirectory.appendingPathComponent("\(shardIdentifier).meta")
        if !fileManager.fileExists(atPath: shardURL.path) {
            let header = VectorIndexHeader(dimension: UInt16(dimension), recordCount: 0)
            try header.data().write(to: shardURL, options: .atomic)
            #if os(iOS)
            try fileManager.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: shardURL.path)
            #endif
        }
        if fileManager.fileExists(atPath: metadataURL.path) {
            let data = try Data(contentsOf: metadataURL)
            let decoded = try JSONDecoder().decode([String: UInt64].self, from: data)
            self.metadata = decoded
        } else {
            self.metadata = [:]
            try persistMetadata()
        }
        try validateHeader()
    }

    func upsert(id: String, vector: [Float]) throws {
        guard vector.count == dimension else {
            throw VectorIndexError.invalidDimension(expected: dimension, actual: vector.count)
        }

        try queue.sync(flags: .barrier) {
            try self.withHandle { handle in
                var metadataChanged = false

                if let existingOffset = metadata[id] {
                    try markRecordDeleted(at: existingOffset, handle: handle)
                    metadataChanged = true
                }

                let offset = try appendRecord(id: id, vector: vector, handle: handle)
                metadata[id] = offset
                metadataChanged = true

                if metadataChanged {
                    try persistMetadata()
                    try updateRecordCount(handle: handle)
                }
            }
        }
    }

    func remove(id: String) throws {
        try queue.sync(flags: .barrier) {
            guard let offset = metadata.removeValue(forKey: id) else { return }
            try self.withHandle { handle in
                try markRecordDeleted(at: offset, handle: handle)
                try persistMetadata()
                try updateRecordCount(handle: handle)
            }
        }
    }

    func search(query: [Float], topK: Int) throws -> [VectorMatch] {
        guard query.count == dimension else {
            throw VectorIndexError.invalidDimension(expected: dimension, actual: query.count)
        }

        var result: Result<[VectorMatch], Error> = .success([])
        queue.sync {
            do {
                let data = try Data(contentsOf: shardURL, options: .mappedIfSafe)
                _ = try currentHeader(from: data)
                var cursor = VectorIndexHeader.byteSize
                var matches: [VectorMatch] = []
                while cursor < data.count {
                    guard let header = readRecordHeader(data: data, offset: cursor) else { break }
                    cursor += VectorRecordHeader.byteSize
                    guard cursor + Int(header.idLength) <= data.count else { break }
                    let idData = data[cursor..<(cursor + Int(header.idLength))]
                    cursor += Int(header.idLength)
                    let vectorByteCount = dimension * MemoryLayout<Float>.size
                    guard cursor + vectorByteCount <= data.count else { break }
                    if header.flags == 0 {
                        let vectorData = data[cursor..<(cursor + vectorByteCount)]
                        let score = l2Distance(query: query, vectorData: vectorData)
                        let identifier = String(decoding: idData, as: UTF8.self)
                        if matches.count < topK {
                            matches.append(VectorMatch(id: identifier, score: score))
                            matches.sort { $0.score < $1.score }
                        } else if let worst = matches.last, score < worst.score {
                            matches.removeLast()
                            matches.append(VectorMatch(id: identifier, score: score))
                            matches.sort { $0.score < $1.score }
                        }
                    }
                    cursor += vectorByteCount
                }
                result = .success(matches)
            } catch {
                result = .failure(error)
            }
        }
        return try result.get()
    }

    private func appendRecord(id: String, vector: [Float], handle: VectorIndexFileHandle) throws -> UInt64 {
        guard let idData = id.data(using: .utf8) else {
            throw VectorIndexError.ioFailure("Unable to encode identifier \(id)")
        }
        let offset = try handle.seekToEnd()
        let recordHeader = VectorRecordHeader(idLength: UInt16(idData.count), flags: 0)
        handle.write(recordHeader.data())
        handle.write(idData)
        vector.forEach { value in
            handle.write(value.bitPattern.littleEndianData)
        }
        return offset
    }

    private func markRecordDeleted(at offset: UInt64, handle: VectorIndexFileHandle) throws {
        try handle.seek(toOffset: offset)
        guard let headerData = try handle.read(upToCount: VectorRecordHeader.byteSize), headerData.count == VectorRecordHeader.byteSize else {
            throw VectorIndexError.corruptShard(shardURL.lastPathComponent)
        }
        let idLength = headerData[0..<2].toUInt16()
        let newFlags = UInt16(1)
        let updatedHeader = VectorRecordHeader(idLength: idLength, flags: newFlags)
        try handle.seek(toOffset: offset)
        handle.write(updatedHeader.data())
    }

    private func persistMetadata() throws {
        let data = try JSONEncoder().encode(metadata)
        try data.write(to: metadataURL, options: .atomic)
        #if os(iOS)
        try fileManager.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: metadataURL.path)
        #endif
    }

    private func updateRecordCount(handle: VectorIndexFileHandle) throws {
        let count = UInt64(metadata.count)
        let header = VectorIndexHeader(dimension: UInt16(dimension), recordCount: count)
        try handle.seek(toOffset: 0)
        handle.write(header.data())
    }

    private func withHandle<T>(_ work: (VectorIndexFileHandle) throws -> T) throws -> T {
        let handle = try fileHandleFactory.updatingHandle(for: shardURL)
        var operationResult: Result<T, Error> = .failure(VectorIndexError.ioFailure("Uninitialized handle state"))
        do {
            let value = try work(handle)
            operationResult = .success(value)
        } catch {
            operationResult = .failure(error)
        }

        var closeError: Error?
        do {
            try handle.close()
        } catch {
            closeError = error
            os_log("VectorIndex: close() failed for %@: %@", type: .error, shardURL.lastPathComponent, String(describing: error))
        }

        if let closeError {
            switch operationResult {
            case let .failure(opError):
                throw VectorIndexError.ioFailure("FileHandle.close() failed for \(shardURL.lastPathComponent) after operation error: \(opError.localizedDescription); close: \(closeError.localizedDescription)")
            case .success:
                throw VectorIndexError.ioFailure("FileHandle.close() failed for \(shardURL.lastPathComponent): \(closeError.localizedDescription)")
            }
        }

        return try operationResult.get()
    }

    private func validateHeader() throws {
        let data = try Data(contentsOf: shardURL)
        guard data.count >= VectorIndexHeader.byteSize else {
            throw VectorIndexError.corruptShard(shardURL.lastPathComponent)
        }
        let header = try currentHeader(from: data)
        guard header.dimension == UInt16(dimension) else {
            throw VectorIndexError.invalidDimension(expected: dimension, actual: Int(header.dimension))
        }
    }

    private func currentHeader(from data: Data? = nil) throws -> VectorIndexHeader {
        let blob = try data ?? Data(contentsOf: shardURL)
        guard blob.count >= VectorIndexHeader.byteSize else {
            throw VectorIndexError.corruptShard(shardURL.lastPathComponent)
        }
        let magic = blob[0..<4].toUInt32()
        guard magic == VectorIndexHeader.magic else {
            throw VectorIndexError.corruptShard(shardURL.lastPathComponent)
        }
        let version = blob[4..<6].toUInt16()
        guard version == VectorIndexHeader.version else {
            throw VectorIndexError.corruptShard(shardURL.lastPathComponent)
        }
        let dimension = blob[6..<8].toUInt16()
        let recordCount = blob[8..<(8 + MemoryLayout<UInt64>.size)].toUInt64()
        return VectorIndexHeader(dimension: dimension, recordCount: recordCount)
    }

    private func readRecordHeader(data: Data, offset: Int) -> VectorRecordHeader? {
        guard offset + VectorRecordHeader.byteSize <= data.count else { return nil }
        let idLength = data[offset..<(offset + 2)].toUInt16()
        let flags = data[(offset + 2)..<(offset + 4)].toUInt16()
        return VectorRecordHeader(idLength: idLength, flags: flags)
    }

    private func l2Distance(query: [Float], vectorData: Data) -> Float {
        var sum: Float = 0
        var index = vectorData.startIndex
        for value in query {
            let end = index + MemoryLayout<Float>.size
            let slice = vectorData[index..<end]
            let stored = Float(bitPattern: slice.toUInt32())
            let diff = value - stored
            sum += diff * diff
            index = end
        }
        return sqrt(sum)
    }
}

actor VectorIndex {
    private let name: String
    private let dimension: Int
    private let shardCount: Int
    private let directory: URL
    private let fileHandleFactory: VectorIndexFileHandleFactory
    private var shards: [Int: VectorIndexShard] = [:]
    private let shardLock = NSLock()

    init(name: String,
         dimension: Int = 384,
         directory: URL = PulsumData.vectorIndexDirectory,
         shardCount: Int = 16,
         fileHandleFactory: VectorIndexFileHandleFactory = SystemVectorIndexFileHandleFactory()) {
        self.name = name
        self.dimension = dimension
        self.directory = directory
        self.shardCount = shardCount
        self.fileHandleFactory = fileHandleFactory
    }

    func upsert(id: String, vector: [Float]) throws {
        let shard = try shard(for: id)
        try shard.upsert(id: id, vector: vector)
    }

    func remove(id: String) throws {
        let shard = try shard(for: id)
        try shard.remove(id: id)
    }

    func search(vector: [Float], topK: Int) throws -> [VectorMatch] {
        guard vector.count == dimension else {
            throw VectorIndexError.invalidDimension(expected: dimension, actual: vector.count)
        }

        var allMatches: [VectorMatch] = []
        for shardIndex in 0..<shardCount {
            let shard = try shard(forShardIndex: shardIndex)
            let matches = try shard.search(query: vector, topK: topK)
            allMatches.append(contentsOf: matches)
        }
        return Array(allMatches.sorted { $0.score < $1.score }.prefix(topK))
    }

    func stats() -> (shards: Int, items: Int) {
        var total = 0
        for index in 0..<shardCount {
            if let shard = try? shard(forShardIndex: index) {
                total += shard.metadata.count
            }
        }
        return (shardCount, total)
    }

    private func shard(for id: String) throws -> VectorIndexShard {
        let shardIndex = abs(id.hashValue) % shardCount
        return try shard(forShardIndex: shardIndex)
    }

    private func shard(forShardIndex index: Int) throws -> VectorIndexShard {
        shardLock.lock()
        defer { shardLock.unlock() }

        if let existing = shards[index] {
            return existing
        }

        let shard = try VectorIndexShard(baseDirectory: directory,
                                         name: name,
                                         shardIdentifier: "shard_\(index)",
                                         dimension: dimension,
                                         fileHandleFactory: fileHandleFactory)
        shards[index] = shard
        return shard
    }
}

private extension FixedWidthInteger {
    var littleEndianData: Data {
        var value = self.littleEndian
        return Data(bytes: &value, count: MemoryLayout<Self>.size)
    }
}

private extension DataProtocol {
    func toUInt16() -> UInt16 {
        var value: UInt16 = 0
        withUnsafeMutableBytes(of: &value) { buffer in
            _ = Data(self).copyBytes(to: buffer)
        }
        return UInt16(littleEndian: value)
    }

    func toUInt32() -> UInt32 {
        var value: UInt32 = 0
        withUnsafeMutableBytes(of: &value) { buffer in
            _ = Data(self).copyBytes(to: buffer)
        }
        return UInt32(littleEndian: value)
    }

    func toUInt64() -> UInt64 {
        var value: UInt64 = 0
        withUnsafeMutableBytes(of: &value) { buffer in
            _ = Data(self).copyBytes(to: buffer)
        }
        return UInt64(littleEndian: value)
    }
}
```
<!-- END_FILE: Packages/PulsumData/Sources/PulsumData/VectorIndex.swift -->

### Packages/PulsumData/Sources/PulsumData/VectorIndexManager.swift
- bytes: 2023
- lines: 52
- sha256: 6137a7951c825be7ab45db9381b53aa493c25c092ba6889c53f9eb5519ca0e4b
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Sources/PulsumData/VectorIndexManager.swift -->
```swift
import Foundation
import PulsumML

public protocol VectorIndexProviding: AnyObject, Sendable {
    @discardableResult
    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float]
    func removeMicroMoment(id: String) async throws
    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch]
    func stats() async -> (shards: Int, items: Int)
}

public extension VectorIndexProviding {
    func stats() async -> (shards: Int, items: Int) { (0, 0) }
}

public actor VectorIndexManager: VectorIndexProviding {
    public static let shared = VectorIndexManager()

    private let microMomentsIndex: VectorIndex
    private let embeddingService: EmbeddingService

    public init(embeddingService: EmbeddingService = .shared) {
        self.embeddingService = embeddingService
        self.microMomentsIndex = VectorIndex(name: "micro_moments")
    }

    init(embeddingService: EmbeddingService = .shared, microMomentsIndex: VectorIndex) {
        self.embeddingService = embeddingService
        self.microMomentsIndex = microMomentsIndex
    }

    @discardableResult
    public func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        let segments = [title, detail ?? "", tags?.joined(separator: " ") ?? ""].filter { !$0.isEmpty }
        let embedding = try embeddingService.embedding(forSegments: segments)
        try await microMomentsIndex.upsert(id: id, vector: embedding)
        return embedding
    }

    public func removeMicroMoment(id: String) async throws {
        try await microMomentsIndex.remove(id: id)
    }

    public func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] {
        let embedding = try embeddingService.embedding(for: query)
        return try await microMomentsIndex.search(vector: embedding, topK: topK)
    }

    public func stats() async -> (shards: Int, items: Int) {
        await microMomentsIndex.stats()
    }
}
```
<!-- END_FILE: Packages/PulsumData/Sources/PulsumData/VectorIndexManager.swift -->

### Packages/PulsumData/Tests/PulsumDataTests/DataStackSecurityTests.swift
- bytes: 1093
- lines: 23
- sha256: 4f05b13b4a24da75537004e0c3860beb27de085493b670e6d2f362443ace8a65
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Tests/PulsumDataTests/DataStackSecurityTests.swift -->
```swift
import XCTest
@testable import PulsumData

final class DataStackSecurityTests: XCTestCase {
    func testDebugApplyBackupExclusionMarksDirectories() throws {
        let temporaryRoot = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: temporaryRoot, withIntermediateDirectories: true)
        let directories = ["AppSupport", "VectorIndex", "Anchors"].map { temporaryRoot.appendingPathComponent($0, isDirectory: true) }
        for directory in directories {
            try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true)
        }

        let issue = DataStack.debugApplyBackupExclusion(to: directories)
        XCTAssertNil(issue)

        for directory in directories {
            let values = try directory.resourceValues(forKeys: [.isExcludedFromBackupKey])
            XCTAssertEqual(values.isExcludedFromBackup, true, "Directory \(directory.path) should be excluded from backup")
        }

        try FileManager.default.removeItem(at: temporaryRoot)
    }
}
```
<!-- END_FILE: Packages/PulsumData/Tests/PulsumDataTests/DataStackSecurityTests.swift -->

### Packages/PulsumData/Tests/PulsumDataTests/Gate0_DataStackSecurityTests.swift
- bytes: 994
- lines: 22
- sha256: 0b34b73cb1d3fe9c1ded2384d9c5accd57fc9d44f93d4ba12e4ba4a2d5f51da4
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate0_DataStackSecurityTests.swift -->
```swift
import XCTest
@testable import PulsumData

final class Gate0_DataStackSecurityTests: XCTestCase {
    func testPHIDirectoriesAreExcludedFromBackup() throws {
        let root = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        defer { try? FileManager.default.removeItem(at: root) }

        let directories = ["AppSupport", "VectorIndex", "Anchors"].map { root.appendingPathComponent($0, isDirectory: true) }
        for directory in directories {
            try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true)
        }

        let issue = DataStack.debugApplyBackupExclusion(to: directories)
        XCTAssertNil(issue)

        for directory in directories {
            let values = try directory.resourceValues(forKeys: [.isExcludedFromBackupKey])
            XCTAssertEqual(values.isExcludedFromBackup, true, "Directory \(directory.path) should be excluded from backup")
        }
    }
}
```
<!-- END_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate0_DataStackSecurityTests.swift -->

### Packages/PulsumData/Tests/PulsumDataTests/Gate5_LibraryImporterAtomicityTests.swift
- bytes: 11801
- lines: 304
- sha256: 83cdd9e3086430e8e7671964cde725c1bb60a27b4867bc57fd2ef65f27fc3df1
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate5_LibraryImporterAtomicityTests.swift -->
```swift
import CoreData
import CryptoKit
import XCTest
@testable import PulsumData
@testable import PulsumML

@MainActor
final class Gate5_LibraryImporterAtomicityTests: XCTestCase {
    private let testConfig = LibraryImporterConfiguration(bundle: .module,
                                                          subdirectory: "PulsumDataTests/Resources")
    private var container: NSPersistentContainer!
    private var storeDirectoryURL: URL?
    private var storeURL: URL?

    override func setUp() async throws {
        try await super.setUp()
        try setUpStore()
        resetStore()
    }

    override func tearDown() async throws {
        try tearDownStore()
        try await super.tearDown()
    }

    func testChecksumNotSavedOnIndexFailure_andRetrySucceeds() async throws {
        let metadata = try sampleMetadata()
        let failingIndex = FlakyIndex(failCount: 3)
        let importerFail = LibraryImporter(configuration: testConfig,
                                           vectorIndex: failingIndex,
                                           persistentContainer: container)

        do {
            try await importerFail.ingestIfNeeded()
            XCTFail("Expected indexing failure")
        } catch LibraryImporterError.indexingFailed {
            // expected
        } catch {
            XCTFail("Unexpected error: \(error)")
        }

        XCTAssertNil(fetchLibraryIngest(source: metadata.filename), "Checksum should not persist on indexing failure")

        let succeedingIndex = FlakyIndex(failCount: 0)
        let importerSuccess = LibraryImporter(configuration: testConfig,
                                              vectorIndex: succeedingIndex,
                                              persistentContainer: container)
        try await importerSuccess.ingestIfNeeded()

        let ingest = fetchLibraryIngest(source: metadata.filename)
        XCTAssertEqual(ingest?.checksum, metadata.checksum)

        let failingCount = await failingIndex.callCount()
        let successCount = await succeedingIndex.callCount()
        let totalUpserts = failingCount + successCount
        XCTAssertGreaterThanOrEqual(totalUpserts, metadata.microMomentCount)
    }

    func testImporterIsIdempotent_NoDuplicateEpisodesAfterRetry() async throws {
        let metadata = try sampleMetadata()
        let failingIndex = FlakyIndex(failCount: 2)
        let importerFail = LibraryImporter(configuration: testConfig,
                                           vectorIndex: failingIndex,
                                           persistentContainer: container)
        do {
            try await importerFail.ingestIfNeeded()
            XCTFail("Expected indexing failure")
        } catch LibraryImporterError.indexingFailed {
            // expected
        } catch {
            XCTFail("Unexpected error: \(error)")
        }

        let succeedingIndex = FlakyIndex(failCount: 0)
        let importerSuccess = LibraryImporter(configuration: testConfig,
                                              vectorIndex: succeedingIndex,
                                              persistentContainer: container)
        try await importerSuccess.ingestIfNeeded()

        let (count, uniqueCount) = fetchMicroMomentCounts()
        XCTAssertEqual(count, metadata.microMomentCount)
        XCTAssertEqual(uniqueCount, metadata.microMomentCount)
    }

    func testSkipWhenChecksumMatches_DoesNotTouchIndex() async throws {
        try await LibraryImporter(configuration: testConfig,
                                  vectorIndex: SpyIndex(),
                                  persistentContainer: container).ingestIfNeeded()

        let spy = SpyIndex(throwsOnUpsert: true)
        let importer = LibraryImporter(configuration: testConfig,
                                       vectorIndex: spy,
                                       persistentContainer: container)
        try await importer.ingestIfNeeded()

        let calls = await spy.upsertCallCount()
        XCTAssertEqual(calls, 0, "Checksum short-circuit should avoid index usage")
    }

    func testEmbeddingsUnavailableDefersIndexingGracefully() async throws {
        let metadata = try sampleMetadata()
        let unavailableIndex = UnavailableEmbeddingIndex()
        let importer = LibraryImporter(configuration: testConfig,
                                       vectorIndex: unavailableIndex,
                                       persistentContainer: container)

        try await importer.ingestIfNeeded()

        XCTAssertTrue(importer.lastImportHadDeferredEmbeddings)
        XCTAssertNil(fetchLibraryIngest(source: metadata.filename), "Checksum should not be saved when embeddings are unavailable")
        let (count, uniqueCount) = fetchMicroMomentCounts()
        XCTAssertGreaterThan(count, 0)
        XCTAssertEqual(count, uniqueCount)
    }

    // MARK: - Helpers

    private func setUpStore() throws {
        let fileManager = FileManager.default
        let directoryURL = fileManager.temporaryDirectory
            .appendingPathComponent("PulsumDataTests-\(UUID().uuidString)", isDirectory: true)
        try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true)
        let storeURL = directoryURL.appendingPathComponent("Pulsum.sqlite")
        container = Self.makePersistentContainer(storeURL: storeURL)
        storeDirectoryURL = directoryURL
        self.storeURL = storeURL
    }

    private func tearDownStore() throws {
        guard let container else { return }
        let coordinator = container.persistentStoreCoordinator
        if let storeURL, let store = coordinator.persistentStore(for: storeURL) {
            try coordinator.remove(store)
        }
        if let storeDirectoryURL {
            try FileManager.default.removeItem(at: storeDirectoryURL)
        }
        self.storeURL = nil
        self.storeDirectoryURL = nil
        self.container = nil
    }

    private static func makePersistentContainer(storeURL: URL) -> NSPersistentContainer {
        let container = NSPersistentContainer(name: "Pulsum",
                                              managedObjectModel: PulsumManagedObjectModel.shared)
        let description = NSPersistentStoreDescription(url: storeURL)
        description.type = NSSQLiteStoreType
        description.shouldAddStoreAsynchronously = false
        description.shouldMigrateStoreAutomatically = true
        description.shouldInferMappingModelAutomatically = true
        description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
        container.persistentStoreDescriptions = [description]
        container.loadPersistentStores { _, error in
            if let error {
                fatalError("Test Core Data store error: \(error)")
            }
        }
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
        container.viewContext.transactionAuthor = "Pulsum.Tests"
        return container
    }

    private func resetStore() {
        guard let container else {
            XCTFail("Test store not initialized")
            return
        }
        let viewContext = container.viewContext
        viewContext.performAndWait {
            ["MicroMoment", "LibraryIngest"].forEach { entity in
                let fetch = NSFetchRequest<NSFetchRequestResult>(entityName: entity)
                let delete = NSBatchDeleteRequest(fetchRequest: fetch)
                _ = try? viewContext.execute(delete)
            }
            try? viewContext.save()
        }
    }

    private func fetchLibraryIngest(source: String) -> LibraryIngest? {
        guard let container else {
            XCTFail("Test store not initialized")
            return nil
        }
        let viewContext = container.viewContext
        return viewContext.performAndWait {
            let request: NSFetchRequest<LibraryIngest> = LibraryIngest.fetchRequest()
            request.predicate = NSPredicate(format: "source == %@", source)
            request.fetchLimit = 1
            let results = try? viewContext.fetch(request)
            return results?.first
        }
    }

    private func fetchMicroMomentCounts() -> (Int, Int) {
        guard let container else {
            XCTFail("Test store not initialized")
            return (0, 0)
        }
        let viewContext = container.viewContext
        return viewContext.performAndWait {
            let request: NSFetchRequest<MicroMoment> = MicroMoment.fetchRequest()
            guard let moments = try? viewContext.fetch(request) else { return (0, 0) }
            let ids = moments.compactMap { $0.id }
            return (ids.count, Set(ids).count)
        }
    }

    private func sampleMetadata() throws -> (filename: String, checksum: String, microMomentCount: Int) {
        let url = try fixtureURL()
        let data = try Data(contentsOf: url)
        let checksum = SHA256.hash(data: data).map { String(format: "%02x", $0) }.joined()
        let episodes = try JSONDecoder().decode([SampleEpisode].self, from: data)
        let count = episodes.reduce(0) { $0 + $1.recommendations.count }
        return (url.lastPathComponent, checksum, count)
    }

    private func fixtureURL() throws -> URL {
        let bundle = Bundle.module
        if let url = bundle.url(forResource: "podcasts_sample",
                                withExtension: "json",
                                subdirectory: testConfig.subdirectory) {
            return url
        }
        if let url = bundle.url(forResource: "podcasts_sample",
                                withExtension: "json") {
            return url
        }
        throw XCTSkip("podcasts_sample.json fixture missing")
    }
}

// MARK: - Test Actors

private actor FlakyIndex: VectorIndexProviding {
    private var remainingFailures: Int
    private var calls = 0

    init(failCount: Int) {
        self.remainingFailures = failCount
    }

    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        calls += 1
        if remainingFailures > 0 {
            remainingFailures -= 1
            throw TestError.transient
        }
        return []
    }

    func removeMicroMoment(id: String) async throws {}

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] { [] }

    func callCount() -> Int { calls }
}

private actor SpyIndex: VectorIndexProviding {
    private var calls = 0
    private let throwsOnUpsert: Bool

    init(throwsOnUpsert: Bool = false) {
        self.throwsOnUpsert = throwsOnUpsert
    }

    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        calls += 1
        if throwsOnUpsert {
            throw TestError.transient
        }
        return []
    }

    func removeMicroMoment(id: String) async throws {}

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] { [] }

    func upsertCallCount() -> Int { calls }
}

private actor UnavailableEmbeddingIndex: VectorIndexProviding {
    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        throw EmbeddingError.generatorUnavailable
    }

    func removeMicroMoment(id: String) async throws {}

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] {
        throw EmbeddingError.generatorUnavailable
    }
}

private enum TestError: Error {
    case transient
}

private struct SampleEpisode: Decodable {
    let recommendations: [SampleRecommendation]
}

private struct SampleRecommendation: Decodable {
    let recommendation: String
}
```
<!-- END_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate5_LibraryImporterAtomicityTests.swift -->

### Packages/PulsumData/Tests/PulsumDataTests/Gate5_LibraryImporterPerfTests.swift
- bytes: 1220
- lines: 30
- sha256: 10e07431805a3ddb494e5b657fc41b9bf70cb265d6368038ae0b1b51ba0e8db9
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate5_LibraryImporterPerfTests.swift -->
```swift
import CoreData
import XCTest
@testable import PulsumData

final class Gate5_LibraryImporterPerfTests: XCTestCase {
    func testCoreDataReadCompletesQuicklyDuringImport() async throws {
        let viewContext = PulsumData.viewContext
        viewContext.performAndWait {
            let request = NSFetchRequest<NSFetchRequestResult>(entityName: "LibraryIngest")
            let deleteRequest = NSBatchDeleteRequest(fetchRequest: request)
            _ = try? viewContext.execute(deleteRequest)
            try? viewContext.save()
        }

        let config = LibraryImporterConfiguration(bundle: .module,
                                                  subdirectory: "PulsumDataTests/Resources")
        let importer = LibraryImporter(configuration: config)

        async let ingestTask: Void = importer.ingestIfNeeded()
        let start = Date()
        viewContext.performAndWait {
            let request = MicroMoment.fetchRequest()
            request.fetchLimit = 1
            _ = try? viewContext.fetch(request)
        }
        let elapsed = Date().timeIntervalSince(start)
        try await ingestTask
        XCTAssertLessThan(elapsed, 0.5, "Core Data read blocked for \(elapsed) seconds")
    }
}
```
<!-- END_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate5_LibraryImporterPerfTests.swift -->

### Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexConcurrencyTests.swift
- bytes: 2600
- lines: 60
- sha256: 712da8fefd05925e0392b1af58143260ab1d155f4a67c0268538f9ec34454ac2
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexConcurrencyTests.swift -->
```swift
import XCTest
@testable import PulsumData

final class Gate5_VectorIndexConcurrencyTests: XCTestCase {
    func testConcurrentShardOperationsRemainDeterministic() async throws {
        let tempDirectory = FileManager.default.temporaryDirectory
            .appendingPathComponent("gate5-vector-\(UUID().uuidString)", isDirectory: true)
        try FileManager.default.createDirectory(at: tempDirectory, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: tempDirectory) }

        let index = VectorIndex(name: "gate5-concurrency",
                                 directory: tempDirectory,
                                 shardCount: 8)
        let identifiers = (0..<64).map { "moment-\($0)" }
        let vectors = Dictionary(uniqueKeysWithValues: identifiers.enumerated().map { offset, id in
            (id, Self.makeVector(seed: offset))
        })

        try await withThrowingTaskGroup(of: Void.self) { group in
            for (offset, id) in identifiers.enumerated() {
                group.addTask { @Sendable () async throws -> Void in
                    guard let vector = vectors[id] else { return }
                    try await index.upsert(id: id, vector: vector)
                    if offset % 4 == 0 {
                        _ = try await index.search(vector: vector, topK: 5)
                    }
                    if offset % 6 == 0 {
                        try await index.remove(id: id)
                        try await index.upsert(id: id, vector: vector)
                    }
                }
            }

            for id in identifiers where ((Int(id.split(separator: "-").last ?? "0") ?? 0) % 5) == 0 {
                group.addTask { @Sendable () async throws -> Void in
                    guard let vector = vectors[id] else { return }
                    _ = try await index.search(vector: vector, topK: 3)
                }
            }

            for try await _ in group {
                // Drain the group so thrown errors surface to the task group caller.
            }
        }

        for id in identifiers {
            guard let vector = vectors[id] else {
                XCTFail("Missing vector for \(id)")
                continue
            }
            let matches = try await index.search(vector: vector, topK: 1)
            XCTAssertEqual(matches.first?.id, id, "Expected deterministic match for \(id)")
        }
    }

    private static func makeVector(seed: Int) -> [Float] {
        let base = Float(seed) / 100.0
        return (0..<384).map { Float($0) * 0.0001 + base }
    }
}
```
<!-- END_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexConcurrencyTests.swift -->

### Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexFileHandleTests.swift
- bytes: 2516
- lines: 76
- sha256: 916c65e2ade2fb397a00ea5bde99424085d961901ff9888357a817ee926d313f
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexFileHandleTests.swift -->
```swift
import XCTest
@testable import PulsumData

final class Gate5_VectorIndexFileHandleTests: XCTestCase {
    func testCloseFailureIsSurfacedToCaller() async throws {
        let directory = FileManager.default.temporaryDirectory
            .appendingPathComponent("gate5-close-\(UUID().uuidString)", isDirectory: true)
        try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: directory) }

        let warmIndex = VectorIndex(name: "gate5-close",
                                    directory: directory,
                                    fileHandleFactory: TestHandleFactory(shouldFailClose: false))
        let vector = Array(repeating: Float(0.1), count: 384)

        try await warmIndex.upsert(id: "seed", vector: vector)

        let failingIndex = VectorIndex(name: "gate5-close",
                                       directory: directory,
                                       fileHandleFactory: TestHandleFactory(shouldFailClose: true))

        do {
            try await failingIndex.upsert(id: "seed", vector: vector)
            XCTFail("Expected close failure to surface")
        } catch VectorIndexError.ioFailure(let message) {
            XCTAssertTrue(message.contains("close"), "Unexpected message: \(message)")
        } catch {
            XCTFail("Unexpected error: \(error)")
        }
    }
}

private struct TestHandleFactory: VectorIndexFileHandleFactory, Sendable {
    let shouldFailClose: Bool

    func updatingHandle(for url: URL) throws -> VectorIndexFileHandle {
        try TestVectorHandle(url: url, shouldFailClose: shouldFailClose)
    }
}

private final class TestVectorHandle: VectorIndexFileHandle {
    enum CloseError: Error {
        case simulated
    }

    private let handle: FileHandle
    private let shouldFailClose: Bool

    init(url: URL, shouldFailClose: Bool) throws {
        self.handle = try FileHandle(forUpdating: url)
        self.shouldFailClose = shouldFailClose
    }

    func seekToEnd() throws -> UInt64 {
        try handle.seekToEnd()
    }

    func seek(toOffset offset: UInt64) throws {
        try handle.seek(toOffset: offset)
    }

    func read(upToCount count: Int) throws -> Data? {
        try handle.read(upToCount: count)
    }

    func write(_ data: Data) {
        handle.write(data)
    }

    func close() throws {
        try handle.close()
        if shouldFailClose {
            throw CloseError.simulated
        }
    }
}
```
<!-- END_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexFileHandleTests.swift -->

### Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexManagerActorTests.swift
- bytes: 1957
- lines: 42
- sha256: 9c6ce70425c3ad6d955a728e31ac7e079c520a7bb189472de99921eb1db69a7c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexManagerActorTests.swift -->
```swift
import XCTest
@testable import PulsumData
@testable import PulsumML

final class Gate5_VectorIndexManagerActorTests: XCTestCase {
    func testManagerAllowsConcurrentAccessFromBackgroundTasks() async throws {
        let directory = FileManager.default.temporaryDirectory
            .appendingPathComponent("gate5-manager-\(UUID().uuidString)", isDirectory: true)
        try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: directory) }

        let vectorIndex = VectorIndex(name: "gate5-manager", directory: directory, shardCount: 4)
        let provider = MockEmbeddingProvider()
        let embeddingService = EmbeddingService.debugInstance(primary: provider, fallback: provider)
        let manager = VectorIndexManager(embeddingService: embeddingService, microMomentsIndex: vectorIndex)

        let identifiers = (0..<12).map { "moment-\($0)" }
        try await withThrowingTaskGroup(of: Void.self) { group in
            for id in identifiers {
                group.addTask {
                    _ = try await manager.upsertMicroMoment(id: id,
                                                            title: id,
                                                            detail: nil as String?,
                                                            tags: nil as [String]?)
                }
            }
            try await group.waitForAll()
        }

        let sampleID = identifiers.first ?? "moment-0"
        let matches = try await manager.searchMicroMoments(query: sampleID, topK: 2)
        XCTAssertTrue(matches.contains(where: { $0.id == sampleID }))
    }
}

private struct MockEmbeddingProvider: TextEmbeddingProviding {
    func embedding(for text: String) throws -> [Float] {
        let seed = abs(text.hashValue % 1000)
        let value = Float(seed) / 1000.0
        return Array(repeating: value, count: 384)
    }
}
```
<!-- END_FILE: Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexManagerActorTests.swift -->

### Packages/PulsumData/Tests/PulsumDataTests/LibraryImporterTests.swift
- bytes: 2484
- lines: 65
- sha256: 4de7874806d84e97e581c45b4c6351f68ad292b3becff5d6f4d20537bf4c627c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Tests/PulsumDataTests/LibraryImporterTests.swift -->
```swift
import CoreData
import XCTest
@testable import PulsumData

final actor HappyPathIndexStub: VectorIndexProviding {
    private(set) var upsertedIds: [String] = []

    @discardableResult
    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] {
        upsertedIds.append(id)
        return Array(repeating: 0.1, count: 384)
    }

    func removeMicroMoment(id: String) async throws {
        // no-op
    }

    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] {
        []
    }
}

final class LibraryImporterTests: XCTestCase {
    func testIngestCreatesMicroMomentsAndVectorIndex() async throws {
        let config = LibraryImporterConfiguration(bundle: .module,
                                                  subdirectory: "PulsumDataTests/Resources")
        let indexStub = HappyPathIndexStub()
        let importer = LibraryImporter(configuration: config, vectorIndex: indexStub)
        try await importer.ingestIfNeeded()

        let viewContext = PulsumData.viewContext
        let snapshot = await viewContext.perform { () -> (id: String, title: String, badge: String?)? in
            do {
                let request = MicroMoment.fetchRequest()
                request.fetchLimit = 1
                if let moment = try viewContext.fetch(request).first {
                    return (moment.id, moment.title, moment.evidenceBadge)
                }
            } catch {
                XCTFail("Fetch failed: \(error)")
            }
            return nil
        }

        guard let momentSnapshot = snapshot else {
            XCTFail("MicroMoment not ingested")
            return
        }

        let counts = await viewContext.perform { () -> (count: Int, unique: Int) in
            let request: NSFetchRequest<MicroMoment> = MicroMoment.fetchRequest()
            let moments = (try? viewContext.fetch(request)) ?? []
            let unique = Set(moments.map(\.id)).count
            return (moments.count, unique)
        }

        XCTAssertEqual(momentSnapshot.title, "Practice diaphragmatic breathing")
        XCTAssertEqual(momentSnapshot.badge, EvidenceBadge.strong.rawValue)
        XCTAssertGreaterThan(counts.count, 0)
        XCTAssertEqual(counts.count, counts.unique)

        let upserts = await indexStub.upsertedIds.count
        XCTAssertGreaterThan(upserts, 0, "Happy-path importer should upsert at least one micro-moment into the index.")
    }
}
```
<!-- END_FILE: Packages/PulsumData/Tests/PulsumDataTests/LibraryImporterTests.swift -->

### Packages/PulsumData/Tests/PulsumDataTests/PulsumDataBootstrapTests.swift
- bytes: 1166
- lines: 29
- sha256: bed04ed0334fbac69018d6d040c366cf9a8ff4b49f88e00c6dac60adbc4a1b20
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Tests/PulsumDataTests/PulsumDataBootstrapTests.swift -->
```swift
import XCTest
import CoreData
@testable import PulsumData

final class PulsumDataBootstrapTests: XCTestCase {
    func testPersistentContainerLoadsPulsumModel() {
        let container = PulsumData.container
        XCTAssertEqual(container.name, "Pulsum")
        XCTAssertNotNil(container.managedObjectModel.entitiesByName["JournalEntry"])
    }

    func testBackgroundContextCreation() {
        let context = PulsumData.newBackgroundContext(name: "Pulsum.Test")
        XCTAssertEqual(context.name, "Pulsum.Test")
        XCTAssertEqual(context.persistentStoreCoordinator, PulsumData.container.persistentStoreCoordinator)
    }

    func testVectorIndexDirectoryIsInsideApplicationSupport() {
        let vectorDirectory = PulsumData.vectorIndexDirectory
        XCTAssertTrue(vectorDirectory.path.contains("Pulsum"))
        XCTAssertTrue(vectorDirectory.path.contains("VectorIndex"))
    }

    func testHealthAnchorsDirectoryIsInsideApplicationSupport() {
        let anchorsDirectory = PulsumData.healthAnchorsDirectory
        XCTAssertTrue(anchorsDirectory.path.contains("Pulsum"))
        XCTAssertTrue(anchorsDirectory.path.contains("Anchors"))
    }
}
```
<!-- END_FILE: Packages/PulsumData/Tests/PulsumDataTests/PulsumDataBootstrapTests.swift -->

### Packages/PulsumData/Tests/PulsumDataTests/Resources/podcasts_sample.json
- bytes: 785
- lines: 20
- sha256: 6a63e871a113e1294d5958150892d674f9098a7bade4bd18931c7a8ec02f96da
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Tests/PulsumDataTests/Resources/podcasts_sample.json -->
```text
[
  {
    "episodeNumber": "001",
    "episodeTitle": "Sample Episode",
    "recommendations": [
      {
        "timestamp": "approximate",
        "recommendation": "Practice diaphragmatic breathing",
        "shortDescription": "Reset your nervous system with a two-minute breathing drill.",
        "detailedDescription": "Slow, deep breaths help stimulate the parasympathetic response. Arnold reminds listeners to anchor breath work before stressful tasks.",
        "microActivity": "Breathe in for 4 seconds, hold 2, exhale 6 for 6 rounds.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/29564973/",
        "difficultyLevel": "Easy",
        "timeToComplete": "2 min",
        "tags": ["breathing", "stress"],
        "category": "Mental Health"
      }
    ]
  }
]
```
<!-- END_FILE: Packages/PulsumData/Tests/PulsumDataTests/Resources/podcasts_sample.json -->

### Packages/PulsumData/Tests/PulsumDataTests/VectorIndexTests.swift
- bytes: 817
- lines: 16
- sha256: c53221882658905c45d9d640eca1102b4ee092e58fdf4e2cd51fa6680a5523d3
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumData/Tests/PulsumDataTests/VectorIndexTests.swift -->
```swift
import XCTest
@testable import PulsumData

final class VectorIndexTests: XCTestCase {
    func testUpsertAndSearch() async throws {
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent("VectorIndexTests-\(UUID().uuidString)", isDirectory: true)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        let vectorIndex = VectorIndex(name: "test-index", directory: tempDir)
        let embedding = Array(repeating: Float(0.5), count: 384)
        try await vectorIndex.upsert(id: "test", vector: embedding)
        let results = try await vectorIndex.search(vector: embedding, topK: 1)
        XCTAssertEqual(results.first?.id, "test")
        XCTAssertEqual(results.first?.score, 0)
        try await vectorIndex.remove(id: "test")
    }
}
```
<!-- END_FILE: Packages/PulsumData/Tests/PulsumDataTests/VectorIndexTests.swift -->

### Packages/PulsumML/Package.swift
- bytes: 1249
- lines: 46
- sha256: ec9bd40e8fbae0fee3ee58e4c746b7484e217416e36e8f53b61d04e949d98064
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Package.swift -->
```swift
// swift-tools-version: 6.1
import PackageDescription

let package = Package(
    name: "PulsumML",
    platforms: [
        .iOS("26.0"),
        .macOS(.v14)
    ],
    products: [
        .library(
            name: "PulsumML",
            targets: ["PulsumML"]
        )
    ],
    dependencies: [
        .package(path: "../PulsumTypes")
    ],
    targets: [
        .target(
            name: "PulsumML",
            dependencies: [
                "PulsumTypes"
            ],
            path: "Sources",
            exclude: [
                "PulsumML/AFM/README_FoundationModels.md",
                "PulsumML/Resources/README_CreateModel.md"
            ],
            resources: [
                .process("PulsumML/Resources/PulsumFallbackEmbedding.mlmodel"),
                .process("PulsumML/Resources/PulsumSentimentCoreML.mlmodel"),
                .process("PulsumML/PrivacyInfo.xcprivacy")
            ],
            linkerSettings: [
                .linkedFramework("FoundationModels", .when(platforms: [.iOS])),
                .linkedFramework("Accelerate")
            ]
        ),
        .testTarget(
            name: "PulsumMLTests",
            dependencies: ["PulsumML"],
            path: "Tests"
        )
    ]
)
```
<!-- END_FILE: Packages/PulsumML/Package.swift -->

### Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsAvailability.swift
- bytes: 1504
- lines: 47
- sha256: 62494100fc9ae10975f9d5d33774f16b711d0d9d9a33469742124e94b0f585f7
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsAvailability.swift -->
```swift
import Foundation
#if canImport(FoundationModels) && os(iOS)
import FoundationModels
#endif

public enum AFMStatus {
    case ready
    case needsAppleIntelligence
    case downloading
    case unsupportedDevice
    case unknown
}

public final class FoundationModelsAvailability {
#if canImport(FoundationModels) && os(iOS)
    public static func checkAvailability() -> AFMStatus {
        guard #available(iOS 26.0, *) else { return .needsAppleIntelligence }
        switch SystemLanguageModel.default.availability {
        case .available:
            return .ready
        case .unavailable(.appleIntelligenceNotEnabled):
            return .needsAppleIntelligence
        case .unavailable(.modelNotReady):
            return .downloading
        default:
            return .unknown
        }
    }
#else
    public static func checkAvailability() -> AFMStatus { .unsupportedDevice }
#endif
    
    public static func availabilityMessage(for status: AFMStatus) -> String {
        switch status {
        case .ready:
            return "Apple Intelligence is ready."
        case .needsAppleIntelligence:
            return "Please enable Apple Intelligence in Settings to use AI features."
        case .downloading:
            return "Preparing AI model... This may take a few minutes."
        case .unsupportedDevice:
            return "This device doesn't support Apple Intelligence."
        case .unknown:
            return "AI features are temporarily unavailable."
        }
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsAvailability.swift -->

### Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsStub.swift
- bytes: 1997
- lines: 81
- sha256: d991cc0b80bd1e6a297717e810570252b4d87b53a0736750e054ecbd926a5b90
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsStub.swift -->
```swift
import Foundation

// TEMPORARY: Foundation Models stubs for current Xcode compatibility
// Remove when iOS 26 SDK becomes available

#if !canImport(FoundationModels)

// Stub Foundation Models types for compilation compatibility
public struct SystemLanguageModel: Sendable {
    @MainActor public static let `default` = SystemLanguageModel()
    public var isAvailable: Bool { false }
}

public struct LanguageModelSession: Sendable {
    public init(instructions: Instructions? = nil) {}
    public init(temperature: Double) {}

    public func respond<T: Decodable & Sendable>(
        to prompt: Prompt,
        generating type: T.Type,
        options: GenerationOptions
    ) async throws -> LanguageModelResult<T> {
        throw FoundationModelsStubError.unavailable
    }

    public func respond(
        to prompt: Prompt,
        options: GenerationOptions
    ) async throws -> LanguageModelResult<String> {
        throw FoundationModelsStubError.unavailable
    }

    public enum GenerationError: Error, Sendable {
        case guardrailViolation(String)
        case refusal(String, String)
    }
}

public struct Instructions: Sendable {
    public init(_ text: String) {}
}

public struct Prompt: Sendable {
    public init(_ text: String) {}
}

public struct GenerationOptions: Sendable {
    public init(temperature: Double) {}
}

public struct LanguageModelResult<Content: Sendable>: Sendable {
    public let content: Content

    public init(content: Content) {
        self.content = content
    }
}

@propertyWrapper
public struct Generable<T: Sendable>: Sendable {
    public var wrappedValue: T
    public init(wrappedValue: T) {
        self.wrappedValue = wrappedValue
    }
}

@propertyWrapper
public struct Guide<T: Sendable>: Sendable {
    public var wrappedValue: T
    public init(wrappedValue: T, description: String) {
        self.wrappedValue = wrappedValue
    }
}

public enum FoundationModelsStubError: Error, Sendable {
    case unavailable
}

#endif


```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsStub.swift -->

### Packages/PulsumML/Sources/PulsumML/BaselineMath.swift
- bytes: 1478
- lines: 41
- sha256: 04a2a2371ae369542d5d792b812c753ff4bb560702dae336aef8ab1fd749bbf9
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/BaselineMath.swift -->
```swift
import Foundation

public enum BaselineMath {
    public struct RobustStats {
        public let median: Double
        public let mad: Double

        public init(median: Double, mad: Double) {
            self.median = median
            self.mad = mad
        }
    }

    public static func robustStats(for values: [Double]) -> RobustStats? {
        guard !values.isEmpty else { return nil }
        let sorted = values.sorted()
        let median = percentile(sorted, percentile: 0.5)
        let deviations = sorted.map { abs($0 - median) }
        let mad = percentile(deviations.sorted(), percentile: 0.5) * 1.4826
        return RobustStats(median: median, mad: max(mad, 1e-6))
    }

    public static func zScore(value: Double, stats: RobustStats) -> Double {
        (value - stats.median) / stats.mad
    }

    public static func ewma(previous: Double?, newValue: Double, lambda: Double = 0.2) -> Double {
        guard let previous else { return newValue }
        return lambda * newValue + (1 - lambda) * previous
    }

    private static func percentile(_ values: [Double], percentile: Double) -> Double {
        guard !values.isEmpty else { return 0 }
        let index = Double(values.count - 1) * percentile
        let lower = Int(floor(index))
        let upper = Int(ceil(index))
        if lower == upper { return values[lower] }
        let weight = index - Double(lower)
        return values[lower] * (1 - weight) + values[upper] * weight
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/BaselineMath.swift -->

### Packages/PulsumML/Sources/PulsumML/Bundle+PulsumMLResources.swift
- bytes: 271
- lines: 12
- sha256: c140b3186d5cf08b3303c136bf7b291c2cede2fd3f9159deb5e31e24d91f314d
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Bundle+PulsumMLResources.swift -->
```swift
import Foundation

#if SWIFT_PACKAGE
extension Bundle {
    static var pulsumMLResources: Bundle { .module }
}
#else
private final class PulsumMLBundleToken {}
extension Bundle {
    static var pulsumMLResources: Bundle { Bundle(for: PulsumMLBundleToken.self) }
}
#endif
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Bundle+PulsumMLResources.swift -->

### Packages/PulsumML/Sources/PulsumML/Embedding/AFMTextEmbeddingProvider.swift
- bytes: 1984
- lines: 51
- sha256: 5c157e9486bc6fefd5da59fbb7ba68df8a56cc9fe99c25589245002e84fd291c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Embedding/AFMTextEmbeddingProvider.swift -->
```swift
import Foundation
import NaturalLanguage

/// Opportunistic AFM/NL embedding provider.
///
/// This provider only attempts contextual embeddings when Apple Intelligence reports `.ready`.
/// On failure (or platforms without FoundationModels), it throws `generatorUnavailable` so callers
/// can fall back to the Core ML provider without masking errors.
@available(iOS 17.0, macOS 13.0, *)
final class AFMTextEmbeddingProvider: TextEmbeddingProviding {
    private let targetDimension = 384
    private let availability: () -> AFMStatus

    init(availability: @escaping () -> AFMStatus = FoundationModelsAvailability.checkAvailability) {
        self.availability = availability
    }

    func embedding(for text: String) throws -> [Float] {
#if canImport(FoundationModels) && os(iOS)
        guard #available(iOS 26.0, *), availability() == .ready else {
            throw EmbeddingError.generatorUnavailable
        }

        // Use the most capable contextual embedding available on the platform.
        let embedding = NLEmbedding.sentenceEmbedding(for: .english) ?? NLEmbedding.wordEmbedding(for: .english)
        guard let embedding, let vector = embedding.vector(for: text), !vector.isEmpty else {
            throw EmbeddingError.generatorUnavailable
        }

        let floats = vector.map { Float($0) }
        let adjusted = adjustDimension(floats)
        guard adjusted.contains(where: { $0 != 0 }) else {
            throw EmbeddingError.emptyResult
        }
        return adjusted
#else
        throw EmbeddingError.generatorUnavailable
#endif
    }

    private func adjustDimension(_ vector: [Float]) -> [Float] {
        if vector.count == targetDimension { return vector }
        if vector.count > targetDimension { return Array(vector.prefix(targetDimension)) }
        var padded = vector
        padded.reserveCapacity(targetDimension)
        while padded.count < targetDimension {
            padded.append(0)
        }
        return padded
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Embedding/AFMTextEmbeddingProvider.swift -->

### Packages/PulsumML/Sources/PulsumML/Embedding/CoreMLEmbeddingFallbackProvider.swift
- bytes: 2240
- lines: 57
- sha256: 598ec8a92896121cddad25535906fcef5e25cf2a0c88be6dad16b8d66faac4f5
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Embedding/CoreMLEmbeddingFallbackProvider.swift -->
```swift
import Foundation
import CoreML
import NaturalLanguage
import os.log

/// Reliable on-device fallback embedding provider backed by the bundled Core ML model.
@available(iOS 17.0, macOS 13.0, *)
final class CoreMLEmbeddingFallbackProvider: TextEmbeddingProviding {
    private let embedding: NLEmbedding?
    private let targetDimension = 384
    private let logger = Logger(subsystem: "com.pulsum", category: "EmbeddingService")

    init() {
        let bundle = Bundle.pulsumMLResources

        if let compiledURL = bundle.url(forResource: "PulsumFallbackEmbedding", withExtension: "mlmodelc"),
           let loaded = try? NLEmbedding(contentsOf: compiledURL) {
            embedding = loaded
        } else if let modelURL = bundle.url(forResource: "PulsumFallbackEmbedding", withExtension: "mlmodel"),
                  let compiled = try? MLModel.compileModel(at: modelURL),
                  let loaded = try? NLEmbedding(contentsOf: compiled) {
            embedding = loaded
        } else {
            embedding = nil
#if DEBUG
            assertionFailure("PulsumFallbackEmbedding.{mlmodel|mlmodelc} is missing from the PulsumML bundle.")
            logger.error("Failed to locate PulsumFallbackEmbedding in bundle \(bundle.bundleURL, privacy: .public)")
#endif
        }
    }

    func embedding(for text: String) throws -> [Float] {
        guard let embedding,
              let vector = embedding.vector(for: text) else {
#if DEBUG
            logger.error("PulsumFallbackEmbedding failed to load; throwing generatorUnavailable.")
#endif
            throw EmbeddingError.generatorUnavailable
        }
        let adjusted = adjustDimension(vector.map { Float($0) })
        guard adjusted.contains(where: { $0 != 0 }) else {
            throw EmbeddingError.emptyResult
        }
        return adjusted
    }

    private func adjustDimension(_ vector: [Float]) -> [Float] {
        if vector.count == targetDimension { return vector }
        if vector.count > targetDimension { return Array(vector.prefix(targetDimension)) }
        var padded = vector
        padded.reserveCapacity(targetDimension)
        while padded.count < targetDimension {
            padded.append(0)
        }
        return padded
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Embedding/CoreMLEmbeddingFallbackProvider.swift -->

### Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingError.swift
- bytes: 401
- lines: 15
- sha256: 5844e56cc3a6982e0cb9c7dfe5a1cb52305e37bf06e60e79eda952a9e065d023
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingError.swift -->
```swift
import Foundation

public enum EmbeddingError: LocalizedError {
    case generatorUnavailable
    case emptyResult

    public var errorDescription: String? {
        switch self {
        case .generatorUnavailable:
            return "On-device embedding generator is unavailable."
        case .emptyResult:
            return "Failed to compute embedding for the provided text."
        }
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingError.swift -->

### Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingService.swift
- bytes: 15632
- lines: 364
- sha256: c4c95c0ff6b70353d5d4b4922796065f6831b08572b4801e285e0415b8970dc8
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingService.swift -->
```swift
import Foundation
import os
import PulsumTypes

/// Central access point for on-device embeddings with AFM primary and hash fallback.
public final class EmbeddingService {
    public static let shared = EmbeddingService()

    public enum AvailabilityMode {
        case available
        case unavailable
    }

    private let primaryProvider: TextEmbeddingProviding?
    private let fallbackProvider: TextEmbeddingProviding?
    private let dimension: Int
    private let availabilityQueue = DispatchQueue(label: "ai.pulsum.embedding.availability", qos: .utility)
    private enum AvailabilityState {
        case unknown
        case available
        case unavailable(lastChecked: Date)
        case probing(previous: Bool?)
    }

    private var availabilityState: AvailabilityState = .unknown
    private var lastReportedAvailability: AvailabilityMode?
    private let availabilityProbeText = "pulsum-availability-check"
    private let reprobeInterval: TimeInterval
    private let dateProvider: () -> Date
    private let logger = Logger(subsystem: "com.pulsum", category: "EmbeddingService")
    #if DEBUG
    private let debugAvailabilityOverride: Bool?
    #endif

    private init(primary: TextEmbeddingProviding? = nil,
                 fallback: TextEmbeddingProviding? = nil,
                 dimension: Int = 384,
                 reprobeInterval: TimeInterval = 3600,
                 dateProvider: @escaping () -> Date = Date.init) {
        self.dimension = dimension
        self.reprobeInterval = reprobeInterval
        self.dateProvider = dateProvider
        #if DEBUG
        self.debugAvailabilityOverride = Self.parseDebugAvailabilityOverride()
        #endif
        if let primary {
            self.primaryProvider = primary
        } else if #available(iOS 17.0, macOS 13.0, *) {
            self.primaryProvider = AFMTextEmbeddingProvider()
        } else {
            self.primaryProvider = nil
        }

        if let fallback {
            self.fallbackProvider = fallback
        } else if #available(iOS 17.0, macOS 13.0, *) {
            self.fallbackProvider = CoreMLEmbeddingFallbackProvider()
        } else {
            self.fallbackProvider = nil
        }
    }

    /// Availability probe with self-healing. Re-probes after a cooldown or once Apple Intelligence reports ready.
    public func isAvailable(trigger: String = "cache_check") -> Bool {
        let now = dateProvider()
        var shouldProbe = true
        var cachedResult: Bool?

        availabilityQueue.sync {
            #if DEBUG
            if let override = debugAvailabilityOverride {
                availabilityState = override ? .available : .unavailable(lastChecked: now)
                shouldProbe = false
                cachedResult = override
                return
            }
            #endif
            switch availabilityState {
            case .available:
                shouldProbe = false
                cachedResult = true
            case .unavailable(let lastChecked):
                let fmReady = FoundationModelsAvailability.checkAvailability() == .ready
                if fmReady || now.timeIntervalSince(lastChecked) >= reprobeInterval {
                    availabilityState = .probing(previous: false)
                    shouldProbe = true
                    cachedResult = false
                } else {
                    shouldProbe = false
                    cachedResult = false
                }
            case .probing(let previous):
                shouldProbe = false
                cachedResult = previous
            case .unknown:
                availabilityState = .probing(previous: nil)
                shouldProbe = true
                cachedResult = nil
            }
        }

        if !shouldProbe {
            return cachedResult ?? false
        }

        let result = probeAvailability(trigger: trigger)

        availabilityQueue.sync {
            availabilityState = result ? .available : .unavailable(lastChecked: now)
            logAvailabilityChangeIfNeeded(newMode: result ? .available : .unavailable, trigger: trigger)
        }
        return result
    }

    /// Clears any cached availability decision so a subsequent probe re-evaluates providers.
    public func invalidateAvailabilityCache() {
        availabilityQueue.sync {
            availabilityState = .unknown
        }
    }

    /// Refreshes availability off the caller's thread, optionally forcing a probe even if cached unavailable.
    @discardableResult
    public func refreshAvailability(force: Bool = false, trigger: String = "manual") async -> AvailabilityMode {
        await withCheckedContinuation { continuation in
            availabilityQueue.async {
                let now = self.dateProvider()

                #if DEBUG
                if let override = self.debugAvailabilityOverride {
                    self.availabilityState = override ? .available : .unavailable(lastChecked: now)
                    continuation.resume(returning: override ? .available : .unavailable)
                    return
                }
                #endif

                var shouldProbe = force
                var cached: AvailabilityMode = .unavailable
                switch self.availabilityState {
                case .available:
                    cached = .available
                case .unavailable(let lastChecked):
                    cached = .unavailable
                    let fmReady = FoundationModelsAvailability.checkAvailability() == .ready
                    if fmReady || now.timeIntervalSince(lastChecked) >= self.reprobeInterval {
                        shouldProbe = true
                    }
                case .probing(let previous):
                    cached = (previous ?? false) ? .available : .unavailable
                case .unknown:
                    shouldProbe = true
                }

                guard shouldProbe else {
                    continuation.resume(returning: cached)
                    return
                }

                self.availabilityState = .probing(previous: cached == .available)
                let result = self.probeAvailability(trigger: trigger)
                let mode: AvailabilityMode = result ? .available : .unavailable
                self.availabilityState = mode == .available ? .available : .unavailable(lastChecked: now)
                self.logAvailabilityChangeIfNeeded(newMode: mode, trigger: trigger)
                continuation.resume(returning: mode)
            }
        }
    }

    /// Lightweight availability probe without invoking caller text; callers can branch without throwing.
    public func availabilityMode(trigger: String = "cache_check") -> AvailabilityMode {
        isAvailable(trigger: trigger) ? .available : .unavailable
    }

    /// Generates an embedding for the supplied text, padding or truncating to 384 dimensions.
    public func embedding(for text: String) throws -> [Float] {
        var lastError: Error?
        var lastProvider: DiagnosticsSafeString?

        if let primaryProvider {
            do {
                let vector = try primaryProvider.embedding(for: text)
                return try validated(vector)
            } catch {
                lastError = error
                lastProvider = DiagnosticsSafeString.stage("primary", allowed: Set(["primary", "fallback"]))
            }
        }

        if let fallbackProvider {
            do {
                let vector = try fallbackProvider.embedding(for: text)
                return try validated(vector)
            } catch {
                lastError = error
                lastProvider = DiagnosticsSafeString.stage("fallback", allowed: Set(["primary", "fallback"]))
            }
        }

        Diagnostics.log(level: .error,
                        category: .embeddings,
                        name: "embeddings.embedding.failed",
                        fields: [
                            "provider": .safeString(lastProvider ?? DiagnosticsSafeString.stage("none", allowed: Set(["none", "primary", "fallback"]))),
                            "dimension": .int(dimension)
                        ],
                        error: lastError)
        throw lastError ?? EmbeddingError.generatorUnavailable
    }

    /// Generates a combined embedding for multiple text segments (averaged element-wise).
    public func embedding(forSegments segments: [String]) throws -> [Float] {
        guard !segments.isEmpty else { throw EmbeddingError.emptyResult }
        var accumulator = [Float](repeating: 0, count: dimension)
        var count: Float = 0
        for (index, segment) in segments.enumerated() where !segment.isEmpty {
            do {
                let vector = try embedding(for: segment)
                for index in 0..<dimension {
                    accumulator[index] += vector[index]
                }
                count += 1
            } catch {
                #if DEBUG
                logger.debug("Segment embedding failed at index \(index, privacy: .public); continuing without it. Error: \(error.localizedDescription, privacy: .public)")
                #endif
                continue
            }
        }
        guard count > 0 else { throw EmbeddingError.generatorUnavailable }
        for index in 0..<dimension {
            accumulator[index] /= count
        }
        guard accumulator.contains(where: { $0 != 0 }) else {
            throw EmbeddingError.emptyResult
        }
        return accumulator
    }

    private func validated(_ vector: [Float]) throws -> [Float] {
        guard !vector.isEmpty else { throw EmbeddingError.emptyResult }
        if vector.count == dimension {
            guard vector.contains(where: { $0 != 0 }) else { throw EmbeddingError.emptyResult }
            return vector
        }
        let adjusted: [Float]
        if vector.count > dimension {
            adjusted = Array(vector.prefix(dimension))
        } else {
            var padded = vector
            padded.reserveCapacity(dimension)
            while padded.count < dimension {
                padded.append(0)
            }
            adjusted = padded
        }
        guard adjusted.contains(where: { $0 != 0 }) else { throw EmbeddingError.emptyResult }
        return adjusted
    }

    private func probeAvailability(trigger: String) -> Bool {
        let triggerSafe = DiagnosticsSafeString.stage(trigger, allowed: Set(["cache_check", "manual", "startup", "foreground", "retry_deferred"]))
        let span = Diagnostics.span(category: .embeddings,
                                    name: "embeddings.availability.probe",
                                    fields: [
                                        "trigger": .safeString(triggerSafe),
                                        "dimension": .int(dimension)
                                    ],
                                    level: .info)
        let start = ContinuousClock().now
        var providerUsed = DiagnosticsSafeString.stage("unknown", allowed: Set(["primary", "fallback", "unknown"]))
        var success = false

        if let primaryProvider {
            if let vector = try? primaryProvider.embedding(for: availabilityProbeText),
               vector.count == dimension,
               vector.contains(where: { $0 != 0 }) {
                success = true
                providerUsed = DiagnosticsSafeString.stage("primary", allowed: Set(["primary", "fallback", "unknown"]))
            }
        }

        if !success, let fallbackProvider {
            if let vector = try? fallbackProvider.embedding(for: availabilityProbeText),
               vector.count == dimension,
               vector.contains(where: { $0 != 0 }) {
                success = true
                providerUsed = DiagnosticsSafeString.stage("fallback", allowed: Set(["primary", "fallback", "unknown"]))
            }
        }

        if !success {
            logger.error("Embedding availability probe failed; providers unavailable or returned zero-vector.")
        }

        let elapsed = ContinuousClock().now - start
        let durationMs = Double(elapsed.components.seconds) * 1_000 + Double(elapsed.components.attoseconds) / 1_000_000_000_000_000.0
        span.end(additionalFields: [
            "trigger": .safeString(triggerSafe),
            "provider": .safeString(providerUsed),
            "result": .safeString(DiagnosticsSafeString.stage(success ? "available" : "unavailable",
                                                              allowed: Set(["available", "unavailable"]))),
            "dimension": .int(dimension)
        ], error: success ? nil : EmbeddingError.generatorUnavailable)
        Diagnostics.log(level: success ? .info : .warn,
                        category: .embeddings,
                        name: "embeddings.availability.probe.end",
                        fields: [
                            "trigger": .safeString(triggerSafe),
                            "provider": .safeString(providerUsed),
                            "result": .safeString(DiagnosticsSafeString.stage(success ? "available" : "unavailable",
                                                                              allowed: Set(["available", "unavailable"]))),
                            "dimension": .int(dimension),
                            "duration_ms": .double(durationMs)
                        ])
        return success
    }

    #if DEBUG
    private static func parseDebugAvailabilityOverride() -> Bool? {
        guard let value = ProcessInfo.processInfo.environment["PULSUM_EMBEDDINGS_AVAILABLE"]?.lowercased() else {
            return nil
        }
        if ["1", "true", "yes", "available"].contains(value) {
            return true
        }
        if ["0", "false", "no", "unavailable"].contains(value) {
            return false
        }
        return nil
    }
    #endif

    private func logAvailabilityChangeIfNeeded(newMode: AvailabilityMode, trigger: String) {
        guard lastReportedAvailability != newMode else { return }
        lastReportedAvailability = newMode
        Diagnostics.log(level: .info,
                        category: .embeddings,
                        name: "embeddings.availability.changed",
                        fields: [
                            "state": .safeString(DiagnosticsSafeString.stage(newMode == .available ? "available" : "unavailable",
                                                                             allowed: Set(["available", "unavailable"]))),
                            "trigger": .safeString(DiagnosticsSafeString.stage(trigger,
                                                                               allowed: Set(["cache_check", "manual", "startup", "foreground", "retry_deferred"])))
                        ])
    }
}

#if DEBUG
extension EmbeddingService {
    public static func debugInstance(primary: TextEmbeddingProviding? = nil,
                                     fallback: TextEmbeddingProviding? = nil,
                                     dimension: Int = 384,
                                     reprobeInterval: TimeInterval = 3600,
                                     dateProvider: @escaping () -> Date = Date.init) -> EmbeddingService {
        EmbeddingService(primary: primary,
                         fallback: fallback,
                         dimension: dimension,
                         reprobeInterval: reprobeInterval,
                         dateProvider: dateProvider)
    }
}
#endif

extension EmbeddingService: @unchecked Sendable {}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingService.swift -->

### Packages/PulsumML/Sources/PulsumML/Embedding/TextEmbeddingProviding.swift
- bytes: 184
- lines: 6
- sha256: ed1277432b9d06cb1cb1824bacbeec59d895ce780c8280140695afe796246ab5
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Embedding/TextEmbeddingProviding.swift -->
```swift
import Foundation

public protocol TextEmbeddingProviding {
    /// Returns a 384-dimensional embedding for the supplied text.
    func embedding(for text: String) throws -> [Float]
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Embedding/TextEmbeddingProviding.swift -->

### Packages/PulsumML/Sources/PulsumML/Placeholder.swift
- bytes: 380
- lines: 13
- sha256: 283800e3ea54495179bf9925048f0d9237ae6e883ddec67852a4ccb5e4697544
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Placeholder.swift -->
```swift
import Foundation

public enum PulsumML {
    public static let version = "0.1.0"

    public static func embedding(for text: String) throws -> [Float] {
        try EmbeddingService.shared.embedding(for: text)
    }

    public static func embedding(forSegments segments: [String]) throws -> [Float] {
        try EmbeddingService.shared.embedding(forSegments: segments)
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Placeholder.swift -->

### Packages/PulsumML/Sources/PulsumML/RecRanker.swift
- bytes: 6038
- lines: 195
- sha256: 9109a3cd896deb1a562a40439a60bfb1791d79c484efa86ca8fd1de5b6c8d3ab
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/RecRanker.swift -->
```swift
import Foundation

public struct RecommendationFeatures {
    public let id: String
    public let wellbeingScore: Double
    public let evidenceStrength: Double
    public let novelty: Double
    public let cooldown: Double
    public let acceptanceRate: Double
    public let timeCostFit: Double
    public let zScores: [String: Double]

    public init(id: String,
                wellbeingScore: Double,
                evidenceStrength: Double,
                novelty: Double,
                cooldown: Double,
                acceptanceRate: Double,
                timeCostFit: Double,
                zScores: [String: Double] = [:]) {
        self.id = id
        self.wellbeingScore = wellbeingScore
        self.evidenceStrength = evidenceStrength
        self.novelty = novelty
        self.cooldown = cooldown
        self.acceptanceRate = acceptanceRate
        self.timeCostFit = timeCostFit
        self.zScores = zScores
    }

    public var vector: [String: Double] {
        var base: [String: Double] = [
            "bias": 1,
            "wellbeing": wellbeingScore,
            "evidence": evidenceStrength,
            "novelty": novelty,
            "cooldown": cooldown,
            "acceptance": acceptanceRate,
            "timeCostFit": timeCostFit
        ]
        for (key, value) in zScores {
            base[key] = value
        }
        return base
    }
}

public struct AcceptanceHistory {
    public let rollingAcceptance: Double
    public let sampleCount: Int

    public init(rollingAcceptance: Double, sampleCount: Int) {
        self.rollingAcceptance = rollingAcceptance
        self.sampleCount = sampleCount
    }
}

public struct UserFeedback {
    public let featureId: String
    public let delta: Double

    public init(featureId: String, delta: Double) {
        self.featureId = featureId
        self.delta = delta
    }
}

public struct RankerMetrics {
    public let weights: [String: Double]
    public let learningRate: Double

    public init(weights: [String: Double], learningRate: Double) {
        self.weights = weights
        self.learningRate = learningRate
    }
}

public struct RecRankerState: Codable, Equatable {
    public let version: Int
    public let weights: [String: Double]
    public let learningRate: Double

    public init(version: Int, weights: [String: Double], learningRate: Double) {
        self.version = version
        self.weights = weights
        self.learningRate = learningRate
    }
}

public final class RecRanker {
    private static let schemaVersion = 1
    private static let defaultWeights: [String: Double] = [
        "bias": 0.0,
        "wellbeing": -0.2,
        "evidence": 0.6,
        "novelty": 0.4,
        "cooldown": -0.5,
        "acceptance": 0.3,
        "timeCostFit": 0.2,
        "z_hrv": 0.25,
        "z_nocthr": -0.2,
        "z_resthr": -0.2,
        "z_sleepDebt": -0.25,
        "z_rr": -0.05,
        "z_steps": 0.18
    ]

    private var weights: [String: Double]
    private var learningRate: Double
    private let weightCap: ClosedRange<Double> = -3.0...3.0

    public init(state: RecRankerState? = nil) {
        self.weights = Self.defaultWeights
        self.learningRate = 0.05
        if let state {
            apply(state: state)
        }
    }

    public func score(features: RecommendationFeatures) -> Double {
        logistic(dot(weights: weights, features: features.vector))
    }

    public func rank(_ candidates: [RecommendationFeatures]) -> [RecommendationFeatures] {
        candidates.sorted { score(features: $0) > score(features: $1) }
    }

    public func update(preferred: RecommendationFeatures, other: RecommendationFeatures) {
        let preferredScore = score(features: preferred)
        let otherScore = score(features: other)
        let gradientPreferred = 1 - preferredScore
        let gradientOther = -otherScore

        applyGradient(features: preferred.vector, gradient: gradientPreferred)
        applyGradient(features: other.vector, gradient: gradientOther)
    }

    public func updateLearningRate(basedOn history: AcceptanceHistory) {
        let normalized = max(0, min(history.rollingAcceptance, 1))
        if history.sampleCount < 10 {
            learningRate = 0.08
        } else if normalized < 0.35 {
            learningRate = 0.07
        } else if normalized > 0.75 {
            learningRate = 0.03
        } else {
            learningRate = 0.05
        }
    }

    public func adaptWeights(from feedback: [UserFeedback]) {
        guard !feedback.isEmpty else { return }
        for entry in feedback {
            let updated = clampedWeight((weights[entry.featureId] ?? 0) + entry.delta)
            weights[entry.featureId] = updated
        }
    }

    public func getPerformanceMetrics() -> RankerMetrics {
        RankerMetrics(weights: weights, learningRate: learningRate)
    }

    public func snapshotState() -> RecRankerState {
        RecRankerState(version: Self.schemaVersion, weights: weights, learningRate: learningRate)
    }

    private func applyGradient(features: [String: Double], gradient: Double) {
        for (feature, value) in features {
            let updated = clampedWeight((weights[feature] ?? 0) + learningRate * gradient * value)
            weights[feature] = updated
        }
    }

    private func dot(weights: [String: Double], features: [String: Double]) -> Double {
        weights.reduce(into: 0.0) { result, element in
            result += element.value * (features[element.key] ?? 0)
        }
    }

    private func logistic(_ x: Double) -> Double {
        1 / (1 + exp(-x))
    }

    private func clampedWeight(_ value: Double) -> Double {
        min(max(value, weightCap.lowerBound), weightCap.upperBound)
    }

    private func apply(state: RecRankerState) {
        guard state.version == Self.schemaVersion else { return }
        for (key, value) in state.weights {
            weights[key] = clampedWeight(value)
        }
        learningRate = state.learningRate
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/RecRanker.swift -->

### Packages/PulsumML/Sources/PulsumML/Safety/FoundationModelsSafetyProvider.swift
- bytes: 3521
- lines: 102
- sha256: fdc9494c4c521953da2d39811adc9c737ee5f74e60543bc13649c6061be90369
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Safety/FoundationModelsSafetyProvider.swift -->
```swift
import Foundation

#if canImport(FoundationModels) && os(iOS)
import FoundationModels

@available(iOS 26.0, *)
@Generable enum SafetyRating: String, CaseIterable {
    case safe, caution, crisis
}

@available(iOS 26.0, *)
@Generable struct SafetyAssessment {
    @Guide(description: "Safety classification: safe (normal discussion), caution (concerning but not dangerous), or crisis (immediate danger/self-harm)")
    let rating: SafetyRating
    @Guide(description: "Brief explanation of why this classification was chosen")
    let reason: String
}

@available(iOS 26.0, *)
public final class FoundationModelsSafetyProvider {
    private let model = SystemLanguageModel.default
    
    public init() {}
    
    public func classify(text: String) async throws -> SafetyClassification {
        guard model.isAvailable else {
            throw SafetyError.modelUnavailable
        }
        
        let session = LanguageModelSession(
            instructions: Instructions("""
            Assess the safety level of user text in a mental health context.
            
            Classifications:
            - SAFE: Normal wellness discussion, general questions, routine check-ins, casual conversation
            - CAUTION: Expressions of stress, anxiety, sadness, or emotional distress that are concerning but not indicating immediate danger
            - CRISIS: ONLY explicit indication of self-harm, suicide ideation, violence, or immediate danger to self or others
            
            Use SAFE for general questions, casual conversation, or anything that doesn't clearly indicate distress.
            CRISIS should ONLY be used when there is explicit mention of harming self or others.
            """)
        )
        
        do {
            let result = try await session.respond(
                to: Prompt("Assess safety of this text: \(text)"),
                generating: SafetyAssessment.self,
                options: GenerationOptions(temperature: 0.0)
            )
            
            switch result.content.rating {
            case .safe:
                return .safe
            case .caution:
                return .caution(reason: result.content.reason)
            case .crisis:
                return .crisis(reason: result.content.reason)
            }
        } catch LanguageModelSession.GenerationError.guardrailViolation {
            // Guardrails triggered - treat as safe to avoid false positives
            return .safe
        } catch LanguageModelSession.GenerationError.refusal {
            // Model refused to analyze - treat as safe and let fallback handle it
            return .safe
        } catch {
            throw SafetyError.classificationFailed
        }
    }
}

@available(iOS 26.0, *)
extension FoundationModelsSafetyProvider: @unchecked Sendable {}

#else

public final class FoundationModelsSafetyProvider {
    private let local = SafetyLocal()
    
    public init() {}
    
    public func classify(text: String) async throws -> SafetyClassification {
        local.classify(text: text)
    }
}

extension FoundationModelsSafetyProvider: @unchecked Sendable {}

#endif

public enum SafetyError: LocalizedError {
    case modelUnavailable
    case classificationFailed
    
    public var errorDescription: String? {
        switch self {
        case .modelUnavailable:
            return "Safety classification model is not available"
        case .classificationFailed:
            return "Failed to classify content safety"
        }
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Safety/FoundationModelsSafetyProvider.swift -->

### Packages/PulsumML/Sources/PulsumML/SafetyLocal.swift
- bytes: 8653
- lines: 220
- sha256: 2fd1dc31fd4f3dfe8406bf68fd87b93d8f7182ded33bc1e0e418011162582554
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/SafetyLocal.swift -->
```swift
import Foundation
import os

public enum SafetyClassification: Equatable, Sendable {
    case safe
    case caution(reason: String)
    case crisis(reason: String)
}

public struct SafetyLocalConfig {
    public let crisisKeywords: [String]
    public let cautionKeywords: [String]
    public let crisisSimilarityThreshold: Float
    public let cautionSimilarityThreshold: Float
    public let resolutionMargin: Float

    public init(
        crisisKeywords: [String] = ["suicide", "kill myself", "ending it", "overdose", "hurt myself"],
        cautionKeywords: [String] = ["depressed", "hopeless", "panic", "anxious", "self-harm"],
        crisisSimilarityThreshold: Float = 0.65,  // Raised from 0.48 - less aggressive for bench testing
        cautionSimilarityThreshold: Float = 0.35, // Raised from 0.22 - less aggressive for bench testing
        resolutionMargin: Float = 0.10            // Raised from 0.05 - require clearer signal
    ) {
        self.crisisKeywords = crisisKeywords
        self.cautionKeywords = cautionKeywords
        self.crisisSimilarityThreshold = crisisSimilarityThreshold
        self.cautionSimilarityThreshold = cautionSimilarityThreshold
        self.resolutionMargin = resolutionMargin
    }
}

public final class SafetyLocal {
    private enum Label: String { case safe, caution, crisis }

    private struct Prototype {
        let label: Label
        let text: String
        let embedding: [Float]
    }

    private let config: SafetyLocalConfig
    private let embeddingService: EmbeddingService
    private let prototypeQueue = DispatchQueue(label: "ai.pulsum.safetyLocal.prototypes", qos: .userInitiated)
    private var prototypes: [Prototype]
    private var degraded: Bool
    private let logger = Logger(subsystem: "com.pulsum", category: "SafetyLocal")

    public init(config: SafetyLocalConfig = SafetyLocalConfig(),
                embeddingService: EmbeddingService = .shared) {
        self.config = config
        self.embeddingService = embeddingService
        let build = SafetyLocal.makePrototypes(using: embeddingService, logger: logger)
        self.prototypes = build.prototypes
        self.degraded = build.degraded
    }

    public var isDegraded: Bool {
        prototypeQueue.sync { degraded || prototypes.isEmpty }
    }

    public func classify(text: String) -> SafetyClassification {
        refreshPrototypesIfNeeded()
        let (localPrototypes, _) = prototypeQueue.sync { (prototypes, degraded) }
        let normalized = text.lowercased()
        #if DEBUG
        logger.debug("SafetyLocal classify lengthBucket=\(self.lengthBucket(for: normalized), privacy: .public)")
        #endif
        
        if containsKeyword(from: config.crisisKeywords, in: normalized) {
            #if DEBUG
            logger.debug("SafetyLocal keyword-based crisis trigger")
            #endif
            return .crisis(reason: "High-risk language detected")
        }

        guard
            let embedding = try? embeddingService.embedding(for: normalized),
            embedding.contains(where: { $0 != 0 }),
            !localPrototypes.isEmpty
        else {
            prototypeQueue.sync { degraded = true }
            #if DEBUG
            logger.debug("SafetyLocal degraded: embedding unavailable or prototypes missing; using fallback classification.")
            #endif
            return fallbackClassification(for: normalized)
        }
        
        var scores: [Label: (similarity: Float, prototype: Prototype)] = [:]
        for prototype in localPrototypes {
            let similarity = cosineSimilarity(embedding, prototype.embedding)
            if let current = scores[prototype.label], current.similarity >= similarity { continue }
            scores[prototype.label] = (similarity, prototype)
        }

        let safeSimilarity = scores[.safe]?.similarity ?? 0

        if let crisis = scores[.crisis],
           crisis.similarity >= config.crisisSimilarityThreshold,
           crisis.similarity - safeSimilarity >= config.resolutionMargin {
            if containsKeyword(from: config.crisisKeywords, in: normalized) {
                #if DEBUG
                logger.debug("SafetyLocal → crisis (keyword + similarity)")
                #endif
                return .crisis(reason: crisis.prototype.text)
            }
            #if DEBUG
            logger.debug("SafetyLocal → caution (similarity only)")
            #endif
            return .caution(reason: crisis.prototype.text)
        }
        if let caution = scores[.caution],
           caution.similarity >= config.cautionSimilarityThreshold,
           caution.similarity - safeSimilarity >= config.resolutionMargin / 2 {
            #if DEBUG
            logger.debug("SafetyLocal → caution (similarity threshold)")
            #endif
            return .caution(reason: caution.prototype.text)
        }
        
        #if DEBUG
        logger.debug("SafetyLocal → safe")
        #endif
        return .safe
    }

    // MARK: - Prototype Setup

    private static func makePrototypes(using service: EmbeddingService, logger: Logger) -> (prototypes: [Prototype], degraded: Bool) {
        let dataset: [(Label, String)] = [
            (.crisis, "I want to hurt myself"),
            (.crisis, "Thinking about ending my life"),
            (.crisis, "I can't stay safe tonight"),
            (.crisis, "I overdosed and don't want to wake up"),
            (.caution, "Feeling really hopeless today"),
            (.caution, "My anxiety is spiking"),
            (.caution, "I'm panicking and can't calm down"),
            (.caution, "Everything feels overwhelming"),
            (.safe, "I could use a gentle nudge"),
            (.safe, "Looking for a quick habit to stay on track"),
            (.safe, "Just want a supportive reminder"),
            (.safe, "I finished a light workout and feel grounded")
        ]

        var built: [Prototype] = []
        var failures = 0

        for (index, item) in dataset.enumerated() {
            do {
                let embedding = try service.embedding(for: item.1)
                built.append(Prototype(label: item.0, text: item.1, embedding: embedding))
            } catch {
                failures += 1
                #if DEBUG
                logger.debug("Failed to embed safety prototype \(index, privacy: .public) label=\(item.0.rawValue, privacy: .public): \(error.localizedDescription, privacy: .public)")
                #endif
            }
        }

        let degraded = failures > 0 || built.isEmpty

        #if DEBUG
        if built.isEmpty {
            logger.warning("SafetyLocal prototypes empty; classifier will operate in degraded keyword-only mode.")
        } else if failures > 0 {
            logger.debug("SafetyLocal built \(built.count, privacy: .public) prototypes with \(failures, privacy: .public) failures. Degraded=\(degraded, privacy: .public)")
        }
        #endif

        return (built, degraded)
    }

    // MARK: - Helpers

    private func refreshPrototypesIfNeeded() {
        let needsRefresh = prototypeQueue.sync { degraded || prototypes.isEmpty }
        guard needsRefresh else { return }
        let build = SafetyLocal.makePrototypes(using: embeddingService, logger: logger)
        prototypeQueue.sync {
            prototypes = build.prototypes
            degraded = build.degraded
        }
    }

    private func containsKeyword(from keywords: [String], in text: String) -> Bool {
        for keyword in keywords where !keyword.isEmpty {
            if text.contains(keyword) { return true }
        }
        return false
    }

    private func fallbackClassification(for text: String) -> SafetyClassification {
        if containsKeyword(from: config.cautionKeywords, in: text) {
            return .caution(reason: "Sensitive language detected")
        }
        return .safe
    }

    private func cosineSimilarity(_ lhs: [Float], _ rhs: [Float]) -> Float {
        guard lhs.count == rhs.count else { return 0 }
        var dot: Float = 0
        var lhsNorm: Float = 0
        var rhsNorm: Float = 0
        for index in 0..<lhs.count {
            dot += lhs[index] * rhs[index]
            lhsNorm += lhs[index] * lhs[index]
            rhsNorm += rhs[index] * rhs[index]
        }
        let denominator = sqrt(lhsNorm) * sqrt(rhsNorm)
        guard denominator > 0 else { return 0 }
        return dot / denominator
    }

    private func lengthBucket(for text: String) -> String {
        switch text.count {
        case 0...20: return "0-20"
        case 21...80: return "21-80"
        default: return "81+"
        }
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/SafetyLocal.swift -->

### Packages/PulsumML/Sources/PulsumML/Sentiment/AFMSentimentProvider.swift
- bytes: 2809
- lines: 68
- sha256: 774975a1336c66521abdef4d08851fe4048ef8dff157ed884f6e43bd804a4334
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/AFMSentimentProvider.swift -->
```swift
import Foundation

final class AFMSentimentProvider: SentimentProviding {
    private let embeddingService: EmbeddingService
    private let positiveAnchors: [[Float]]
    private let negativeAnchors: [[Float]]

    init(embeddingService: EmbeddingService = .shared) {
        self.embeddingService = embeddingService
        let positives = [
            "I feel grounded and steady today.",
            "There's momentum building and I can sense the progress.",
            "I'm proud of the effort I put in.",
            "My energy feels balanced and supportive.",
            "I can see the habits working for me."
        ]
        let negatives = [
            "I'm overwhelmed and can't slow my thoughts.",
            "Everything feels heavy and unmanageable.",
            "I'm exhausted and running on fumes.",
            "It feels like I'm slipping backwards.",
            "I'm tense and can't shake the stress."
        ]
        positiveAnchors = positives.compactMap { try? embeddingService.embedding(for: $0) }
        negativeAnchors = negatives.compactMap { try? embeddingService.embedding(for: $0) }
    }

    func sentimentScore(for text: String) async throws -> Double {
        let cleaned = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard cleaned.count > 2 else { throw SentimentProviderError.insufficientInput }
        guard !positiveAnchors.isEmpty, !negativeAnchors.isEmpty else {
            throw SentimentProviderError.unavailable
        }
        let embedding = try embeddingService.embedding(for: cleaned.lowercased())
        guard embedding.contains(where: { $0 != 0 }) else {
            throw SentimentProviderError.unavailable
        }

        let positive = averageSimilarity(for: embedding, anchors: positiveAnchors)
        let negative = averageSimilarity(for: embedding, anchors: negativeAnchors)
        let score = positive - negative
        return max(min(score, 1), -1)
    }

    private func averageSimilarity(for vector: [Float], anchors: [[Float]]) -> Double {
        guard !anchors.isEmpty else { return 0 }
        var total: Double = 0
        for anchor in anchors {
            total += Double(cosineSimilarity(vector, anchor))
        }
        return total / Double(anchors.count)
    }

    private func cosineSimilarity(_ lhs: [Float], _ rhs: [Float]) -> Float {
        guard lhs.count == rhs.count else { return 0 }
        var dot: Float = 0
        var lhsNorm: Float = 0
        var rhsNorm: Float = 0
        for idx in 0..<lhs.count {
            dot += lhs[idx] * rhs[idx]
            lhsNorm += lhs[idx] * lhs[idx]
            rhsNorm += rhs[idx] * rhs[idx]
        }
        let denominator = sqrt(lhsNorm) * sqrt(rhsNorm)
        guard denominator > 0 else { return 0 }
        return dot / denominator
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/AFMSentimentProvider.swift -->

### Packages/PulsumML/Sources/PulsumML/Sentiment/CoreMLSentimentProvider.swift
- bytes: 1404
- lines: 41
- sha256: 56693e10770e921ff3c044b4ae763c6d4d77efa7652681ac76b094052067220d
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/CoreMLSentimentProvider.swift -->
```swift
import Foundation
import NaturalLanguage
import CoreML

final class CoreMLSentimentProvider: SentimentProviding {
    private let model: NLModel

    init?() {
        let bundle = Bundle.pulsumMLResources
        if let compiledURL = bundle.url(forResource: "PulsumSentimentCoreML", withExtension: "mlmodelc"),
           let nlModel = try? NLModel(contentsOf: compiledURL) {
            model = nlModel
        } else if let rawURL = bundle.url(forResource: "PulsumSentimentCoreML", withExtension: "mlmodel"),
                  let compiled = try? MLModel.compileModel(at: rawURL),
                  let nlModel = try? NLModel(contentsOf: compiled) {
            model = nlModel
        } else {
            return nil
        }
    }

    func sentimentScore(for text: String) async throws -> Double {
        guard let label = model.predictedLabel(for: text.lowercased()) else {
            throw SentimentProviderError.unavailable
        }
        let normalized = label.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        switch normalized {
        case "positive":
            return 0.7
        case "negative":
            return -0.7
        case "neutral":
            return 0
        default:
            if let value = Double(normalized) {
                return max(min(value, 1), -1)
            }
            throw SentimentProviderError.unavailable
        }
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/CoreMLSentimentProvider.swift -->

### Packages/PulsumML/Sources/PulsumML/Sentiment/FoundationModelsSentimentProvider.swift
- bytes: 2445
- lines: 71
- sha256: 41d6f1d8a956c769a7b00717abe5f29588e7f46b6cb3c302a1118ea4193ec6d5
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/FoundationModelsSentimentProvider.swift -->
```swift
import Foundation

#if canImport(FoundationModels) && os(iOS)
import FoundationModels

@available(iOS 26.0, *)
@Generable enum SentimentLabel: String, CaseIterable {
    case positive, neutral, negative
}

@available(iOS 26.0, *)
@Generable struct SentimentAnalysis {
    @Guide(description: "Sentiment classification: positive, neutral, or negative")
    let label: SentimentLabel
    @Guide(description: "Confidence score between -1.0 (very negative) and 1.0 (very positive)")
    let score: Double
}

@available(iOS 26.0, *)
final class FoundationModelsSentimentProvider: SentimentProviding {
    private let model = SystemLanguageModel.default
    
    func sentimentScore(for text: String) async throws -> Double {
        guard model.isAvailable else {
            throw SentimentProviderError.unavailable
        }
        
        let session = LanguageModelSession(
            instructions: Instructions("""
            Analyze the sentiment of user text with high precision.
            Return a score between -1.0 (very negative) and 1.0 (very positive).
            Consider emotional tone, stress indicators, and overall mood.
            Be calibrated: 0.0 is truly neutral, ±0.3 is mild, ±0.7 is strong, ±1.0 is extreme.
            """)
        )
        
        do {
            let result = try await session.respond(
                to: Prompt("Analyze sentiment of this text: \(text)"),
                generating: SentimentAnalysis.self,
                options: GenerationOptions(temperature: 0.1)
            )
            return max(min(result.content.score, 1.0), -1.0)
        } catch LanguageModelSession.GenerationError.guardrailViolation {
            // If guardrails triggered, text might be too sensitive - return neutral
            return 0.0
        } catch LanguageModelSession.GenerationError.refusal {
            // Model refused to analyze - return neutral
            return 0.0
        } catch {
            throw SentimentProviderError.unavailable
        }
    }
}

@available(iOS 26.0, *)
extension FoundationModelsSentimentProvider: @unchecked Sendable {}

#else

final class FoundationModelsSentimentProvider: SentimentProviding {
    private let local = NaturalLanguageSentimentProvider()

    func sentimentScore(for text: String) async throws -> Double {
        try await local.sentimentScore(for: text)
    }
}

extension FoundationModelsSentimentProvider: @unchecked Sendable {}

#endif
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/FoundationModelsSentimentProvider.swift -->

### Packages/PulsumML/Sources/PulsumML/Sentiment/NaturalLanguageSentimentProvider.swift
- bytes: 721
- lines: 16
- sha256: f1a4ccb297bcad228df67c8699ff45c5c3812a658202b047e057e5ade0b6794c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/NaturalLanguageSentimentProvider.swift -->
```swift
import Foundation
import NaturalLanguage

final class NaturalLanguageSentimentProvider: SentimentProviding {
    func sentimentScore(for text: String) async throws -> Double {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { throw SentimentProviderError.insufficientInput }
        let tagger = NLTagger(tagSchemes: [.sentimentScore])
        tagger.string = trimmed
        let (tag, _) = tagger.tag(at: trimmed.startIndex, unit: .paragraph, scheme: .sentimentScore)
        guard let rawValue = tag?.rawValue, let score = Double(rawValue) else {
            throw SentimentProviderError.unavailable
        }
        return max(min(score, 1), -1)
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/NaturalLanguageSentimentProvider.swift -->

### Packages/PulsumML/Sources/PulsumML/Sentiment/PIIRedactor.swift
- bytes: 1502
- lines: 37
- sha256: e569fbeec0e7b15b77f98229582ce36cc636849abdf5dcef62aff81b65499847
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/PIIRedactor.swift -->
```swift
import Foundation
import NaturalLanguage

public enum PIIRedactor {
    public static func redact(_ transcript: String) -> String {
        guard !transcript.isEmpty else { return transcript }
        var output = transcript
        let patterns = [
            #"[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}"#,
            #"\+?\d[\d\s\-]{7,}\d"#
        ]
        for pattern in patterns {
            if let regex = try? NSRegularExpression(pattern: pattern, options: [.caseInsensitive]) {
                let range = NSRange(location: 0, length: output.utf16.count)
                output = regex.stringByReplacingMatches(in: output, options: [], range: range, withTemplate: "[redacted]")
            }
        }
        if #available(iOS 17, macOS 13, *) {
            let tagger = NLTagger(tagSchemes: [.nameType])
            tagger.string = output
            var replacements: [Range<String.Index>] = []
            tagger.enumerateTags(in: output.startIndex..<output.endIndex,
                                 unit: .word,
                                 scheme: .nameType,
                                 options: [.omitWhitespace, .omitPunctuation]) { tag, range in
                if let tag, tag == .personalName {
                    replacements.append(range)
                }
                return true
            }
            for range in replacements.reversed() {
                output.replaceSubrange(range, with: "[redacted]")
            }
        }
        return output
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/PIIRedactor.swift -->

### Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentProviding.swift
- bytes: 556
- lines: 20
- sha256: cc7c462a2415e54cf5b0829d47d2911ea81e83065183347f1419fe883bace095
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentProviding.swift -->
```swift
import Foundation

public protocol SentimentProviding {
    /// Produces a sentiment score in the range [-1, 1].
    func sentimentScore(for text: String) async throws -> Double
}

public enum SentimentProviderError: LocalizedError {
    case unavailable
    case insufficientInput

    public var errorDescription: String? {
        switch self {
        case .unavailable:
            return "Sentiment provider is unavailable on this device."
        case .insufficientInput:
            return "Not enough text to analyze sentiment."
        }
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentProviding.swift -->

### Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentService.swift
- bytes: 1298
- lines: 41
- sha256: d6e476e54a4d7c8942ac814aa91c3e9b14f225d17117eabf421622a255dac823
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentService.swift -->
```swift
import Foundation

public final class SentimentService {
    private let providers: [SentimentProviding]

    public init(providers: [SentimentProviding]? = nil) {
        if let providers, !providers.isEmpty {
            self.providers = providers
        } else {
            var stack: [SentimentProviding] = []
            // Prefer Foundation Models when available
            if #available(iOS 26.0, *) {
                stack.append(FoundationModelsSentimentProvider())
            }
            stack.append(AFMSentimentProvider())
            if let coreML = CoreMLSentimentProvider() {
                stack.append(coreML)
            }
            self.providers = stack
        }
    }

    public func sentiment(for text: String) async -> Double {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return 0 }

        for provider in providers {
            do {
                let score = try await provider.sentimentScore(for: trimmed)
                return max(min(score, 1), -1)
            } catch SentimentProviderError.insufficientInput {
                continue
            } catch {
                continue
            }
        }
        return 0
    }
}

extension SentimentService: @unchecked Sendable {}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentService.swift -->

### Packages/PulsumML/Sources/PulsumML/StateEstimator.swift
- bytes: 3885
- lines: 110
- sha256: bfd54454feca22b23f34ea38c2a2305fd4b8646cbef5ffbb812d6d8ebbbbfd8e
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/StateEstimator.swift -->
```swift
import Foundation

public struct StateEstimatorConfig {
    public let learningRate: Double
    public let regularization: Double
    public let weightCap: ClosedRange<Double>

    public init(learningRate: Double = 0.05,
                regularization: Double = 1e-3,
                weightCap: ClosedRange<Double> = -2.0...2.0) {
        self.learningRate = learningRate
        self.regularization = regularization
        self.weightCap = weightCap
    }
}

public struct StateEstimatorSnapshot: Sendable {
    public let weights: [String: Double]
    public let bias: Double
    public let wellbeingScore: Double
    public let contributions: [String: Double]
}

public struct StateEstimatorState: Codable, Sendable {
    public let version: Int
    public let weights: [String: Double]
    public let bias: Double

    public init(version: Int = 1, weights: [String: Double], bias: Double) {
        self.version = version
        self.weights = weights
        self.bias = bias
    }
}

public final class StateEstimator {
    public static let defaultWeights: [String: Double] = [
        "z_hrv": 0.6,
        "z_nocthr": -0.45,
        "z_resthr": -0.35,
        "z_sleepDebt": -0.55,
        "z_steps": 0.3,
        "z_rr": -0.1,
        "subj_stress": -0.5,
        "subj_energy": 0.5,
        "subj_sleepQuality": 0.35,
        "sentiment": 0.25
    ]

    private let config: StateEstimatorConfig
    private var weights: [String: Double]
    private var bias: Double

    public init(initialWeights: [String: Double] = StateEstimator.defaultWeights,
                bias: Double = 0,
                config: StateEstimatorConfig = StateEstimatorConfig()) {
        self.weights = initialWeights
        self.config = config
        self.bias = bias
    }

    public init(state: StateEstimatorState, config: StateEstimatorConfig = StateEstimatorConfig()) {
        self.weights = state.weights
        self.bias = state.bias
        self.config = config
    }

    public func predict(features: [String: Double]) -> Double {
        let contributions = contributionVector(features: features)
        return contributions.values.reduce(bias, +)
    }

    public func update(features: [String: Double], target: Double) -> StateEstimatorSnapshot {
        let prediction = predict(features: features)
        let error = target - prediction

        for (feature, value) in features {
            let gradient = -error * value + config.regularization * (weights[feature] ?? 0)
            var updated = (weights[feature] ?? 0) - config.learningRate * gradient
            updated = min(max(updated, config.weightCap.lowerBound), config.weightCap.upperBound)
            weights[feature] = updated
        }

        bias -= config.learningRate * (-error)

        let contributions = contributionVector(features: features)
        let wellbeing = contributions.values.reduce(bias, +)
        return StateEstimatorSnapshot(weights: weights, bias: bias, wellbeingScore: wellbeing, contributions: contributions)
    }

    public func currentSnapshot(features: [String: Double]) -> StateEstimatorSnapshot {
        let contributions = contributionVector(features: features)
        let wellbeing = contributions.values.reduce(bias, +)
        return StateEstimatorSnapshot(weights: weights, bias: bias, wellbeingScore: wellbeing, contributions: contributions)
    }

    public func persistedState(version: Int = 1) -> StateEstimatorState {
        StateEstimatorState(version: version, weights: weights, bias: bias)
    }

    private func contributionVector(features: [String: Double]) -> [String: Double] {
        var result: [String: Double] = [:]
        result.reserveCapacity(features.count)
        for (feature, value) in features {
            let weight = weights[feature] ?? 0
            result[feature] = weight * value
        }
        return result
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/StateEstimator.swift -->

### Packages/PulsumML/Sources/PulsumML/TopicGate/EmbeddingTopicGateProvider.swift
- bytes: 7192
- lines: 178
- sha256: 86c881d7b03b97871a16ae312b24f259cabe851ab40109e65d3480d95067d226
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/TopicGate/EmbeddingTopicGateProvider.swift -->
```swift
import Foundation
import os

/// Fallback topic gate using embedding similarity against wellbeing knowledge base
public final class EmbeddingTopicGateProvider: TopicGateProviding, @unchecked Sendable {
    private let embeddingService: EmbeddingService
    private let wellbeingPrototypes: [WellbeingPrototype]
    private let oodPrototypes: [[Float]]
    private let logger = Logger(subsystem: "com.pulsum", category: "EmbeddingTopicGateProvider")

    private let OOD_MARGIN: Float = 0.12
    private let ON_TOPIC_THRESHOLD: Float = 0.59

    private struct WellbeingPrototype {
        let text: String
        let embedding: [Float]
        let topic: String?  // Canonical topic or nil for greetings
    }

    private static let OOD_PROTOTYPES: [String] = [
        "prime factors",
        "matrix multiplication",
        "calculus",
        "pizza recipe",
        "restaurant menu",
        "cooking recipe",
        "subway schedule",
        "train timetable",
        "crypto price",
        "tax filing",
        "budget planning",
        "python code",
        "swift algorithm",
        "weather forecast",
        "stock ticker"
    ]

    public init(embeddingService: EmbeddingService = .shared) {
        self.embeddingService = embeddingService

        // Wellbeing knowledge base prototypes with canonical topics
        let prototypeData: [(text: String, topic: String?)] = [
            ("stress management breathing relaxation anxiety", "stress"),
            ("sleep quality rest recovery insomnia fatigue fall asleep can't sleep sleep better sleep hygiene", "sleep"),
            ("energy vitality mood motivation movement exercise motivation motivated momentum keep going stick with consistency", "energy"),
            ("heart rate variability HRV health metrics rmssd vagal tone parasympathetic recovery", "hrv"),
            ("mental health wellbeing self-care support", "mood"),
            ("physical activity steps walking fitness", "movement"),
            ("meditation mindfulness grounding calm", "mindfulness"),
            ("journal feelings emotions reflection", "mood"),
            ("health goals wellness habits routine motivation motivated momentum keep going stick with consistency", "goals"),
            ("micro-moment micromoment micro activity quick action nudge habit tiny step", "goals"),
            ("hi coach hello coach hey pulsum good morning coach", nil)  // Greetings have no topic
        ]

        self.wellbeingPrototypes = prototypeData.compactMap { text, topic in
            guard let embedding = try? embeddingService.embedding(for: text) else { return nil }
            return WellbeingPrototype(
                text: text,
                embedding: embedding,
                topic: topic
            )
        }

        self.oodPrototypes = Self.OOD_PROTOTYPES.compactMap { try? embeddingService.embedding(for: $0) }
    }

    public func classify(_ text: String) async throws -> GateDecision {
        let decision = computeDecision(for: text.lowercased())
        return decision.decision
    }

#if DEBUG
    internal func debugScores(for text: String) async throws -> (domain: Double, ood: Double, margin: Double, topic: String?) {
        let decision = computeDecision(for: text.lowercased())
        return (
            domain: Double(decision.domainScore),
            ood: Double(decision.oodScore),
            margin: Double(decision.domainScore - decision.oodScore),
            topic: decision.topic
        )
    }
#endif

    private func cosineSimilarity(_ lhs: [Float], _ rhs: [Float]) -> Float {
        guard lhs.count == rhs.count else { return 0 }
        var dot: Float = 0
        var lhsNorm: Float = 0
        var rhsNorm: Float = 0
        for index in 0..<lhs.count {
            dot += lhs[index] * rhs[index]
            lhsNorm += lhs[index] * lhs[index]
            rhsNorm += rhs[index] * rhs[index]
        }
        let denominator = sqrt(lhsNorm) * sqrt(rhsNorm)
        guard denominator > 0 else { return 0 }
        return dot / denominator
    }

    private func computeDecision(for text: String) -> (decision: GateDecision, domainScore: Float, oodScore: Float, topic: String?) {
        guard
            let inputEmbedding = try? embeddingService.embedding(for: text),
            inputEmbedding.contains(where: { $0 != 0 }),
            !wellbeingPrototypes.isEmpty,
            !oodPrototypes.isEmpty
        else {
            #if DEBUG
            logger.debug("Topic gate degraded: embedding unavailable or prototypes empty (wellbeing=\(self.wellbeingPrototypes.count, privacy: .public), ood=\(self.oodPrototypes.count, privacy: .public)).")
            #endif
            let decision = GateDecision(
                isOnTopic: false,
                reason: "Unable to embed input text",
                confidence: 0.5,
                topic: nil
            )
            return (decision, 0, 0, nil)
        }

        let similaritiesWithPrototypes = wellbeingPrototypes.map { prototype in
            (similarity: cosineSimilarity(inputEmbedding, prototype.embedding), prototype: prototype)
        }

        guard let bestMatch = similaritiesWithPrototypes.max(by: { $0.similarity < $1.similarity }) else {
            let decision = GateDecision(
                isOnTopic: false,
                reason: "No prototype matches found",
                confidence: 0.0,
                topic: nil
            )
            return (decision, 0, 0, nil)
        }

        let domainScore = bestMatch.similarity
        let matchedTopic = bestMatch.prototype.topic
        let oodScore = computeOODScore(for: inputEmbedding)
        let marginOK = (domainScore - oodScore) >= OOD_MARGIN

        let isGreeting = (matchedTopic == nil)
        let isOnTopic: Bool

        if isGreeting {
            isOnTopic = domainScore >= 0.3 // greetings stay permissive as before
        } else {
            isOnTopic = domainScore >= ON_TOPIC_THRESHOLD && marginOK
        }

        let reason: String
        if isOnTopic {
            if isGreeting {
                reason = "Greeting detected (similarity: \(String(format: "%.2f", domainScore)))"
            } else {
                reason = "Input matches wellbeing topics (sim: \(String(format: "%.2f", domainScore))) with margin \(String(format: "%.2f", domainScore - oodScore))"
            }
        } else {
            reason = "Input outside wellbeing margin (domain: \(String(format: "%.2f", domainScore)), ood: \(String(format: "%.2f", oodScore)))"
        }

        let gateDecision = GateDecision(
            isOnTopic: isOnTopic,
            reason: reason,
            confidence: Double(domainScore),
            topic: isOnTopic ? matchedTopic : nil
        )

        return (gateDecision, domainScore, oodScore, matchedTopic)
    }

    private func computeOODScore(for embedding: [Float]) -> Float {
        var maxSimilarity: Float = 0
        for prototype in oodPrototypes {
            let similarity = cosineSimilarity(embedding, prototype)
            if similarity > maxSimilarity {
                maxSimilarity = similarity
            }
        }
        return maxSimilarity
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/TopicGate/EmbeddingTopicGateProvider.swift -->

### Packages/PulsumML/Sources/PulsumML/TopicGate/FoundationModelsTopicGateProvider.swift
- bytes: 2714
- lines: 81
- sha256: 99ad03f1d50635a4ae21452abacdfcb6ae26fcc4dd14f9d9b8422951e2866866
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/TopicGate/FoundationModelsTopicGateProvider.swift -->
```swift
import Foundation

#if canImport(FoundationModels) && os(iOS)
import FoundationModels

@available(iOS 26.0, *)
@Generable
public struct OnTopic: Codable, Sendable {
    public let isOnTopic: Bool
    public let confidence: Double // 0...1
    public let reason: String

    public init(isOnTopic: Bool, confidence: Double, reason: String) {
        self.isOnTopic = isOnTopic
        self.confidence = confidence
        self.reason = reason
    }
}

@available(iOS 26.0, *)
public final class FoundationModelsTopicGateProvider: TopicGateProviding {
    private let session: LanguageModelSession

    public init() {
        self.session = LanguageModelSession(
            instructions: Instructions("""
            You are a topic classifier for a wellbeing coaching app.
            Classify whether user input is on-topic (relevant to health, wellness, stress, sleep, energy, mood, movement, or personal wellbeing).
            Off-topic examples: general knowledge questions, weather, news, entertainment, unrelated chitchat.
            On-topic examples: questions about stress management, sleep advice, energy levels, health metrics, emotional support.
            Return your classification with confidence (0.0 to 1.0) and a brief reason.
            Be generous with greetings—"hi", "hello", "how are you" should be considered on-topic with moderate confidence (0.7).
            """)
        )
    }

    public func classify(_ text: String) async throws -> GateDecision {
        guard SystemLanguageModel.default.isAvailable else {
            throw TopicGateError.modelUnavailable
        }

        let result = try await session.respond(
            to: Prompt("Classify: '\(text)'"),
            generating: OnTopic.self,
            options: GenerationOptions(temperature: 0.1)
        )

        return GateDecision(
            isOnTopic: result.content.isOnTopic,
            reason: result.content.reason,
            confidence: result.content.confidence
        )
    }
}

@available(iOS 26.0, *)
extension FoundationModelsTopicGateProvider: @unchecked Sendable {}
#else
public final class FoundationModelsTopicGateProvider: TopicGateProviding {
    private let local = EmbeddingTopicGateProvider()

    public init() {}

    public func classify(_ text: String) async throws -> GateDecision {
        try await local.classify(text)
    }
}

extension FoundationModelsTopicGateProvider: @unchecked Sendable {}
#endif

public enum TopicGateError: LocalizedError {
    case modelUnavailable

    public var errorDescription: String? {
        switch self {
        case .modelUnavailable:
            return "Foundation Models is not available for topic classification."
        }
    }
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/TopicGate/FoundationModelsTopicGateProvider.swift -->

### Packages/PulsumML/Sources/PulsumML/TopicGate/TopicGateProviding.swift
- bytes: 1017
- lines: 25
- sha256: a0f5256a0f83aa741bb31cd1b76c9e12f52ff21261997cc19a92a9b2dc7b8575
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Sources/PulsumML/TopicGate/TopicGateProviding.swift -->
```swift
import Foundation

/// Decision from the topic gate classifier
public struct GateDecision: Sendable {
    public let isOnTopic: Bool
    public let reason: String
    public let confidence: Double
    public let topic: String?  // Canonical topics: "sleep", "stress", "energy", "hrv", "mood", "movement", "mindfulness", "goals", or nil for greetings

    public init(isOnTopic: Bool, reason: String, confidence: Double, topic: String? = nil) {
        self.isOnTopic = isOnTopic
        self.reason = reason
        self.confidence = confidence
        self.topic = topic
    }
}

/// Protocol for on-device topic classification
/// Validates whether user input is relevant to wellbeing coaching before cloud calls
public protocol TopicGateProviding: Sendable {
    /// Classify text as on-topic (wellbeing-related) or off-topic
    /// - Parameter text: User input to classify
    /// - Returns: Gate decision with topic classification and confidence
    func classify(_ text: String) async throws -> GateDecision
}
```
<!-- END_FILE: Packages/PulsumML/Sources/PulsumML/TopicGate/TopicGateProviding.swift -->

### Packages/PulsumML/Tests/PulsumMLTests/EmbeddingServiceAvailabilityTests.swift
- bytes: 2565
- lines: 73
- sha256: ee8146d37126444a3f7d35aa464a6b864edb1a17f80ad04b6f13bbaf8124c722
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Tests/PulsumMLTests/EmbeddingServiceAvailabilityTests.swift -->
```swift
import XCTest
@testable import PulsumML

final class EmbeddingServiceAvailabilityTests: XCTestCase {
    func testReprobesAfterCooldown() {
        let provider = MutableEmbeddingProvider(response: .failure(EmbeddingError.generatorUnavailable))
        let clock = StubClock()
        let service = EmbeddingService.debugInstance(primary: provider,
                                                     fallback: nil,
                                                     dimension: 4,
                                                     reprobeInterval: 10,
                                                     dateProvider: { clock.now })

        XCTAssertFalse(service.isAvailable())
        XCTAssertEqual(provider.callCount, 1)

        provider.response = .success([Float](repeating: 0.5, count: 4))

        // Within cooldown, should not probe again even though provider is now healthy.
        XCTAssertFalse(service.isAvailable())
        XCTAssertEqual(provider.callCount, 1)

        clock.advance(by: 11)
        XCTAssertTrue(service.isAvailable())
        XCTAssertEqual(provider.callCount, 2)
    }

    func testAvailabilityStaysTrueAfterSuccess() {
        let provider = MutableEmbeddingProvider(response: .success([Float](repeating: 0.3, count: 4)))
        let clock = StubClock()
        let service = EmbeddingService.debugInstance(primary: provider,
                                                     fallback: nil,
                                                     dimension: 4,
                                                     reprobeInterval: 10,
                                                     dateProvider: { clock.now })

        XCTAssertTrue(service.isAvailable())

        provider.response = .failure(EmbeddingError.generatorUnavailable)

        // No reprobe needed while cached as available.
        XCTAssertTrue(service.isAvailable())
        XCTAssertEqual(provider.callCount, 1)
    }
}

private final class MutableEmbeddingProvider: TextEmbeddingProviding {
    var response: Result<[Float], Error>
    private(set) var callCount = 0

    init(response: Result<[Float], Error>) {
        self.response = response
    }

    func embedding(for text: String) throws -> [Float] {
        callCount += 1
        return try response.get()
    }
}

private final class StubClock {
    private var current: Date

    init(now: Date = Date()) {
        self.current = now
    }

    var now: Date { current }

    func advance(by seconds: TimeInterval) {
        current = current.addingTimeInterval(seconds)
    }
}
```
<!-- END_FILE: Packages/PulsumML/Tests/PulsumMLTests/EmbeddingServiceAvailabilityTests.swift -->

### Packages/PulsumML/Tests/PulsumMLTests/EmbeddingServiceFallbackTests.swift
- bytes: 942
- lines: 27
- sha256: ed9fd859fefcbc3ee2dd267f43fce16d92bbd124a91e89464f7c9077e0316d91
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Tests/PulsumMLTests/EmbeddingServiceFallbackTests.swift -->
```swift
import XCTest
@testable import PulsumML

final class EmbeddingServiceFallbackTests: XCTestCase {
    func testFallsBackWhenPrimaryUnavailable() throws {
        let fallback = MockEmbeddingProvider(vector: Array(repeating: Float(0.25), count: 4))
        let service = EmbeddingService.debugInstance(primary: FailingEmbeddingProvider(),
                                                     fallback: fallback,
                                                     dimension: 4)
        let vector = try service.embedding(for: "pulsum")
        XCTAssertEqual(vector, fallback.vector)
    }
}

private struct FailingEmbeddingProvider: TextEmbeddingProviding {
    func embedding(for text: String) throws -> [Float] {
        throw EmbeddingError.generatorUnavailable
    }
}

private struct MockEmbeddingProvider: TextEmbeddingProviding {
    let vector: [Float]

    func embedding(for text: String) throws -> [Float] {
        vector
    }
}
```
<!-- END_FILE: Packages/PulsumML/Tests/PulsumMLTests/EmbeddingServiceFallbackTests.swift -->

### Packages/PulsumML/Tests/PulsumMLTests/Gate0_EmbeddingServiceFallbackTests.swift
- bytes: 1379
- lines: 47
- sha256: add43c9e63d6f0962cb41cdf1a88dc094c5275980a361ff1b34c5f2816b188bc
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Tests/PulsumMLTests/Gate0_EmbeddingServiceFallbackTests.swift -->
```swift
import XCTest
@testable import PulsumML

private struct MockEmbeddingProvider: TextEmbeddingProviding {
    enum Mode {
        case succeeds([Float])
        case fails(Error)
    }

    let mode: Mode

    func embedding(for text: String) throws -> [Float] {
        switch mode {
        case let .succeeds(vector):
            return vector
        case let .fails(error):
            throw error
        }
    }
}

private struct MockError: Error {}

final class Gate0_EmbeddingServiceFallbackTests: XCTestCase {
    func testFallsBackWhenPrimaryUnavailable() throws {
        let fallbackVector: [Float] = [1, 2, 3, 4]
        let service = EmbeddingService.debugInstance(
            primary: MockEmbeddingProvider(mode: .fails(MockError())),
            fallback: MockEmbeddingProvider(mode: .succeeds(fallbackVector)),
            dimension: 4
        )

        let result = try service.embedding(for: "test")
        XCTAssertEqual(result, fallbackVector)
    }

    func testAvailabilityProbeUsesFallback() throws {
        let fallbackVector: [Float] = [0.1, 0.2, 0.3, 0.4]
        let service = EmbeddingService.debugInstance(
            primary: MockEmbeddingProvider(mode: .fails(MockError())),
            fallback: MockEmbeddingProvider(mode: .succeeds(fallbackVector)),
            dimension: 4
        )

        XCTAssertTrue(service.isAvailable())
    }
}
```
<!-- END_FILE: Packages/PulsumML/Tests/PulsumMLTests/Gate0_EmbeddingServiceFallbackTests.swift -->

### Packages/PulsumML/Tests/PulsumMLTests/Gate6_EmbeddingProviderContextualTests.swift
- bytes: 2450
- lines: 70
- sha256: a449bbb1e509d32f7b386eeeda15962910f8bf423aba8518dce5583c951618c7
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Tests/PulsumMLTests/Gate6_EmbeddingProviderContextualTests.swift -->
```swift
import XCTest
@testable import PulsumML

final class Gate6_EmbeddingProviderContextualTests: XCTestCase {
    func testEmbeddingServiceRejectsZeroVector() {
        let service = EmbeddingService.debugInstance(
            primary: ZeroEmbeddingProvider(),
            fallback: ThrowingEmbeddingProvider(),
            dimension: 4
        )

        XCTAssertThrowsError(try service.embedding(for: "fail")) { error in
            XCTAssertTrue(error is EmbeddingError)
        }
    }

    func testEmbeddingServiceThrowsWhenAllProvidersFail() {
        let service = EmbeddingService.debugInstance(
            primary: ThrowingEmbeddingProvider(),
            fallback: ThrowingEmbeddingProvider(),
            dimension: 3
        )
        XCTAssertThrowsError(try service.embedding(for: "unavailable"))
    }

    func testEmbeddingServiceAveragesSegments() throws {
        let provider = ConstantEmbeddingProvider(vector: [1, 1, 1, 1])
        let service = EmbeddingService.debugInstance(primary: provider, fallback: nil, dimension: 4)
        let vector = try service.embedding(forSegments: ["a", "b"])
        XCTAssertEqual(vector.count, 4)
        XCTAssertTrue(vector.allSatisfy { $0 == 1 })
    }

    func testContextualProviderProducesNonZeroVectorIfAvailable() throws {
#if canImport(FoundationModels)
        if #available(iOS 17.0, macOS 14.0, *) {
            let provider = AFMTextEmbeddingProvider()
            guard let vector = try? provider.embedding(for: "contextual embedding check") else {
                throw XCTSkip("Contextual embeddings unavailable in this environment")
            }
            XCTAssertEqual(vector.count, 384)
            XCTAssertFalse(vector.allSatisfy { $0 == 0 })
        } else {
            throw XCTSkip("Contextual embeddings unavailable on this platform")
        }
#else
        throw XCTSkip("FoundationModels not available on this platform")
#endif
    }
}

private struct ZeroEmbeddingProvider: TextEmbeddingProviding {
    func embedding(for text: String) throws -> [Float] {
        Array(repeating: 0, count: 4)
    }
}

private struct ThrowingEmbeddingProvider: TextEmbeddingProviding {
    func embedding(for text: String) throws -> [Float] {
        throw EmbeddingError.generatorUnavailable
    }
}

private struct ConstantEmbeddingProvider: TextEmbeddingProviding {
    let vector: [Float]

    func embedding(for text: String) throws -> [Float] {
        vector
    }
}
```
<!-- END_FILE: Packages/PulsumML/Tests/PulsumMLTests/Gate6_EmbeddingProviderContextualTests.swift -->

### Packages/PulsumML/Tests/PulsumMLTests/PackageEmbedTests.swift
- bytes: 5284
- lines: 130
- sha256: 30d4e3974f37ed691af92954c5047d719ca8ad3c1c65ef21b027e548f7bd57ed
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Tests/PulsumMLTests/PackageEmbedTests.swift -->
```swift
import XCTest
@testable import PulsumML

final class PackageEmbedTests: XCTestCase {
    func testVersionStringIsPresent() {
        XCTAssertFalse(PulsumML.version.isEmpty)
    }

    func testEmbeddingDimensionIs384() throws {
        let provider = ConstantEmbeddingProvider(vector: Array(repeating: Float(0.5), count: 384))
        let service = EmbeddingService.debugInstance(primary: provider, fallback: nil, dimension: 384)
        let vector = try service.embedding(for: "Calm breathing exercise and gentle walk")
        XCTAssertEqual(vector.count, 384)
    }

    func testSegmentEmbeddingAveragesVectors() throws {
        let vectors: [String: [Float]] = [
            "sleep hygiene": Array(repeating: Float(1), count: 384),
            "low HRV": Array(repeating: Float(3), count: 384)
        ]
        let provider = MappingEmbeddingProvider(map: vectors)
        let service = EmbeddingService.debugInstance(primary: provider, fallback: nil, dimension: 384)
        let vector = try service.embedding(forSegments: ["sleep hygiene", "low HRV"])
        XCTAssertEqual(vector.count, 384)
        XCTAssertEqual(vector.first, 2)
    }

    func testCoreMLFallbackModelIsBundled() throws {
        // Ensures the packaged Core ML embedding exists and yields a non-zero vector.
        if #available(iOS 17.0, macOS 13.0, *) {
            do {
                let provider = CoreMLEmbeddingFallbackProvider()
                let vector = try provider.embedding(for: "pulsum bundle availability")
                XCTAssertEqual(vector.count, 384)
                XCTAssertFalse(vector.allSatisfy { $0 == 0 })
            } catch EmbeddingError.generatorUnavailable {
                throw XCTSkip("Core ML fallback embedding unavailable in this environment.")
            }
        } else {
            throw XCTSkip("Core ML fallback requires at least iOS 17 / macOS 13.")
        }
    }

    func testRobustStatsMedianAndZScore() {
        let values: [Double] = [50, 52, 49, 80, 51, 48, 47]
        guard let stats = BaselineMath.robustStats(for: values) else {
            XCTFail("Stats should not be nil")
            return
        }
        let z = BaselineMath.zScore(value: 80, stats: stats)
        XCTAssertGreaterThan(z, 2.0)
    }
    func testStateEstimatorUpdatesWeights() {
        let estimator = StateEstimator()
        let features = [
            "z_hrv": -1.0,
            "subj_stress": 2.0,
            "subj_energy": -1.0
        ]
        let snapshotBefore = estimator.currentSnapshot(features: features)
        let updated = estimator.update(features: features, target: 1.0)
        XCTAssertNotEqual(snapshotBefore.weights, updated.weights)
    }

    func testRecRankerPrefersHigherEvidence() {
        let ranker = RecRanker()
        let strong = RecommendationFeatures(id: "strong",
                                            wellbeingScore: -0.5,
                                            evidenceStrength: 1.0,
                                            novelty: 0.5,
                                            cooldown: 0.0,
                                            acceptanceRate: 0.5,
                                            timeCostFit: 0.8)
        let weak = RecommendationFeatures(id: "weak",
                                          wellbeingScore: -0.5,
                                          evidenceStrength: 0.2,
                                          novelty: 0.3,
                                          cooldown: 0.0,
                                          acceptanceRate: 0.5,
                                          timeCostFit: 0.8)
        let ranked = ranker.rank([weak, strong])
        XCTAssertEqual(ranked.first?.id, "strong")
    }

    func testSafetyLocalDetectsCrisisLanguage() {
        let safety = SafetyLocal()
        let classification = safety.classify(text: "I am thinking about suicide tonight")
        switch classification {
        case .crisis:
            XCTAssertTrue(true)
        default:
            XCTFail("Expected crisis classification")
        }
    }

    func testAvailabilityModeReportsUnavailableWhenProvidersFail() {
        let provider = FailingEmbeddingProvider()
        let service = EmbeddingService.debugInstance(primary: provider,
                                                     fallback: nil,
                                                     dimension: 384,
                                                     reprobeInterval: 0,
                                                     dateProvider: Date.init)
        XCTAssertEqual(service.availabilityMode(), .unavailable)
    }
}

private struct ConstantEmbeddingProvider: TextEmbeddingProviding {
    let vector: [Float]

    func embedding(for text: String) throws -> [Float] {
        vector
    }
}

private struct FailingEmbeddingProvider: TextEmbeddingProviding {
    func embedding(for text: String) throws -> [Float] {
        throw EmbeddingError.generatorUnavailable
    }
}

private struct MappingEmbeddingProvider: TextEmbeddingProviding {
    let map: [String: [Float]]

    func embedding(for text: String) throws -> [Float] {
        guard let vector = map[text] else {
            throw EmbeddingError.generatorUnavailable
        }
        return vector
    }
}
```
<!-- END_FILE: Packages/PulsumML/Tests/PulsumMLTests/PackageEmbedTests.swift -->

### Packages/PulsumML/Tests/PulsumMLTests/SafetyLocalTests.swift
- bytes: 1062
- lines: 32
- sha256: 76fb751d8be17af00f3cf442d6dd5102020c259ab4d64d2dc3a3a0e894f13dd2
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Tests/PulsumMLTests/SafetyLocalTests.swift -->
```swift
import XCTest
@testable import PulsumML

final class SafetyLocalTests: XCTestCase {
    func testCrisisKeywordTriggersCrisisClassification() {
        let safety = SafetyLocal()
        let decision = safety.classify(text: "I am going to kill myself tonight")
        switch decision {
        case .crisis:
            XCTAssertTrue(true)
        default:
            XCTFail("Expected crisis classification for explicit self-harm language")
        }
    }

    func testSimilarityThresholdIdentifiesCautionTone() {
        let safety = SafetyLocal()
        let decision = safety.classify(text: "I'm panicking right now and can't calm down")
        switch decision {
        case .caution:
            XCTAssertTrue(true)
        default:
            XCTFail("Expected caution classification for overwhelming language")
        }
    }

    func testSafeTextRemainsUnaffected() {
        let safety = SafetyLocal()
        let result = safety.classify(text: "I finished a restorative stretch and feel balanced")
        XCTAssertEqual(result, .safe)
    }
}
```
<!-- END_FILE: Packages/PulsumML/Tests/PulsumMLTests/SafetyLocalTests.swift -->

### Packages/PulsumML/Tests/PulsumMLTests/TopicGateMarginTests.swift
- bytes: 1909
- lines: 61
- sha256: 746de33b614a12f07f8566f29d9c894249a75770878c67ce7e5e246c2da272f9
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Tests/PulsumMLTests/TopicGateMarginTests.swift -->
```swift
import Testing
@testable import PulsumML

private func makeMarginTopicGateProvider() -> EmbeddingTopicGateProvider {
    let embeddingService = EmbeddingService.debugInstance(
        primary: KeywordEmbeddingProvider(dimension: 4),
        fallback: nil,
        dimension: 4
    )
    return EmbeddingTopicGateProvider(embeddingService: embeddingService)
}

struct TopicGateMarginTests {

    @Test("Topic gate margin telemetry")
    func topicGateMarginTelemetry() async throws {
        let provider = makeMarginTopicGateProvider()
        let onTopic = [
            "How to improve sleep",
            "Ideas to manage stress better",
            "Ways to keep my energy steady"
        ]
        let offTopic = [
            "Calculate the prime factors of 512",
            "Where to find the best pizza recipe",
            "Plan my taxes for 2025"
        ]

        for text in onTopic {
            let scores = try await provider.debugScores(for: text)
            #expect(scores.margin >= 0.12)
        }

        for text in offTopic {
            let scores = try await provider.debugScores(for: text)
            #expect(scores.margin < 0.12)
        }
    }
}

private struct KeywordEmbeddingProvider: TextEmbeddingProviding {
    let dimension: Int

    func embedding(for text: String) throws -> [Float] {
        var vector = [Float](repeating: 0, count: dimension)
        let lower = text.lowercased()
        if lower.contains("sleep") {
            vector[0] = 1
        } else if lower.contains("stress") || lower.contains("anxious") {
            vector[1] = 1
        } else if lower.contains("energy") || lower.contains("motiv") {
            vector[2] = 1
        } else if lower.contains("hrv") {
            vector[3] = 1
        }
        if vector.allSatisfy({ $0 == 0 }) {
            vector = Array(repeating: 0.1, count: dimension)
        }
        return vector
    }
}
```
<!-- END_FILE: Packages/PulsumML/Tests/PulsumMLTests/TopicGateMarginTests.swift -->

### Packages/PulsumML/Tests/PulsumMLTests/TopicGateTests.swift
- bytes: 5366
- lines: 149
- sha256: fc24f96db640af18a43dc4e955a702d576a29656c271197991d6fd60fc84b162
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumML/Tests/PulsumMLTests/TopicGateTests.swift -->
```swift
import Testing
import Foundation
@testable import PulsumML

private func makeTopicGateProvider() -> EmbeddingTopicGateProvider {
    let embeddingService = EmbeddingService.debugInstance(
        primary: KeywordEmbeddingProvider(dimension: 4),
        fallback: nil,
        dimension: 4
    )
    return EmbeddingTopicGateProvider(embeddingService: embeddingService)
}

/// Tests for TopicGate providers (on-device topical guardrail)
struct TopicGateTests {

    @Test("Embedding fallback classifies on-topic wellbeing queries")
    func embeddingFallbackOnTopic() async throws {
        let provider = makeTopicGateProvider()

        let onTopicQueries = [
            "I'm feeling stressed today, what should I do?",
            "My sleep has been poor lately",
            "I need help managing my energy levels",
            "How can I improve my HRV?",
            "My mood is low and I'm anxious"
        ]

        for query in onTopicQueries {
            let decision = try await provider.classify(query)
            #expect(decision.isOnTopic, "Expected '\(query)' to be classified as on-topic")
            #expect(decision.confidence > 0.5, "Expected confidence > 0.5 for on-topic query")
        }
    }

    @Test("Embedding fallback classifies off-topic queries")
    func embeddingFallbackOffTopic() async throws {
        let provider = makeTopicGateProvider()

        let offTopicQueries = [
            "Calculate the prime factors of 512",
            "Where to find the best pizza recipe",
            "Schedule for city subway trains",
            "Plan my taxes for 2025",
            "Explain quantum entanglement"
        ]

        for query in offTopicQueries {
            let decision = try await provider.classify(query)
            #expect(!decision.isOnTopic, "Expected off-topic for: \(query)")
        }
    }

    @Test("Greetings are treated generously")
    func greetingsOnTopic() async throws {
        let provider = makeTopicGateProvider()

        let greetings = [
            "hi",
            "hello",
            "hey there",
            "good morning",
            "how are you?"
        ]

        for greeting in greetings {
            let decision = try await provider.classify(greeting)
            // Greetings should have moderate similarity to wellbeing topics
            #expect(decision.confidence >= 0.3, "Expected greetings to have reasonable confidence")
        }
    }

    @Test("Empty input fails gracefully")
    func emptyInputHandling() async throws {
        let provider = makeTopicGateProvider()
        let decision = try await provider.classify("")

        // Empty input should fail-closed (off-topic)
        #expect(!decision.isOnTopic, "Expected empty input to be classified as off-topic")
    }

    @Test("Sleep coaching query maps to sleep topic")
    func sleepQueryMapsToSleepTopic() async throws {
        let provider = makeTopicGateProvider()
        let decision = try await provider.classify("How to improve sleep")
        #expect(decision.isOnTopic)
        #expect(decision.topic == "sleep")
        #expect(decision.confidence >= 0.59)
    }

    @Test("Motivation query maps to goals domain")
    func motivationQueryMapsToGoals() async throws {
        let provider = makeTopicGateProvider()
        let decision = try await provider.classify("How can I keep motivated lately")
        #expect(decision.isOnTopic)
        #expect(decision.topic == "goals" || decision.topic == "energy")
        #expect(decision.confidence >= 0.59)
    }

    @Test("Margin guard rejects near-threshold off-topic")
    func marginGuardRejectsOffTopic() async throws {
        let provider = makeTopicGateProvider()
        let scores = try await provider.debugScores(for: "Calculate the prime factors of 512")
        #expect(scores.margin < 0.12)
    }

#if canImport(FoundationModels) && os(iOS)
    @available(iOS 26.0, *)
    @Test("Foundation Models provider requires availability")
    func foundationModelsRequiresAvailability() async throws {
        let provider = FoundationModelsTopicGateProvider()

        // Test should gracefully handle unavailable models
        do {
            _ = try await provider.classify("test input")
            // If we reach here, model is available (test environment specific)
        } catch TopicGateError.modelUnavailable {
            // Expected in environments without Apple Intelligence
            #expect(true)
        } catch {
            throw error // Unexpected error
        }
    }
#endif
}

private struct ConstantEmbeddingProvider: TextEmbeddingProviding {
    let dimension: Int

    func embedding(for text: String) throws -> [Float] {
        var vector = [Float](repeating: 0, count: dimension)
        let lower = text.lowercased()
        if lower.contains("sleep") {
            vector[0] = 1
        } else if lower.contains("stress") || lower.contains("anxious") || lower.contains("anxiety") {
            vector[1] = 1
        } else if lower.contains("energy") || lower.contains("motiv") {
            vector[2] = 1
        } else if lower.contains("hrv") {
            vector[3] = 1
        }
        if vector.allSatisfy({ $0 == 0 }) {
            vector = Array(repeating: 0.1, count: dimension)
        }
        return vector
    }
}

private typealias KeywordEmbeddingProvider = ConstantEmbeddingProvider
```
<!-- END_FILE: Packages/PulsumML/Tests/PulsumMLTests/TopicGateTests.swift -->

### Packages/PulsumServices/Package.swift
- bytes: 1067
- lines: 43
- sha256: c5c5798d7857c373a43eb198de4f7fdbe5424fd7810c35351ccc18103c5b6b7a
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Package.swift -->
```swift
// swift-tools-version: 6.1
import PackageDescription

let package = Package(
    name: "PulsumServices",
    platforms: [
        .iOS("26.0"),
        .macOS(.v14)
    ],
    products: [
        .library(
            name: "PulsumServices",
            targets: ["PulsumServices"]
        )
    ],
    dependencies: [
        .package(path: "../PulsumData"),
        .package(path: "../PulsumML"),
        .package(path: "../PulsumTypes")
    ],
    targets: [
        .target(
            name: "PulsumServices",
            dependencies: [
                "PulsumData",
                "PulsumML",
                "PulsumTypes"
            ],
            path: "Sources",
            resources: [
                .process("PulsumServices/PrivacyInfo.xcprivacy")
            ],
            linkerSettings: [
                .linkedFramework("FoundationModels", .when(platforms: [.iOS]))
            ]
        ),
        .testTarget(
            name: "PulsumServicesTests",
            dependencies: ["PulsumServices"],
            path: "Tests"
        )
    ]
)
```
<!-- END_FILE: Packages/PulsumServices/Package.swift -->

### Packages/PulsumServices/Sources/PulsumServices/BuildFlags.swift
- bytes: 732
- lines: 26
- sha256: c230d24d84494e824cb848fa0a14adead6e9fb7d8838c91a8254abae6d518441
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Sources/PulsumServices/BuildFlags.swift -->
```swift
import Foundation

// Gate-1b: UITest seam hardening
// Shared entry point so all services know if UITest seams are compiled in.
enum BuildFlags {
#if DEBUG || PULSUM_UITESTS
    static let uiTestSeamsCompiledIn = true
#else
    static let uiTestSeamsCompiledIn = false
#endif

#if DEBUG
    nonisolated(unsafe) private static var modernSpeechOverride: Bool?

    static func overrideModernSpeechBackend(_ value: Bool?) {
        modernSpeechOverride = value
    }

    static var useModernSpeechBackend: Bool {
        if let override = modernSpeechOverride { return override }
        return ProcessInfo.processInfo.environment["PULSUM_USE_MODERN_SPEECH"] == "1"
    }
#else
    static let useModernSpeechBackend = false
#endif
}
```
<!-- END_FILE: Packages/PulsumServices/Sources/PulsumServices/BuildFlags.swift -->

### Packages/PulsumServices/Sources/PulsumServices/Bundle+PulsumServicesResources.swift
- bytes: 311
- lines: 14
- sha256: b278424341a51881aa3bd7e16ccf7701cf09a0680fb1d602b2cd1f3b716816b0
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Sources/PulsumServices/Bundle+PulsumServicesResources.swift -->
```swift
import Foundation

#if SWIFT_PACKAGE
extension Bundle {
    static var pulsumServicesResources: Bundle { .module }
}
#else
private final class PulsumServicesBundleLocator {}
extension Bundle {
    static var pulsumServicesResources: Bundle {
        Bundle(for: PulsumServicesBundleLocator.self)
    }
}
#endif
```
<!-- END_FILE: Packages/PulsumServices/Sources/PulsumServices/Bundle+PulsumServicesResources.swift -->

### Packages/PulsumServices/Sources/PulsumServices/CoachPhrasingSchema.swift
- bytes: 2365
- lines: 67
- sha256: fb03e55fe72a1eabe811058bd87d6d58077a777e9794804f0394273f18c3d20b
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Sources/PulsumServices/CoachPhrasingSchema.swift -->
```swift
import Foundation

/// Canonical strict schema for GPT‑5 structured coach phrasing.
/// All fields are 'required' (strict JSON mode), but semantically-optional
/// ones ("refusalReason", "nextAction", "intentTopic") must allow empty "".
public enum CoachPhrasingSchema {
    public static func json() -> [String: Any] {
        // Properties dictionary
        let props: [String: Any] = [
            "coachReply": [
                "type": "string",
                "minLength": 1,
                "maxLength": 280,
                "description": "Reply ≤2 sentences, ≤280 chars total."
            ],
            "isOnTopic": [
                "type": "boolean",
                "description": "Model’s own topicality check."
            ],
            "groundingScore": [
                "type": "number",
                "minimum": 0.0,
                "maximum": 1.0,
                "description": "Self-assessed grounding in provided context."
            ],
            "intentTopic": [
                "type": "string",
                "minLength": 0,
                "maxLength": 32,
                "enum": ["sleep","stress","energy","hrv","mood","movement","mindfulness","goals","none"],
                "description": "Echo of deterministic routing topic (or 'none')."
            ],
            "refusalReason": [
                "type": "string",
                "minLength": 0,
                "maxLength": 160,
                "description": "Empty string when not refusing/cautioning."
            ],
            "nextAction": [
                "type": "string",
                "minLength": 0,
                "maxLength": 120,
                "description": "Optional micro-action; empty string when N/A."
            ]
        ]

        // strict=true requires every property to be in 'required'
        let required = Array(props.keys).sorted()

        return [
            "type": "object",
            "additionalProperties": false,
            "properties": props,
            "required": required
        ]
    }

    /// Top-level Responses API wrapper for strict JSON Schema output
    public static func responsesFormat() -> [String: Any] {
        return [
            "type": "json_schema",
            "name": "CoachPhrasing",
            "schema": CoachPhrasingSchema.json(),
            "strict": true
        ]
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Sources/PulsumServices/CoachPhrasingSchema.swift -->

### Packages/PulsumServices/Sources/PulsumServices/FoundationModelsCoachGenerator.swift
- bytes: 4895
- lines: 107
- sha256: 60971352cdf6f3bac4be66adb8872ed0332fe5959aca07cbd457169ac38d0d73
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Sources/PulsumServices/FoundationModelsCoachGenerator.swift -->
```swift
import Foundation
#if canImport(FoundationModels) && os(iOS)
import FoundationModels
#endif
import PulsumML

public final class FoundationModelsCoachGenerator: OnDeviceCoachGenerator {
    public init() {}

    public func generate(context: CoachLLMContext) async -> CoachReplyPayload {
#if canImport(FoundationModels) && os(iOS)
        if #available(iOS 26.0, *) {
            let model = SystemLanguageModel.default
            guard model.isAvailable else {
                return fallbackResponse(for: context.topSignal)
            }

            var instructionText = """
            You are Pulsum's wellness coach. Guidelines:
            - Keep responses under 80 words and maximum 2 sentences
            - Ground suggestions in provided wellbeing signals and scores
            - Be supportive, calm, and actionable - NEVER diagnostic
            - Focus on immediate, doable actions
            - Use language like "may help", "consider", or "notice"; never "should", "must", or medical claims
            - NEVER diagnose, prescribe, or claim to treat conditions
            - Relate suggestions to current wellbeing context (sleep, energy, stress, mood, movement)
            """

            if let topic = topicFromSignal(context.topSignal) {
                switch topic {
                case "sleep":
                    instructionText += "\nWhen topic is sleep and data is sparse, favor wind-down routines, light exposure timing, and mindful caffeine timing; avoid medical claims."
                case "stress":
                    instructionText += "\nWhen topic is stress, encourage brief breathing exercises, gentle walks, or grounded check-ins; avoid therapeutic claims."
                case "energy":
                    instructionText += "\nWhen topic is energy or motivation, suggest pacing, hydration, or light movement to build steady momentum without promising outcomes."
                default:
                    break
                }
            }

            let session = LanguageModelSession(
                instructions: Instructions(instructionText)
            )

            let prompt = """
            User context: \(context.userToneHints)
            Current health signal: \(context.topSignal)
            Health metrics: \(context.zScoreSummary)
            Analysis: \(context.rationale)

            Provide a brief, supportive coaching response that addresses their current state.
            """

            do {
                let response = try await session.respond(
                    to: Prompt(prompt),
                    options: GenerationOptions(temperature: 0.6)
                )
                return CoachReplyPayload(
                    coachReply: sanitizeResponse(response.content),
                    nextAction: nil  // Foundation Models doesn't generate nextAction
                )
            } catch LanguageModelSession.GenerationError.guardrailViolation {
                return CoachReplyPayload(
                    coachReply: "Take a moment to focus on what feels supportive right now.",
                    nextAction: nil
                )
            } catch LanguageModelSession.GenerationError.refusal {
                return CoachReplyPayload(
                    coachReply: "Let's keep the focus on gentle, grounding actions.",
                    nextAction: nil
                )
            } catch {
                return fallbackResponse(for: context.topSignal)
            }
        }
#endif
        return fallbackResponse(for: context.topSignal)
    }

    private func topicFromSignal(_ signal: String) -> String? {
        guard let range = signal.range(of: "topic=") else { return nil }
        let suffix = signal[range.upperBound...]
        let components = suffix.split(separator: " ", maxSplits: 1)
        return components.first.map { String($0) }
    }

    private func sanitizeResponse(_ response: String) -> String {
        let sentences = response.split(whereSeparator: { $0 == "." || $0 == "!" || $0 == "?" })
        let trimmed = sentences.prefix(2).map { sentence -> String in
            let cleaned = sentence.trimmingCharacters(in: .whitespacesAndNewlines)
            return cleaned.prefix(280).trimmingCharacters(in: .whitespacesAndNewlines)
        }
        return trimmed.joined(separator: ". ").appending(trimmed.isEmpty ? "" : ".")
    }

    private func fallbackResponse(for signal: String) -> CoachReplyPayload {
        let topic = topicFromSignal(signal) ?? "today"
        let hint = topic == "today" ? "" : " A tiny action for \(topic) may help.".trimmingCharacters(in: .whitespaces)
        let message = "Take a slow breath and notice one thing that feels steady right now." + (hint.isEmpty ? "" : " \(hint)")
        return CoachReplyPayload(
            coachReply: sanitizeResponse(message),
            nextAction: nil
        )
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Sources/PulsumServices/FoundationModelsCoachGenerator.swift -->

### Packages/PulsumServices/Sources/PulsumServices/HealthKitAnchorStore.swift
- bytes: 3144
- lines: 78
- sha256: 0b8534734c1c4dfa20372faf5f44f2f2dcf99d02db61d0fb1095dcc68d2e9340
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Sources/PulsumServices/HealthKitAnchorStore.swift -->
```swift
import Foundation
import HealthKit
import PulsumData
import PulsumTypes

/// Persists HealthKit query anchors on-device with complete file protection.
public final class HealthKitAnchorStore {
    private let directory: URL
    private let fileManager: FileManager
    private let queue = DispatchQueue(label: "ai.pulsum.healthkit.anchorstore")

    public init(directory: URL = PulsumData.healthAnchorsDirectory, fileManager: FileManager = .default) {
        self.directory = directory
        self.fileManager = fileManager
    }

    public func anchor(for sampleTypeIdentifier: String) -> HKQueryAnchor? {
        queue.sync {
            let fileURL = url(for: sampleTypeIdentifier)
            guard fileManager.fileExists(atPath: fileURL.path) else { return nil }
            guard let data = try? Data(contentsOf: fileURL) else { return nil }
            return try? NSKeyedUnarchiver.unarchivedObject(ofClass: HKQueryAnchor.self, from: data)
        }
    }

    public func store(anchor: HKQueryAnchor, for sampleTypeIdentifier: String) {
        queue.async {
            let fileURL = self.url(for: sampleTypeIdentifier)
            do {
                let data = try NSKeyedArchiver.archivedData(withRootObject: anchor, requiringSecureCoding: true)
                try data.write(to: fileURL, options: .atomic)
                self.applyFileProtectionIfAvailable(to: fileURL)
            } catch {
                Diagnostics.log(level: .warn,
                                category: .healthkit,
                                name: "healthkit.anchor.persist.failed",
                                fields: ["type": .safeString(.metadata(sampleTypeIdentifier))],
                                error: error)
            }
        }
    }

    public func removeAnchor(for sampleTypeIdentifier: String) {
        queue.async {
            let fileURL = self.url(for: sampleTypeIdentifier)
            guard self.fileManager.fileExists(atPath: fileURL.path) else { return }
            do {
                try self.fileManager.removeItem(at: fileURL)
            } catch {
                Diagnostics.log(level: .warn,
                                category: .healthkit,
                                name: "healthkit.anchor.remove.failed",
                                fields: ["type": .safeString(.metadata(sampleTypeIdentifier))],
                                error: error)
            }
        }
    }

    private func url(for identifier: String) -> URL {
        directory.appendingPathComponent(identifier.safeFilenameComponent).appendingPathExtension("anchor")
    }

    private func applyFileProtectionIfAvailable(to url: URL) {
#if os(iOS)
        try? fileManager.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: url.path)
#endif
    }
}

private extension String {
    /// Sanitizes the identifier for safe filesystem usage.
    var safeFilenameComponent: String {
        let invalidCharacters = CharacterSet(charactersIn: ":/")
        return components(separatedBy: invalidCharacters).joined(separator: "_")
    }
}

extension HealthKitAnchorStore: @unchecked Sendable {}
```
<!-- END_FILE: Packages/PulsumServices/Sources/PulsumServices/HealthKitAnchorStore.swift -->

### Packages/PulsumServices/Sources/PulsumServices/HealthKitService.swift
- bytes: 33389
- lines: 780
- sha256: 2163a3f96b8bc70ba4552ff69560c23be4e690c4638c227b0771083432e888c7
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Sources/PulsumServices/HealthKitService.swift -->
```swift
import Foundation
@preconcurrency import HealthKit
import PulsumTypes

public protocol HealthKitObservationToken: AnyObject {}
#if canImport(HealthKit)
extension HKObserverQuery: HealthKitObservationToken {}
#endif

/// Errors thrown by `HealthKitService`.
public enum HealthKitServiceError: LocalizedError {
    case healthDataUnavailable
    case authorizationDenied
    case backgroundDeliveryFailed(type: HKObjectType, underlying: Error)
    case queryExecutionFailed(underlying: Error)

    public var errorDescription: String? {
        switch self {
        case .healthDataUnavailable:
            return "Health data is not available on this device."
        case .authorizationDenied:
            return "Pulsum does not have permission to read the requested health data."
        case let .backgroundDeliveryFailed(type, underlying):
            return "Background delivery failed for \(type.identifier): \(underlying.localizedDescription)"
        case let .queryExecutionFailed(underlying):
            return "Failed to execute HealthKit query: \(underlying.localizedDescription)"
        }
    }
}

public enum ReadAuthorizationProbeResult: Equatable, Sendable {
    case authorized
    case denied
    case notDetermined
    case protectedDataUnavailable
    case healthDataUnavailable
    case error(domain: String, code: Int)
}

#if DEBUG
private enum HealthKitStatusOverrideBehavior: String {
    case none
    case grantAll
}

private final class HealthKitAuthorizationOverrides: @unchecked Sendable {
    static let shared = HealthKitAuthorizationOverrides()

    private let queue = DispatchQueue(label: "ai.pulsum.healthkit.override", qos: .utility)
    private var overrides: [String: HKAuthorizationStatus]
    private let requestBehavior: HealthKitStatusOverrideBehavior
    private let debugLoggingEnabled: Bool

    private init() {
        self.overrides = Self.parseOverrides(ProcessInfo.processInfo.environment["PULSUM_HEALTHKIT_STATUS_OVERRIDE"])
        if let rawBehavior = ProcessInfo.processInfo.environment["PULSUM_HEALTHKIT_REQUEST_BEHAVIOR"],
           let behavior = HealthKitStatusOverrideBehavior(rawValue: rawBehavior) {
            self.requestBehavior = behavior
        } else {
            self.requestBehavior = .none
        }
        self.debugLoggingEnabled = ProcessInfo.processInfo.environment["PULSUM_HEALTHKIT_DEBUG"] == "1"
    }

    func status(for identifier: String) -> HKAuthorizationStatus? {
        queue.sync { overrides[identifier] }
    }

    func handleRequest(availableTypes: Set<HKSampleType>) -> Bool {
        switch requestBehavior {
        case .grantAll:
            queue.sync {
                for type in availableTypes {
                    overrides[type.identifier] = .sharingAuthorized
                }
                if debugLoggingEnabled {
                    let identifiers = availableTypes.map(\.identifier).sorted()
                    Diagnostics.log(level: .debug,
                                    category: .healthkit,
                                    name: "healthkit.override.grantAll",
                                    fields: [
                                        "type_count": .int(identifiers.count)
                                    ])
                }
            }
            return true
        case .none:
            if debugLoggingEnabled {
                Diagnostics.log(level: .debug,
                                category: .healthkit,
                                name: "healthkit.override.none")
            }
            return false
        }
    }

    private static func parseOverrides(_ raw: String?) -> [String: HKAuthorizationStatus] {
        guard let raw, !raw.isEmpty else { return [:] }
        var result: [String: HKAuthorizationStatus] = [:]
        for entry in raw.split(separator: ",") {
            let pair = entry.split(separator: "=", maxSplits: 1).map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            guard pair.count == 2,
                  let status = status(from: pair[1]) else { continue }
            let identifier = identifier(from: pair[0])
            guard !identifier.isEmpty else { continue }
            result[identifier] = status
        }
        return result
    }

    private static func status(from value: String) -> HKAuthorizationStatus? {
        switch value.lowercased() {
        case "authorized", "sharingauthorized", "granted", "allow":
            return .sharingAuthorized
        case "denied", "sharingdenied":
            return .sharingDenied
        case "undetermined", "notdetermined", "pending":
            return .notDetermined
        default:
            return nil
        }
    }

    private static func identifier(from raw: String) -> String {
        let lower = raw.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        switch lower {
        case "hrv", "heartratevariability", "heartratevariabilitysdnn":
            return HKQuantityTypeIdentifier.heartRateVariabilitySDNN.rawValue
        case "heartrate", "hr":
            return HKQuantityTypeIdentifier.heartRate.rawValue
        case "restingheartrate", "restinghr":
            return HKQuantityTypeIdentifier.restingHeartRate.rawValue
        case "respiratoryrate", "rr":
            return HKQuantityTypeIdentifier.respiratoryRate.rawValue
        case "steps", "stepcount":
            return HKQuantityTypeIdentifier.stepCount.rawValue
        case "sleep", "sleepanalysis":
            return HKCategoryTypeIdentifier.sleepAnalysis.rawValue
        default:
            return raw
        }
    }
}
#endif

/// Encapsulates HealthKit anchored + observer queries for Pulsum ingestion.
public final class HealthKitService: @unchecked Sendable {
    public struct AnchoredUpdate {
        public let samples: [HKSample]
        public let deletedSamples: [HKDeletedObject]
        public let newAnchor: HKQueryAnchor
    }

    public typealias AnchoredUpdateHandler = @Sendable (Result<AnchoredUpdate, Error>) -> Void

    private let healthStore: HKHealthStore
    private let anchorStore: HealthKitAnchorStore
    private let calendar = Calendar(identifier: .gregorian)
    private let processingQueue = DispatchQueue(label: "ai.pulsum.healthkit.service")
    private let initialAnchorWindowDays = 2

    private var activeObserverQueries: [HKSampleType: HKObserverQuery] = [:]
    private var activeAnchoredQueries: [HKSampleType: HKAnchoredObjectQuery] = [:]

    public init(healthStore: HKHealthStore = HKHealthStore(), anchorStore: HealthKitAnchorStore = HealthKitAnchorStore()) {
        self.healthStore = healthStore
        self.anchorStore = anchorStore
    }

    /// All HealthKit sample types Pulsum consumes.
    public static var readSampleTypes: Set<HKSampleType> {
        var types: Set<HKSampleType> = []
        if let hrv = HKObjectType.quantityType(forIdentifier: .heartRateVariabilitySDNN) { types.insert(hrv) }
        if let heartRate = HKObjectType.quantityType(forIdentifier: .heartRate) { types.insert(heartRate) }
        if let restingHR = HKObjectType.quantityType(forIdentifier: .restingHeartRate) { types.insert(restingHR) }
        if let respiratoryRate = HKObjectType.quantityType(forIdentifier: .respiratoryRate) { types.insert(respiratoryRate) }
        if let steps = HKObjectType.quantityType(forIdentifier: .stepCount) { types.insert(steps) }
        if let sleep = HKObjectType.categoryType(forIdentifier: .sleepAnalysis) { types.insert(sleep) }
        return types
    }

    /// Sorted array of required sample types for deterministic UI display.
    public static var orderedReadSampleTypes: [HKSampleType] {
        readSampleTypes.sorted { $0.identifier < $1.identifier }
    }

    public var isHealthDataAvailable: Bool {
        HKHealthStore.isHealthDataAvailable()
    }

    /// Requests read authorization for Pulsum health data requirements.
    public func requestAuthorization() async throws {
        guard HKHealthStore.isHealthDataAvailable() else {
            throw HealthKitServiceError.healthDataUnavailable
        }

#if DEBUG
        if BuildFlags.uiTestSeamsCompiledIn,
           HealthKitAuthorizationOverrides.shared.handleRequest(availableTypes: HealthKitService.readSampleTypes) {
            return
        }
#endif

        let readTypes = HealthKitService.readSampleTypes

        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            healthStore.requestAuthorization(toShare: nil, read: readTypes) { success, error in
                if let error {
                    continuation.resume(throwing: error)
                } else if success {
                    continuation.resume()
                } else {
                    continuation.resume(throwing: HealthKitServiceError.authorizationDenied)
                }
            }
        }
    }

    public func requestStatusForAuthorization(readTypes: Set<HKSampleType>) async -> HKAuthorizationRequestStatus? {
#if DEBUG
        if BuildFlags.uiTestSeamsCompiledIn {
            let hasOverride = readTypes.contains { type in
                HealthKitAuthorizationOverrides.shared.status(for: type.identifier) != nil
            }
            if hasOverride {
                return .unnecessary
            }
        }
#endif
        guard #available(iOS 14.0, *) else { return nil }
        let objectTypes = Set(readTypes.map { $0 as HKObjectType })
        return try? await withCheckedThrowingContinuation { (continuation: CheckedContinuation<HKAuthorizationRequestStatus, Error>) in
            healthStore.getRequestStatusForAuthorization(toShare: [], read: objectTypes) { status, error in
                if let error {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume(returning: status)
                }
            }
        }
    }

    public func probeReadAuthorization(for type: HKSampleType) async -> ReadAuthorizationProbeResult {
#if DEBUG
        if BuildFlags.uiTestSeamsCompiledIn,
           let override = HealthKitAuthorizationOverrides.shared.status(for: type.identifier) {
            switch override {
            case .sharingAuthorized:
                return .authorized
            case .sharingDenied:
                return .denied
            case .notDetermined:
                return .notDetermined
            @unknown default:
                return .notDetermined
            }
        }
#endif
        guard HKHealthStore.isHealthDataAvailable() else {
            return .healthDataUnavailable
        }

        let endDate = Date()
        let startDate = calendar.date(byAdding: .day, value: -1, to: endDate) ?? endDate.addingTimeInterval(-86_400)
        let predicate = HKQuery.predicateForSamples(withStart: startDate, end: endDate, options: [.strictStartDate])

        return await withCheckedContinuation { continuation in
            let query = HKSampleQuery(sampleType: type,
                                      predicate: predicate,
                                      limit: 1,
                                      sortDescriptors: nil) { _, _, error in
                if let error {
                    continuation.resume(returning: self.readProbeResult(for: error))
                } else {
                    continuation.resume(returning: .authorized)
                }
            }

            self.healthStore.execute(query)
        }
    }

    public func probeReadAuthorization(for types: [HKSampleType]) async -> [HKSampleType: ReadAuthorizationProbeResult] {
        guard !types.isEmpty else { return [:] }
        let maxConcurrent = 3
        return await withTaskGroup(of: (HKSampleType, ReadAuthorizationProbeResult).self) { group in
            var iterator = types.makeIterator()
            for _ in 0 ..< maxConcurrent {
                guard let next = iterator.next() else { break }
                group.addTask { [self] in
                    let result = await self.probeReadAuthorization(for: next)
                    return (next, result)
                }
            }

            var results: [HKSampleType: ReadAuthorizationProbeResult] = [:]
            for await (type, result) in group {
                results[type] = result
                if let next = iterator.next() {
                    group.addTask { [self] in
                        let result = await self.probeReadAuthorization(for: next)
                        return (next, result)
                    }
                }
            }
            return results
        }
    }

    public func fetchDailyStepTotals(startDate: Date, endDate: Date) async throws -> [Date: Int] {
        guard HKHealthStore.isHealthDataAvailable() else {
            throw HealthKitServiceError.healthDataUnavailable
        }

        let quantityType = HKObjectType.quantityType(forIdentifier: .stepCount)!
        let predicate = HKQuery.predicateForSamples(withStart: startDate, end: endDate, options: .strictStartDate)

        var interval = DateComponents()
        interval.day = 1
        let anchorDate = calendar.startOfDay(for: startDate)
        let healthStore = self.healthStore
        let handle = HealthKitQueryHandle<[Date: Int]>()

        return try await withTaskCancellationHandler(operation: {
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[Date: Int], Error>) in
                let coordinator = HealthKitQueryCoordinator<[Date: Int]>(continuation: continuation)
                handle.set(coordinator)

                let query = HKStatisticsCollectionQuery(quantityType: quantityType,
                                                        quantitySamplePredicate: predicate,
                                                        options: .cumulativeSum,
                                                        anchorDate: anchorDate,
                                                        intervalComponents: interval)

                coordinator.setQuery(query)

                query.initialResultsHandler = { [calendar] _, collection, error in
                    if let error {
                        coordinator.resumeFailure(error)
                        return
                    }

                    guard let collection else {
                        coordinator.resumeSuccess([:])
                        return
                    }

                    var results: [Date: Int] = [:]
                    collection.enumerateStatistics(from: startDate, to: endDate) { statistics, _ in
                        guard let sum = statistics.sumQuantity() else { return }
                        let day = calendar.startOfDay(for: statistics.startDate)
                        results[day] = Int(sum.doubleValue(for: HKUnit.count()))
                    }

                    coordinator.resumeSuccess(results)
                }

                healthStore.execute(query)
            }
        }, onCancel: {
            handle.cancel(healthStore: healthStore)
        })
    }

    public func fetchNocturnalHeartRateStats(startDate: Date, endDate: Date) async throws -> [Date: (avgBPM: Double, minBPM: Double?)] {
        guard HKHealthStore.isHealthDataAvailable() else {
            throw HealthKitServiceError.healthDataUnavailable
        }

        let quantityType = HKObjectType.quantityType(forIdentifier: .heartRate)!
        var results: [Date: (avgBPM: Double, minBPM: Double?)] = [:]

        var day = calendar.startOfDay(for: startDate)
        let endBoundary = calendar.startOfDay(for: endDate)
        let healthStore = self.healthStore

        while day < endBoundary {
            guard let nextDay = calendar.date(byAdding: .day, value: 1, to: day) else { break }
            let nightStart = calendar.date(bySettingHour: 22, minute: 0, second: 0, of: day) ?? day
            let nightEnd = calendar.date(bySettingHour: 8, minute: 0, second: 0, of: nextDay) ?? nextDay

            let windowStart = max(nightStart, startDate)
            let windowEnd = min(nightEnd, endDate)
            if windowStart < windowEnd {
                let predicate = HKQuery.predicateForSamples(withStart: windowStart, end: windowEnd, options: .strictStartDate)
                let handle = HealthKitQueryHandle<(Double, Double?)?>()

                let stats = try await withTaskCancellationHandler(operation: {
                    try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<(Double, Double?)?, Error>) in
                        let coordinator = HealthKitQueryCoordinator<(Double, Double?)?>(continuation: continuation)
                        handle.set(coordinator)

                        let query = HKStatisticsQuery(quantityType: quantityType,
                                                      quantitySamplePredicate: predicate,
                                                      options: [.discreteAverage, .discreteMin]) { _, statistics, error in
                            if let error {
                                if let hkError = error as? HKError, hkError.code == .errorNoData {
                                    coordinator.resumeSuccess(nil)
                                    return
                                }
                                let nsError = error as NSError
                                if nsError.domain == HKError.errorDomain,
                                   nsError.code == HKError.Code.errorNoData.rawValue {
                                    coordinator.resumeSuccess(nil)
                                    return
                                }
                                coordinator.resumeFailure(error)
                                return
                            }
                            guard let statistics, let average = statistics.averageQuantity() else {
                                coordinator.resumeSuccess(nil)
                                return
                            }
                            let unit = HKUnit.count().unitDivided(by: .minute())
                            let avg = average.doubleValue(for: unit)
                            let min = statistics.minimumQuantity()?.doubleValue(for: unit)
                            coordinator.resumeSuccess((avg, min))
                        }
                        coordinator.setQuery(query)
                        healthStore.execute(query)
                    }
                }, onCancel: {
                    handle.cancel(healthStore: healthStore)
                })

                if let stats {
                    results[day] = (avgBPM: stats.0, minBPM: stats.1)
                }
            }

            if day == endBoundary { break }
            guard let advance = calendar.date(byAdding: .day, value: 1, to: day) else { break }
            day = advance
        }

        return results
    }

    public func fetchSamples(for sampleType: HKSampleType, startDate: Date, endDate: Date) async throws -> [HKSample] {
        guard HKHealthStore.isHealthDataAvailable() else {
            throw HealthKitServiceError.healthDataUnavailable
        }

        let healthStore = self.healthStore
        let handle = HealthKitQueryHandle<[HKSample]>()

        return try await withTaskCancellationHandler(operation: {
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[HKSample], Error>) in
                let coordinator = HealthKitQueryCoordinator<[HKSample]>(continuation: continuation)
                handle.set(coordinator)

                let predicate = HKQuery.predicateForSamples(withStart: startDate, end: endDate, options: [.strictStartDate])
                let sortDescriptor = NSSortDescriptor(key: HKSampleSortIdentifierStartDate, ascending: false)
                let query = HKSampleQuery(sampleType: sampleType,
                                          predicate: predicate,
                                          limit: HKObjectQueryNoLimit,
                                          sortDescriptors: [sortDescriptor]) { _, samples, error in
                    if let error {
                        coordinator.resumeFailure(error)
                    } else {
                        coordinator.resumeSuccess(samples ?? [])
                    }
                }

                coordinator.setQuery(query)
                healthStore.execute(query)
            }
        }, onCancel: {
            handle.cancel(healthStore: healthStore)
        })
    }


    /// Configures background delivery for all supported data types.
    public func enableBackgroundDelivery() async throws {
        try await enableBackgroundDelivery(for: HealthKitService.readSampleTypes)
    }

    /// Configures background delivery for a subset of data types.
    public func enableBackgroundDelivery(for types: Set<HKSampleType>) async throws {
        try await withThrowingTaskGroup(of: Void.self) { group in
            guard !types.isEmpty else { return }
            for type in types {
                group.addTask { [healthStore] in
                    try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
                        healthStore.enableBackgroundDelivery(for: type, frequency: .immediate) { success, error in
                            if let error {
                                continuation.resume(throwing: HealthKitServiceError.backgroundDeliveryFailed(type: type, underlying: error))
                            } else if success {
                                continuation.resume()
                            } else {
                                continuation.resume(throwing: HealthKitServiceError.backgroundDeliveryFailed(type: type, underlying: HealthKitServiceError.authorizationDenied))
                            }
                        }
                    }
                }
            }

            try await group.waitForAll()
        }
    }

    /// Starts an observer + anchored query pair for the provided sample type.
    @discardableResult
    public func observeSampleType(_ sampleType: HKSampleType,
                                  predicate: NSPredicate? = nil,
                                  updateHandler: @escaping AnchoredUpdateHandler) throws -> HealthKitObservationToken {
        let predicateBox = PredicateBox(value: predicate)

        let observer = HKObserverQuery(sampleType: sampleType, predicate: predicateBox.value) { [weak self] _, completionHandler, error in
            guard let self else { completionHandler(); return }

            if let error {
                updateHandler(.failure(error))
                completionHandler()
                return
            }

            let completionBox = CompletionBox(handler: completionHandler)
            self.executeAnchoredQuery(for: sampleType, predicateBox: predicateBox, updateHandler: updateHandler) {
                completionBox.call()
            }
        }

        healthStore.execute(observer)
        processingQueue.async { [weak self] in
            self?.activeObserverQueries[sampleType] = observer
        }

        let hasAnchor = anchorStore.anchor(for: sampleType.identifier) != nil
        if predicateBox.value != nil || hasAnchor {
            executeAnchoredQuery(for: sampleType, predicateBox: predicateBox, updateHandler: updateHandler, completion: nil)
        } else {
            Diagnostics.log(level: .info,
                            category: .healthkit,
                            name: "healthkit.observe.initialFetch.skipped",
                            fields: [
                                "type": .safeString(.metadata(sampleType.identifier)),
                                "reason": .safeString(.stage("no_anchor", allowed: ["no_anchor"]))
                            ])
        }

        return observer
    }

    /// Stops observation for a sample type and clears the persisted anchor.
    public func stopObserving(sampleType: HKSampleType, resetAnchor: Bool = false) {
        processingQueue.async { [weak self] in
            guard let self else { return }
            if let observer = self.activeObserverQueries.removeValue(forKey: sampleType) {
                self.healthStore.stop(observer)
            }
            if let anchored = self.activeAnchoredQueries.removeValue(forKey: sampleType) {
                self.healthStore.stop(anchored)
            }
            if resetAnchor {
                self.anchorStore.removeAnchor(for: sampleType.identifier)
            }
        }
    }

    /// Returns the current authorization status for a specific sample type.
    public func authorizationStatus(for sampleType: HKSampleType) -> HKAuthorizationStatus {
#if DEBUG
        if BuildFlags.uiTestSeamsCompiledIn,
           let override = HealthKitAuthorizationOverrides.shared.status(for: sampleType.identifier) {
            return override
        }
#endif
        return healthStore.authorizationStatus(for: sampleType)
    }

    private func executeAnchoredQuery(for sampleType: HKSampleType,
                                      predicateBox: PredicateBox,
                                      updateHandler: @escaping AnchoredUpdateHandler,
                                      completion: (@Sendable () -> Void)?) {
        processingQueue.async { [weak self] in
            guard let self else { completion?(); return }
            let currentAnchor = self.anchorStore.anchor(for: sampleType.identifier)
            var predicate = predicateBox.value
            if predicate == nil, currentAnchor == nil {
                let endDate = Date()
                let windowDays = self.initialAnchorWindowDays
                let startDate = self.calendar.date(byAdding: .day, value: -windowDays, to: endDate)
                    ?? endDate.addingTimeInterval(-Double(windowDays) * 86_400)
                predicate = HKQuery.predicateForSamples(withStart: startDate, end: endDate, options: [.strictStartDate])
                Diagnostics.log(level: .info,
                                category: .healthkit,
                                name: "healthkit.anchored.initialBounded",
                                fields: [
                                    "type": .safeString(.metadata(sampleType.identifier)),
                                    "window_days": .int(windowDays)
                                ])
            }
            let query = HKAnchoredObjectQuery(type: sampleType,
                                             predicate: predicate,
                                             anchor: currentAnchor,
                                             limit: HKObjectQueryNoLimit) { [weak self] _, samples, deletedObjects, newAnchor, error in
                defer { completion?() }

                guard let self else { return }

                if let error {
                    updateHandler(.failure(error))
                    return
                }

                guard let newAnchor else {
                    updateHandler(.failure(HealthKitServiceError.queryExecutionFailed(underlying: CocoaError(.coderValueNotFound))))
                    return
                }

                self.anchorStore.store(anchor: newAnchor, for: sampleType.identifier)
                let samples = samples ?? []
                let deleted = deletedObjects ?? []
                let result = AnchoredUpdate(samples: samples, deletedSamples: deleted, newAnchor: newAnchor)
                updateHandler(.success(result))
            }

            query.updateHandler = { [weak self] _, samples, deletedObjects, newAnchor, error in
                guard let self else { return }
                if let error {
                    updateHandler(.failure(error))
                    return
                }
                guard let newAnchor else { return }
                self.anchorStore.store(anchor: newAnchor, for: sampleType.identifier)
                let samples = samples ?? []
                let deleted = deletedObjects ?? []
                let result = AnchoredUpdate(samples: samples, deletedSamples: deleted, newAnchor: newAnchor)
                updateHandler(.success(result))
            }

            self.healthStore.execute(query)
            self.activeAnchoredQueries[sampleType] = query
        }
    }
}

public protocol HealthKitServicing: AnyObject, Sendable {
    var isHealthDataAvailable: Bool { get }
    func requestAuthorization() async throws
    func requestStatusForAuthorization(readTypes: Set<HKSampleType>) async -> HKAuthorizationRequestStatus?
    func probeReadAuthorization(for type: HKSampleType) async -> ReadAuthorizationProbeResult
    func probeReadAuthorization(for types: [HKSampleType]) async -> [HKSampleType: ReadAuthorizationProbeResult]
    func fetchDailyStepTotals(startDate: Date, endDate: Date) async throws -> [Date: Int]
    func fetchNocturnalHeartRateStats(startDate: Date, endDate: Date) async throws -> [Date: (avgBPM: Double, minBPM: Double?)]
    func fetchSamples(for sampleType: HKSampleType, startDate: Date, endDate: Date) async throws -> [HKSample]
    func enableBackgroundDelivery(for types: Set<HKSampleType>) async throws
    func enableBackgroundDelivery() async throws
    @discardableResult
    func observeSampleType(_ sampleType: HKSampleType,
                           predicate: NSPredicate?,
                           updateHandler: @escaping HealthKitService.AnchoredUpdateHandler) throws -> HealthKitObservationToken
    func stopObserving(sampleType: HKSampleType, resetAnchor: Bool)
    func authorizationStatus(for sampleType: HKSampleType) -> HKAuthorizationStatus
}

extension HealthKitService: HealthKitServicing {}

extension HealthKitService.AnchoredUpdate: @unchecked Sendable {}

private final class HealthKitQueryHandle<Result: Sendable>: @unchecked Sendable {
    private let lock = NSLock()
    private var coordinator: HealthKitQueryCoordinator<Result>?

    func set(_ coordinator: HealthKitQueryCoordinator<Result>) {
        lock.lock()
        self.coordinator = coordinator
        lock.unlock()
    }

    func cancel(healthStore: HKHealthStore) {
        lock.lock()
        let coordinator = coordinator
        lock.unlock()
        coordinator?.cancel(healthStore: healthStore)
    }
}

private final class HealthKitQueryCoordinator<Result: Sendable>: @unchecked Sendable {
    private let lock = NSLock()
    private var resumed = false
    private var query: HKQuery?
    private let continuation: CheckedContinuation<Result, Error>

    init(continuation: CheckedContinuation<Result, Error>) {
        self.continuation = continuation
    }

    func setQuery(_ query: HKQuery) {
        lock.lock()
        self.query = query
        lock.unlock()
    }

    func resumeSuccess(_ result: Result) {
        lock.lock()
        guard !resumed else { lock.unlock(); return }
        resumed = true
        lock.unlock()
        continuation.resume(returning: result)
    }

    func resumeFailure(_ error: Error) {
        lock.lock()
        guard !resumed else { lock.unlock(); return }
        resumed = true
        lock.unlock()
        continuation.resume(throwing: error)
    }

    func cancel(healthStore: HKHealthStore) {
        let query: HKQuery?
        lock.lock()
        query = self.query
        let shouldResume = !resumed
        if !resumed {
            resumed = true
        }
        lock.unlock()

        if let query {
            healthStore.stop(query)
        }
        if shouldResume {
            continuation.resume(throwing: CancellationError())
        }
    }
}

private struct CompletionBox: @unchecked Sendable {
    let handler: HKObserverQueryCompletionHandler
    func call() { handler() }
}

private struct PredicateBox: @unchecked Sendable {
    let value: NSPredicate?
}

private extension HealthKitService {
    func readProbeResult(for error: Error) -> ReadAuthorizationProbeResult {
        if let hkError = error as? HKError {
            return readProbeResult(for: hkError)
        }

        let nsError = error as NSError
        if nsError.domain == HKError.errorDomain,
           let code = HKError.Code(rawValue: nsError.code) {
            return readProbeResult(forHKCode: code)
        }

        return .error(domain: (error as NSError).domain, code: (error as NSError).code)
    }

    func readProbeResult(for hkError: HKError) -> ReadAuthorizationProbeResult {
        return readProbeResult(forHKCode: hkError.code)
    }

    func readProbeResult(forHKCode code: HKError.Code) -> ReadAuthorizationProbeResult {
        switch code {
        case .errorAuthorizationDenied, .errorRequiredAuthorizationDenied:
            return .denied
        case .errorAuthorizationNotDetermined:
            return .notDetermined
        case .errorDatabaseInaccessible:
            return .protectedDataUnavailable
        case .errorHealthDataUnavailable, .errorHealthDataRestricted:
            return .healthDataUnavailable
        case .errorNoData:
            return .authorized
#if compiler(>=6.0)
        case .errorNotPermissibleForGuestUserMode:
            return .healthDataUnavailable
#endif
        default:
            return .error(domain: HKError.errorDomain, code: code.rawValue)
        }
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Sources/PulsumServices/HealthKitService.swift -->

### Packages/PulsumServices/Sources/PulsumServices/KeychainService.swift
- bytes: 4665
- lines: 138
- sha256: d9b990e801c425fb38555ed2c78755a6b97ebb763770efc281babe0ddecfa7e5
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Sources/PulsumServices/KeychainService.swift -->
```swift
import Foundation
import Security
import PulsumTypes

public protocol APIKeyProviding: Sendable {
    func storeAPIKeyData(_ value: Data, identifier: String) throws
    func fetchAPIKeyData(for identifier: String) throws -> Data?
    func removeAPIKey(for identifier: String) throws
}

public protocol KeychainStoring: APIKeyProviding {
    func setSecret(_ value: Data, for key: String) throws
    func secret(for key: String) throws -> Data?
    func removeSecret(for key: String) throws
}

public extension KeychainStoring {
    func storeAPIKeyData(_ value: Data, identifier: String) throws {
        try setSecret(value, for: identifier)
    }

    func fetchAPIKeyData(for identifier: String) throws -> Data? {
        try secret(for: identifier)
    }

    func removeAPIKey(for identifier: String) throws {
        try removeSecret(for: identifier)
    }
}

public enum KeychainServiceError: LocalizedError {
    case unexpectedStatus(OSStatus)

    public var errorDescription: String? {
        switch self {
        case let .unexpectedStatus(status):
            if let message = SecCopyErrorMessageString(status, nil) as String? {
                return message
            }
            return "Unexpected keychain status: \(status)"
        }
    }
}

/// Minimal wrapper around iOS Keychain for Pulsum secrets.
public final class KeychainService: KeychainStoring {
    public static let shared = KeychainService()

    private let accessGroup: String?
    private let service = "ai.pulsum.app"

    private var useFallbackStore: Bool {
        AppRuntimeConfig.disableKeychain
    }

    public init(accessGroup: String? = nil) {
        self.accessGroup = accessGroup
    }

    public func setSecret(_ value: Data, for key: String) throws {
        if useFallbackStore {
            Self.storeFallback(value, for: key)
            return
        }
        var query: [String: Any] = baseQuery(for: key)
        query[kSecValueData as String] = value
        query[kSecAttrAccessible as String] = kSecAttrAccessibleWhenUnlockedThisDeviceOnly

        let status = SecItemAdd(query as CFDictionary, nil)
        if status == errSecDuplicateItem {
            try updateSecret(value, for: key)
            return
        }
        guard status == errSecSuccess else { throw KeychainServiceError.unexpectedStatus(status) }
    }

    public func secret(for key: String) throws -> Data? {
        if useFallbackStore {
            return Self.fetchFallback(for: key)
        }
        var query = baseQuery(for: key)
        query[kSecReturnData as String] = true
        query[kSecMatchLimit as String] = kSecMatchLimitOne

        var item: CFTypeRef?
        let status = SecItemCopyMatching(query as CFDictionary, &item)
        if status == errSecItemNotFound { return nil }
        guard status == errSecSuccess else { throw KeychainServiceError.unexpectedStatus(status) }
        return item as? Data
    }

    public func removeSecret(for key: String) throws {
        if useFallbackStore {
            Self.removeFallback(for: key)
            return
        }
        let status = SecItemDelete(baseQuery(for: key) as CFDictionary)
        guard status == errSecSuccess || status == errSecItemNotFound else {
            throw KeychainServiceError.unexpectedStatus(status)
        }
    }

    private func updateSecret(_ value: Data, for key: String) throws {
        let status = SecItemUpdate(baseQuery(for: key) as CFDictionary,
                                   [kSecValueData as String: value] as CFDictionary)
        guard status == errSecSuccess else { throw KeychainServiceError.unexpectedStatus(status) }
    }

    private func baseQuery(for key: String) -> [String: Any] {
        var query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: key
        ]
        if let accessGroup {
            query[kSecAttrAccessGroup as String] = accessGroup
        }
        return query
    }

    private static func storeFallback(_ value: Data, for key: String) {
        let defaults = AppRuntimeConfig.uiTestDefaults
        defaults.set(value, forKey: key)
        AppRuntimeConfig.synchronizeUITestDefaults()
    }

    private static func fetchFallback(for key: String) -> Data? {
        AppRuntimeConfig.uiTestDefaults.data(forKey: key)
    }

    private static func removeFallback(for key: String) {
        let defaults = AppRuntimeConfig.uiTestDefaults
        defaults.removeObject(forKey: key)
        AppRuntimeConfig.synchronizeUITestDefaults()
    }
}

extension KeychainService: @unchecked Sendable {}
```
<!-- END_FILE: Packages/PulsumServices/Sources/PulsumServices/KeychainService.swift -->

### Packages/PulsumServices/Sources/PulsumServices/LLMGateway.swift
- bytes: 37211
- lines: 916
- sha256: 24d531ac62571337c779e28e582387c8081fedb4fd3f26b09a5917e118a9790d
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Sources/PulsumServices/LLMGateway.swift -->
```swift
import Foundation
import os.log
import PulsumData
import PulsumML
import PulsumTypes

/// Candidate micro-moment snippet for context (privacy-safe; no PHI)
public struct CandidateMoment: Codable, Sendable, Equatable {
    public let id: String
    public let title: String
    public let shortDescription: String
    public let detail: String?
    public let evidenceBadge: String?

    public init(id: String,
                title: String,
                shortDescription: String,
                detail: String?,
                evidenceBadge: String?) {
        self.id = id
        self.title = title
        self.shortDescription = shortDescription
        self.detail = detail
        self.evidenceBadge = evidenceBadge
    }
}

/// Convenience wrapper for app-internal payload handled downstream by UI & agents
public struct CoachReplyPayload: Sendable {
    public let coachReply: String
    public let nextAction: String?

    public init(coachReply: String, nextAction: String? = nil) {
        self.coachReply = coachReply
        self.nextAction = nextAction
    }
}

public struct CoachPhrasing: Codable, Sendable {
    public let coachReply: String
    public let isOnTopic: Bool
    public let groundingScore: Double
    public let intentTopic: String
    public let refusalReason: String?
    public let nextAction: String?

    enum CodingKeys: String, CodingKey {
        case coachReply
        case isOnTopic
        case groundingScore
        case intentTopic
        case refusalReason
        case nextAction
    }

    public init(coachReply: String,
                isOnTopic: Bool,
                groundingScore: Double,
                intentTopic: String,
                refusalReason: String? = nil,
                nextAction: String? = nil) {
        self.coachReply = coachReply
        self.isOnTopic = isOnTopic
        self.groundingScore = groundingScore
        self.intentTopic = intentTopic
        self.refusalReason = refusalReason
        self.nextAction = nextAction
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        coachReply = try container.decode(String.self, forKey: .coachReply)
        isOnTopic = try container.decode(Bool.self, forKey: .isOnTopic)
        groundingScore = try container.decode(Double.self, forKey: .groundingScore)
        intentTopic = try container.decode(String.self, forKey: .intentTopic)

        let refusal = (try? container.decode(String.self, forKey: .refusalReason)) ?? ""
        let next = (try? container.decode(String.self, forKey: .nextAction)) ?? ""

        let trimmedRefusal = refusal.trimmingCharacters(in: .whitespacesAndNewlines)
        let trimmedNext = next.trimmingCharacters(in: .whitespacesAndNewlines)

        refusalReason = trimmedRefusal.isEmpty ? nil : trimmedRefusal
        nextAction = trimmedNext.isEmpty ? nil : trimmedNext
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(coachReply, forKey: .coachReply)
        try container.encode(isOnTopic, forKey: .isOnTopic)
        try container.encode(groundingScore, forKey: .groundingScore)
        try container.encode(intentTopic, forKey: .intentTopic)
        try container.encode(refusalReason ?? "", forKey: .refusalReason)
        try container.encode(nextAction ?? "", forKey: .nextAction)
    }
}

public struct CoachLLMContext: Codable, Sendable {
    public let userToneHints: String
    public let topSignal: String
    public let topMomentId: String?
    public let rationale: String
    public let zScoreSummary: String
    public let candidateMoments: [CandidateMoment]

    public init(userToneHints: String,
                topSignal: String,
                topMomentId: String?,
                rationale: String,
                zScoreSummary: String,
                candidateMoments: [CandidateMoment] = []) {
        self.userToneHints = userToneHints
        self.topSignal = topSignal
        self.topMomentId = topMomentId
        self.rationale = rationale
        self.zScoreSummary = zScoreSummary
        self.candidateMoments = candidateMoments
    }
}

/// Encodes minimized cloud payloads and enforces schema guardrails.
struct MinimizedCloudRequest: Codable, Sendable, Equatable {
    struct MomentContext: Codable, Sendable, Equatable {
        let id: String
        let title: String
        let short: String
        let detail: String?
        let evidenceBadge: String?
    }

    enum GuardError: Error {
        case encodingFailed
        case unexpectedRootFields(Set<String>)
        case unexpectedMomentFields(Set<String>)
        case forbiddenField(String)
    }

    private static let allowedRootKeys: Set<String> = [
        "userToneHints",
        "topSignal",
        "topMomentId",
        "rationale",
        "zScoreSummary",
        "candidateMoments"
    ]
    private static let allowedMomentKeys: Set<String> = [
        "id",
        "title",
        "short",
        "detail",
        "evidenceBadge"
    ]

    let userToneHints: String
    let topSignal: String
    let topMomentId: String?
    let rationale: String
    let zScoreSummary: String
    let candidateMoments: [MomentContext]

    static func build(from context: CoachLLMContext,
                      candidateMoments: [CandidateMoment]) -> MinimizedCloudRequest {
        let limitedMoments = Array(candidateMoments.prefix(3))
        let sanitizedMoments = limitedMoments.map { moment -> MomentContext in
            let short = sanitize(moment.shortDescription, limit: 180)
            let detail = sanitize(moment.detail ?? "", limit: 200)
            let sanitizedDetail = detail.isEmpty ? nil : detail
            let badge = sanitize(moment.evidenceBadge ?? "", limit: 32)
            return MomentContext(id: sanitize(moment.id, limit: 80),
                                 title: sanitize(moment.title, limit: 120),
                                 short: short,
                                 detail: sanitizedDetail,
                                 evidenceBadge: badge.isEmpty ? nil : badge)
        }

        return MinimizedCloudRequest(
            userToneHints: sanitize(context.userToneHints, limit: 180),
            topSignal: sanitize(context.topSignal, limit: 120),
            topMomentId: context.topMomentId.map { sanitize($0, limit: 80) },
            rationale: sanitize(context.rationale, limit: 180),
            zScoreSummary: sanitize(context.zScoreSummary, limit: 220),
            candidateMoments: sanitizedMoments
        )
    }

    func encodedJSONString() throws -> String {
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.sortedKeys]
        let data = try encoder.encode(self)
        try Self.guardFields(in: data)
        guard let json = String(data: data, encoding: .utf8) else {
            throw GuardError.encodingFailed
        }
        return json
    }

    private static func guardFields(in data: Data) throws {
        let object = try JSONSerialization.jsonObject(with: data)
        guard let root = object as? [String: Any] else {
            throw GuardError.encodingFailed
        }
        let rootKeys = Set(root.keys)
        if !rootKeys.isSubset(of: allowedRootKeys) {
            throw GuardError.unexpectedRootFields(rootKeys.subtracting(allowedRootKeys))
        }
        if let moments = root["candidateMoments"] as? [[String: Any]] {
            for moment in moments {
                let keys = Set(moment.keys)
                if !keys.isSubset(of: allowedMomentKeys) {
                    throw GuardError.unexpectedMomentFields(keys.subtracting(allowedMomentKeys))
                }
            }
        }
        guard let jsonString = String(data: data, encoding: .utf8) else {
            throw GuardError.encodingFailed
        }
        let lower = jsonString.lowercased()
        for forbidden in ["\"transcript\"", "\"heartrate\"", "\"samples\""] {
            if lower.contains(forbidden) {
                throw GuardError.forbiddenField(forbidden)
            }
        }
    }

    private static func sanitize(_ text: String, limit: Int) -> String {
        if text.isEmpty { return "" }
        let collapsed = text
            .components(separatedBy: .whitespacesAndNewlines)
            .filter { !$0.isEmpty }
            .joined(separator: " ")
        let trimmed = collapsed.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmed.count <= limit { return trimmed }
        return String(trimmed.prefix(limit))
    }
}

public protocol CloudLLMClient {
    func generateResponse(context: CoachLLMContext,
                          intentTopic: String?,
                          candidateMoments: [CandidateMoment],
                          apiKey: String,
                          keySource: String) async throws -> CoachPhrasing
}

public protocol OnDeviceCoachGenerator {
    func generate(context: CoachLLMContext) async -> CoachReplyPayload
}

public enum LLMGatewayError: LocalizedError, Equatable {
    case apiKeyMissing
    case cloudGenerationFailed(String)

    public static func == (lhs: LLMGatewayError, rhs: LLMGatewayError) -> Bool {
        switch (lhs, rhs) {
        case (.apiKeyMissing, .apiKeyMissing):
            return true
        case let (.cloudGenerationFailed(l), .cloudGenerationFailed(r)):
            return l == r
        default:
            return false
        }
    }

    public var errorDescription: String? {
        switch self {
        case .apiKeyMissing:
            return "LLM API key is missing."
        case .cloudGenerationFailed(let detail):
            return "Cloud phrasing failed: \(detail)"
        }
    }
}

/// Manages consent-aware phrasing requests.
private let validationLogger = Logger(subsystem: "ai.pulsum", category: "LLMGateway.Validation")

public final class LLMGateway {
    private static let apiKeyIdentifier = "openai.api.key"
    private static let environmentVariableName = "PULSUM_COACH_API_KEY"

    private static func environmentAPIKey() -> String? {
        guard let raw = ProcessInfo.processInfo.environment[environmentVariableName]?.trimmedNonEmpty else {
            return nil
        }
        return raw
    }

    private let apiKeyStore: APIKeyProviding
    private let cloudClient: CloudLLMClient
    private let localGenerator: OnDeviceCoachGenerator
    private let session: URLSession
    private let usesUITestStub: Bool

    private var inMemoryAPIKey: String?

    private let logger = Logger(subsystem: "ai.pulsum", category: "LLMGateway")

    public init(keychain: APIKeyProviding = KeychainService(),
                cloudClient: CloudLLMClient? = nil,
                localGenerator: OnDeviceCoachGenerator? = nil,
                session: URLSession = .shared) {
        self.apiKeyStore = keychain
        let stubEnabled = Self.isUITestStubEnabled()
        self.usesUITestStub = stubEnabled

        let resolvedCloudClient: CloudLLMClient
#if DEBUG
        if BuildFlags.uiTestSeamsCompiledIn && stubEnabled {
            resolvedCloudClient = UITestMockCloudClient()
        } else {
            resolvedCloudClient = cloudClient ?? GPT5Client(session: session)
        }
#else
        resolvedCloudClient = cloudClient ?? GPT5Client(session: session)
#endif
        self.cloudClient = resolvedCloudClient

        self.localGenerator = localGenerator ?? createDefaultLocalGenerator()
        self.session = session
    }

    public func setAPIKey(_ key: String) throws {
        guard let trimmed = key.trimmedNonEmpty,
              let data = trimmed.data(using: .utf8) else {
            throw LLMGatewayError.apiKeyMissing
        }
        try apiKeyStore.storeAPIKeyData(data, identifier: Self.apiKeyIdentifier)
        inMemoryAPIKey = trimmed
        logger.debug("LLM API key saved to keychain (length=\(trimmed.count, privacy: .private)).")
    }

    public func testAPIConnection() async throws -> Bool {
        if usesUITestStub {
            logger.debug("UITest stub enabled: short-circuiting GPT ping.")
            return true
        }
        let body = Self.makePingRequestBody()
        if let text = body["text"] as? [String: Any],
           let format = text["format"] as? [String: Any] {
            let hasName = (format["name"] as? String) == "CoachPhrasing"
            let hasSchema = format["schema"] as? [String: Any] != nil
            let tokenLogValue = body["max_output_tokens"] as? Int ?? -1
            logger.debug("Responses API: max_output_tokens=\(tokenLogValue, privacy: .public) schemaNamePresent=\(hasName) schemaPresent=\(hasSchema)")
        }

        guard Self.validatePingPayload(body) else {
            logger.error("Ping payload failed validation guard.")
            return false
        }

        var request = URLRequest(url: URL(string: "https://api.openai.com/v1/responses")!)
        request.httpMethod = "POST"
        request.httpBody = try JSONSerialization.data(withJSONObject: body)

        let apiKey = try resolveAPIKey()
        let source = keySourceDescriptor()
        logger.debug("LLM using API key from \(source, privacy: .public).")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            logger.error("Ping failed: missing HTTP response")
            return false
        }

        guard (200...299).contains(httpResponse.statusCode) else {
            let code = httpResponse.statusCode
            let errorText = String(data: data, encoding: .utf8) ?? "HTTP \(code)"
            logger.error("Ping failed: status=\(code) body=\(errorText.prefix(200), privacy: .public)")
            return false
        }

        return true
    }

    public func generateCoachResponse(context: CoachLLMContext,
                                      intentTopic: String?,
                                      candidateMoments: [CandidateMoment],
                                      consentGranted: Bool,
                                      groundingFloor: Double = 0.50) async -> CoachReplyPayload {
        if usesUITestStub {
            return CoachReplyPayload(
                coachReply: "Stub response: Pulsum coach stub reply for UI testing.",
                nextAction: "Take a mindful breathing break"
            )
        }
        let sanitizedContext = CoachLLMContext(userToneHints: PIIRedactor.redact(context.userToneHints),
                                               topSignal: context.topSignal,
                                               topMomentId: context.topMomentId,
                                               rationale: PIIRedactor.redact(context.rationale),
                                               zScoreSummary: context.zScoreSummary,
                                               candidateMoments: context.candidateMoments)
        logger.debug("Generating coach response. Consent: \(consentGranted, privacy: .public), tone_chars: \(sanitizedContext.userToneHints.count, privacy: .public), rationale_chars: \(sanitizedContext.rationale.count, privacy: .public), score_chars: \(sanitizedContext.zScoreSummary.count, privacy: .public), topSignal: \(sanitizedContext.topSignal, privacy: .public), candidates: \(candidateMoments.count, privacy: .public)")
        if consentGranted {
            do {
                let apiKey = try resolveAPIKey()
                let keySource = keySourceDescriptor()
                logger.info("Attempting cloud phrasing via GPT client (key=\(keySource, privacy: .public)).")
                let phrasing = try await cloudClient.generateResponse(context: sanitizedContext,
                                                                      intentTopic: intentTopic,
                                                                      candidateMoments: candidateMoments,
                                                                      apiKey: apiKey,
                                                                      keySource: keySource)
                if phrasing.isOnTopic, phrasing.groundingScore >= groundingFloor {
                    let cleaned = CoachReplyPayload(
                        coachReply: sanitize(response: phrasing.coachReply),
                        nextAction: phrasing.nextAction
                    )
                    logger.debug("Cloud response received. Grounding: \(String(format: "%.2f", phrasing.groundingScore), privacy: .public), hasNextAction: \(cleaned.nextAction != nil, privacy: .public)")
                    return cleaned
                }
                logger.warning("Wall-2 grounding too low (score=\(String(format: "%.2f", phrasing.groundingScore)) floor=\(String(format: "%.2f", groundingFloor))). Falling back on-device.")
                notifyCloudError("Grounding score \(String(format: "%.2f", phrasing.groundingScore)) below floor \(String(format: "%.2f", groundingFloor))")
            } catch {
                // WALL 2 failure: schema validation failed or grounding too low
                // Fail-closed: fallback to on-device Foundation Models
                let nsError = error as NSError
                logger.error("Cloud phrasing failed (schema validation/grounding). domain=\(nsError.domain, privacy: .public) code=\(nsError.code, privacy: .public). Falling back to on-device generator.")
                notifyCloudError(error.localizedDescription)
            }
        }
        let fallback = await localGenerator.generate(context: sanitizedContext)
        let cleanedFallback = CoachReplyPayload(
            coachReply: sanitize(response: fallback.coachReply),
            nextAction: fallback.nextAction
        )
        logger.notice("Using on-device phrasing. Length: \(cleanedFallback.coachReply.count, privacy: .public)")
        return cleanedFallback
    }

    private func notifyCloudError(_ message: String) {
#if DEBUG
        NotificationCenter.default.post(name: .pulsumChatCloudError,
                                        object: nil,
                                        userInfo: ["message": message])
#endif
    }

    private func keySourceDescriptor() -> String {
        if usesUITestStub {
            return "uitest-stub"
        }
        if inMemoryAPIKey?.trimmedNonEmpty != nil {
            return "memory"
        }
        if ((try? apiKeyStore.fetchAPIKeyData(for: Self.apiKeyIdentifier)) ?? nil) != nil {
            return "keychain"
        }
        if Self.environmentAPIKey() != nil {
            return "env"
        }
        return "missing"
    }

    public func currentAPIKey() -> String? {
        if usesUITestStub {
            return "UITEST_STUB_KEY"
        }
        if let m = inMemoryAPIKey?.trimmedNonEmpty { return m }
        if let data = try? apiKeyStore.fetchAPIKeyData(for: Self.apiKeyIdentifier),
           let k = String(data: data, encoding: .utf8)?.trimmedNonEmpty {
            return k
        }
        if let env = Self.environmentAPIKey() {
            return env
        }
        return nil
    }

    private func resolveAPIKey() throws -> String {
        guard let key = currentAPIKey() else {
            throw LLMGatewayError.apiKeyMissing
        }
        return key
    }

    private func sanitize(response: String) -> String {
        // Ensure output is ≤2 sentences and neutral tone.
        let sentences = response.split(whereSeparator: { $0 == "." || $0 == "!" || $0 == "?" })
        let trimmed = sentences.prefix(2).map { sentence -> String in
            let cleaned = sentence.trimmingCharacters(in: .whitespacesAndNewlines)
            return cleaned.prefix(280).trimmingCharacters(in: .whitespacesAndNewlines)
        }
        return trimmed.joined(separator: ". ").appending(trimmed.isEmpty ? "" : ".")
    }

    func debugResolveAPIKey() throws -> String {
        try resolveAPIKey()
    }

    func debugOverrideInMemoryKey(_ key: String?) {
        inMemoryAPIKey = key?.trimmedNonEmpty
    }

    func debugClearPersistedAPIKey() throws {
        try apiKeyStore.removeAPIKey(for: Self.apiKeyIdentifier)
    }

    // Gate-1b: UITest seams are compiled out of Release builds.
    // In Release, env flags are ignored so remote stubs never activate.
    private static func isUITestStubEnabled() -> Bool {
#if DEBUG
        return BuildFlags.uiTestSeamsCompiledIn && AppRuntimeConfig.useStubLLM
#else
        return false
#endif
    }
}

fileprivate func validateChatPayload(body: [String: Any],
                                     context: CoachLLMContext,
                                     intentTopic: String?,
                                     candidateMoments: [CandidateMoment],
                                     maxTokens: Int) -> Bool {
    guard
        let text = body["text"] as? [String: Any],
        let format = text["format"] as? [String: Any],
        (format["type"] as? String) == "json_schema"
    else {
        return false
    }

    let schemaNamePresent = (format["name"] as? String) == "CoachPhrasing"
    guard schemaNamePresent,
          let schema = format["schema"] as? [String: Any] else {
        return false
    }

    validationLogger.debug("validateChatPayload schemaNamePresent=true schemaPresent=true")

    guard schema["type"] as? String == "object",
          (schema["additionalProperties"] as? Bool) == false,
          let properties = schema["properties"] as? [String: Any],
          let required = schema["required"] as? [String] else {
        return false
    }

    guard Set(required) == Set(properties.keys) else {
        return false
    }

    if !(128...1024).contains(maxTokens) { return false }

    guard let input = body["input"] as? [[String: Any]], input.count == 2,
          (input.first? ["role"] as? String) == "system",
          (input.last? ["role"] as? String) == "user"
    else { return false }

    guard let input = body["input"] as? [[String: Any]],
          input.count == 2,
          (input.first?["role"] as? String) == "system",
          (input.last?["role"] as? String) == "user",
          let userContent = input.last?["content"] as? String else {
        return false
    }

    do {
        let expected = MinimizedCloudRequest.build(from: context, candidateMoments: candidateMoments)
        let expectedJSON = try expected.encodedJSONString()
        if expectedJSON != userContent {
            return false
        }
    } catch {
        return false
    }

    return true
}

extension LLMGateway {
    static func validatePingPayload(_ body: [String: Any]) -> Bool {
    guard
        let text = body["text"] as? [String: Any],
        let format = text["format"] as? [String: Any],
        (format["type"] as? String) == "json_schema"
    else {
        return false
    }

    let schemaNamePresent = (format["name"] as? String) == "CoachPhrasing"
    guard schemaNamePresent,
          let schema = format["schema"] as? [String: Any] else {
        return false
    }

    validationLogger.debug("validatePingPayload schemaNamePresent=true schemaPresent=true")

    guard schema["type"] as? String == "object",
          (schema["additionalProperties"] as? Bool) == false,
          let properties = schema["properties"] as? [String: Any],
          let required = schema["required"] as? [String] else {
        return false
    }

    guard Set(required) == Set(properties.keys) else {
        return false
    }

    guard body["max_output_tokens"] as? Int == 32 else { return false }

    guard let input = body["input"] as? [[String: Any]],
          input.count == 1,
          (input.first? ["role"] as? String) == "user",
          let content = (input.first? ["content"] as? String)?.lowercased(),
          content == "ping" else {
        return false
    }

    return true
    }
}

// MARK: - Cloud Client

public final class GPT5Client: CloudLLMClient {
    private let endpoint = URL(string: "https://api.openai.com/v1/responses")!
    private let logger = Logger(subsystem: "ai.pulsum", category: "LLMGateway.Cloud")
    private let session: URLSession

    public init(session: URLSession = .shared) {
        self.session = session
    }

    public func generateResponse(context: CoachLLMContext,
                                 intentTopic: String?,
                                 candidateMoments: [CandidateMoment],
                                 apiKey: String,
                                 keySource: String) async throws -> CoachPhrasing {
        logger.debug("Sending cloud chat request with JSON schema. Top signal: \(context.topSignal, privacy: .public)")

        var requestedTokens: Int? = nil
        var attempt = 0
        let limitedMoments = Array(candidateMoments.prefix(2))

        while attempt < 2 {
            var request = URLRequest(url: endpoint)
            request.httpMethod = "POST"

            let body = try LLMGateway.makeChatRequestBody(context: context,
                                                          candidateMoments: limitedMoments,
                                                          maxOutputTokens: requestedTokens ?? 512)

            if let text = body["text"] as? [String: Any],
               let format = text["format"] as? [String: Any] {
                let hasName = (format["name"] as? String) == "CoachPhrasing"
                let hasSchema = format["schema"] as? [String: Any] != nil
                let tokenLogValue = body["max_output_tokens"] as? Int ?? -1
                logger.debug("Responses API: max_output_tokens=\(tokenLogValue, privacy: .public) schemaNamePresent=\(hasName) schemaPresent=\(hasSchema)")
            }

            let maxTokens = body["max_output_tokens"] as? Int ?? LLMGateway.clampTokens(512)
            guard validateChatPayload(body: body,
                                      context: context,
                                      intentTopic: intentTopic,
                                      candidateMoments: limitedMoments,
                                      maxTokens: maxTokens) else {
                throw LLMGatewayError.cloudGenerationFailed("Invalid payload structure")
            }

            request.httpBody = try JSONSerialization.data(withJSONObject: body)

            logger.debug("LLM using API key from \(keySource, privacy: .public).")
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")

            let (data, response) = try await session.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse else {
                throw LLMGatewayError.cloudGenerationFailed("Invalid HTTP response")
            }

            if (200...299).contains(httpResponse.statusCode) {
                do {
                    let phrasing = try parseAndValidateStructuredResponse(data: data)
                    logger.debug("Cloud chat succeeded. Grounding: \(String(format: "%.2f", phrasing.groundingScore), privacy: .public), isOnTopic: \(phrasing.isOnTopic, privacy: .public), hasNextAction: \(phrasing.nextAction != nil, privacy: .public)")
                    return phrasing
                } catch {
                    // If parsing fails due to incomplete response, retry with more tokens
                    let errorMsg = error.localizedDescription
                    if attempt == 0, errorMsg.contains("incomplete") {
                        requestedTokens = 1024
                        attempt += 1
                        logger.info("Retrying with max tokens due to incomplete response")
                        continue
                    }
                    throw error
                }
            }

            let statusCode = httpResponse.statusCode
            let errorMsg = String(data: data, encoding: .utf8) ?? "HTTP \(statusCode)"

            if attempt == 0, statusCode == 400, errorMsg.contains("max_output_tokens") {
                requestedTokens = 128
                attempt += 1
                continue
            }

            logger.error("Cloud chat failed. status=\(statusCode), message=\(errorMsg.prefix(256), privacy: .public)")
            throw LLMGatewayError.cloudGenerationFailed(errorMsg)
        }

        throw LLMGatewayError.cloudGenerationFailed("Exceeded retry attempts")
    }

    private func parseAndValidateStructuredResponse(data: Data) throws -> CoachPhrasing {
        guard let root = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            let errorMsg = String(data: data, encoding: .utf8) ?? "<non-utf8>"
            logger.error("Failed to parse GPT response: \(errorMsg.prefix(280), privacy: .public)")
            throw LLMGatewayError.cloudGenerationFailed("Invalid JSON structure")
        }

        // Check for incomplete response (token limit exceeded)
        if let status = root["status"] as? String, status == "incomplete",
           let details = root["incomplete_details"] as? [String: Any],
           let reason = details["reason"] as? String {
            logger.warning("GPT response incomplete: \(reason, privacy: .public)")
            throw LLMGatewayError.cloudGenerationFailed("Response incomplete: \(reason)")
        }

        func extractText(from node: Any) -> String? {
            guard let object = node as? [String: Any] else { return nil }
            if let content = object["content"] as? [[String: Any]] {
                for part in content {
                    if let text = part["text"] as? String { return text }
                }
            }
            return nil
        }

        var textPayload: String?

        if let outputArray = root["output"] as? [[String: Any]] {
            for item in outputArray {
                if let text = extractText(from: item) {
                    textPayload = text
                    break
                }
            }
        } else if let outputObject = root["output"] as? [String: Any] {
            textPayload = extractText(from: outputObject)
        }

        if textPayload == nil,
           let choices = root["choices"] as? [[String: Any]],
           let message = choices.first? ["message"] as? [String: Any],
           let text = message["content"] as? String {
            textPayload = text
        }

        // Optional legacy parsed fallback (for older responses/tests)
        if textPayload == nil {
            if let parsed = (root["output"] as? [String: Any])?["parsed"] ?? (root["output"] as? [[String: Any]])?.first? ["parsed"] {
                if let parsedData = try? JSONSerialization.data(withJSONObject: parsed),
                   let parsedString = String(data: parsedData, encoding: .utf8) {
                    textPayload = parsedString
                }
            }
        }

        guard let jsonString = textPayload,
              let jsonData = jsonString.data(using: .utf8) else {
            let snippet = String(data: data, encoding: .utf8) ?? "<non-utf8>"
            logger.error("Failed to locate structured content in GPT response (snippet: \(snippet.prefix(280)), privacy: .public)")
            throw LLMGatewayError.cloudGenerationFailed("Missing structured output")
        }

        let phrasing: CoachPhrasing
        do {
            phrasing = try JSONDecoder().decode(CoachPhrasing.self, from: jsonData)
        } catch {
            let nsError = error as NSError
            logger.error("Failed to decode CoachPhrasing schema. domain=\(nsError.domain, privacy: .public) code=\(nsError.code, privacy: .public)")
            throw LLMGatewayError.cloudGenerationFailed("Schema validation failed: \(nsError.domain)#\(nsError.code)")
        }

        guard phrasing.isOnTopic else {
            let refusal = phrasing.refusalReason ?? "none"
            logger.notice("GPT marked response as off-topic. Refusal: \(refusal, privacy: .public)")
            throw LLMGatewayError.cloudGenerationFailed("Response marked as off-topic by model")
        }

        return phrasing
    }
}

#if DEBUG
private final class UITestMockCloudClient: CloudLLMClient {
    private let logger = Logger(subsystem: "ai.pulsum", category: "LLMGateway.UITests")

    func generateResponse(context: CoachLLMContext,
                          intentTopic: String?,
                          candidateMoments: [CandidateMoment],
                          apiKey: String,
                          keySource: String) async throws -> CoachPhrasing {
        logger.debug("UITest stub invoked. keySource=\(keySource, privacy: .public)")
        let reply = "Stub response: focus on \(context.topSignal.lowercased()). Three steady breaths and a quick stretch keep momentum."
        return CoachPhrasing(
            coachReply: reply,
            isOnTopic: true,
            groundingScore: 0.99,
            intentTopic: intentTopic ?? "general",
            refusalReason: nil,
            nextAction: "Take a mindful breathing break"
        )
    }
}
#endif

// MARK: - Generator Factory

private func createDefaultLocalGenerator() -> OnDeviceCoachGenerator {
    if #available(iOS 26.0, *) {
        return FoundationModelsCoachGenerator()
    } else {
        return LegacyCoachGenerator()
    }
}

// MARK: - Legacy fallback generator (pre-iOS 26 only)

public final class LegacyCoachGenerator: OnDeviceCoachGenerator {
    private let logger = Logger(subsystem: "ai.pulsum", category: "LLMGateway.Legacy")

    public init() {}

    public func generate(context: CoachLLMContext) async -> CoachReplyPayload {
        logger.warning("Legacy generator called on pre-iOS 26 device. Foundation Models unavailable.")
        // Honest failure - no rule-based coaching
        return CoachReplyPayload(
            coachReply: "Personalized coaching requires iOS 26 or cloud connection. Please update your device or check your internet connection.",
            nextAction: nil
        )
    }
}

extension LLMGateway {
    static func coachFormat() -> [String: Any] {
        CoachPhrasingSchema.responsesFormat()
    }

    static func makeChatRequestBody(context: CoachLLMContext,
                                    candidateMoments: [CandidateMoment],
                                    maxOutputTokens: Int) throws -> [String: Any] {
        let minimized = MinimizedCloudRequest.build(from: context, candidateMoments: candidateMoments)
        let userPayload = try minimized.encodedJSONString()

        let systemMessage =
"""
You are Pulsum, a supportive wellness coach. You MUST return ONLY JSON that matches the CoachPhrasing schema provided via text.format (no prose, no markdown). The user input is a JSON blob with keys: userToneHints, topSignal, topMomentId, rationale, zScoreSummary, candidateMoments[]. Each candidate includes id, title, short, detail, and evidenceBadge. Use ONLY that minimized context (no assumptions, no external data).

Style for coachReply:
- 1–2 short sentences.
- Warm, actionable, specific to the user's top signal and context.
- Avoid disclaimers and generic platitudes.

Field rules:
- isOnTopic: true if the message touches sleep, stress, energy, mood, movement, or nutrition; false otherwise.
- refusalReason: "" when isOnTopic is true; otherwise a short code like "off_topic_smalltalk".
- groundingScore: number 0.0–1.0; estimate confidence from provided z-scores (higher confidence → closer to 1.0). Round to two decimals.
- intentTopic: one of ["sleep","stress","energy","mood","movement","nutrition","goals"] based on the input.
- nextAction: one concrete step the user can do in < 8 words, e.g., "Dim lights 30 min before bed".

Keep JSON compact. Do not echo the schema or input.
"""

        let body: [String: Any] = [
            "model": "gpt-5",
            "input": [
                ["role": "system",
                 "content": systemMessage],
                ["role": "user",
                 "content": userPayload]
            ],
            "max_output_tokens": clampTokens(maxOutputTokens),
            "text": [
                "verbosity": "low",
                "format": coachFormat()
            ]
        ]

        return body
    }

    static func makePingRequestBody() -> [String: Any] {
        return [
            "model": "gpt-5",
            "input": [
                ["role": "user", "content": "ping"]
            ],
            "max_output_tokens": 32,
            "text": [
                "verbosity": "low",
                "format": coachFormat()
            ]
        ]
    }

    fileprivate static func clampTokens(_ requested: Int) -> Int {
        let value = requested
        let minTokens = 128
        let maxTokens = 1024
        return max(minTokens, min(maxTokens, value))
    }
}

extension LLMGateway: @unchecked Sendable {}

// Small helper
private extension String {
    var trimmedNonEmpty: String? {
        let t = trimmingCharacters(in: .whitespacesAndNewlines)
        return t.isEmpty ? nil : t
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Sources/PulsumServices/LLMGateway.swift -->

### Packages/PulsumServices/Sources/PulsumServices/Placeholder.swift
- bytes: 543
- lines: 18
- sha256: 8939f52054e950b10a8b8936c3b7bd00d9da5254bea740a1aa0a04e347ea10b8
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Sources/PulsumServices/Placeholder.swift -->
```swift
import Foundation
import PulsumData
import PulsumML

public enum PulsumServices {
    private static let healthKitInstance = HealthKitService()

    public static var healthKit: HealthKitService { healthKitInstance }
    public static var keychain: KeychainService { KeychainService.shared }

    public static func storageMetadata() -> (storeURL: URL, anchorsDirectory: URL) {
        (PulsumData.sqliteStoreURL, PulsumData.healthAnchorsDirectory)
    }

    public static func embeddingVersion() -> String {
        PulsumML.version
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Sources/PulsumServices/Placeholder.swift -->

### Packages/PulsumServices/Sources/PulsumServices/SpeechService.swift
- bytes: 20789
- lines: 562
- sha256: 0062e11bc133a20d20c8f796efd6922e1b323f756712ff499f8e3b533f01d874
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Sources/PulsumServices/SpeechService.swift -->
```swift
import Foundation
import Speech
#if os(iOS)
import AVFoundation
#endif
import os.log
import PulsumTypes

private let speechLogger = Logger(subsystem: "ai.pulsum", category: "SpeechService")

enum SpeechLoggingPolicy {
#if DEBUG
    static let transcriptLoggingEnabled = true
#else
    static let transcriptLoggingEnabled = false
#endif
}

private struct SpeechAuthorizationState {
    let speechStatus: SFSpeechRecognizerAuthorizationStatus
    let microphoneGranted: Bool
}

public protocol SpeechAuthorizationProviding: Sendable {
    func requestSpeechAuthorization() async -> SFSpeechRecognizerAuthorizationStatus
    func requestRecordPermission() async -> Bool
}

public struct SystemSpeechAuthorizationProvider: SpeechAuthorizationProviding {
    public init() {}

    public func requestSpeechAuthorization() async -> SFSpeechRecognizerAuthorizationStatus {
        await withCheckedContinuation { continuation in
            SFSpeechRecognizer.requestAuthorization { status in
                continuation.resume(returning: status)
            }
        }
    }

    public func requestRecordPermission() async -> Bool {
#if os(iOS)
        await withCheckedContinuation { continuation in
            AVAudioSession.sharedInstance().requestRecordPermission { granted in
                continuation.resume(returning: granted)
            }
        }
#else
        return true
#endif
    }
}

public enum SpeechServiceError: LocalizedError {
    case speechPermissionDenied
    case speechPermissionRestricted
    case microphonePermissionDenied
    case recognitionUnavailable
    case engineError(String)
    case audioSessionUnavailable

    public var errorDescription: String? {
        switch self {
        case .speechPermissionDenied:
            return "Speech recognition permission denied."
        case .speechPermissionRestricted:
            return "Speech recognition is restricted on this device."
        case .microphonePermissionDenied:
            return "Microphone access is required to record journals."
        case .recognitionUnavailable:
            return "On-device speech recognition is not available."
        case let .engineError(message):
            return message
        case .audioSessionUnavailable:
            return "Unable to configure audio session."
        }
    }
}

/// Handles on-device speech recognition with a managed lifecycle.
public actor SpeechService {
    public struct Session: Sendable {
        public let stream: AsyncThrowingStream<SpeechSegment, Error>
        public let stop: @Sendable () -> Void
        public let audioLevels: AsyncStream<Float>?
    }

    private let backend: any SpeechBackending
    private let authorizationProvider: SpeechAuthorizationProviding
    private let overrides: SpeechUITestOverrides
    private let backendName: String
    private var cachedAuthorization: SpeechAuthorizationState?

    public init(
        locale: Locale = Locale(identifier: "en_US"),
        authorizationProvider: SpeechAuthorizationProviding = SystemSpeechAuthorizationProvider()
    ) {
        self.authorizationProvider = authorizationProvider
        self.overrides = SpeechUITestOverrides()
#if DEBUG
        if BuildFlags.uiTestSeamsCompiledIn && overrides.useFakeBackend {
            backend = FakeSpeechBackend(
                authorizationProvider: authorizationProvider,
                autoGrantPermissions: overrides.autoGrantPermissions
            )
            backendName = backend.backendName
            return
        }
#endif

        if #available(iOS 26.0, *),
           BuildFlags.useModernSpeechBackend,
           let modern = ModernSpeechBackend(locale: locale, authorizationProvider: authorizationProvider) {
            backend = modern
        } else {
            backend = LegacySpeechBackend(locale: locale, authorizationProvider: authorizationProvider)
        }
        backendName = backend.backendName
    }

    public func requestAuthorization() async throws {
        try await preflightPermissions()
        try await backend.requestAuthorization()
    }

    public func startRecording(maxDuration: TimeInterval = 30) async throws -> Session {
#if DEBUG
        let clock = ContinuousClock()
        let start = clock.now
        let session = try await backend.startRecording(maxDuration: maxDuration)
        let elapsed = start.duration(to: clock.now)
        speechLogger.debug("Speech backend \(self.backendName, privacy: .public) start latency \(elapsed.components.seconds, privacy: .public)s")
        return session
#else
        return try await backend.startRecording(maxDuration: maxDuration)
#endif
    }

    public func stopRecording() {
        backend.stopRecording()
    }

    public nonisolated var selectedBackendIdentifier: String { backendName }

    private func preflightPermissions() async throws {
#if DEBUG
        if overrides.autoGrantPermissions {
            cachedAuthorization = SpeechAuthorizationState(speechStatus: .authorized, microphoneGranted: true)
            return
        }
#endif
        if let cached = cachedAuthorization,
           cached.speechStatus == .authorized,
           cached.microphoneGranted {
            return
        }

        let speechStatus = await authorizationProvider.requestSpeechAuthorization()
        switch speechStatus {
        case .authorized:
            break
        case .denied:
            throw SpeechServiceError.speechPermissionDenied
        case .restricted:
            throw SpeechServiceError.speechPermissionRestricted
        default:
            throw SpeechServiceError.speechPermissionDenied
        }

#if os(iOS)
        let microphoneGranted = await authorizationProvider.requestRecordPermission()
        guard microphoneGranted else { throw SpeechServiceError.microphonePermissionDenied }
#else
        let microphoneGranted = true
#endif
        cachedAuthorization = SpeechAuthorizationState(speechStatus: speechStatus, microphoneGranted: microphoneGranted)
    }
}

private protocol SpeechBackending: Sendable {
    var backendName: String { get }
    func requestAuthorization() async throws
    func startRecording(maxDuration: TimeInterval) async throws -> SpeechService.Session
    func stopRecording()
}

// Gate-1b: UITest seams are compiled out of Release builds.
// Gate-1b: UITest seams are compiled out of Release builds.
private struct SpeechUITestOverrides {
    let useFakeBackend: Bool
    let autoGrantPermissions: Bool

    init() {
#if DEBUG
        useFakeBackend = AppRuntimeConfig.useFakeSpeechBackend
        autoGrantPermissions = AppRuntimeConfig.autoGrantSpeechPermissions
#else
        useFakeBackend = false
        autoGrantPermissions = false
#endif
    }
}

private final class LegacySpeechBackend: SpeechBackending {
    private let recognizer: SFSpeechRecognizer?
    private var audioEngine: AVAudioEngine?
    private var recognitionTask: SFSpeechRecognitionTask?
    private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest?
    private var streamContinuation: AsyncThrowingStream<SpeechSegment, Error>.Continuation?
    private var levelContinuation: AsyncStream<Float>.Continuation?
    let backendName = "legacy"

    init(locale: Locale, authorizationProvider _: SpeechAuthorizationProviding) {
        let recognizer = SFSpeechRecognizer(locale: locale)
        recognizer?.supportsOnDeviceRecognition = true
        self.recognizer = recognizer
    }

    func requestAuthorization() async throws {
        guard let recognizer else {
            throw SpeechServiceError.recognitionUnavailable
        }
        guard recognizer.isAvailable else {
            throw SpeechServiceError.recognitionUnavailable
        }
    }

    func startRecording(maxDuration: TimeInterval) async throws -> SpeechService.Session {
        guard let recognizer, recognizer.isAvailable else {
            speechLogger.error("Speech recognizer not available.")
            throw SpeechServiceError.recognitionUnavailable
        }
        speechLogger.info("Speech recognizer available (on-device: \(recognizer.supportsOnDeviceRecognition)).")

#if os(iOS)
        let session = AVAudioSession.sharedInstance()
        if session.recordPermission == .undetermined {
            _ = try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Bool, Error>) in
                session.requestRecordPermission { granted in
                    continuation.resume(returning: granted)
                }
            }
        }
        guard session.recordPermission == .granted else {
            throw SpeechServiceError.microphonePermissionDenied
        }
        do {
            try session.setCategory(.record, mode: .measurement, options: [.duckOthers])
            try session.setActive(true, options: .notifyOthersOnDeactivation)
            speechLogger.info("Audio session configured.")
        } catch {
#if targetEnvironment(simulator)
            // In simulator, audio session config may fail but recording still works
            let info = Self.safeErrorInfo(error)
            speechLogger.debug("Audio session config failed in simulator (expected). domain=\(info.domain, privacy: .public) code=\(info.code, privacy: .public)")
#else
            let info = Self.safeErrorInfo(error)
            speechLogger.error("Audio session configuration failed. domain=\(info.domain, privacy: .public) code=\(info.code, privacy: .public)")
            throw SpeechServiceError.audioSessionUnavailable
#endif
        }
#endif

        let engine = AVAudioEngine()
        let request = SFSpeechAudioBufferRecognitionRequest()
        request.requiresOnDeviceRecognition = recognizer.supportsOnDeviceRecognition
        request.shouldReportPartialResults = true
        
        speechLogger.debug("Starting audio engine...")

        let inputNode = engine.inputNode
        let format = inputNode.outputFormat(forBus: 0)
        speechLogger.debug("Audio format sampleRate=\(format.sampleRate, privacy: .public) channels=\(format.channelCount, privacy: .public)")
        inputNode.removeTap(onBus: 0)
        
        // Create audio level stream with stored continuation
        let audioLevelStream = AsyncStream<Float> { continuation in
            self.levelContinuation = continuation
            continuation.onTermination = { @Sendable _ in
                speechLogger.debug("Audio level stream terminated.")
            }
            
            // Install tap to capture audio and send to recognition
            inputNode.installTap(onBus: 0, bufferSize: 1024, format: format) { buffer, _ in
                // Feed buffer to speech recognition
                request.append(buffer)
                
                // Calculate and yield RMS power level for waveform visualization
                let level = Self.calculateRMSLevel(from: buffer)
                continuation.yield(level)
            }
        }

        engine.prepare()
        do {
            try engine.start()
            speechLogger.info("Audio engine started.")
        } catch {
            let info = Self.safeErrorInfo(error)
            speechLogger.error("Failed to start audio engine. domain=\(info.domain, privacy: .public) code=\(info.code, privacy: .public)")
            throw SpeechServiceError.engineError(error.localizedDescription)
        }

        audioEngine = engine
        recognitionRequest = request

        // Create speech segment stream with stored continuation
        let stream = AsyncThrowingStream<SpeechSegment, Error> { continuation in
            self.streamContinuation = continuation
            continuation.onTermination = { @Sendable _ in
                speechLogger.debug("Speech segment stream terminated.")
            }
        }
        
        // Start recognition task IMMEDIATELY (not deferred until stream consumption)
        speechLogger.debug("Starting recognition task.")
        self.recognitionTask = recognizer.recognitionTask(with: request) { [weak self] result, error in
            guard let self else { return }
            
            if let error {
                let info = Self.safeErrorInfo(error)
                speechLogger.error("Recognition error. domain=\(info.domain, privacy: .public) code=\(info.code, privacy: .public)")
                self.streamContinuation?.finish(throwing: error)
                return
            }
            
            guard let result else { return }
            
            let confidence = result.transcriptions.first?.segments.averageConfidence ?? 0
            let transcript = result.bestTranscription.formattedString
            
            if !transcript.isEmpty {
#if DEBUG
                if SpeechLoggingPolicy.transcriptLoggingEnabled {
                    speechLogger
                        .debug("PULSUM_TRANSCRIPT_LOG_MARKER final=\(result.isFinal, privacy: .public) chars=\(transcript.count, privacy: .public) confidence=\(confidence, privacy: .public)")
                }
#endif
                self.streamContinuation?.yield(
                    SpeechSegment(transcript: transcript, isFinal: result.isFinal, confidence: confidence)
                )
            }
            
            if result.isFinal {
                speechLogger.info("Recognition completed with final transcript.")
                self.streamContinuation?.finish()
            }
        }
        
        speechLogger.info("Recognition task listening.")

        // Set up max duration timeout
        if maxDuration > 0 {
            Task { [weak self] in
                try? await Task.sleep(nanoseconds: UInt64(maxDuration * 1_000_000_000))
                speechLogger.info("Max recording duration reached; stopping.")
                self?.stopRecording()
            }
        }

        return SpeechService.Session(
            stream: stream,
            stop: { [weak self] in
                self?.stopRecording()
            },
            audioLevels: audioLevelStream
        )
    }

    private static func safeErrorInfo(_ error: Error) -> (domain: String, code: Int) {
        let nsError = error as NSError
        return (nsError.domain, nsError.code)
    }
    
    private static func calculateRMSLevel(from buffer: AVAudioPCMBuffer) -> Float {
        guard let channelData = buffer.floatChannelData else { return 0 }
        let channelDataValue = channelData.pointee
        let channelDataValueArray = stride(from: 0, to: Int(buffer.frameLength), by: buffer.stride)
            .map { channelDataValue[$0] }
        
        let rms = sqrt(channelDataValueArray.map { $0 * $0 }.reduce(0, +) / Float(buffer.frameLength))
        
        // Convert to dB and normalize to 0...1 range
        let decibels = 20 * log10(max(rms, 0.00001))
        let normalized = max(0, min(1, (decibels + 50) / 50)) // -50dB to 0dB mapped to 0...1
        
        return normalized
    }

    func stopRecording() {
        speechLogger.info("Stopping recording.")
        
        // Finish streams
        streamContinuation?.finish()
        streamContinuation = nil
        levelContinuation?.finish()
        levelContinuation = nil
        
        // Cancel recognition task (not cancel, just finish cleanly)
        recognitionRequest?.endAudio()
        recognitionRequest = nil
        recognitionTask?.finish()
        recognitionTask = nil
        
        // Stop audio engine
        audioEngine?.stop()
        audioEngine?.inputNode.removeTap(onBus: 0)
        audioEngine = nil
        
#if os(iOS)
        try? AVAudioSession.sharedInstance().setActive(false, options: .notifyOthersOnDeactivation)
#endif
        speechLogger.info("Recording stopped and cleaned up.")
    }
}

extension LegacySpeechBackend: @unchecked Sendable {}

#if DEBUG
#if DEBUG
private final class FakeSpeechBackend: SpeechBackending {
    private let authorizationProvider: SpeechAuthorizationProviding
    private let autoGrantPermissions: Bool
    private var streamTask: Task<Void, Never>?
    private var levelTask: Task<Void, Never>?
    private var streamContinuation: AsyncThrowingStream<SpeechSegment, Error>.Continuation?
    private var levelContinuation: AsyncStream<Float>.Continuation?
    private var stopHandler: (@Sendable () -> Void)?
    let backendName = "fake"

    init(authorizationProvider: SpeechAuthorizationProviding, autoGrantPermissions: Bool) {
        self.authorizationProvider = authorizationProvider
        self.autoGrantPermissions = autoGrantPermissions
    }

    func requestAuthorization() async throws {
        guard !autoGrantPermissions else { return }
        _ = await authorizationProvider.requestSpeechAuthorization()
#if os(iOS)
        _ = await authorizationProvider.requestRecordPermission()
#endif
    }

    func startRecording(maxDuration: TimeInterval) async throws -> SpeechService.Session {
        let stream = AsyncThrowingStream<SpeechSegment, Error> { continuation in
            self.streamContinuation = continuation
            self.streamTask = Task {
                for segment in Self.scriptedSegments {
                    if Task.isCancelled { break }
                    try? await Task.sleep(nanoseconds: 350_000_000)
                    continuation.yield(segment)
                }
                continuation.finish()
            }
        }

        let levelStream = AsyncStream<Float> { continuation in
            self.levelContinuation = continuation
            self.levelTask = Task {
                var cursor: Float = 0.15
                while !Task.isCancelled {
                    cursor = cursor >= 0.9 ? 0.2 : cursor + 0.15
                    continuation.yield(cursor)
                    try? await Task.sleep(nanoseconds: 120_000_000)
                }
            }
        }

        let stop: @Sendable () -> Void = { [weak self] in
            guard let self else { return }
            self.streamTask?.cancel()
            self.levelTask?.cancel()
            self.streamContinuation?.finish()
            self.levelContinuation?.finish()
        }
        stopHandler = stop

        return SpeechService.Session(
            stream: stream,
            stop: stop,
            audioLevels: levelStream
        )
    }

    func stopRecording() {
        stopHandler?()
        stopHandler = nil
    }

    private static let scriptedSegments: [SpeechSegment] = [
        SpeechSegment(transcript: "Quick calm check-in for Pulsum.", isFinal: false, confidence: 0.92),
        SpeechSegment(transcript: "Energy feels steady and focus is clear.", isFinal: false, confidence: 0.95),
        SpeechSegment(transcript: "Plan is to stretch after meetings.", isFinal: true, confidence: 0.97)
    ]
}
extension FakeSpeechBackend: @unchecked Sendable {}
#endif
#endif

@available(iOS 26.0, *)
private final class ModernSpeechBackend: SpeechBackending {
    private let fallback: LegacySpeechBackend
    let backendName = "modern"
#if DEBUG
    nonisolated(unsafe) static var availabilityOverride: Bool?
#endif

    init?(locale: Locale, authorizationProvider: SpeechAuthorizationProviding) {
        self.fallback = LegacySpeechBackend(locale: locale, authorizationProvider: authorizationProvider)

        guard ModernSpeechBackend.isSystemAnalyzerAvailable else {
            return nil
        }
    }

    func requestAuthorization() async throws {
        try await fallback.requestAuthorization()
    }

    func startRecording(maxDuration: TimeInterval) async throws -> SpeechService.Session {
        // NOTE: When Apple ships public SpeechAnalyzer/SpeechTranscriber APIs, integrate them here.
        // For now we reuse the legacy backend under a feature flag (Gate-2 hook) to preserve functionality.
        return try await fallback.startRecording(maxDuration: maxDuration)
    }

    func stopRecording() {
        fallback.stopRecording()
    }

    private static var isSystemAnalyzerAvailable: Bool {
#if DEBUG
        if let override = availabilityOverride { return override }
#endif
        return NSClassFromString("SpeechTranscriber") != nil || NSClassFromString("SpeechAnalyzer") != nil
    }
}

@available(iOS 26.0, *)
extension ModernSpeechBackend: @unchecked Sendable {}

#if os(iOS)
private extension Array where Element == SFTranscriptionSegment {
    var averageConfidence: Float {
        guard !isEmpty else { return 0 }
        let total = reduce(Float(0)) { $0 + $1.confidence }
        return total / Float(count)
    }
}
#else
private extension Array where Element == SFTranscriptionSegment {
    var averageConfidence: Float { 0 }
}
#endif

#if DEBUG
enum SpeechServiceDebug {
    static func overrideModernBackendAvailability(_ value: Bool?) {
        if #available(iOS 26.0, *) {
            ModernSpeechBackend.availabilityOverride = value
        }
    }
}
#endif
```
<!-- END_FILE: Packages/PulsumServices/Sources/PulsumServices/SpeechService.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_LLMGatewayTests.swift
- bytes: 1803
- lines: 56
- sha256: df64be6e418ba765444fa9be5be72fda90220f56819dfeaab6cf9c7494245de6
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_LLMGatewayTests.swift -->
```swift
import Foundation
import XCTest
@testable import PulsumServices

private final class InMemoryKeychainStore: KeychainStoring, @unchecked Sendable {
    private var storage: [String: Data] = [:]

    func setSecret(_ value: Data, for key: String) throws {
        storage[key] = value
    }

    func secret(for key: String) throws -> Data? {
        storage[key]
    }

    func removeSecret(for key: String) throws {
        storage.removeValue(forKey: key)
    }
}

final class Gate0_LLMGatewayTests: XCTestCase {
    private let envVarName = "PULSUM_COACH_API_KEY"

    override func tearDown() {
        unsetenv(envVarName)
        super.tearDown()
    }

    func test_keyResolution_failsWithoutSources() throws {
        unsetenv(envVarName)
        let gateway = LLMGateway(keychain: InMemoryKeychainStore())
        gateway.debugOverrideInMemoryKey(nil)
        try gateway.debugClearPersistedAPIKey()

        XCTAssertThrowsError(try gateway.debugResolveAPIKey()) { error in
            XCTAssertEqual(error as? LLMGatewayError, .apiKeyMissing)
        }
    }

    func test_keyResolution_precedence_memory_then_keychain_then_env() throws {
        let keychain = InMemoryKeychainStore()
        let gateway = LLMGateway(keychain: keychain)
        try gateway.debugClearPersistedAPIKey()

        gateway.debugOverrideInMemoryKey("memory-key")
        XCTAssertEqual(try gateway.debugResolveAPIKey(), "memory-key")

        gateway.debugOverrideInMemoryKey(nil)
        try keychain.setSecret(Data("keychain-key".utf8), for: "openai.api.key")
        XCTAssertEqual(try gateway.debugResolveAPIKey(), "keychain-key")

        try keychain.removeSecret(for: "openai.api.key")
        setenv(envVarName, "env-key", 1)
        XCTAssertEqual(try gateway.debugResolveAPIKey(), "env-key")
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_LLMGatewayTests.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_SpeechServiceAuthorizationTests.swift
- bytes: 3744
- lines: 105
- sha256: d4cb86d50966d0d0ec388f164fa251438b964c6048fea3f17c63d5990c7ec79c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_SpeechServiceAuthorizationTests.swift -->
```swift
#if os(iOS)
import Speech
import XCTest
@testable import PulsumServices

private struct MockSpeechAuthorizationProvider: SpeechAuthorizationProviding {
    let speechStatus: SFSpeechRecognizerAuthorizationStatus
    let microphoneGranted: Bool

    func requestSpeechAuthorization() async -> SFSpeechRecognizerAuthorizationStatus {
        speechStatus
    }

    func requestRecordPermission() async -> Bool {
        microphoneGranted
    }
}

private final class CountingSpeechAuthorizationProvider: SpeechAuthorizationProviding {
    var speechRequests = 0
    var micRequests = 0

    func requestSpeechAuthorization() async -> SFSpeechRecognizerAuthorizationStatus {
        speechRequests += 1
        return .authorized
    }

    func requestRecordPermission() async -> Bool {
        micRequests += 1
        return true
    }
}

final class Gate0_SpeechServiceAuthorizationTests: XCTestCase {
    func testSpeechPermissionDenied() async {
        let provider = MockSpeechAuthorizationProvider(speechStatus: .denied, microphoneGranted: true)
        let service = SpeechService(authorizationProvider: provider)

        await expect(service: service, toThrow: .speechPermissionDenied)
    }

    func testSpeechPermissionRestricted() async {
        let provider = MockSpeechAuthorizationProvider(speechStatus: .restricted, microphoneGranted: true)
        let service = SpeechService(authorizationProvider: provider)

        await expect(service: service, toThrow: .speechPermissionRestricted)
    }

    func testMicrophonePermissionDenied() async {
        let provider = MockSpeechAuthorizationProvider(speechStatus: .authorized, microphoneGranted: false)
        let service = SpeechService(authorizationProvider: provider)

        await expect(service: service, toThrow: .microphonePermissionDenied)
    }

    func testPermissionsGranted() async throws {
        let provider = MockSpeechAuthorizationProvider(speechStatus: .authorized, microphoneGranted: true)
        let service = SpeechService(authorizationProvider: provider)

        XCTAssertNoThrow(try await service.requestAuthorization())
    }

    func testAuthorizationCachingSkipsRepeatPrompts() async throws {
        let provider = CountingSpeechAuthorizationProvider()
        let service = SpeechService(authorizationProvider: provider)

        try await service.requestAuthorization()
        try await service.requestAuthorization()

        XCTAssertEqual(provider.speechRequests, 1)
        XCTAssertEqual(provider.micRequests, 1)
    }
}

private extension Gate0_SpeechServiceAuthorizationTests {
    func expect(service: SpeechService,
                toThrow expected: SpeechServiceError,
                file: StaticString = #filePath,
                line: UInt = #line) async {
        do {
            try await service.requestAuthorization()
            XCTFail("Expected error \(expected) but call succeeded", file: file, line: line)
        } catch let error as SpeechServiceError {
            switch (error, expected) {
            case (.speechPermissionDenied, .speechPermissionDenied),
                 (.speechPermissionRestricted, .speechPermissionRestricted),
                 (.microphonePermissionDenied, .microphonePermissionDenied):
                break
            default:
                XCTFail("Unexpected SpeechServiceError: \(error)", file: file, line: line)
            }
        } catch {
            XCTFail("Unexpected error: \(error)", file: file, line: line)
        }
    }
}
#else
import XCTest

final class Gate0_SpeechServiceAuthorizationTests: XCTestCase {
    func testSpeechAuthorizationSkippedOnNonIOS() throws {
        throw XCTSkip("Speech authorization matrix is only available on iOS.")
    }
}
#endif
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_SpeechServiceAuthorizationTests.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_SpeechServiceLoggingTests.swift
- bytes: 1087
- lines: 26
- sha256: 055e58acd7eb5b5864c9984162589ed0987352661844f09876c8146cf3ffc8d4
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_SpeechServiceLoggingTests.swift -->
```swift
import XCTest
@testable import PulsumServices

final class Gate0_SpeechServiceLoggingTests: XCTestCase {
    func testReleaseBuildDisablesTranscriptLogging() throws {
#if RELEASE_LOG_AUDIT
        XCTAssertFalse(SpeechLoggingPolicy.transcriptLoggingEnabled, "Release builds must never log transcripts.")
#else
        throw XCTSkip("Release-only assertion. Build with -DRELEASE_LOG_AUDIT to run.")
#endif
    }

    func testReleaseBinaryOmitsTranscriptAuditMarker() throws {
#if RELEASE_LOG_AUDIT
        let marker = ["PULSUM", "TRANSCRIPT", "LOG", "MARKER"].joined(separator: "_")
        guard let executableURL = Bundle(for: Self.self).executableURL else {
            return XCTFail("Unable to resolve test bundle executable URL.")
        }
        let data = try Data(contentsOf: executableURL)
        let haystack = String(decoding: data, as: UTF8.self)
        XCTAssertFalse(haystack.contains(marker), "Release binary should not contain transcript audit marker")
#else
        throw XCTSkip("Release-only binary audit. Build with -DRELEASE_LOG_AUDIT to run.")
#endif
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_SpeechServiceLoggingTests.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/Gate1_LLMGatewayUITestSeams.swift
- bytes: 946
- lines: 32
- sha256: f43377a4a5434675a69b86a9033762b49e8617d92a66540ab48681d3d38c3e60
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate1_LLMGatewayUITestSeams.swift -->
```swift
import XCTest
@testable import PulsumServices

final class Gate1_LLMGatewayUITestSeams: XCTestCase {
    func testStubPingShortCircuits_whenFlagOn() async throws {
        guard ProcessInfo.processInfo.environment["UITEST_USE_STUB_LLM"] == "1" else {
            throw XCTSkip("UITEST_USE_STUB_LLM not set")
        }

        let gateway = LLMGateway(keychain: InMemoryKeychainStore())
        let ok = try await gateway.testAPIConnection()

        XCTAssertTrue(ok)
        XCTAssertEqual(gateway.currentAPIKey(), "UITEST_STUB_KEY")
    }
}

private final class InMemoryKeychainStore: KeychainStoring, @unchecked Sendable {
    private var storage: [String: Data] = [:]

    func setSecret(_ value: Data, for key: String) throws {
        storage[key] = value
    }

    func secret(for key: String) throws -> Data? {
        storage[key]
    }

    func removeSecret(for key: String) throws {
        storage.removeValue(forKey: key)
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate1_LLMGatewayUITestSeams.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/Gate1_SpeechFakeBackendTests.swift
- bytes: 965
- lines: 29
- sha256: e81902093780838a3ad429d522425472cfd772d60125a5ea6831dd6e53000275
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate1_SpeechFakeBackendTests.swift -->
```swift
import XCTest
@testable import PulsumServices

final class Gate1_SpeechFakeBackendTests: XCTestCase {
    func testFakeBackendStreamsScriptedSegments_whenFlagOn() async throws {
        guard ProcessInfo.processInfo.environment["UITEST_FAKE_SPEECH"] == "1" else {
            throw XCTSkip("UITEST_FAKE_SPEECH not set")
        }

        let service = SpeechService()
        try await service.requestAuthorization()

        let session = try await service.startRecording(maxDuration: 1.5)
        var didEmit = false

        do {
            for try await segment in session.stream {
                XCTAssertFalse(segment.transcript.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                didEmit = true
                break
            }
        } catch {
            XCTFail("Fake backend should not throw: \(error)")
        }

        XCTAssertTrue(didEmit, "Fake backend should emit at least one segment")
        session.stop()
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate1_SpeechFakeBackendTests.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/Gate2_ModernSpeechBackendTests.swift
- bytes: 1311
- lines: 39
- sha256: 21608ee41ee3b0e1ac355a2f72cf8c2d80867d3e8d0b8f6269180438e2cb49ea
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate2_ModernSpeechBackendTests.swift -->
```swift
import XCTest
@testable import PulsumServices

final class Gate2_ModernSpeechBackendTests: XCTestCase {
    func testModernBackendRespectsFeatureFlag() async throws {
#if os(iOS)
        guard #available(iOS 26.0, *) else {
            throw XCTSkip("Modern backend only available on iOS 26+")
        }
        BuildFlags.overrideModernSpeechBackend(true)
        SpeechServiceDebug.overrideModernBackendAvailability(true)
        defer {
            BuildFlags.overrideModernSpeechBackend(nil)
            SpeechServiceDebug.overrideModernBackendAvailability(nil)
        }

        let service = SpeechService()
        XCTAssertEqual(service.selectedBackendIdentifier, "modern")
#else
        throw XCTSkip("Speech backend selection only available on iOS")
#endif
    }

    func testLegacyBackendDefault() async throws {
#if os(iOS)
        BuildFlags.overrideModernSpeechBackend(false)
        SpeechServiceDebug.overrideModernBackendAvailability(true)
        defer {
            BuildFlags.overrideModernSpeechBackend(nil)
            SpeechServiceDebug.overrideModernBackendAvailability(nil)
        }

        let service = SpeechService()
        XCTAssertEqual(service.selectedBackendIdentifier, "legacy")
#else
        throw XCTSkip("Speech backend selection only available on iOS")
#endif
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate2_ModernSpeechBackendTests.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/Gate4_LLMGatewayPingSeams.swift
- bytes: 628
- lines: 20
- sha256: 93be30df4c2bc2c1a4b534ed99df7ccc52e208d1ab3c0c2604df188639696adf
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate4_LLMGatewayPingSeams.swift -->
```swift
import XCTest
@testable import PulsumServices

final class Gate4_LLMGatewayPingSeams: XCTestCase {
    func testStubPingShortCircuitsWhenFlagEnabled() async throws {
        let previous = getenv("UITEST_USE_STUB_LLM").flatMap { String(cString: $0) }
        setenv("UITEST_USE_STUB_LLM", "1", 1)
        defer {
            if let previous {
                setenv("UITEST_USE_STUB_LLM", previous, 1)
            } else {
                unsetenv("UITEST_USE_STUB_LLM")
            }
        }

        let gateway = LLMGateway()
        let result = try await gateway.testAPIConnection()
        XCTAssertTrue(result)
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/Gate4_LLMGatewayPingSeams.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/HealthKitAnchorStoreTests.swift
- bytes: 1910
- lines: 45
- sha256: cf5714930608e9fd3231b12e646de79837ecba7543a3760c295275c747ab5ed6
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/HealthKitAnchorStoreTests.swift -->
```swift
import XCTest
import HealthKit
@testable import PulsumServices

final class HealthKitAnchorStoreTests: XCTestCase {
    func testPersistAndLoadAnchor() throws {
        let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempURL, withIntermediateDirectories: true)

        let store = HealthKitAnchorStore(directory: tempURL)
        let anchor = HKQueryAnchor(fromValue: Int(Date().timeIntervalSince1970))
        let identifier = "com.apple.healthkit.heartRate"

        store.store(anchor: anchor, for: identifier)

        let expectation = XCTestExpectation(description: "Anchor persisted")
        DispatchQueue.global().asyncAfter(deadline: .now() + 0.2) {
            let retrieved = store.anchor(for: identifier)
            XCTAssertNotNil(retrieved)
            expectation.fulfill()
        }
        wait(for: [expectation], timeout: 1.0)
    }

    func testRemoveAnchorDeletesFile() throws {
        let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempURL, withIntermediateDirectories: true)

        let store = HealthKitAnchorStore(directory: tempURL)
        let anchor = HKQueryAnchor(fromValue: 1)
        let identifier = "com.apple.healthkit.sleepAnalysis"
        store.store(anchor: anchor, for: identifier)

        let expectation = XCTestExpectation(description: "Anchor removed")
        DispatchQueue.global().asyncAfter(deadline: .now() + 0.2) {
            store.removeAnchor(for: identifier)
            DispatchQueue.global().asyncAfter(deadline: .now() + 0.2) {
                let retrieved = store.anchor(for: identifier)
                XCTAssertNil(retrieved)
                expectation.fulfill()
            }
        }
        wait(for: [expectation], timeout: 1.5)
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/HealthKitAnchorStoreTests.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/KeychainServiceTests.swift
- bytes: 490
- lines: 15
- sha256: 385fa2e3d8666fd9112ecddfccfd9c595c156d217d6e290872561811f28eb69c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/KeychainServiceTests.swift -->
```swift
import XCTest
@testable import PulsumServices

final class KeychainServiceTests: XCTestCase {
    func testRoundTripSecret() throws {
        let service = KeychainService()
        let key = "test.api.key"
        let value = Data("secret".utf8)
        try service.setSecret(value, for: key)
        let retrieved = try service.secret(for: key)
        XCTAssertEqual(retrieved, value)
        try service.removeSecret(for: key)
        XCTAssertNil(try service.secret(for: key))
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/KeychainServiceTests.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewaySchemaTests.swift
- bytes: 11668
- lines: 247
- sha256: 9e3a9a781b2b0de6ec99de4ce1ede6bfc6b921b9d8a3471e04e9d498e186ff14
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewaySchemaTests.swift -->
```swift
import Testing
import Foundation
@testable import PulsumServices

/// Tests for LLMGateway structured output schema validation (Wall 2)
struct LLMGatewaySchemaTests {

    @Test("CoachPhrasing schema has required fields")
    func schemaStructure() {
        let schema = CoachPhrasingSchema.json()

        // Verify top-level schema structure
        #expect(schema["type"] as? String == "object", "Schema should be of type 'object'")

        guard let properties = schema["properties"] as? [String: Any] else {
            Issue.record("Schema should have properties")
            return
        }

        // Verify required fields
        let required = schema["required"] as? [String] ?? []
        #expect(Set(required) == Set(properties.keys), "Required keys should match properties")

        // Verify strict format block (now under text.format path)
        let format = CoachPhrasingSchema.responsesFormat()
        #expect(format["type"] as? String == "json_schema", "text.format type should be json_schema")
        #expect(format["name"] as? String == "CoachPhrasing", "Schema name should be CoachPhrasing")
        #expect(format["strict"] as? Bool == true, "text.format should enable strict mode")
        #expect(format["schema"] is [String: Any], "Embedded schema should be present")
    }

    @Test("CoachPhrasing grounding score bounds")
    func groundingScoreBounds() {
        let schema = CoachPhrasingSchema.json()
        let properties = schema["properties"] as? [String: Any]
        let groundingScore = properties?["groundingScore"] as? [String: Any]

        #expect(groundingScore?["type"] as? String == "number", "groundingScore should be numeric")
        #expect(groundingScore?["minimum"] as? Double == 0.0, "groundingScore min should be 0.0")
        #expect(groundingScore?["maximum"] as? Double == 1.0, "groundingScore max should be 1.0")
    }

    @Test("CoachPhrasing validates successfully")
    func validPhrasingDecodes() throws {
        let validJSON = """
        {
            "coachReply": "Your HRV looks low today. Try a short breathing exercise to help reset your nervous system.",
            "isOnTopic": true,
            "groundingScore": 0.85,
            "intentTopic": "sleep",
            "refusalReason": "",
            "nextAction": ""
        }
        """

        let data = validJSON.data(using: .utf8)!
        let phrasing = try JSONDecoder().decode(CoachPhrasing.self, from: data)

        #expect(phrasing.isOnTopic == true)
        #expect(phrasing.groundingScore == 0.85)
        #expect(phrasing.refusalReason == nil)
        #expect(phrasing.nextAction == nil)
        #expect(phrasing.coachReply.contains("HRV"))
    }

    @Test("CoachPhrasing rejects off-topic response")
    func offTopicPhrasingDecodes() throws {
        let offTopicJSON = """
        {
            "coachReply": "I’m not able to help with that.",
            "isOnTopic": false,
            "groundingScore": 0.2,
            "refusalReason": "User asked about weather, not wellbeing",
            "intentTopic": "none",
            "nextAction": ""
        }
        """

        let data = offTopicJSON.data(using: .utf8)!
        let phrasing = try JSONDecoder().decode(CoachPhrasing.self, from: data)

        #expect(phrasing.isOnTopic == false, "Off-topic response should be rejected")
        #expect(phrasing.groundingScore < 0.5, "Low grounding score expected")
        #expect(phrasing.refusalReason != nil, "Refusal reason should be provided")
    }

    @Test("CoachPhrasing low grounding score")
    func lowGroundingScore() throws {
        let lowGroundingJSON = """
        {
            "coachReply": "I can't provide specific advice without more context.",
            "isOnTopic": true,
            "groundingScore": 0.3,
            "intentTopic": "none",
            "refusalReason": "",
            "nextAction": ""
        }
        """

        let data = lowGroundingJSON.data(using: .utf8)!
        let phrasing = try JSONDecoder().decode(CoachPhrasing.self, from: data)

        #expect(phrasing.groundingScore < 0.5, "Low grounding score should be detected")
        // In production, this would be rejected by validation threshold (≥0.5)
    }

    @Test("Grounding threshold is 0.5")
    func groundingThreshold() {
        // GPT5Client uses groundingThreshold = 0.5
        // Responses with groundingScore < 0.5 should be rejected
        let threshold = 0.5

        #expect(0.3 < threshold, "Below threshold should fail")
        #expect(0.5 >= threshold, "At threshold should pass")
        #expect(0.85 >= threshold, "Above threshold should pass")
    }

    @Test("Max output tokens clamped to window")
    func maxOutputTokensClamped() throws {
        let context = CoachLLMContext(userToneHints: "hi",
                                      topSignal: "topic=sleep",
                                      topMomentId: nil,
                                      rationale: "steady",
                                      zScoreSummary: "z_hrv:-1.2")
        let low = try LLMGateway.makeChatRequestBody(context: context,
                                                     candidateMoments: [],
                                                     maxOutputTokens: 32)
        let high = try LLMGateway.makeChatRequestBody(context: context,
                                                      candidateMoments: [],
                                                      maxOutputTokens: 2000)

        #expect(low["max_output_tokens"] as? Int == 128)
        #expect(high["max_output_tokens"] as? Int == 1024)
    }

    @Test("Schema enforces strict mode")
    func schemaStrictMode() {
        let schema = CoachPhrasingSchema.json()

        #expect(schema["additionalProperties"] as? Bool == false, "Schema should disallow additional properties")

        guard let properties = schema["properties"] as? [String: Any] else {
            Issue.record("Schema should have properties")
            return
        }

        let optionalKeys = ["intentTopic", "refusalReason", "nextAction"]
        optionalKeys.forEach { key in
            if let property = properties[key] as? [String: Any] {
                #expect(property["type"] as? String == "string", "\(key) should be a plain string")
                #expect(property["minLength"] as? Int == 0, "\(key) should allow empty string")
            } else {
                Issue.record("Property \(key) missing in schema")
            }
        }
    }

    @Test("Payload includes candidate moments and minimized context only")
    func payloadIncludesCandidateMoments() throws {
        let candidates = [
            CandidateMoment(id: "moment-1",
                            title: "Wind-down ritual",
                            shortDescription: "Dim the lights and breathe slowly for two minutes.",
                            detail: "This short practice taps the parasympathetic response on low HRV days.",
                            evidenceBadge: "Strong"),
            CandidateMoment(id: "moment-2",
                            title: "Micro walk",
                            shortDescription: "A five-minute outdoor walk lifts mood quickly.",
                            detail: nil,
                            evidenceBadge: "Medium")
        ]
        let context = CoachLLMContext(userToneHints: "Need an evening routine",
                                      topSignal: "subj_sleepQuality:-0.8",
                                      topMomentId: candidates.first?.id,
                                      rationale: "sleep debt + subjective fatigue",
                                      zScoreSummary: "z_sleepDebt:1.2,z_hrv:-0.7",
                                      candidateMoments: candidates)
        let body = try LLMGateway.makeChatRequestBody(context: context,
                                                      candidateMoments: candidates,
                                                      maxOutputTokens: 400)

        guard let userPayload = (body["input"] as? [[String: Any]])?.last?["content"] as? String,
              let payloadData = userPayload.data(using: .utf8),
              let json = try JSONSerialization.jsonObject(with: payloadData) as? [String: Any] else {
            Issue.record("Failed to decode minimized payload")
            return
        }
        #expect(Set(json.keys) == ["userToneHints", "topSignal", "topMomentId", "rationale", "zScoreSummary", "candidateMoments"])
        guard let embeddedMoments = json["candidateMoments"] as? [[String: Any]],
              let first = embeddedMoments.first else {
            Issue.record("Missing embedded candidate moments")
            return
        }
        #expect(Set(first.keys).isSubset(of: ["id", "title", "short", "detail", "evidenceBadge"]))
        #expect((first["id"] as? String) == "moment-1")
        #expect(((first["short"] as? String) ?? "").contains("Dim the lights"))
    }

    @Test("Payload excludes PHI and forbidden fields like transcript/heartrate/samples")
    func payloadExcludesForbiddenFields() throws {
        let context = CoachLLMContext(userToneHints: "Focus on sleep without sharing transcript",
                                      topSignal: "subj_sleepQuality:-0.8",
                                      topMomentId: nil,
                                      rationale: "sleep debt + low HRV",
                                      zScoreSummary: "z_sleepDebt:1.2,z_hrv:-0.7")
        let body = try LLMGateway.makeChatRequestBody(context: context,
                                                      candidateMoments: [],
                                                      maxOutputTokens: 256)
        guard let userPayload = (body["input"] as? [[String: Any]])?.last?["content"] as? String else {
            Issue.record("Missing minimized payload")
            return
        }
        let lower = userPayload.lowercased()
        #expect(!lower.contains("\"transcript\""))
        #expect(!lower.contains("\"heartrate\""))
        #expect(!lower.contains("\"samples\""))
    }

    @Test("Candidate detail omitted when nil")
    func candidateDetailOmittedWhenNil() throws {
        let candidates = [
            CandidateMoment(id: "moment-1",
                            title: "Breathing reset",
                            shortDescription: "Take three calm breaths.",
                            detail: nil,
                            evidenceBadge: "Strong")
        ]
        let context = CoachLLMContext(userToneHints: "Need help relaxing",
                                      topSignal: "subj_stress:+1.2",
                                      topMomentId: candidates.first?.id,
                                      rationale: "stress + low HRV",
                                      zScoreSummary: "z_hrv:-0.6",
                                      candidateMoments: candidates)
        let body = try LLMGateway.makeChatRequestBody(context: context,
                                                      candidateMoments: candidates,
                                                      maxOutputTokens: 256)
        guard let userPayload = (body["input"] as? [[String: Any]])?.last?["content"] as? String,
              let data = userPayload.data(using: .utf8),
              let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let embedded = json["candidateMoments"] as? [[String: Any]],
              let first = embedded.first else {
            Issue.record("Failed to decode minimized payload")
            return
        }
        #expect(first["detail"] == nil)
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewaySchemaTests.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewayTests.swift
- bytes: 11616
- lines: 263
- sha256: 5622f5f88a677080791d26dfe684027406e22868fa725a393481b427480f17dd
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewayTests.swift -->
```swift
import XCTest
#if canImport(Darwin)
import Darwin
#else
import Glibc
#endif
@testable import PulsumServices

final class MockCloudClient: CloudLLMClient {
    var shouldFail = false
    var groundingScore: Double = 0.65
    var isOnTopic = true
    var callCount = 0

    func generateResponse(context: CoachLLMContext,
                          intentTopic: String?,
                          candidateMoments: [CandidateMoment],
                          apiKey: String,
                          keySource: String) async throws -> CoachPhrasing {
        callCount += 1
        if shouldFail { throw LLMGatewayError.cloudGenerationFailed("forced failure") }
        return CoachPhrasing(
            coachReply: "Cloud response referencing \(context.topSignal).",
            isOnTopic: isOnTopic,
            groundingScore: groundingScore,
            intentTopic: intentTopic ?? "none"
        )
    }
}

final class MockLocalGenerator: OnDeviceCoachGenerator {
    var callCount = 0

    func generate(context: CoachLLMContext) async -> CoachReplyPayload {
        callCount += 1
        return CoachReplyPayload(
            coachReply: "Local fallback for \(context.topSignal)",
            nextAction: nil
        )
    }
}

final class LLMGatewayTests: XCTestCase {
    func testFallbackWhenConsentDisabled() async {
        let keychain = KeychainService()
        let gateway = LLMGateway(keychain: keychain,
                                 cloudClient: MockCloudClient(),
                                 localGenerator: MockLocalGenerator())
        try? gateway.setAPIKey("stub-key")
        let context = CoachLLMContext(userToneHints: "calm",
                                      topSignal: "topic=sleep",
                                      topMomentId: nil,
                                      rationale: "HRV suppressed",
                                      zScoreSummary: "z_hrv:-2")
        let payload = await gateway.generateCoachResponse(context: context,
                                                          intentTopic: "sleep",
                                                          candidateMoments: [],
                                                          consentGranted: false)
        XCTAssertTrue(payload.coachReply.lowercased().contains("local"))
    }

    func testGroundingFloorRespected() async {
        let cloudClient = MockCloudClient()
        let gateway = LLMGateway(keychain: KeychainService(),
                                 cloudClient: cloudClient,
                                 localGenerator: MockLocalGenerator())
        try? gateway.setAPIKey("stub-key")
        let context = CoachLLMContext(userToneHints: "calm",
                                      topSignal: "topic=sleep",
                                      topMomentId: nil,
                                      rationale: "HRV suppressed",
                                      zScoreSummary: "z_hrv:-2")

        cloudClient.groundingScore = 0.41
        let softPayload = await gateway.generateCoachResponse(context: context,
                                                              intentTopic: "sleep",
                                                              candidateMoments: [],
                                                              consentGranted: true,
                                                              groundingFloor: 0.40)
        XCTAssertTrue(softPayload.coachReply.contains("Cloud response"))

        cloudClient.groundingScore = 0.39
        let fallbackPayload = await gateway.generateCoachResponse(context: context,
                                                                  intentTopic: "sleep",
                                                                  candidateMoments: [],
                                                                  consentGranted: true,
                                                                  groundingFloor: 0.40)
        XCTAssertTrue(fallbackPayload.coachReply.lowercased().contains("local"))
    }

    func testCloudRequestBodyFormatUsesUnifiedSchema() throws {
        let candidates = [
            CandidateMoment(id: "a",
                            title: "Quick reset",
                            shortDescription: "Deep breathing reset.",
                            detail: "A concise prompt to slow breathing.",
                            evidenceBadge: "Strong")
        ]
        let context = CoachLLMContext(userToneHints: String(repeating: "a", count: 400),
                                      topSignal: "topic=sleep",
                                      topMomentId: candidates.first?.id,
                                      rationale: String(repeating: "b", count: 250),
                                      zScoreSummary: String(repeating: "c", count: 210),
                                      candidateMoments: candidates)
        let body = try LLMGateway.makeChatRequestBody(context: context,
                                                      candidateMoments: candidates,
                                                      maxOutputTokens: 512)

        XCTAssertEqual(body["model"] as? String, "gpt-5")
        let tokens = body["max_output_tokens"] as? Int
        XCTAssertEqual(tokens, 512)
        XCTAssertTrue((tokens ?? 0) >= 128 && (tokens ?? 0) <= 1024)

        guard let text = body["text"] as? [String: Any],
              text["verbosity"] as? String == "low",
              let format = text["format"] as? [String: Any],
              format["type"] as? String == "json_schema",
              format["name"] as? String == "CoachPhrasing",
              let schema = format["schema"] as? [String: Any],
              let properties = schema["properties"] as? [String: Any],
              let required = schema["required"] as? [String] else {
            XCTFail("Missing or invalid text.format schema data")
            return
        }

        XCTAssertEqual(schema["additionalProperties"] as? Bool, false)
        XCTAssertEqual(Set(required), Set(properties.keys))

        guard let inputMessages = body["input"] as? [[String: Any]],
              inputMessages.count == 2,
              let systemRole = inputMessages.first? ["role"] as? String,
              let userRole = inputMessages.last? ["role"] as? String,
              let userContent = inputMessages.last? ["content"] as? String else {
            XCTFail("Invalid input message structure")
            return
        }

        XCTAssertEqual(systemRole, "system")
       XCTAssertEqual(userRole, "user")
        XCTAssertTrue(userContent.contains("\"userToneHints\""))
        XCTAssertTrue(userContent.contains("\"candidateMoments\""))
    }

    func testSchemaErrorFallsBackToLocalGenerator() async {
        let local = MockLocalGenerator()
        let configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [LLMURLProtocolStub.self]
        LLMURLProtocolStub.invocationCount = 0
        LLMURLProtocolStub.handler = nil
        LLMURLProtocolStub.respondWithSchemaError = true

        let gateway = LLMGateway(cloudClient: nil,
                                 localGenerator: local,
                                 session: URLSession(configuration: configuration))
        try? gateway.setAPIKey("stub-key")
        let context = CoachLLMContext(userToneHints: "calm",
                                      topSignal: "topic=sleep",
                                      topMomentId: nil,
                                      rationale: "HRV suppressed",
                                      zScoreSummary: "z_hrv:-2")

        let payload = await gateway.generateCoachResponse(context: context,
                                                          intentTopic: "sleep",
                                                          candidateMoments: [],
                                                          consentGranted: true,
                                                          groundingFloor: 0.5)

        XCTAssertTrue(payload.coachReply.lowercased().contains("local"))
        XCTAssertEqual(local.callCount, 1)
        XCTAssertEqual(LLMURLProtocolStub.invocationCount, 1)

        LLMURLProtocolStub.respondWithSchemaError = false
    }

    func testAPIConnectionReturnsTrueOn200() async throws {
        let configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [LLMURLProtocolStub.self]
        LLMURLProtocolStub.handler = nil
        LLMURLProtocolStub.invocationCount = 0

        let gateway = LLMGateway(session: URLSession(configuration: configuration))
        try? gateway.setAPIKey("stub-key")
        let success = try await gateway.testAPIConnection()

        XCTAssertTrue(success)
        XCTAssertEqual(LLMURLProtocolStub.invocationCount, 1)
    }

    func testAPIConnectionReturnsFalseOn400() async throws {
        let configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [LLMURLProtocolStub.self]
        LLMURLProtocolStub.invocationCount = 0
        LLMURLProtocolStub.handler = { _ in
            (400, Data("{\"error\":{\"message\":\"Missing text.format.name\"}}".utf8))
        }

        let gateway = LLMGateway(session: URLSession(configuration: configuration))
        try? gateway.setAPIKey("stub-key")
        let success = try await gateway.testAPIConnection()

        XCTAssertFalse(success)
        XCTAssertEqual(LLMURLProtocolStub.invocationCount, 1)

        LLMURLProtocolStub.handler = nil
    }

    func testKeyResolutionFailsWhenSourcesMissing() throws {
        unsetenv("PULSUM_COACH_API_KEY")
        let gateway = LLMGateway(keychain: InMemoryKeychain(),
                                 cloudClient: MockCloudClient(),
                                 localGenerator: MockLocalGenerator())
        XCTAssertNil(gateway.currentAPIKey())
        XCTAssertThrowsError(try gateway.debugResolveAPIKey()) { error in
            guard case LLMGatewayError.apiKeyMissing = error else {
                return XCTFail("Expected apiKeyMissing, got \(error)")
            }
        }
    }

    func testKeyResolutionPrefersInMemoryThenKeychainThenEnv() throws {
        let keychain = InMemoryKeychain()
        let gateway = LLMGateway(keychain: keychain,
                                 cloudClient: MockCloudClient(),
                                 localGenerator: MockLocalGenerator())

        let previousEnv = getenv("PULSUM_COACH_API_KEY").flatMap { String(cString: $0) }
        setenv("PULSUM_COACH_API_KEY", "env-key", 1)
        defer {
            if let previousEnv {
                setenv("PULSUM_COACH_API_KEY", previousEnv, 1)
            } else {
                unsetenv("PULSUM_COACH_API_KEY")
            }
        }

        XCTAssertEqual(try gateway.debugResolveAPIKey(), "env-key")

        try keychain.setSecret(Data("kc-key".utf8), for: "openai.api.key")
        gateway.debugOverrideInMemoryKey(nil)
        XCTAssertEqual(try gateway.debugResolveAPIKey(), "kc-key")

        gateway.debugOverrideInMemoryKey("memory-key")
        XCTAssertEqual(try gateway.debugResolveAPIKey(), "memory-key")
    }
}

private final class InMemoryKeychain: KeychainStoring {
    private var values: [String: Data] = [:]

    func setSecret(_ value: Data, for key: String) throws {
        values[key] = value
    }

    func secret(for key: String) throws -> Data? {
        values[key]
    }

    func removeSecret(for key: String) throws {
        values.removeValue(forKey: key)
    }
}

extension InMemoryKeychain: @unchecked Sendable {}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewayTests.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/PulsumServicesDependencyTests.swift
- bytes: 506
- lines: 13
- sha256: 1df9d256c36836d2610cfc95c7ccddc27ed8cc5b3e85eae388bac384acb7f6f2
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/PulsumServicesDependencyTests.swift -->
```swift
import XCTest
@testable import PulsumServices

final class PulsumServicesDependencyTests: XCTestCase {
    func testStorageMetadataAndEmbeddingVersion() {
        let metadata = PulsumServices.storageMetadata()
        XCTAssertTrue(metadata.storeURL.lastPathComponent.contains("Pulsum.sqlite"))
        XCTAssertTrue(metadata.anchorsDirectory.lastPathComponent.contains("Anchors"))

        let embeddingVersion = PulsumServices.embeddingVersion()
        XCTAssertFalse(embeddingVersion.isEmpty)
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/PulsumServicesDependencyTests.swift -->

### Packages/PulsumServices/Tests/PulsumServicesTests/SpeechServiceTests.swift
- bytes: 2765
- lines: 72
- sha256: 3b511d9d21acfbb070c36cf65794dfb0737b2a5a4bd620fbfe8652e99f55e2df
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/SpeechServiceTests.swift -->
```swift
import XCTest
import Speech
@testable import PulsumServices

final class SpeechServiceAuthorizationTests: XCTestCase {
    func testRequestAuthorizationSucceedsWhenPermissionsGranted() async throws {
        let provider = StubSpeechAuthorizationProvider(speechStatus: .authorized, recordPermission: true)
        let service = SpeechService(authorizationProvider: provider)
        try await service.requestAuthorization()
    }

    func testRequestAuthorizationFailsWhenSpeechDenied() async {
        let provider = StubSpeechAuthorizationProvider(speechStatus: .denied, recordPermission: true)
        let service = SpeechService(authorizationProvider: provider)
        await XCTAssertThrowsErrorAsync(try await service.requestAuthorization()) { error in
            guard case SpeechServiceError.speechPermissionDenied = error else {
                return XCTFail("Unexpected error: \(error)")
            }
        }
    }

    func testRequestAuthorizationFailsWhenSpeechRestricted() async {
        let provider = StubSpeechAuthorizationProvider(speechStatus: .restricted, recordPermission: true)
        let service = SpeechService(authorizationProvider: provider)
        await XCTAssertThrowsErrorAsync(try await service.requestAuthorization()) { error in
            guard case SpeechServiceError.speechPermissionRestricted = error else {
                return XCTFail("Unexpected error: \(error)")
            }
        }
    }

#if os(iOS)
    func testRequestAuthorizationFailsWhenMicDenied() async {
        let provider = StubSpeechAuthorizationProvider(speechStatus: .authorized, recordPermission: false)
        let service = SpeechService(authorizationProvider: provider)
        await XCTAssertThrowsErrorAsync(try await service.requestAuthorization()) { error in
            guard case SpeechServiceError.microphonePermissionDenied = error else {
                return XCTFail("Unexpected error: \(error)")
            }
        }
    }
#endif
}

private struct StubSpeechAuthorizationProvider: SpeechAuthorizationProviding {
    let speechStatus: SFSpeechRecognizerAuthorizationStatus
    let recordPermission: Bool

    func requestSpeechAuthorization() async -> SFSpeechRecognizerAuthorizationStatus {
        speechStatus
    }

    func requestRecordPermission() async -> Bool {
        recordPermission
    }
}

private extension XCTestCase {
    func XCTAssertThrowsErrorAsync<T>(
        _ expression: @autoclosure () async throws -> T,
        _ handler: (Error) -> Void,
        file: StaticString = #filePath,
        line: UInt = #line
    ) async {
        do {
            _ = try await expression()
            XCTFail("Expected error", file: file, line: line)
        } catch {
            handler(error)
        }
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/PulsumServicesTests/SpeechServiceTests.swift -->

### Packages/PulsumServices/Tests/Support/LLMURLProtocolStub.swift
- bytes: 3599
- lines: 80
- sha256: 5f486a47c55eaa9838e63b87579c52743f59c158e66472b0cc2c3a34bb7f221c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumServices/Tests/Support/LLMURLProtocolStub.swift -->
```swift
import Foundation

final class LLMURLProtocolStub: URLProtocol {
    nonisolated(unsafe) static var handler: ((URLRequest) -> (Int, Data))?
    nonisolated(unsafe) static var respondWithSchemaError: Bool = false
    nonisolated(unsafe) static var invocationCount: Int = 0

    private static let endpointSuffix = "/v1/responses"
    private static let defaultSuccess = Data("{\"id\":\"resp_stub\",\"object\":\"response\",\"model\":\"gpt-5\",\"output\":[{\"type\":\"message\",\"role\":\"assistant\",\"content\":[{\"type\":\"output_text\",\"text\":\"{\\\"coachReply\\\":\\\"We can anchor with one calm breath and a soft light stretch.\\\",\\\"isOnTopic\\\":true,\\\"groundingScore\\\":0.82,\\\"intentTopic\\\":\\\"sleep\\\",\\\"refusalReason\\\":\\\"\\\",\\\"nextAction\\\":\\\"Dim lights 30 minutes before bed\\\"}\"}]}]}".utf8)
    private static let pingResponse = Data("{\"output\":[]}".utf8)
    private static let schemaErrorResponse = Data("{\"error\":{\"message\":\"Invalid schema: Missing text.format.name\"}}".utf8)

    override class func canInit(with request: URLRequest) -> Bool {
        guard let url = request.url else { return false }
        return url.absoluteString.contains(endpointSuffix)
    }

    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
        request
    }

    override func startLoading() {
        LLMURLProtocolStub.invocationCount += 1

        let (status, data): (Int, Data)
        if let handler = LLMURLProtocolStub.handler {
            (status, data) = handler(request)
        } else if Self.isPing(request: request) {
            (status, data) = (200, Self.pingResponse)
        } else if LLMURLProtocolStub.respondWithSchemaError {
            (status, data) = (400, Self.schemaErrorResponse)
        } else {
            (status, data) = (200, Self.defaultSuccess)
        }

        let response = HTTPURLResponse(url: request.url!,
                                       statusCode: status,
                                       httpVersion: nil,
                                       headerFields: ["Content-Type": "application/json"])!
        client?.urlProtocol(self, didReceive: response, cacheStoragePolicy: .notAllowed)
        client?.urlProtocol(self, didLoad: data)
        client?.urlProtocolDidFinishLoading(self)
    }

    override func stopLoading() {}

    private static func isPing(request: URLRequest) -> Bool {
        guard let body = bodyJSON(from: request),
              let input = body["input"] as? [[String: Any]],
              let user = input.last,
              let content = (user["content"] as? String)?.lowercased() else {
            return false
        }
        return content == "ping"
    }

    private static func bodyJSON(from request: URLRequest) -> [String: Any]? {
        guard let data = bodyData(from: request) else { return nil }
        return (try? JSONSerialization.jsonObject(with: data)) as? [String: Any]
    }

    private static func bodyData(from request: URLRequest) -> Data? {
        if let data = request.httpBody { return data }
        guard let stream = request.httpBodyStream else { return nil }
        stream.open()
        defer { stream.close() }
        var data = Data()
        let bufferSize = 1024
        var buffer = [UInt8](repeating: 0, count: bufferSize)
        while stream.hasBytesAvailable {
            let read = stream.read(&buffer, maxLength: bufferSize)
            if read > 0 {
                data.append(buffer, count: read)
            } else {
                break
            }
        }
        return data
    }
}
```
<!-- END_FILE: Packages/PulsumServices/Tests/Support/LLMURLProtocolStub.swift -->

### Packages/PulsumTypes/Package.swift
- bytes: 541
- lines: 27
- sha256: a760ef4ac3b83de683f4e5975b936853d70ba507c70eb1d1d82e31d18024992c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Package.swift -->
```swift
// swift-tools-version: 6.1
import PackageDescription

let package = Package(
    name: "PulsumTypes",
    platforms: [
        .iOS("26.0"),
        .macOS(.v14)
    ],
    products: [
        .library(
            name: "PulsumTypes",
            targets: ["PulsumTypes"]
        )
    ],
    targets: [
        .target(
            name: "PulsumTypes",
            path: "Sources"
        ),
        .testTarget(
            name: "PulsumTypesTests",
            dependencies: ["PulsumTypes"],
            path: "Tests"
        )
    ]
)
```
<!-- END_FILE: Packages/PulsumTypes/Package.swift -->

### Packages/PulsumTypes/Sources/PulsumTypes/AppRuntimeConfig.swift
- bytes: 2067
- lines: 73
- sha256: 4254510325f8acbaed808b60f63bd6f23917f95fed070843b69b455692b0931a
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Sources/PulsumTypes/AppRuntimeConfig.swift -->
```swift
import Foundation

public enum AppRuntimeConfig {
    public static let uiTestDefaultsSuite = "pulsum.uitest"

    private static var environment: [String: String] {
        ProcessInfo.processInfo.environment
    }

    private static var arguments: [String] {
        ProcessInfo.processInfo.arguments
    }

    public static var isUITesting: Bool {
        if arguments.contains("-ui_testing") {
            return true
        }
        return environment["UITEST"] == "1"
    }

    public static var disableAnimations: Bool {
        isUITesting || environment["UITEST_DISABLE_ANIMATIONS"] == "1"
    }

    public static var skipHeavyStartupWork: Bool {
        isUITesting || environment["UITEST_SKIP_STARTUP"] == "1"
    }

    public static var useStubLLM: Bool {
        isUITesting || environment["UITEST_USE_STUB_LLM"] == "1"
    }

    public static var disableKeychain: Bool {
        isUITesting || environment["UITEST_DISABLE_CLOUD_KEYCHAIN"] == "1"
    }

    public static var hideConsentBanner: Bool {
        environment["UITEST_HIDE_CONSENT_BANNER"] == "1"
    }

    public static var settingsHookEnabled: Bool {
        environment["UITEST_SETTINGS_HOOK"] == "1"
    }

    public static var forceSettingsFallback: Bool {
        environment["UITEST_FORCE_SETTINGS_FALLBACK"] == "1"
    }

    public static var captureSettingsURLs: Bool {
        environment["UITEST_CAPTURE_URLS"] == "1"
    }

    public static var useFakeSpeechBackend: Bool {
        environment["UITEST_FAKE_SPEECH"] == "1"
    }

    public static var autoGrantSpeechPermissions: Bool {
        environment["UITEST_AUTOGRANT"] == "1"
    }

    public static var uiTestDefaults: UserDefaults {
        UserDefaults(suiteName: uiTestDefaultsSuite) ?? .standard
    }

    public static var runtimeDefaults: UserDefaults {
        isUITesting ? uiTestDefaults : .standard
    }

    public static func synchronizeUITestDefaults() {
        guard isUITesting || disableKeychain else { return }
        CFPreferencesAppSynchronize(uiTestDefaultsSuite as CFString)
    }
}
```
<!-- END_FILE: Packages/PulsumTypes/Sources/PulsumTypes/AppRuntimeConfig.swift -->

### Packages/PulsumTypes/Sources/PulsumTypes/DebugLog.swift
- bytes: 1279
- lines: 50
- sha256: 8c55c17923a51bdbf8cfbfdad6567055523a99b172426439a2085a4e8e2684c6
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Sources/PulsumTypes/DebugLog.swift -->
```swift
import Foundation

public actor DebugLogBuffer {
    public static let shared = DebugLogBuffer()

    private var lines: [String] = []
    private let maxLines = 30_000
    private let formatter: ISO8601DateFormatter

    private init() {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        self.formatter = formatter
    }

    public func append(_ message: String) {
        let timestamp = formatter.string(from: Date())
        lines.append("[\(timestamp)] \(message)")
        if lines.count > maxLines {
            lines.removeFirst(lines.count - maxLines)
        }
    }

    public func appendFormattedLine(_ line: String) {
        lines.append(line)
        if lines.count > maxLines {
            lines.removeFirst(lines.count - maxLines)
        }
    }

    public func snapshot() -> String {
        lines.joined(separator: "\n")
    }

    public func tail(maxLines: Int) -> [String] {
        guard maxLines > 0 else { return [] }
        if lines.count <= maxLines { return lines }
        return Array(lines.suffix(maxLines))
    }

    public func clear() {
        lines.removeAll()
    }

#if DEBUG
    public func _testReset() {
        lines.removeAll()
    }
#endif
}
```
<!-- END_FILE: Packages/PulsumTypes/Sources/PulsumTypes/DebugLog.swift -->

### Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsLogger.swift
- bytes: 20058
- lines: 524
- sha256: 7eb446c53849cb265bf317e664c1a50b4afbab76695505023e5f067e50c774c8
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsLogger.swift -->
```swift
import Dispatch
import Foundation
import OSLog
import os.signpost

public enum Diagnostics {
    private static let sessionIdentifier = UUID()
    private static let subsystem = "com.pulsum"
    private static let signpostLogs: [DiagnosticsCategory: OSLog] = Dictionary(uniqueKeysWithValues: DiagnosticsCategory.allCases.map {
        ($0, OSLog(subsystem: subsystem, category: $0.rawValue))
    })

    public static var sessionId: UUID { sessionIdentifier }

    public static func log(level: DiagnosticsLevel,
                           category: DiagnosticsCategory,
                           name: String,
                           fields: [String: DiagnosticsValue] = [:],
                           traceId: UUID? = nil,
                           error: Error? = nil,
                           errorDomain: DiagnosticsSafeString? = nil,
                           errorCode: Int? = nil,
                           durationMs: Double? = nil) {
        let config = DiagnosticsConfigStore.current
        guard config.enabled, level >= config.minLevel else { return }
        let errorInfo = resolveError(error, fallbackDomain: errorDomain, fallbackCode: errorCode)
        let event = DiagnosticsEvent(timestamp: Date(),
                                     level: level,
                                     category: category,
                                     name: name,
                                     sessionId: sessionIdentifier,
                                     traceId: traceId,
                                     fields: fields,
                                     errorDomain: errorInfo.domain,
                                     errorCode: errorInfo.code,
                                     durationMs: durationMs)
        DiagnosticsLogger.enqueue(event: event, configSnapshot: config)
    }

    public static func span(category: DiagnosticsCategory,
                            name: String,
                            fields: [String: DiagnosticsValue] = [:],
                            traceId: UUID? = nil,
                            level: DiagnosticsLevel = .info) -> DiagnosticsSpanToken {
        let config = DiagnosticsConfigStore.current
        guard config.enabled, level >= config.minLevel else {
            return DiagnosticsSpanToken(isEnabled: false,
                                        category: category,
                                        name: name,
                                        traceId: traceId,
                                        baseFields: fields,
                                        signpostLog: nil,
                                        level: level)
        }
        let signpostLog = config.enableSignposts ? signpostLogs[category] : nil
        let token = DiagnosticsSpanToken(isEnabled: true,
                                         category: category,
                                         name: name,
                                         traceId: traceId,
                                         baseFields: fields,
                                         signpostLog: signpostLog,
                                         level: level)
        log(level: level, category: category, name: "\(name).begin", fields: fields, traceId: traceId)
        token.beginSignpost()
        return token
    }

    public static func measure<T>(category: DiagnosticsCategory,
                                  name: String,
                                  fields: [String: DiagnosticsValue] = [:],
                                  traceId: UUID? = nil,
                                  level: DiagnosticsLevel = .info,
                                  operation: @Sendable () async throws -> T) async rethrows -> T {
        let token = span(category: category,
                         name: name,
                         fields: fields,
                         traceId: traceId,
                         level: level)
        do {
            let result = try await operation()
            token.end(additionalFields: [:], error: nil)
            return result
        } catch {
            token.end(additionalFields: [:], error: error)
            throw error
        }
    }

    public static func updateConfig(_ config: DiagnosticsConfig) {
        DiagnosticsConfigStore.update(config)
        DiagnosticsLogger.updateConfig(config)
    }

    public static func currentConfig() -> DiagnosticsConfig {
        DiagnosticsConfigStore.current
    }

    public static func clearDiagnostics() async {
        await DebugLogBuffer.shared.clear()
        await DiagnosticsLogger.shared.clearPersistedLogs()
    }

    public static func persistedLogTail(maxLines: Int) async -> [String] {
        await DiagnosticsLogger.shared.persistedLogTail(maxLines: maxLines)
    }

    public static func flushPersistence() async {
        await DiagnosticsLogger.shared.flushPending()
    }

    private static func resolveError(_ error: Error?,
                                     fallbackDomain: DiagnosticsSafeString?,
                                     fallbackCode: Int?) -> (domain: DiagnosticsSafeString?, code: Int?) {
        if fallbackDomain != nil || fallbackCode != nil {
            return (fallbackDomain, fallbackCode)
        }
        guard let error else { return (nil, nil) }
        let nsError = error as NSError
        let allowlist: Set<String> = [
            NSCocoaErrorDomain,
            NSURLErrorDomain,
            NSPOSIXErrorDomain,
            NSOSStatusErrorDomain,
            "CMErrorDomain",
            "AVFoundationErrorDomain",
            "AVErrorDomain",
            "HKErrorDomain",
            "PulsumErrorDomain"
        ]
        let domain = DiagnosticsSafeString.stage(nsError.domain, allowed: allowlist)
        return (domain, nsError.code)
    }
}

public struct DiagnosticsSpanToken {
    private let isEnabled: Bool
    private let category: DiagnosticsCategory
    private let name: String
    private let traceId: UUID?
    private let baseFields: [String: DiagnosticsValue]
    private let start: ContinuousClock.Instant
    private let signpostID: OSSignpostID
    private let signpostLog: OSLog?
    private let level: DiagnosticsLevel

    init(isEnabled: Bool,
         category: DiagnosticsCategory,
         name: String,
         traceId: UUID?,
         baseFields: [String: DiagnosticsValue],
         signpostLog: OSLog?,
         level: DiagnosticsLevel) {
        self.isEnabled = isEnabled
        self.category = category
        self.name = name
        self.traceId = traceId
        self.baseFields = baseFields
        self.signpostID = OSSignpostID(log: signpostLog ?? OSLog.disabled)
        self.signpostLog = signpostLog
        self.level = level
        self.start = ContinuousClock().now
    }

    fileprivate func beginSignpost() {
        guard isEnabled, let signpostLog else { return }
        os_signpost(.begin,
                    log: signpostLog,
                    name: "diagnostics.span",
                    signpostID: signpostID,
                    "%{public}s",
                    name)
    }

    public func end(additionalFields: [String: DiagnosticsValue] = [:], error: Error?) {
        guard isEnabled else { return }
        let elapsed = ContinuousClock().now - start
        let millis = Double(elapsed.components.seconds) * 1_000 + Double(elapsed.components.attoseconds) / 1_000_000_000_000_000.0
        var mergedFields = baseFields
        additionalFields.forEach { mergedFields[$0.key] = $0.value }
        Diagnostics.log(level: error == nil ? level : .error,
                        category: category,
                        name: "\(name).end",
                        fields: mergedFields,
                        traceId: traceId,
                        error: error,
                        durationMs: millis)
        guard let signpostLog else { return }
        os_signpost(.end,
                    log: signpostLog,
                    name: "diagnostics.span",
                    signpostID: signpostID,
                    "event=%{public}s duration_ms=%{public}.3f",
                    name,
                    millis)
    }
}

public actor DiagnosticsStallMonitor {
    private let category: DiagnosticsCategory
    private let name: String
    private let traceId: UUID?
    private let threshold: TimeInterval
    private var lastHeartbeat: Date
    private var lastFields: [String: DiagnosticsValue]
    private var task: Task<Void, Never>?
    private var isActive = false

    public init(category: DiagnosticsCategory,
                name: String,
                traceId: UUID?,
                thresholdSeconds: TimeInterval,
                initialFields: [String: DiagnosticsValue] = [:]) {
        self.category = category
        self.name = name
        self.traceId = traceId
        self.threshold = thresholdSeconds
        self.lastHeartbeat = Date()
        self.lastFields = initialFields
    }

    deinit {
        task?.cancel()
    }

    public func heartbeat(progressFields: [String: DiagnosticsValue] = [:]) {
        lastHeartbeat = Date()
        progressFields.forEach { lastFields[$0.key] = $0.value }
    }

    public func start() {
        guard task == nil else { return }
        isActive = true
        let thresholdSeconds = threshold
        task = Task.detached(priority: .utility) { [weak self] in
            guard let self else { return }
            await self.monitorLoop(thresholdSeconds: thresholdSeconds)
        }
    }

    public func stop(finalFields: [String: DiagnosticsValue] = [:]) {
        isActive = false
        task?.cancel()
        task = nil
        finalFields.forEach { lastFields[$0.key] = $0.value }
    }

    private func monitorLoop(thresholdSeconds: TimeInterval) async {
        while !Task.isCancelled {
            try? await Task.sleep(nanoseconds: UInt64(thresholdSeconds * 500_000_000))
            await checkForStallIfActive()
            if !isActive {
                break
            }
        }
    }

    private func checkForStallIfActive() async {
        guard isActive else { return }
        let elapsed = Date().timeIntervalSince(lastHeartbeat)
        guard elapsed >= threshold else { return }
        Diagnostics.log(level: .warn,
                        category: category,
                        name: "\(name).stall",
                        fields: lastFields,
                        traceId: traceId,
                        durationMs: elapsed * 1_000)
        lastHeartbeat = Date()
    }
}

public actor DiagnosticsLogger {
    static let shared = DiagnosticsLogger()

    private var config: DiagnosticsConfig
    private let formatter: ISO8601DateFormatter
    private let subsystem = "com.pulsum"
    private let osLoggers: [DiagnosticsCategory: Logger]
    private var pendingLines: [String] = []
    private var pendingBytes: Int = 0
    private var flushTask: Task<Void, Never>?
    private let flushInterval: TimeInterval = 1.0
    private let logDirectoryURL: URL
    private var currentLogURL: URL?

    private init() {
        self.config = DiagnosticsConfigStore.current
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        self.formatter = formatter
        var loggerMap: [DiagnosticsCategory: Logger] = [:]
        for category in DiagnosticsCategory.allCases {
            loggerMap[category] = Logger(subsystem: subsystem, category: category.rawValue)
        }
        self.osLoggers = loggerMap
        self.logDirectoryURL = DiagnosticsLogger.makeDirectory()
    }

    nonisolated static func enqueue(event: DiagnosticsEvent, configSnapshot: DiagnosticsConfig) {
        Task.detached(priority: .utility) {
            await DiagnosticsLogger.shared.record(event: event, configSnapshot: configSnapshot)
        }
    }

    nonisolated static func updateConfig(_ config: DiagnosticsConfig) {
        Task.detached(priority: .utility) {
            await DiagnosticsLogger.shared.apply(config: config)
        }
    }

    func apply(config: DiagnosticsConfig) {
        self.config = config
    }

    func record(event: DiagnosticsEvent, configSnapshot: DiagnosticsConfig) async {
        self.config = configSnapshot
        let formatted = format(event: event)
        await DebugLogBuffer.shared.appendFormattedLine(formatted)

        if config.mirrorToOSLog {
            mirrorToOSLog(event: event)
        }

        if config.persistToDisk {
            await enqueueForPersistence(formatted)
        }
    }

    func flushPending() async {
        let lines = pendingLines
        pendingLines.removeAll()
        pendingBytes = 0
        flushTask?.cancel()
        flushTask = nil
        guard !lines.isEmpty else { return }
        await write(lines: lines)
    }

    func clearPersistedLogs() async {
        flushTask?.cancel()
        flushTask = nil
        pendingLines.removeAll()
        pendingBytes = 0
        try? FileManager.default.removeItem(at: logDirectoryURL)
        _ = DiagnosticsLogger.makeDirectory()
        currentLogURL = nil
    }

    func persistedLogTail(maxLines: Int) async -> [String] {
        await flushPending()
        let fileManager = FileManager.default
        guard let files = try? fileManager.contentsOfDirectory(at: logDirectoryURL, includingPropertiesForKeys: nil, options: [.skipsHiddenFiles]) else {
            return []
        }
        let candidates: [(index: Int, url: URL)] = files.compactMap { url in
            let name = url.lastPathComponent
            if name == "diagnostics.log" {
                return (0, url)
            }
            let prefix = "diagnostics.log."
            if name.hasPrefix(prefix), let index = Int(name.dropFirst(prefix.count)) {
                return (index, url)
            }
            return nil
        }
        let sorted = candidates.sorted {
            if $0.index == $1.index {
                return $0.url.path < $1.url.path
            }
            return $0.index > $1.index
        }

        var collected: [String] = []
        for (_, url) in sorted {
            guard let data = try? Data(contentsOf: url),
                  let content = String(data: data, encoding: .utf8) else { continue }
            let lines = content.split(separator: "\n").map(String.init)
            collected.append(contentsOf: lines)
        }
        if collected.count > maxLines {
            collected = Array(collected.suffix(maxLines))
        }
        return collected
    }

    private func format(event: DiagnosticsEvent) -> String {
        let timestamp = formatter.string(from: event.timestamp)
        var components: [String] = []
        components.append("[\(timestamp)]")
        components.append("[\(event.level.label)]")
        components.append("[\(event.category.rawValue)]")
        components.append(event.name)
        components.append("session=\(event.sessionId.uuidString)")
        if let traceId = event.traceId {
            components.append("trace=\(traceId.uuidString)")
        }

        var keyValues: [String: DiagnosticsValue] = event.fields
        if let duration = event.durationMs {
            keyValues["duration_ms"] = .double(duration)
        }
        if let errorDomain = event.errorDomain {
            keyValues["error_domain"] = .safeString(errorDomain)
        }
        if let errorCode = event.errorCode {
            keyValues["error_code"] = .int(errorCode)
        }

        for key in keyValues.keys.sorted() {
            if let value = keyValues[key] {
                components.append("\(key)=\(value.toDisplayString())")
            }
        }
        return components.joined(separator: " ")
    }

    private func mirrorToOSLog(event: DiagnosticsEvent) {
        let logger = osLoggers[event.category] ?? Logger(subsystem: subsystem, category: event.category.rawValue)
        let keyValuesSummary = event.fields
            .map { "\($0.key)=\($0.value.toDisplayString())" }
            .joined(separator: " ")
        logger.log(level: osLogType(for: event.level),
                   "\(event.name, privacy: .public) session=\(event.sessionId.uuidString, privacy: .public) trace=\(event.traceId?.uuidString ?? "none", privacy: .public) \(keyValuesSummary, privacy: .public)")
    }

    private func osLogType(for level: DiagnosticsLevel) -> OSLogType {
        switch level {
        case .debug: return .debug
        case .info: return .info
        case .warn: return .default
        case .error: return .error
        }
    }

    private func enqueueForPersistence(_ line: String) async {
        pendingLines.append(line)
        pendingBytes += line.utf8.count + 1
        let threshold = max(4096, config.maxFileBytes / 8)
        if pendingBytes >= threshold {
            await flushPending()
            return
        }
        scheduleFlushIfNeeded()
    }

    private func scheduleFlushIfNeeded() {
        guard flushTask == nil else { return }
        flushTask = Task.detached(priority: .utility) { [weak self] in
            try? await Task.sleep(nanoseconds: UInt64((self?.flushInterval ?? 1.0) * 1_000_000_000))
            await self?.flushPending()
        }
    }

    private func write(lines: [String]) async {
        let joined = lines.joined(separator: "\n") + "\n"
        guard let data = joined.data(using: .utf8) else { return }
        do {
            try rotateIfNeeded(addingBytes: data.count)
            let url = try ensureLogFile()
            if let handle = try? FileHandle(forWritingTo: url) {
                try handle.seekToEnd()
                try handle.write(contentsOf: data)
                try handle.close()
            } else {
                try data.write(to: url, options: [.atomic])
            }
        } catch {
            // Persisted logging is best-effort; intentionally swallow errors.
        }
    }

    private func ensureLogFile() throws -> URL {
        if let currentLogURL {
            return currentLogURL
        }
        let url = logDirectoryURL.appendingPathComponent("diagnostics.log")
        if !FileManager.default.fileExists(atPath: url.path) {
            FileManager.default.createFile(atPath: url.path, contents: nil)
            Self.applySecurityAttributes(to: url)
        }
        currentLogURL = url
        return url
    }

    private func rotateIfNeeded(addingBytes: Int) throws {
        let url = try ensureLogFile()
        let currentSize = (try? FileManager.default.attributesOfItem(atPath: url.path)[.size] as? Int) ?? 0
        guard currentSize + addingBytes > config.maxFileBytes else { return }
        let fm = FileManager.default
        for index in stride(from: config.maxFiles - 1, through: 1, by: -1) {
            let source = logDirectoryURL.appendingPathComponent("diagnostics.log.\(index)")
            let target = logDirectoryURL.appendingPathComponent("diagnostics.log.\(index + 1)")
            if fm.fileExists(atPath: target.path) {
                try? fm.removeItem(at: target)
            }
            if fm.fileExists(atPath: source.path) {
                try? fm.moveItem(at: source, to: target)
            }
        }
        let rotated = logDirectoryURL.appendingPathComponent("diagnostics.log.1")
        try? fm.removeItem(at: rotated)
        if fm.fileExists(atPath: url.path) {
            try fm.moveItem(at: url, to: rotated)
        }
        currentLogURL = nil
    }

    nonisolated static func applySecurityAttributes(to url: URL) {
#if os(iOS)
        try? FileManager.default.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: url.path)
#endif
        var resourceValues = URLResourceValues()
        resourceValues.isExcludedFromBackup = true
        var mutableURL = url
        try? mutableURL.setResourceValues(resourceValues)
    }

    nonisolated static func diagnosticsDirectory() -> URL {
        makeDirectory()
    }

    private static func makeDirectory() -> URL {
        DiagnosticsPaths.logsDirectory()
    }
}
```
<!-- END_FILE: Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsLogger.swift -->

### Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsPaths.swift
- bytes: 1212
- lines: 32
- sha256: e94b48f09ca0bf3faf971147f54c5a9c7817354cc2d6d2feb009d0e197fed672
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsPaths.swift -->
```swift
import Foundation

enum DiagnosticsPaths {
    static func baseDirectory() -> URL {
        let fm = FileManager.default
        let base = fm.urls(for: .applicationSupportDirectory, in: .userDomainMask).first ?? fm.temporaryDirectory
        let diagnosticsDir = base.appendingPathComponent("Diagnostics", isDirectory: true)
        return ensureDirectory(at: diagnosticsDir)
    }

    static func logsDirectory() -> URL {
        let logsDir = baseDirectory().appendingPathComponent("Logs", isDirectory: true)
        return ensureDirectory(at: logsDir)
    }

    static func exportsDirectory() -> URL {
        let exportsDir = baseDirectory().appendingPathComponent("Exports", isDirectory: true)
        return ensureDirectory(at: exportsDir)
    }

    private static func ensureDirectory(at url: URL) -> URL {
        let fm = FileManager.default
        if !fm.fileExists(atPath: url.path) {
            try? fm.createDirectory(at: url, withIntermediateDirectories: true)
        }
        var resourceValues = URLResourceValues()
        resourceValues.isExcludedFromBackup = true
        var mutableURL = url
        try? mutableURL.setResourceValues(resourceValues)
        return mutableURL
    }
}
```
<!-- END_FILE: Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsPaths.swift -->

### Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsReport.swift
- bytes: 6190
- lines: 149
- sha256: 49b61ab3093e301ea84ada8b55c514131cc0c7f7c8e87deb5aeb7e279489417f
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsReport.swift -->
```swift
import Foundation

public struct DiagnosticsReportContext: Sendable {
    public let appVersion: String
    public let buildNumber: String
    public let deviceModel: String
    public let osVersion: String
    public let locale: String
    public let sessionId: UUID
    public let diagnosticsEnabled: Bool
    public let persistenceEnabled: Bool
    public let sessionsIncluded: [String]?

    public init(appVersion: String,
                buildNumber: String,
                deviceModel: String,
                osVersion: String,
                locale: String,
                sessionId: UUID,
                diagnosticsEnabled: Bool,
                persistenceEnabled: Bool,
                sessionsIncluded: [String]? = nil) {
        self.appVersion = appVersion
        self.buildNumber = buildNumber
        self.deviceModel = deviceModel
        self.osVersion = osVersion
        self.locale = locale
        self.sessionId = sessionId
        self.diagnosticsEnabled = diagnosticsEnabled
        self.persistenceEnabled = persistenceEnabled
        self.sessionsIncluded = sessionsIncluded
    }
}

public struct DiagnosticsSnapshot: Sendable {
    public var healthGrantedCount: Int?
    public var healthDeniedCount: Int?
    public var healthPendingCount: Int?
    public var healthAvailability: DiagnosticsSafeString?
    public var embeddingsAvailable: Bool?
    public var pendingJournalsCount: Int?
    public var backfillWarmCompleted: Int?
    public var backfillFullCompleted: Int?
    public var deferredLibraryImport: Bool?
    public var lastSnapshotDay: String?
    public var wellbeingScore: Double?

    public init(healthGrantedCount: Int? = nil,
                healthDeniedCount: Int? = nil,
                healthPendingCount: Int? = nil,
                healthAvailability: DiagnosticsSafeString? = nil,
                embeddingsAvailable: Bool? = nil,
                pendingJournalsCount: Int? = nil,
                backfillWarmCompleted: Int? = nil,
                backfillFullCompleted: Int? = nil,
                deferredLibraryImport: Bool? = nil,
                lastSnapshotDay: String? = nil,
                wellbeingScore: Double? = nil) {
        self.healthGrantedCount = healthGrantedCount
        self.healthDeniedCount = healthDeniedCount
        self.healthPendingCount = healthPendingCount
        self.healthAvailability = healthAvailability
        self.embeddingsAvailable = embeddingsAvailable
        self.pendingJournalsCount = pendingJournalsCount
        self.backfillWarmCompleted = backfillWarmCompleted
        self.backfillFullCompleted = backfillFullCompleted
        self.deferredLibraryImport = deferredLibraryImport
        self.lastSnapshotDay = lastSnapshotDay
        self.wellbeingScore = wellbeingScore
    }
}

public enum DiagnosticsReportBuilder {
    public static func buildReport(context: DiagnosticsReportContext,
                                   snapshot: DiagnosticsSnapshot,
                                   logTail: [String]) throws -> URL {
        let timestamp = ISO8601DateFormatter().string(from: Date())
        var sections: [String] = []
        sections.append("Pulsum Diagnostics Report")
        sections.append("Generated: \(timestamp)")
        sections.append("")
        sections.append("[Header]")
        sections.append("app_version=\(context.appVersion)")
        sections.append("build_number=\(context.buildNumber)")
        sections.append("device_model=\(context.deviceModel)")
        sections.append("os_version=\(context.osVersion)")
        sections.append("locale=\(context.locale)")
        sections.append("session_id=\(context.sessionId.uuidString)")
        sections.append("diagnostics_enabled=\(context.diagnosticsEnabled)")
        sections.append("persistence_enabled=\(context.persistenceEnabled)")
        if let sessions = context.sessionsIncluded, !sessions.isEmpty {
            sections.append("sessions_included=\(sessions.joined(separator: ","))")
        }

        sections.append("")
        sections.append("[Snapshot]")
        if let granted = snapshot.healthGrantedCount {
            sections.append("health_granted=\(granted)")
        }
        if let denied = snapshot.healthDeniedCount {
            sections.append("health_denied=\(denied)")
        }
        if let pending = snapshot.healthPendingCount {
            sections.append("health_pending=\(pending)")
        }
        if let availability = snapshot.healthAvailability {
            sections.append("health_availability=\(availability.value)")
        }
        if let available = snapshot.embeddingsAvailable {
            sections.append("embeddings_available=\(available)")
        }
        if let pending = snapshot.pendingJournalsCount {
            sections.append("pending_journals_count=\(pending)")
        }
        if let warm = snapshot.backfillWarmCompleted {
            sections.append("backfill_warm_completed_types=\(warm)")
        }
        if let full = snapshot.backfillFullCompleted {
            sections.append("backfill_full_completed_types=\(full)")
        }
        if let deferred = snapshot.deferredLibraryImport {
            sections.append("deferred_library_import=\(deferred)")
        }
        if let day = snapshot.lastSnapshotDay {
            sections.append("last_snapshot_day=\(day)")
        }
        if let score = snapshot.wellbeingScore {
            sections.append(String(format: "last_wellbeing_score=%.3f", score))
        }

        sections.append("")
        sections.append("[Logs]")
        if logTail.isEmpty {
            sections.append("No diagnostics captured yet.")
        } else {
            sections.append(contentsOf: logTail)
        }

        let content = sections.joined(separator: "\n")
        let directory = DiagnosticsPaths.exportsDirectory()
        let url = directory.appendingPathComponent("PulsumDiagnostics-Latest.txt")
        guard let data = content.data(using: .utf8) else {
            throw NSError(domain: "PulsumDiagnostics", code: -1)
        }
        try data.write(to: url, options: .atomic)
        DiagnosticsLogger.applySecurityAttributes(to: url)
        return url
    }
}
```
<!-- END_FILE: Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsReport.swift -->

### Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsTypes.swift
- bytes: 8588
- lines: 251
- sha256: 8b2450f77b5e3a8a152c4c564a729e7026cafaefe8106afb667e84ef0ff968be
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsTypes.swift -->
```swift
import Foundation

public enum DiagnosticsLevel: Int, Codable, Comparable, Sendable {
    case debug = 0
    case info = 1
    case warn = 2
    case error = 3

    public static func < (lhs: DiagnosticsLevel, rhs: DiagnosticsLevel) -> Bool {
        lhs.rawValue < rhs.rawValue
    }

    var label: String {
        switch self {
        case .debug: return "DEBUG"
        case .info: return "INFO"
        case .warn: return "WARN"
        case .error: return "ERROR"
        }
    }
}

public enum DiagnosticsCategory: String, Codable, CaseIterable, Sendable {
    case app
    case ui
    case orchestrator
    case healthkit
    case dataAgent
    case backfill
    case embeddings
    case sentiment
    case library
    case vectorIndex
    case coach
    case llm
    case speech
    case safety
    case persistence
}

public struct DiagnosticsSafeString: Codable, Sendable, Hashable {
    public let value: String

    private init(_ value: String) {
        self.value = value
    }

    public static func literal(_ value: StaticString) -> DiagnosticsSafeString {
        DiagnosticsSafeString(String(describing: value))
    }

    public static func enumCase<T: RawRepresentable>(_ value: T) -> DiagnosticsSafeString where T.RawValue == String {
        DiagnosticsSafeString(value.rawValue)
    }

    public static func stage(_ value: String, allowed: Set<String>) -> DiagnosticsSafeString {
        guard allowed.contains(value) else { return .redacted() }
        return DiagnosticsSafeString(value)
    }

    public static func metadata(_ value: String, maxLength: Int = 48) -> DiagnosticsSafeString {
        let trimmed = value.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return .redacted() }
        let allowed = CharacterSet(charactersIn: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._-+")
        let filteredScalars = trimmed.unicodeScalars.filter { allowed.contains($0) }
        guard filteredScalars.count == trimmed.unicodeScalars.count else { return .redacted() }
        guard !filteredScalars.isEmpty else { return .redacted() }
        let limited = String(String.UnicodeScalarView(filteredScalars).prefix(maxLength))
        return DiagnosticsSafeString(limited)
    }

    public static func redacted() -> DiagnosticsSafeString {
        DiagnosticsSafeString("<redacted>")
    }
}

public enum DiagnosticsValue: Codable, Sendable, Hashable {
    case int(Int)
    case double(Double)
    case bool(Bool)
    case safeString(DiagnosticsSafeString)
    case day(String)
    case uuid(UUID)

    public static func day(_ date: Date) -> DiagnosticsValue {
        .day(DiagnosticsDayFormatter.dayString(from: date))
    }

    public func toDisplayString() -> String {
        switch self {
        case .int(let value): return String(value)
        case .double(let value): return String(format: "%.3f", value)
        case .bool(let value): return value ? "true" : "false"
        case .safeString(let value): return value.value
        case .day(let value): return value
        case .uuid(let value): return value.uuidString
        }
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case value
    }

    private enum ValueType: String, Codable {
        case int
        case double
        case bool
        case safeString
        case day
        case uuid
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(ValueType.self, forKey: .type)
        switch type {
        case .int:
            self = .int(try container.decode(Int.self, forKey: .value))
        case .double:
            self = .double(try container.decode(Double.self, forKey: .value))
        case .bool:
            self = .bool(try container.decode(Bool.self, forKey: .value))
        case .safeString:
            self = .safeString(try container.decode(DiagnosticsSafeString.self, forKey: .value))
        case .day:
            self = .day(try container.decode(String.self, forKey: .value))
        case .uuid:
            self = .uuid(try container.decode(UUID.self, forKey: .value))
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case .int(let value):
            try container.encode(ValueType.int, forKey: .type)
            try container.encode(value, forKey: .value)
        case .double(let value):
            try container.encode(ValueType.double, forKey: .type)
            try container.encode(value, forKey: .value)
        case .bool(let value):
            try container.encode(ValueType.bool, forKey: .type)
            try container.encode(value, forKey: .value)
        case .safeString(let value):
            try container.encode(ValueType.safeString, forKey: .type)
            try container.encode(value, forKey: .value)
        case .day(let value):
            try container.encode(ValueType.day, forKey: .type)
            try container.encode(value, forKey: .value)
        case .uuid(let value):
            try container.encode(ValueType.uuid, forKey: .type)
            try container.encode(value, forKey: .value)
        }
    }
}

public struct DiagnosticsEvent: Codable, Sendable, Hashable {
    public let timestamp: Date
    public let level: DiagnosticsLevel
    public let category: DiagnosticsCategory
    public let name: String
    public let sessionId: UUID
    public let traceId: UUID?
    public let fields: [String: DiagnosticsValue]
    public let errorDomain: DiagnosticsSafeString?
    public let errorCode: Int?
    public let durationMs: Double?

    enum CodingKeys: String, CodingKey {
        case timestamp = "ts"
        case level
        case category
        case name
        case sessionId = "session_id"
        case traceId = "trace_id"
        case fields
        case errorDomain = "error_domain"
        case errorCode = "error_code"
        case durationMs = "duration_ms"
    }
}

public struct DiagnosticsConfig: Codable, Equatable, Sendable {
    public var enabled: Bool
    public var minLevel: DiagnosticsLevel
    public var persistToDisk: Bool
    public var mirrorToOSLog: Bool
    public var enableSignposts: Bool
    public var maxFileBytes: Int
    public var maxFiles: Int
    public var logTailLinesForExport: Int

    public static func `default`() -> DiagnosticsConfig {
#if DEBUG
        return DiagnosticsConfig(enabled: true,
                                 minLevel: .debug,
                                 persistToDisk: true,
                                 mirrorToOSLog: true,
                                 enableSignposts: true,
                                 maxFileBytes: 3_000_000,
                                 maxFiles: 3,
                                 logTailLinesForExport: 2_000)
#else
        return DiagnosticsConfig(enabled: true,
                                 minLevel: .info,
                                 persistToDisk: true,
                                 mirrorToOSLog: true,
                                 enableSignposts: true,
                                 maxFileBytes: 3_000_000,
                                 maxFiles: 3,
                                 logTailLinesForExport: 2_000)
#endif
    }
}

public enum DiagnosticsConfigStore {
    private static let defaultsKey = "ai.pulsum.diagnostics.config"

    public static var current: DiagnosticsConfig {
        loadFromDefaults() ?? DiagnosticsConfig.default()
    }

    public static func update(_ config: DiagnosticsConfig) {
        persist(config)
    }

    private static func loadFromDefaults() -> DiagnosticsConfig? {
        guard let data = UserDefaults.standard.data(forKey: defaultsKey) else { return nil }
        return try? JSONDecoder().decode(DiagnosticsConfig.self, from: data)
    }

    private static func persist(_ config: DiagnosticsConfig) {
        guard let data = try? JSONEncoder().encode(config) else { return }
        UserDefaults.standard.set(data, forKey: defaultsKey)
    }
}

public enum DiagnosticsDayFormatter {
    private static let formatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.timeZone = TimeZone(secondsFromGMT: 0)
        return formatter
    }()

    public static func dayString(from date: Date) -> String {
        formatter.string(from: date)
    }
}
```
<!-- END_FILE: Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsTypes.swift -->

### Packages/PulsumTypes/Sources/PulsumTypes/Notifications.swift
- bytes: 393
- lines: 11
- sha256: 33cc102c79f42140e253b39bbaba8186d9a67570fae85d7155f852e83c3e07ac
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Sources/PulsumTypes/Notifications.swift -->
```swift
import Foundation

public extension Notification.Name {
    static let pulsumScoresUpdated = Notification.Name("pulsumScoresUpdated")
    static let pulsumChatRouteDiagnostics = Notification.Name("com.pulsum.chatRouteDiagnostics")
    static let pulsumChatCloudError = Notification.Name("com.pulsum.chatCloudError")
}

public enum AgentNotificationKeys {
    public static let date = "date"
}
```
<!-- END_FILE: Packages/PulsumTypes/Sources/PulsumTypes/Notifications.swift -->

### Packages/PulsumTypes/Sources/PulsumTypes/SpeechTypes.swift
- bytes: 360
- lines: 13
- sha256: 6ad871ea564b2e7fb071d7549cfcd61456c408c6606bd3e30e9f73dd711998ea
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Sources/PulsumTypes/SpeechTypes.swift -->
```swift
import Foundation

public struct SpeechSegment: Sendable, Equatable {
    public let transcript: String
    public let isFinal: Bool
    public let confidence: Float?

    public init(transcript: String, isFinal: Bool, confidence: Float? = nil) {
        self.transcript = transcript
        self.isFinal = isFinal
        self.confidence = confidence
    }
}
```
<!-- END_FILE: Packages/PulsumTypes/Sources/PulsumTypes/SpeechTypes.swift -->

### Packages/PulsumTypes/Sources/PulsumTypes/Timeout.swift
- bytes: 3153
- lines: 103
- sha256: f8baae150f75393eae0a0230fc0f5cdc38c8842567342c396b5c0b8fba0b5abd
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Sources/PulsumTypes/Timeout.swift -->
```swift
import Foundation

public enum HardTimeoutResult<T: Sendable>: Sendable {
    case value(T)
    case timedOut
}

public enum HardTimeoutError: LocalizedError, Sendable {
    case timedOut(seconds: Double)

    public var errorDescription: String? {
        switch self {
        case .timedOut(let seconds):
            return String(format: "Operation timed out after %.3f seconds.", seconds)
        }
    }
}

/// Runs `operation` with a hard timeout that returns immediately once the timeout elapses.
/// The underlying task is cancelled on timeout, but the caller does not wait for it to finish,
/// so non-cooperative tasks cannot stall the caller.
public func withHardTimeout<T: Sendable>(seconds: Double,
                                         operation: @escaping @Sendable () async throws -> T) async throws -> HardTimeoutResult<T> {
    let deadlineNanos = UInt64(max(0, seconds) * 1_000_000_000)
    return try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<HardTimeoutResult<T>, Error>) in
        let coordinator = HardTimeoutCoordinator(continuation: continuation)

        let operationTask = Task { @Sendable in
            do {
                let value = try await operation()
                coordinator.resumeValue(value)
            } catch is CancellationError {
                coordinator.resumeCancellation()
            } catch {
                coordinator.resumeError(error)
            }
        }
        coordinator.setOperationTask(operationTask)

        Task { @Sendable in
            try? await Task.sleep(nanoseconds: deadlineNanos)
            coordinator.resumeTimeout()
        }
    }
}

private final class HardTimeoutCoordinator<T: Sendable>: @unchecked Sendable {
    private let lock = NSLock()
    private var finished = false
    private var operationTask: Task<Void, Never>?
    private let continuation: CheckedContinuation<HardTimeoutResult<T>, Error>

    init(continuation: CheckedContinuation<HardTimeoutResult<T>, Error>) {
        self.continuation = continuation
    }

    func setOperationTask(_ task: Task<Void, Never>) {
        lock.lock()
        operationTask = task
        lock.unlock()
    }

    func resumeValue(_ value: T) {
        guard markFinished() else { return }
        continuation.resume(returning: .value(value))
    }

    func resumeError(_ error: Error) {
        guard markFinished() else { return }
        continuation.resume(throwing: error)
    }

    func resumeCancellation() {
        guard markFinished() else { return }
        continuation.resume(throwing: CancellationError())
    }

    func resumeTimeout() {
        let task: Task<Void, Never>?
        lock.lock()
        if finished {
            task = nil
            lock.unlock()
            return
        }
        finished = true
        task = operationTask
        lock.unlock()

        task?.cancel()
        continuation.resume(returning: .timedOut)
    }

    private func markFinished() -> Bool {
        lock.lock()
        defer { lock.unlock() }
        if finished {
            return false
        }
        finished = true
        return true
    }
}
```
<!-- END_FILE: Packages/PulsumTypes/Sources/PulsumTypes/Timeout.swift -->

### Packages/PulsumTypes/Sources/PulsumTypes/WellbeingSnapshotKind.swift
- bytes: 105
- lines: 5
- sha256: a905c5b83889aadf510f28512d362a734f98494d5a9be0253658d975cca4af41
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Sources/PulsumTypes/WellbeingSnapshotKind.swift -->
```swift
public enum WellbeingSnapshotKind: String, Sendable {
    case none
    case placeholder
    case real
}
```
<!-- END_FILE: Packages/PulsumTypes/Sources/PulsumTypes/WellbeingSnapshotKind.swift -->

### Packages/PulsumTypes/Tests/DiagnosticsLoggerTests.swift
- bytes: 9748
- lines: 187
- sha256: 36ed2b0bf959e9ab9c147ade9eb82d1ed94136a72d119d1fcd6dacafd74c2e91
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Tests/DiagnosticsLoggerTests.swift -->
```swift
import XCTest
@testable import PulsumTypes

final class DiagnosticsLoggerTests: XCTestCase {

    override func setUp() async throws {
        await Diagnostics.clearDiagnostics()
        #if DEBUG
        await DebugLogBuffer.shared._testReset()
        #else
        await DebugLogBuffer.shared.clear()
        #endif
        let exportsDir = DiagnosticsPaths.exportsDirectory()
        try? FileManager.default.removeItem(at: exportsDir)
        _ = DiagnosticsPaths.exportsDirectory()
        var config = DiagnosticsConfig.default()
        config.enabled = true
        config.persistToDisk = true
        config.mirrorToOSLog = false
        config.enableSignposts = false
        config.maxFileBytes = 512
        config.maxFiles = 2
        config.logTailLinesForExport = 50
        Diagnostics.updateConfig(config)
    }

    func testFormattedLogIncludesSessionAndCategory() async throws {
        Diagnostics.log(level: .info,
                        category: .app,
                        name: "test.event",
                        fields: ["count": .int(1)])
        try await Task.sleep(nanoseconds: 200_000_000)
        let snapshot = await DebugLogBuffer.shared.snapshot()
        XCTAssertTrue(snapshot.contains("test.event"))
        XCTAssertTrue(snapshot.contains("session="))
        XCTAssertTrue(snapshot.contains("[app]"))
    }

    func testRotationRespectsMaxFilesAndBackupExclusion() async throws {
        await Diagnostics.clearDiagnostics()
        var config = Diagnostics.currentConfig()
        config.persistToDisk = true
        config.mirrorToOSLog = false
        config.enableSignposts = false
        config.maxFileBytes = 200
        config.maxFiles = 2
        Diagnostics.updateConfig(config)

        for idx in 0..<25 {
            Diagnostics.log(level: .info,
                            category: .app,
                            name: "rotate.event",
                            fields: ["idx": .int(idx)])
        }
        try await Task.sleep(nanoseconds: 400_000_000)
        await Diagnostics.flushPersistence()

        let diagnosticsDir = DiagnosticsPaths.logsDirectory()
        let files = try FileManager.default.contentsOfDirectory(at: diagnosticsDir, includingPropertiesForKeys: [.isExcludedFromBackupKey], options: [.skipsHiddenFiles])
        let logFiles = files.filter { $0.lastPathComponent.hasPrefix("diagnostics.log") }
        XCTAssertLessThanOrEqual(logFiles.count, 2)
        if let primary = logFiles.first(where: { $0.lastPathComponent == "diagnostics.log" }) {
            let values = try primary.resourceValues(forKeys: [.isExcludedFromBackupKey])
            XCTAssertEqual(values.isExcludedFromBackup, true)
        }
    }

    func testExportReportContainsHeaderAndSnapshot() throws {
        let context = DiagnosticsReportContext(appVersion: "1.0.0",
                                               buildNumber: "100",
                                               deviceModel: "TestDevice",
                                               osVersion: "17.0",
                                               locale: "en_US",
                                               sessionId: UUID(uuidString: "00000000-0000-0000-0000-000000000001")!,
                                               diagnosticsEnabled: true,
                                               persistenceEnabled: true,
                                               sessionsIncluded: nil)
        let snapshot = DiagnosticsSnapshot(healthGrantedCount: 2,
                                           healthDeniedCount: 1,
                                           healthPendingCount: 0,
                                           healthAvailability: DiagnosticsSafeString.stage("available", allowed: ["available", "unavailable"]),
                                           embeddingsAvailable: true,
                                           pendingJournalsCount: 0,
                                           backfillWarmCompleted: 2,
                                           backfillFullCompleted: 1,
                                           deferredLibraryImport: false,
                                           lastSnapshotDay: "2025-10-10",
                                           wellbeingScore: 0.75)
        let url = try DiagnosticsReportBuilder.buildReport(context: context,
                                                           snapshot: snapshot,
                                                           logTail: ["sample log"])
        let contents = try String(contentsOf: url)
        XCTAssertTrue(contents.contains("Pulsum Diagnostics Report"))
        XCTAssertTrue(contents.contains("app_version=1.0.0"))
        XCTAssertTrue(contents.contains("health_granted=2"))
        XCTAssertTrue(contents.contains("last_snapshot_day=2025-10-10"))
        XCTAssertTrue(contents.contains("sample log"))
        let exportsDir = DiagnosticsPaths.exportsDirectory()
        XCTAssertEqual(url.deletingLastPathComponent(), exportsDir)
        let values = try url.resourceValues(forKeys: [.isExcludedFromBackupKey])
        XCTAssertEqual(values.isExcludedFromBackup, true)
#if os(iOS)
        let attributes = try FileManager.default.attributesOfItem(atPath: url.path)
        let protection = attributes[.protectionKey] as? FileProtectionType
        XCTAssertEqual(protection, .complete)
#endif
    }

    func testForbiddenSubstringNotLeaked() async throws {
        await Diagnostics.clearDiagnostics()
        #if DEBUG
        await DebugLogBuffer.shared._testReset()
        #else
        await DebugLogBuffer.shared.clear()
        #endif
        let unsafe = "USER ENTERED FREE TEXT 1234"
        let compact = unsafe.replacingOccurrences(of: " ", with: "")
        let alphanumericsOnly = unsafe.unicodeScalars
            .filter { CharacterSet.alphanumerics.contains($0) }
            .map { String($0) }
            .joined()
        Diagnostics.log(level: .info,
                        category: .app,
                        name: "test.forbidden",
                        fields: ["unsafe": .safeString(.metadata(unsafe))])
        try await Task.sleep(nanoseconds: 300_000_000)
        await Diagnostics.flushPersistence()

        let snapshot = await DebugLogBuffer.shared.snapshot()
        XCTAssertTrue(snapshot.contains("<redacted>"))
        XCTAssertFalse(snapshot.lowercased().contains(unsafe.lowercased()))
        XCTAssertFalse(snapshot.lowercased().contains(compact.lowercased()))
        XCTAssertFalse(snapshot.lowercased().contains(alphanumericsOnly.lowercased()))

        let diagnosticsDir = DiagnosticsPaths.logsDirectory()
        if let content = try? String(contentsOf: diagnosticsDir.appendingPathComponent("diagnostics.log")) {
            let haystack = content.lowercased()
            XCTAssertFalse(haystack.contains(unsafe.lowercased()))
            XCTAssertFalse(haystack.contains(compact.lowercased()))
            XCTAssertFalse(haystack.contains(alphanumericsOnly.lowercased()))
        }
    }

    func testPersistedTailOrdersOldestToNewestIgnoringExports() async throws {
        let logsDir = DiagnosticsPaths.logsDirectory()
        try? FileManager.default.removeItem(at: logsDir)
        _ = DiagnosticsPaths.logsDirectory()

        let log2 = logsDir.appendingPathComponent("diagnostics.log.2")
        let log1 = logsDir.appendingPathComponent("diagnostics.log.1")
        let log0 = logsDir.appendingPathComponent("diagnostics.log")
        try "old-1\nold-2\n".write(to: log2, atomically: true, encoding: .utf8)
        try "mid-1\n".write(to: log1, atomically: true, encoding: .utf8)
        try "new-1\nnew-2\n".write(to: log0, atomically: true, encoding: .utf8)

        let unrelated = logsDir.appendingPathComponent("PulsumDiagnostics-Old.txt")
        try "should-be-ignored".write(to: unrelated, atomically: true, encoding: .utf8)

        let tail = await Diagnostics.persistedLogTail(maxLines: 10)
        XCTAssertEqual(tail, ["old-1", "old-2", "mid-1", "new-1", "new-2"])
        XCTAssertFalse(tail.contains("should-be-ignored"))
    }

    func testExportReportOverwritesLatestInExportsDirectory() throws {
        let context = DiagnosticsReportContext(appVersion: "1.0.0",
                                               buildNumber: "100",
                                               deviceModel: "TestDevice",
                                               osVersion: "17.0",
                                               locale: "en_US",
                                               sessionId: UUID(uuidString: "00000000-0000-0000-0000-000000000001")!,
                                               diagnosticsEnabled: true,
                                               persistenceEnabled: true,
                                               sessionsIncluded: nil)
        let firstURL = try DiagnosticsReportBuilder.buildReport(context: context,
                                                                snapshot: DiagnosticsSnapshot(),
                                                                logTail: ["first-log-line"])
        let secondURL = try DiagnosticsReportBuilder.buildReport(context: context,
                                                                 snapshot: DiagnosticsSnapshot(),
                                                                 logTail: ["second-log-line"])
        XCTAssertEqual(firstURL, secondURL)
        let exportsDir = DiagnosticsPaths.exportsDirectory()
        XCTAssertEqual(secondURL.deletingLastPathComponent(), exportsDir)
        let contents = try String(contentsOf: secondURL)
        XCTAssertTrue(contents.contains("second-log-line"))
        XCTAssertFalse(contents.contains("first-log-line"))
    }
}
```
<!-- END_FILE: Packages/PulsumTypes/Tests/DiagnosticsLoggerTests.swift -->

### Packages/PulsumTypes/Tests/PulsumTypesTests/TimeoutTests.swift
- bytes: 1071
- lines: 33
- sha256: bc5c76b1be57aab654320be4196c00a6a169b0c22128f76c14d2c52dae07ee1e
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumTypes/Tests/PulsumTypesTests/TimeoutTests.swift -->
```swift
import XCTest
@testable import PulsumTypes

final class TimeoutTests: XCTestCase {
    func testHardTimeoutReturnsTimedOutWithinBudget() async throws {
        let start = Date()
        let result = try await withHardTimeout(seconds: 0.2) {
            try await Task.sleep(nanoseconds: 2_000_000_000) // deliberately longer than timeout
            return "done"
        }
        let elapsed = Date().timeIntervalSince(start)
        XCTAssertLessThan(elapsed, 1.0, "Timeout should return promptly")
        switch result {
        case .timedOut:
            break
        case .value:
            XCTFail("Expected timeout, got value")
        }
    }

    func testHardTimeoutPropagatesValueWhenWithinBudget() async throws {
        let result = try await withHardTimeout(seconds: 1.0) {
            try await Task.sleep(nanoseconds: 50_000_000)
            return 42
        }
        switch result {
        case .value(let value):
            XCTAssertEqual(value, 42)
        case .timedOut:
            XCTFail("Expected value, got timeout")
        }
    }
}
```
<!-- END_FILE: Packages/PulsumTypes/Tests/PulsumTypesTests/TimeoutTests.swift -->

### Packages/PulsumUI/Package.swift
- bytes: 982
- lines: 41
- sha256: 67ed05d1a82b47c605f660a245fab620a051da573bd209459a4e0cd0cc0556c3
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Package.swift -->
```swift
// swift-tools-version: 6.1
import PackageDescription

let package = Package(
    name: "PulsumUI",
    platforms: [
        .iOS("26.0")
    ],
    products: [
        .library(
            name: "PulsumUI",
            targets: ["PulsumUI"]
        )
    ],
    dependencies: [
        .package(path: "../PulsumAgents"),
        .package(path: "../PulsumData"),
        .package(path: "../PulsumServices"),
        .package(path: "../PulsumTypes")
    ],
    targets: [
        .target(
            name: "PulsumUI",
            dependencies: [
                "PulsumAgents",
                "PulsumData",
                "PulsumServices",
                "PulsumTypes"
            ],
            path: "Sources",
            resources: [
                .process("PulsumUI/PrivacyInfo.xcprivacy")
            ]
        ),
        .testTarget(
            name: "PulsumUITests",
            dependencies: ["PulsumUI", "PulsumAgents"],
            path: "Tests"
        )
    ]
)
```
<!-- END_FILE: Packages/PulsumUI/Package.swift -->

### Packages/PulsumUI/Sources/PulsumUI/AppViewModel.swift
- bytes: 22565
- lines: 546
- sha256: fe781bd20bf1c0258b1f701cdad68c5a5d0b1997c172940c28002b8ecb47bb1c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/AppViewModel.swift -->
```swift
import Foundation
import CoreData
import Observation
import PulsumAgents
import PulsumData
import PulsumTypes
#if canImport(HealthKit)
import HealthKit
#endif
#if canImport(UIKit)
import UIKit
#endif

@MainActor
@Observable
final class AppViewModel {
    enum StartupState: Equatable {
        case idle
        case loading
        case ready
        case failed(String)
        case blocked(String)
    }

    enum Tab: String, CaseIterable, Identifiable, Hashable {
        case main
        case insights
        case coach

        var id: String { rawValue }

        var displayName: String {
            switch self {
            case .main: return "Main"
            case .insights: return "Insights"
            case .coach: return "Coach"
            }
        }

        var iconName: String {
            switch self {
            case .main: return "gauge.with.needle"
            case .insights: return "lightbulb"
            case .coach: return "text.bubble"
            }
        }
    }

    private let consentStore: ConsentStore
    @ObservationIgnored private(set) var orchestrator: AgentOrchestrator?
    @ObservationIgnored private var scoreRefreshObserver: NSObjectProtocol?
    #if canImport(UIKit)
    @ObservationIgnored private var appActiveObserver: NSObjectProtocol?
    @ObservationIgnored private var appBackgroundObserver: NSObjectProtocol?
    #endif

    var startupState: StartupState = .idle
    var selectedTab: Tab = .main
    var isPresentingPulse = false
    var isPresentingSettings = false
    var isShowingSafetyCard = false
    var safetyMessage: String?

    var consentGranted: Bool
    var shouldHideConsentBanner = false
    var showConsentBanner: Bool { !consentGranted && !shouldHideConsentBanner }

    let coachViewModel: CoachViewModel
    let pulseViewModel: PulseViewModel
    let settingsViewModel: SettingsViewModel
    private let startupTraceId = UUID()
    private var didEmitFirstRunStart = false
    private var didEmitFirstRunEnd = false
    private let firstLaunch: Bool
    private let sessionInfo: (version: String, build: String)
    private let firstRunReasonAllowlist: Set<String> = [
        "blocked",
        "ready",
        "failed",
        "health_unavailable",
        "background_delivery_ignored",
        "embeddings_pending",
        "health_backfill_running",
        "library_index_deferred",
        "journal_embeddings_pending",
        "unknown"
    ]
#if DEBUG
    private var isRunningUnderXCTest: Bool {
        let env = ProcessInfo.processInfo.environment
        return env.keys.contains("XCTestConfigurationFilePath") || env.keys.contains("XCTestBundlePath")
    }
#endif

    init(consentStore: ConsentStore = ConsentStore(),
         userDefaults: UserDefaults = AppRuntimeConfig.runtimeDefaults,
         sessionInfo: (version: String, build: String) = AppViewModel.makeVersionInfo()) {
        let consent = consentStore.loadConsent()
        let launchKey = "ai.pulsum.hasLaunched"
        let hasLaunched = userDefaults.bool(forKey: launchKey)
        let coachVM = CoachViewModel()
        let pulseVM = PulseViewModel()
        let settingsVM = SettingsViewModel(initialConsent: consent)

        self.consentStore = consentStore
        self.consentGranted = consent
        self.sessionInfo = sessionInfo
        self.firstLaunch = !hasLaunched
        userDefaults.set(true, forKey: launchKey)
        self.coachViewModel = coachVM
        self.pulseViewModel = pulseVM
        self.settingsViewModel = settingsVM
        if AppRuntimeConfig.hideConsentBanner {
            self.shouldHideConsentBanner = true
        }
#if canImport(UIKit)
        if AppRuntimeConfig.disableAnimations {
            UIView.setAnimationsEnabled(false)
        }
#endif

        settingsVM.onConsentChanged = { [weak self] newValue in
            guard let self else { return }
            self.updateConsent(to: newValue)
        }

        pulseVM.onSafetyDecision = { [weak self] decision in
            guard let self else { return }
            if !decision.allowCloud, case .crisis = decision.classification {
                self.safetyMessage = decision.crisisMessage ?? "If in danger, call 911"
                self.isShowingSafetyCard = true
            }
        }

        scoreRefreshObserver = NotificationCenter.default.addObserver(forName: .pulsumScoresUpdated,
                                                                      object: nil,
                                                                      queue: .main) { [weak self] _ in
            guard let self else { return }
            Task { [weak self] in
                await self?.coachViewModel.refreshRecommendations()
            }
        }

        #if canImport(UIKit)
        appActiveObserver = NotificationCenter.default.addObserver(forName: UIApplication.didBecomeActiveNotification,
                                                                   object: nil,
                                                                   queue: .main) { [weak self] _ in
            Diagnostics.log(level: .info,
                            category: .app,
                            name: "app.lifecycle.didBecomeActive",
                            traceId: self?.startupTraceId)
            self?.refreshOnForeground()
        }
        appBackgroundObserver = NotificationCenter.default.addObserver(forName: UIApplication.didEnterBackgroundNotification,
                                                                       object: nil,
                                                                       queue: .main) { [weak self] _ in
            Diagnostics.log(level: .info,
                            category: .app,
                            name: "app.lifecycle.didEnterBackground",
                            traceId: self?.startupTraceId)
        }
        #endif

        logSessionStart()
        Task { await DebugLogBuffer.shared.append("AppViewModel.init invoked") }
    }

    func start() {
        guard startupState == .idle else { return }
#if DEBUG
        if isRunningUnderXCTest && !AppRuntimeConfig.isUITesting {
            startupState = .ready
            return
        }
#endif
        emitFirstRunStartIfNeeded()
        if AppRuntimeConfig.skipHeavyStartupWork {
            startupState = .ready
            Task { await DebugLogBuffer.shared.append("Startup: UITest mode, skipping orchestrator bootstrap") }
            emitFirstRunEnd(fields: [
                "reason": .safeString(.stage("ready",
                                             allowed: firstRunReasonAllowlist))
            ])
            return
        }
        if let issue = PulsumData.backupSecurityIssue {
            let location = issue.url.lastPathComponent
            startupState = .blocked("Storage is not secured for backup (directory: \(location)). \(issue.reason)")
            Task { await DebugLogBuffer.shared.append("Startup blocked: \(issue.reason)") }
            emitFirstRunEnd(fields: [
                "reason": .safeString(.stage("blocked",
                                             allowed: firstRunReasonAllowlist)),
                "directory": .safeString(.metadata(location))
            ])
            return
        }
        startupState = .loading
        Task { [weak self] in
            guard let self else { return }
            do {
                Diagnostics.log(level: .info,
                                category: .app,
                                name: "app.orchestrator.create.begin",
                                traceId: startupTraceId)
                let orchestrator = try PulsumAgents.makeOrchestrator()
                Diagnostics.log(level: .info,
                                category: .app,
                                name: "app.orchestrator.create.end",
                                traceId: startupTraceId)
                self.orchestrator = orchestrator
                self.coachViewModel.bind(orchestrator: orchestrator, consentProvider: { [weak self] in
                    self?.consentGranted ?? false
                })
                self.pulseViewModel.bind(orchestrator: orchestrator)
                self.settingsViewModel.bind(orchestrator: orchestrator)
                self.settingsViewModel.refreshFoundationStatus()
                Diagnostics.log(level: .info,
                                category: .ui,
                                name: "timeline.firstRun.checkpoint",
                                fields: [
                                    "stage": .safeString(.stage("orchestrator_bound", allowed: ["orchestrator_bound"]))
                                ],
                                traceId: startupTraceId)
                self.startupState = .ready

                Task { [weak self] in
                    guard let self else { return }
                    let startSpan = Diagnostics.span(category: .orchestrator,
                                                     name: "orchestrator.start.call",
                                                     traceId: startupTraceId)
                    do {
                        try await orchestrator.start(traceId: startupTraceId)
                        startSpan.end(error: nil)
                        self.settingsViewModel.refreshHealthAccessStatus()
                        await self.coachViewModel.refreshRecommendations()
                        if let deferred = analysisDeferredFields(from: await orchestrator.diagnosticsSnapshot()) {
                            var fields = deferred.fields
                            fields["reason"] = .safeString(deferred.reason)
                            Diagnostics.log(level: .info,
                                            category: .ui,
                                            name: "ui.analysis.deferred",
                                            fields: fields,
                                            traceId: startupTraceId)
                            emitFirstRunEnd(fields: fields)
                        } else {
                            emitFirstRunEnd(fields: [
                                "reason": .safeString(.stage("ready",
                                                             allowed: firstRunReasonAllowlist))
                            ])
                        }
                        await DebugLogBuffer.shared.append("Orchestrator start complete; recommendations refreshed")
                    } catch {
                        Diagnostics.log(level: .error,
                                        category: .app,
                                        name: "orchestrator.start.failed",
                                        traceId: startupTraceId,
                                        error: error)
                        startSpan.end(error: error)
                        await DebugLogBuffer.shared.append("Orchestrator start failed")
                        if let startupError = error as? OrchestratorStartupError {
                            switch startupError {
                            case .healthDataUnavailable:
                                await DebugLogBuffer.shared.append("HealthDataUnavailable during start")
                                emitFirstRunEnd(fields: [
                                    "reason": .safeString(.stage("health_unavailable",
                                                                 allowed: firstRunReasonAllowlist))
                                ])
                                return
                            case let .healthBackgroundDeliveryMissing(underlying):
                                if shouldIgnoreBackgroundDeliveryError(underlying) {
                                    await DebugLogBuffer.shared.append("Background delivery missing but ignored")
                                    emitFirstRunEnd(fields: [
                                        "reason": .safeString(.stage("background_delivery_ignored",
                                                                     allowed: firstRunReasonAllowlist)),
                                        "background_delivery_missing": .bool(true)
                                    ])
                                    return
                                }
                            }
                        }
                        self.startupState = .failed(error.localizedDescription)
                        emitFirstRunEnd(fields: [
                            "reason": .safeString(.stage("failed",
                                                         allowed: firstRunReasonAllowlist))
                        ], error: error)
                    }
                }
            } catch {
                Diagnostics.log(level: .error,
                                category: .app,
                                name: "app.orchestrator.create.failed",
                                traceId: startupTraceId,
                                error: error)
                await DebugLogBuffer.shared.append("Failed to create orchestrator")
                self.startupState = .failed(error.localizedDescription)
                emitFirstRunEnd(fields: [
                    "reason": .safeString(.stage("failed",
                                                 allowed: firstRunReasonAllowlist))
                ], error: error)
            }
        }
    }

    func retryStartup() {
        startupState = .idle
        start()
    }

    func updateConsent(to newValue: Bool) {
        consentGranted = newValue
        consentStore.saveConsent(newValue)
        coachViewModel.updateConsent(newValue)
        settingsViewModel.refreshConsent(newValue)
        Task { [weak self] in
            await self?.coachViewModel.refreshRecommendations()
        }
    }

    func triggerCoachFocus() {
        selectedTab = .coach
        coachViewModel.requestChatFocus()
    }

    func dismissConsentBanner() {
        shouldHideConsentBanner = true
    }

    func handleRecommendationCompletion(_ card: RecommendationCard) {
        Task { [weak self] in
            guard let self, let orchestrator else { return }
            await coachViewModel.complete(card: card, orchestrator: orchestrator)
        }
    }

    func dismissSafetyCard() {
        isShowingSafetyCard = false
        safetyMessage = nil
    }

    private func refreshOnForeground() {
        guard startupState == .ready, let orchestrator else { return }
        Task {
            await orchestrator.refreshOnDeviceModelAvailabilityAndRetryDeferredWork(traceId: startupTraceId)
        }
    }

    @MainActor
    deinit {
        if let scoreRefreshObserver {
            NotificationCenter.default.removeObserver(scoreRefreshObserver)
        }
        #if canImport(UIKit)
        if let appActiveObserver {
            NotificationCenter.default.removeObserver(appActiveObserver)
        }
        if let appBackgroundObserver {
            NotificationCenter.default.removeObserver(appBackgroundObserver)
        }
        #endif
    }
}

private func shouldIgnoreBackgroundDeliveryError(_ error: Error) -> Bool {
    (error as NSError).localizedDescription.contains("Missing com.apple.developer.healthkit.background-delivery")
}

private extension AppViewModel {
    func logSessionStart() {
        let locale = Locale.current.identifier
        #if canImport(UIKit)
        let deviceModel = UIDevice.current.model
        let osVersion = UIDevice.current.systemVersion
        let lowPower = ProcessInfo.processInfo.isLowPowerModeEnabled
        #else
        let deviceModel = "mac"
        let osVersion = ProcessInfo.processInfo.operatingSystemVersionString
        let lowPower = false
        #endif
        Diagnostics.log(level: .info,
                        category: .app,
                        name: "app.session.start",
                        fields: [
                            "app_version": .safeString(.metadata(sessionInfo.version)),
                            "build_number": .safeString(.metadata(sessionInfo.build)),
                            "device_model": .safeString(.metadata(deviceModel)),
                            "os_version": .safeString(.metadata(osVersion)),
                            "locale": .safeString(.metadata(locale)),
                            "low_power_mode": .bool(lowPower),
                            "first_launch": .bool(firstLaunch)
                        ],
                        traceId: startupTraceId)
    }

    static func makeVersionInfo() -> (String, String) {
        let bundle = Bundle.main
        let version = bundle.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String ?? "unknown"
        let build = bundle.object(forInfoDictionaryKey: "CFBundleVersion") as? String ?? "unknown"
        return (version, build)
    }

    func analysisDeferredFields(from snapshot: DiagnosticsSnapshot) -> (reason: DiagnosticsSafeString, fields: [String: DiagnosticsValue])? {
        let reasonAllowlist: Set<String> = ["embeddings_pending", "health_backfill_running", "library_index_deferred", "journal_embeddings_pending", "unknown"]
        let embeddingsAvailable = snapshot.embeddingsAvailable ?? false
        let pendingJournals = snapshot.pendingJournalsCount ?? 0
        let warmCompleted = snapshot.backfillWarmCompleted ?? 0
        let fullCompleted = snapshot.backfillFullCompleted ?? 0
        let deferredLibraryImport = snapshot.deferredLibraryImport ?? false
        let expectedTypes = snapshot.healthGrantedCount ?? 0
        let baseFields: [String: DiagnosticsValue] = [
            "pending_journals": .int(pendingJournals),
            "backfill_warm_completed": .int(warmCompleted),
            "backfill_full_completed": .int(fullCompleted),
            "embeddings_available": .bool(embeddingsAvailable),
            "deferred_library_import": .bool(deferredLibraryImport)
        ]
        if !embeddingsAvailable {
            return (.stage("embeddings_pending", allowed: reasonAllowlist), baseFields)
        }
        if pendingJournals > 0 {
            return (.stage("journal_embeddings_pending", allowed: reasonAllowlist), baseFields)
        }
        if deferredLibraryImport {
            return (.stage("library_index_deferred", allowed: reasonAllowlist), baseFields)
        }
        if warmCompleted < expectedTypes || fullCompleted < expectedTypes {
            return (.stage("health_backfill_running", allowed: reasonAllowlist), baseFields)
        }
        return nil
    }

    func emitFirstRunStartIfNeeded() {
        guard !didEmitFirstRunStart else { return }
        Diagnostics.log(level: .info,
                        category: .app,
                        name: "timeline.firstRun.start",
                        traceId: startupTraceId)
        didEmitFirstRunStart = true
    }

    func emitFirstRunEnd(fields: [String: DiagnosticsValue], error: Error? = nil) {
        guard !didEmitFirstRunEnd else { return }
        let level: DiagnosticsLevel = error == nil ? .info : .error
        Diagnostics.log(level: level,
                        category: .app,
                        name: "timeline.firstRun.end",
                        fields: fields,
                        traceId: startupTraceId,
                        error: error)
        didEmitFirstRunEnd = true
    }
}

@MainActor
struct ConsentStore {
    private let contextProvider: () -> NSManagedObjectContext
    private static let recordID = "default"
    private static let consentDefaultsKey = "ai.pulsum.cloudConsent"
    private let consentVersion: String

    init(contextProvider: @escaping () -> NSManagedObjectContext = { PulsumData.viewContext },
         consentVersion: String = ConsentStore.defaultConsentVersion()) {
        self.contextProvider = contextProvider
        self.consentVersion = consentVersion
    }

    private var context: NSManagedObjectContext { contextProvider() }

    private var defaults: UserDefaults {
        AppRuntimeConfig.runtimeDefaults
    }

    func loadConsent() -> Bool {
        let defaults = defaults
        if defaults.object(forKey: Self.consentDefaultsKey) != nil {
            return defaults.bool(forKey: Self.consentDefaultsKey)
        }
        if AppRuntimeConfig.isUITesting {
            return false
        }
        let request = UserPrefs.fetchRequest()
        request.fetchLimit = 1
        request.predicate = NSPredicate(format: "id == %@", Self.recordID)
        if let existing = try? context.fetch(request).first {
            defaults.set(existing.consentCloud, forKey: Self.consentDefaultsKey)
            return existing.consentCloud
        }
        return false
    }

    func saveConsent(_ granted: Bool) {
        let defaults = defaults
        defaults.set(granted, forKey: Self.consentDefaultsKey)
        AppRuntimeConfig.synchronizeUITestDefaults()
        if AppRuntimeConfig.isUITesting {
            return
        }
        let request = UserPrefs.fetchRequest()
        request.fetchLimit = 1
        request.predicate = NSPredicate(format: "id == %@", Self.recordID)
        let prefs: UserPrefs
        if let existing = try? context.fetch(request).first {
            prefs = existing
        } else {
            prefs = UserPrefs(context: context)
            prefs.id = Self.recordID
        }
        prefs.consentCloud = granted
        prefs.updatedAt = Date()
        do {
            persistConsentHistory(granted: granted)
            try context.save()
        } catch {
            context.rollback()
        }
    }

    private func persistConsentHistory(granted: Bool) {
        let request = ConsentState.fetchRequest()
        request.fetchLimit = 1
        request.predicate = NSPredicate(format: "version == %@", consentVersion)

        let record: ConsentState
        if let existing = try? context.fetch(request).first {
            record = existing
        } else {
            record = ConsentState(context: context)
            record.id = UUID()
            record.version = consentVersion
        }

        let timestamp = Date()
        if granted {
            record.grantedAt = timestamp
            record.revokedAt = nil
        } else {
            if record.grantedAt == nil {
                record.grantedAt = timestamp
            }
            record.revokedAt = timestamp
        }
    }

    private static func defaultConsentVersion() -> String {
        Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String ?? "unknown"
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/AppViewModel.swift -->

### Packages/PulsumUI/Sources/PulsumUI/CoachView.swift
- bytes: 16323
- lines: 432
- sha256: 329fd97441c7e7a1539c5141715f7e63de529e3b3cfaf154f6444f7db4e93cf1
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/CoachView.swift -->
```swift
import SwiftUI
import Observation
import PulsumAgents
import PulsumTypes

public struct ChatInputView: View {
    @Bindable var viewModel: CoachViewModel
    @FocusState private var chatFieldInFocus: Bool

    init(viewModel: CoachViewModel) {
        self.viewModel = viewModel
    }

    public var body: some View {
        HStack(spacing: PulsumSpacing.sm) {
            TextField("Ask Pulsum anything about your recovery", text: $viewModel.chatInput, axis: .vertical)
                .lineLimit(1...3)
                .font(.pulsumBody)
                .foregroundStyle(Color.pulsumTextPrimary)
                .padding(PulsumSpacing.md)
                .background(
                    RoundedRectangle(cornerRadius: PulsumRadius.lg, style: .continuous)
                        .fill(Color.pulsumCardWhite.opacity(0.9))
                )
                .overlay {
                    RoundedRectangle(cornerRadius: PulsumRadius.lg, style: .continuous)
                        .stroke(Color.white.opacity(0.5), lineWidth: 0.5)
                }
                .focused($chatFieldInFocus)
                .disabled(viewModel.isSendingChat)

            Button {
                Task { await viewModel.sendChat() }
            } label: {
                Image(systemName: "paperplane.fill")
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundStyle(
                        viewModel.chatInput.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
                            ? Color.pulsumTextSecondary
                            : Color.pulsumTextPrimary
                    )
                    .frame(width: 44, height: 44)
            }
            .glassEffect(
                .regular.tint(
                    (viewModel.chatInput.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
                        ? Color.gray.opacity(0.3)
                        : Color.pulsumGreenSoft.opacity(0.7))
                ).interactive()
            )
            .accessibilityLabel("Send coach message")
            .accessibilityIdentifier("CoachSendButton")
            .disabled(viewModel.chatInput.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty || viewModel.isSendingChat)
            
            // Close keyboard button (iOS 26 style)
            if chatFieldInFocus {
                Button {
                    chatFieldInFocus = false
                } label: {
                    Image(systemName: "xmark")
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundStyle(Color.pulsumTextSecondary)
                        .frame(width: 44, height: 44)
                }
                .glassEffect(.regular.tint(Color.gray.opacity(0.3)).interactive())
                .transition(.scale.combined(with: .opacity))
            }
        }
        .frame(maxWidth: .infinity)
        .animation(AppRuntimeConfig.disableAnimations ? nil : .spring(response: 0.3, dampingFraction: 0.8),
                   value: chatFieldInFocus)
        .onChange(of: viewModel.chatFocusToken) { _, _ in
            chatFieldInFocus = true
        }
    }
}

struct CoachScreen: View {
    @Bindable var viewModel: CoachViewModel
    let showChatInput: Bool

    private let chatBottomAnchor = "coach-chat-bottom"

    var body: some View {
        VStack(spacing: 0) {
            chatMessagesOnly
            
            if showChatInput {
                ChatInputView(viewModel: viewModel)
                    .padding(.horizontal, PulsumSpacing.lg)
                    .padding(.vertical, PulsumSpacing.md)
                    .background(Color.pulsumBackgroundBeige.opacity(0.95))
            }
        }
        .background(
            Color.pulsumBackgroundBeige
                .ignoresSafeArea()
        )
        .scrollDismissesKeyboard(.interactively)
        .onAppear {
#if canImport(UIKit)
            if AppRuntimeConfig.disableAnimations {
                UIView.setAnimationsEnabled(false)
            } else {
                UIView.setAnimationsEnabled(true)
            }
#endif
        }
    }

    private var chatMessagesOnly: some View {
        ScrollViewReader { proxy in
            ScrollView {
                LazyVStack(alignment: .leading, spacing: PulsumSpacing.md) {
                    ForEach(viewModel.messages) { message in
                        ChatBubble(message: message)
                            .padding(message.role == .user ? .leading : .trailing, 48)
                    }

                    if viewModel.isSendingChat {
                        HStack(spacing: PulsumSpacing.xs) {
                            ProgressView()
                                .progressViewStyle(.circular)
                                .tint(Color.pulsumGreenSoft)
                            Text("Analyzing...")
                                .font(.pulsumCallout)
                                .foregroundStyle(Color.pulsumTextSecondary)
                        }
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.vertical, PulsumSpacing.sm)
                    }

                    if let message = viewModel.chatErrorMessage {
                        MessageBubble(icon: "exclamationmark.circle", text: message, tint: Color.pulsumWarning)
                    }

                    Color.clear
                        .frame(height: 1)
                        .id(chatBottomAnchor)
                }
                .frame(maxWidth: 520, alignment: .leading)
                .padding(.horizontal, PulsumSpacing.lg)
                .padding(.top, PulsumSpacing.md)
                .padding(.bottom, 100)
            }
            .scrollIndicators(.hidden)
            .scrollDismissesKeyboard(.interactively)
            .onAppear {
                DispatchQueue.main.async {
                    proxy.scrollTo(chatBottomAnchor, anchor: .bottom)
                }
            }
            .onChange(of: viewModel.messages.count) { _, _ in
                DispatchQueue.main.async {
                    proxy.scrollTo(chatBottomAnchor, anchor: .bottom)
                }
            }
            .onChange(of: viewModel.isSendingChat) { _, sending in
                if sending {
                    DispatchQueue.main.async {
                        proxy.scrollTo(chatBottomAnchor, anchor: .bottom)
                    }
                }
            }
        }
    }
}

struct InsightsScreen: View {
    @Bindable var viewModel: CoachViewModel
    let foundationStatus: String
    let consentGranted: Bool
    let triggerSettings: () -> Void

    var body: some View {
        ScrollView {
            LazyVStack(spacing: PulsumSpacing.lg) {
                todayPicksSection
            }
            .frame(maxWidth: 520, alignment: .center)
            .padding(.horizontal, PulsumSpacing.lg)
            .padding(.top, PulsumSpacing.md)
            .padding(.bottom, PulsumSpacing.xxxl)
        }
        .scrollIndicators(.hidden)
        .background(
            Color.pulsumBackgroundBeige
                .ignoresSafeArea()
        )
        .task { await viewModel.refreshRecommendations() }
    }

    private var todayPicksSection: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.lg) {
            HStack(alignment: .center) {
                Text("Today's picks")
                    .font(.pulsumTitle2)
                    .foregroundStyle(Color.pulsumTextPrimary)
                Spacer()
                if viewModel.isLoadingCards {
                    ProgressView()
                        .progressViewStyle(.circular)
                        .tint(Color.pulsumGreenSoft)
                }
            }
            .padding(.top, PulsumSpacing.sm)

            if let message = viewModel.cardErrorMessage {
                MessageBubble(icon: "exclamationmark.triangle", text: message, tint: Color.pulsumWarning)
            }

            if let message = viewModel.recommendationsSoftTimeoutMessage {
                MessageBubble(icon: "clock.arrow.circlepath", text: message, tint: Color.pulsumBlueSoft)
            }

            if let notice = viewModel.wellbeingNotice {
                MessageBubble(icon: notice.icon,
                              text: notice.text,
                              tint: notice.tone == .warning ? Color.pulsumWarning : Color.pulsumBlueSoft)
            }

            if !consentGranted {
                ConsentPrompt(triggerSettings: triggerSettings)
            }

            if foundationStatus != "Apple Intelligence is ready." {
                MessageBubble(
                    icon: "sparkles.slash",
                    text: "Enhanced AI features require Apple Intelligence. Using on-device intelligence until it's ready.",
                    tint: Color.pulsumBlueSoft
                )
            }

            if viewModel.recommendations.isEmpty && !viewModel.isLoadingCards {
                MessageBubble(
                    icon: "clock.arrow.circlepath",
                    text: "We're gathering more context. Check back soon for fresh recommendations.",
                    tint: Color.pulsumTextSecondary
                )
            } else {
                ForEach(viewModel.recommendations, id: \.id) { card in
                    RecommendationCardView(card: card) {
                        Task { await viewModel.markCardComplete(card) }
                    }
                }
            }

            if let cheerMessage = viewModel.cheerEventMessage {
                MessageBubble(icon: "heart.fill", text: cheerMessage, tint: Color.pulsumPinkSoft)
            }
        }
    }

    
}

private struct MessageBubble: View {
    let icon: String
    let text: String
    let tint: Color

    var body: some View {
        HStack(alignment: .top, spacing: PulsumSpacing.sm) {
            Image(systemName: icon)
                .font(.pulsumHeadline)
                .foregroundStyle(tint)
            Text(text)
                .font(.pulsumCallout)
                .foregroundStyle(Color.pulsumTextPrimary)
        }
        .padding(PulsumSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color.pulsumCardWhite)
        .cornerRadius(PulsumRadius.lg)
        .shadow(
            color: PulsumShadow.small.color,
            radius: PulsumShadow.small.radius,
            x: PulsumShadow.small.x,
            y: PulsumShadow.small.y
        )
    }
}

private struct ConsentPrompt: View {
    let triggerSettings: () -> Void

    private let bannerCopy = "Pulsum can optionally use GPT‑5 to phrase brief coaching text. If you allow cloud processing, Pulsum sends only minimized context (no journals, no raw health data, no identifiers). PII is redacted. You can turn this off anytime in Settings ▸ Cloud Processing."

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            Text("Cloud processing is off")
                .font(.pulsumHeadline)
                .foregroundStyle(Color.pulsumTextPrimary)
            Text(bannerCopy)
                .font(.pulsumCallout)
                .foregroundStyle(Color.pulsumTextSecondary)
                .lineSpacing(4)
            Button(action: triggerSettings) {
                Text("Review Settings")
                    .font(.pulsumHeadline)
                    .foregroundStyle(Color.pulsumTextPrimary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, PulsumSpacing.sm)
            }
            .glassEffect(.regular.tint(Color.pulsumBlueSoft.opacity(0.7)).interactive())
        }
        .padding(PulsumSpacing.lg)
        .background(Color.pulsumCardWhite)
        .cornerRadius(PulsumRadius.xl)
        .shadow(
            color: PulsumShadow.medium.color,
            radius: PulsumShadow.medium.radius,
            x: PulsumShadow.medium.x,
            y: PulsumShadow.medium.y
        )
    }
}

private struct ChatBubble: View {
    let message: CoachViewModel.ChatMessage

    var body: some View {
        VStack(alignment: message.role == .user ? .trailing : .leading, spacing: 6) {
            Text(message.text)
                .font(.pulsumBody)
                .foregroundStyle(message.role == .user ? Color.pulsumTextPrimary : Color.pulsumTextPrimary)
                .padding(.horizontal, PulsumSpacing.md)
                .padding(.vertical, PulsumSpacing.sm)
                .background(bubbleBackground)
                .cornerRadius(PulsumRadius.md)
                .shadow(
                    color: PulsumShadow.small.color,
                    radius: PulsumShadow.small.radius,
                    x: PulsumShadow.small.x,
                    y: PulsumShadow.small.y
                )
                .accessibilityIdentifier(message.role == .assistant ? "CoachAssistantMessage" : "CoachUserMessage")

            Text(message.timestamp, style: .time)
                .font(.pulsumCaption2)
                .foregroundStyle(Color.pulsumTextTertiary)
        }
        .frame(maxWidth: .infinity, alignment: message.role == .user ? .trailing : .leading)
    }

    private var bubbleBackground: Color {
        switch message.role {
        case .user:
            return Color.pulsumCardWhite
        case .assistant:
            return Color.pulsumMintGreen // Mint green for AI responses (from maindesign.png)
        case .system:
            return Color.pulsumBackgroundCream
        }
    }
}

private struct RecommendationCardView: View {
    let card: RecommendationCard
    let completionAction: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            HStack(alignment: .top) {
                VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                    Text(card.title)
                        .font(.pulsumHeadline)
                        .foregroundStyle(Color.pulsumTextPrimary)
                        .lineSpacing(2)

                    BadgeView(text: card.sourceBadge)
                }

                Spacer()
            }

            Text(card.body)
                .font(.pulsumBody)
                .foregroundStyle(Color.pulsumTextSecondary)
                .lineSpacing(4)
                .fixedSize(horizontal: false, vertical: true)

            if let caution = card.caution {
                HStack(spacing: PulsumSpacing.xs) {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .font(.pulsumCaption)
                        .foregroundStyle(Color.pulsumWarning)
                    Text(caution)
                        .font(.pulsumCaption)
                        .foregroundStyle(Color.pulsumWarning.opacity(0.9))
                }
                .padding(.horizontal, PulsumSpacing.sm)
                .padding(.vertical, PulsumSpacing.xs)
                .background(Color.pulsumWarning.opacity(0.1))
                .cornerRadius(PulsumRadius.sm)
            }

            Button(action: completionAction) {
                Label("Mark complete", systemImage: "checkmark")
                    .font(.pulsumCallout.weight(.semibold))
                    .foregroundStyle(Color.pulsumTextPrimary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, PulsumSpacing.sm)
            }
            .glassEffect(.regular.tint(Color.pulsumGreenSoft.opacity(0.6)).interactive())
        }
        .padding(PulsumSpacing.lg)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color.pulsumCardWhite)
        .cornerRadius(PulsumRadius.xl)
        .shadow(
            color: PulsumShadow.medium.color,
            radius: PulsumShadow.medium.radius,
            x: PulsumShadow.medium.x,
            y: PulsumShadow.medium.y
        )
    }
}

private struct BadgeView: View {
    let text: String

    var body: some View {
        Text(text)
            .font(.pulsumCaption2.weight(.semibold))
            .foregroundStyle(Color.pulsumBlueSoft)
            .padding(.vertical, PulsumSpacing.xxs)
            .padding(.horizontal, PulsumSpacing.xs)
            .background(Color.pulsumBlueSoft.opacity(0.15))
            .cornerRadius(PulsumRadius.xs)
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/CoachView.swift -->

### Packages/PulsumUI/Sources/PulsumUI/CoachViewModel.swift
- bytes: 18594
- lines: 464
- sha256: 23019ab1219123a8ffc23f3f340094d369a33694a8d9817107eef50d1578f003
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/CoachViewModel.swift -->
```swift
import Foundation
import Observation
import os
import PulsumAgents
#if canImport(FoundationModels) && os(iOS)
import FoundationModels
#endif
import PulsumTypes

@MainActor
protocol CoachOrchestrating: AnyObject {
    func wellbeingSnapshotState(consentGranted: Bool) async throws -> WellbeingSnapshotResponse
    func recommendations(consentGranted: Bool) async throws -> RecommendationResponse
    func logCompletion(momentId: String) async throws -> CheerEvent
    func chat(userInput: String, consentGranted: Bool) async throws -> String
}

extension AgentOrchestrator: CoachOrchestrating {}

@MainActor
@Observable
final class CoachViewModel {
    struct ChatMessage: Identifiable, Equatable {
        enum Role {
            case user
            case assistant
            case system
        }

        let id = UUID()
        let role: Role
        let text: String
        let timestamp: Date
    }

    enum WellbeingNoticeTone: Equatable {
        case neutral
        case warning
    }

    struct WellbeingNotice: Equatable {
        let icon: String
        let text: String
        let tone: WellbeingNoticeTone
    }

    @ObservationIgnored fileprivate var orchestrator: (any CoachOrchestrating)?
    @ObservationIgnored private var consentProvider: () -> Bool = { false }
    private let recommendationsDebounceNanoseconds: UInt64
    private let recommendationsSoftTimeoutSeconds: Double

    var recommendations: [RecommendationCard] = []
    var wellbeingScore: Double?
    var contributions: [String: Double] = [:]
    var wellbeingState: WellbeingScoreState = .loading
    private var hasLoadedWellbeing = false
    var snapshotKind: WellbeingSnapshotKind = .none

    var isLoadingCards = false
    var cardErrorMessage: String?

    var messages: [ChatMessage] = []
    var chatInput: String = ""
    var isSendingChat = false
    var chatErrorMessage: String?

    var cheerEventMessage: String?
    var lastCheerDate: Date?

    private(set) var consentGranted: Bool = false
    var chatFocusToken = UUID()
    @ObservationIgnored private let logger = Logger(subsystem: "com.pulsum", category: "CoachViewModel")
    private var lastWellbeingState: WellbeingScoreState = .loading
    private var refreshSequence = 0
    private var recommendationsTask: Task<Void, Never>?
    private var recommendationsDebounceTask: Task<Void, Never>?
    private var recommendationsPending = false
    private var recommendationsCoalesced = false
    private var recommendationsSoftTimeoutTask: Task<Void, Never>?
    private var recommendationsSoftTimedOut = false
    private var activeRecommendationsRefreshID: Int?

    var recommendationsSoftTimeoutMessage: String?

    var wellbeingNotice: WellbeingNotice? {
        switch wellbeingState {
        case let .noData(reason):
            if snapshotKind == .placeholder, reason == .insufficientSamples {
                return WellbeingNotice(icon: "clock",
                                       text: "Warming up... Health data may take a moment on first run.",
                                       tone: .neutral)
            }
            return WellbeingNotice(icon: "exclamationmark.triangle",
                                   text: noDataMessage(for: reason),
                                   tone: .warning)
        case .error:
            return WellbeingNotice(icon: "exclamationmark.triangle",
                                   text: "We couldn't compute your wellbeing score yet. Try again after enabling Health access or adding data.",
                                   tone: .warning)
        default:
            return nil
        }
    }

    init(recommendationsDebounceNanoseconds: UInt64 = 750_000_000,
         recommendationsSoftTimeoutSeconds: Double = 9) {
        self.recommendationsDebounceNanoseconds = recommendationsDebounceNanoseconds
        self.recommendationsSoftTimeoutSeconds = recommendationsSoftTimeoutSeconds
    }

    func bind(orchestrator: any CoachOrchestrating, consentProvider: @escaping () -> Bool) {
        self.orchestrator = orchestrator
        self.consentProvider = consentProvider
        self.consentGranted = consentProvider()
    }

    func refreshRecommendations() async {
        guard let orchestrator else { return }
        consentGranted = consentProvider()
        let refreshID = nextRefreshID()
        if !hasLoadedWellbeing {
            let previous = wellbeingState
            wellbeingState = .loading
            snapshotKind = .none
            logWellbeingTransition(from: previous, to: wellbeingState, reason: "loading")
            cardErrorMessage = nil
        }
        do {
            let snapshot = try await orchestrator.wellbeingSnapshotState(consentGranted: consentProvider())
            guard refreshID == refreshSequence else { return }
            applyWellbeingState(snapshot.wellbeingState,
                                snapshotKind: snapshot.snapshotKind,
                                reason: "snapshot")
            logWellbeingSnapshotUpdate(snapshot, refreshID: refreshID)
        } catch is CancellationError {
            logger.debug("Wellbeing snapshot refresh cancelled.")
            return
        } catch {
            let previous = wellbeingState
            wellbeingState = .error(message: "Unable to compute wellbeing right now.")
            snapshotKind = .none
            logWellbeingTransition(from: previous, to: wellbeingState, reason: "error")
            wellbeingScore = nil
            contributions = [:]
            hasLoadedWellbeing = true
            lastWellbeingState = wellbeingState
        }
        if Task.isCancelled { return }
        scheduleRecommendationsRefresh()
    }

    func updateConsent(_ granted: Bool) {
        consentGranted = granted
    }

    func requestChatFocus() {
        chatFocusToken = UUID()
    }

    func reloadIfNeeded() {
        Task { [weak self] in
            guard let self else { return }
            await self.refreshRecommendations()
        }
    }

    func complete(card: RecommendationCard, orchestrator: any CoachOrchestrating) async {
        do {
            let event = try await orchestrator.logCompletion(momentId: card.id)
            let message = "\(event.message)"
            cheerEventMessage = message
            lastCheerDate = Date()
            scheduleCheerReset()
            await refreshRecommendations()
        } catch {
            cheerEventMessage = "Couldn't log completion. Please try again later."
            scheduleCheerReset()
        }
    }

    func markCardComplete(_ card: RecommendationCard) async {
        guard let orchestrator else { return }
        await complete(card: card, orchestrator: orchestrator)
    }

    func sendChat() async {
        let trimmed = chatInput.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }
        logger.debug("Sending chat message. Characters: \(trimmed.count, privacy: .public)")
        let userMessage = ChatMessage(role: .user, text: trimmed, timestamp: Date())
        messages.append(userMessage)
        chatInput = ""
        chatErrorMessage = nil
        isSendingChat = true
        defer { isSendingChat = false }
        guard let orchestrator else {
            if AppRuntimeConfig.useStubLLM {
                let assistant = ChatMessage(role: .assistant,
                                            text: "Stub response: Pulsum coach stub reply for UI testing.",
                                            timestamp: Date())
                messages.append(assistant)
            } else {
                chatErrorMessage = "Coach is unavailable right now."
            }
            return
        }
        do {
            let response = try await orchestrator.chat(userInput: trimmed, consentGranted: consentProvider())
            let assistant = ChatMessage(role: .assistant, text: response, timestamp: Date())
            messages.append(assistant)
            logger.debug("Chat response appended. Characters: \(response.count, privacy: .public)")
        } catch {
            chatErrorMessage = mapError(error)
            let nsError = error as NSError
            logger.error("Chat send failed. domain=\(nsError.domain, privacy: .public) code=\(nsError.code, privacy: .public)")
        }
    }

    private func mapError(_ error: Error) -> String {
        #if canImport(FoundationModels) && os(iOS)
        if #available(iOS 26.0, *), let generationError = error as? LanguageModelSession.GenerationError {
            switch generationError {
            case .guardrailViolation:
                return "Let's keep the focus on supportive wellness actions"
            case .refusal:
                return "Unable to process that request. Try rephrasing."
            default:
                break
            }
        }
        #endif
        if (error as NSError).domain == NSURLErrorDomain {
            return "Network connection appears offline."
        }
        return error.localizedDescription
    }

    private func noDataMessage(for reason: WellbeingNoDataReason) -> String {
        switch reason {
        case .healthDataUnavailable:
            return "Health data isn't available on this device. Try on a device with Health access."
        case .permissionsDeniedOrPending:
            return "Health permissions are needed to personalize picks. Enable Health data in Settings."
        case .insufficientSamples:
            return "We're waiting for enough Health data to personalize your picks."
        }
    }

    private func scheduleCheerReset() {
        Task { [weak self] in
            try? await Task.sleep(nanoseconds: 4_000_000_000)
            guard let self else { return }
            cheerEventMessage = nil
        }
    }

    private func logWellbeingTransition(from: WellbeingScoreState, to: WellbeingScoreState, reason: String) {
        let allowedStates: Set<String> = ["loading", "ready", "no_data", "error"]
        let allowedReasons: Set<String> = ["refresh", "snapshot", "error", "loading", "unknown"]
        Diagnostics.log(level: .info,
                        category: .ui,
                        name: "ui.wellbeingState.transition",
                        fields: [
                            "from": .safeString(.stage(label(for: from), allowed: allowedStates)),
                            "to": .safeString(.stage(label(for: to), allowed: allowedStates)),
                            "reason": .safeString(.stage(reason, allowed: allowedReasons)),
                            "has_snapshot": .bool(snapshotKind == .real)
                        ])
    }

    private func label(for state: WellbeingScoreState) -> String {
        switch state {
        case .loading: return "loading"
        case .ready: return "ready"
        case .noData: return "no_data"
        case .error: return "error"
        }
    }

    private func nextRefreshID() -> Int {
        refreshSequence += 1
        return refreshSequence
    }

    private func applyWellbeingState(_ state: WellbeingScoreState,
                                     snapshotKind: WellbeingSnapshotKind,
                                     reason: String) {
        let previous = wellbeingState
        wellbeingState = state
        self.snapshotKind = snapshotKind
        logWellbeingTransition(from: previous, to: wellbeingState, reason: reason)
        switch state {
        case let .ready(score, contributions):
            wellbeingScore = score
            self.contributions = contributions
        default:
            wellbeingScore = nil
            contributions = [:]
        }
        hasLoadedWellbeing = true
        lastWellbeingState = wellbeingState
    }

    private func logWellbeingSnapshotUpdate(_ snapshot: WellbeingSnapshotResponse, refreshID: Int) {
        let allowedStates: Set<String> = ["loading", "ready", "no_data", "error"]
        let allowedSnapshotKinds: Set<String> = ["none", "placeholder", "real"]
        let hasRealSnapshot = snapshot.snapshotKind == .real
        var fields: [String: DiagnosticsValue] = [
            "refresh_id": .int(refreshID),
            "state": .safeString(.stage(label(for: snapshot.wellbeingState), allowed: allowedStates)),
            "snapshot_kind": .safeString(.stage(snapshot.snapshotKind.rawValue,
                                                allowed: allowedSnapshotKinds)),
            "has_snapshot": .bool(hasRealSnapshot),
            "score_present": .bool(hasRealSnapshot)
        ]
        if let dayString = snapshot.dayString {
            fields["day"] = .safeString(.metadata(dayString))
        }
        Diagnostics.log(level: .info,
                        category: .ui,
                        name: "ui.wellbeing.snapshot.update",
                        fields: fields)
    }

    private func scheduleRecommendationsRefresh() {
        if recommendationsTask != nil {
            recommendationsPending = true
            recommendationsCoalesced = true
            updateRecommendationsLoadingState()
            return
        }

        if recommendationsDebounceTask != nil {
            recommendationsCoalesced = true
        }

        recommendationsDebounceTask?.cancel()
        let debounceNanoseconds = recommendationsDebounceNanoseconds
        recommendationsDebounceTask = Task { [weak self] in
            guard let self else { return }
            defer {
                self.recommendationsDebounceTask = nil
                self.updateRecommendationsLoadingState()
            }
            if debounceNanoseconds > 0 {
                do {
                    try await Task.sleep(nanoseconds: debounceNanoseconds)
                } catch {
                    return
                }
            }
            self.startRecommendationsRefresh()
        }
        updateRecommendationsLoadingState()
    }

    private func startRecommendationsRefresh() {
        guard recommendationsTask == nil else { return }
        guard let orchestrator else {
            updateRecommendationsLoadingState()
            return
        }
        let refreshID = refreshSequence
        let coalesced = recommendationsCoalesced
        recommendationsCoalesced = false
        cardErrorMessage = nil
        resetRecommendationsSoftTimeout()
        activeRecommendationsRefreshID = refreshID

        let span = Diagnostics.span(category: .ui,
                                    name: "ui.recommendations.refresh",
                                    fields: [
                                        "refresh_id": .int(refreshID),
                                        "coalesced": .bool(coalesced)
                                    ],
                                    level: .info)

        let task = Task { @MainActor [weak self] in
            guard let self else { return }
            defer {
                self.recommendationsTask = nil
                self.activeRecommendationsRefreshID = nil
                self.clearRecommendationsSoftTimeout()
                if self.recommendationsPending {
                    self.recommendationsPending = false
                    self.scheduleRecommendationsRefresh()
                } else {
                    self.updateRecommendationsLoadingState()
                }
            }
            let resultAllowlist: Set<String> = ["applied", "stale", "failed", "cancelled"]
            do {
                let response = try await orchestrator.recommendations(consentGranted: consentProvider())
                try Task.checkCancellation()
                let isStale = refreshID != self.refreshSequence
                let shouldApply = !isStale || self.recommendations.isEmpty
                if shouldApply {
                    self.recommendations = response.cards
                    self.cardErrorMessage = response.notice
                    self.clearRecommendationsSoftTimeout()
                }
                span.end(additionalFields: [
                    "result": .safeString(.stage(isStale ? "stale" : "applied", allowed: resultAllowlist)),
                    "cards_count": .int(response.cards.count)
                ], error: nil)
            } catch is CancellationError {
                span.end(additionalFields: [
                    "result": .safeString(.stage("cancelled", allowed: resultAllowlist))
                ], error: nil)
            } catch {
                if refreshID == self.refreshSequence {
                    self.cardErrorMessage = mapError(error)
                }
                span.end(additionalFields: [
                    "result": .safeString(.stage("failed", allowed: resultAllowlist))
                ], error: error)
            }
        }

        recommendationsTask = task
        beginRecommendationsSoftTimeout(for: refreshID)
        updateRecommendationsLoadingState()
    }

    private func updateRecommendationsLoadingState() {
        let isBusy = recommendationsTask != nil
            || recommendationsPending
            || recommendationsDebounceTask != nil
        isLoadingCards = isBusy && !recommendationsSoftTimedOut
    }

    private func beginRecommendationsSoftTimeout(for refreshID: Int) {
        recommendationsSoftTimeoutTask?.cancel()
        guard recommendationsSoftTimeoutSeconds > 0 else { return }
        let timeoutNanos = UInt64(max(0, recommendationsSoftTimeoutSeconds) * 1_000_000_000)
        recommendationsSoftTimeoutTask = Task { @MainActor [weak self] in
            guard let self else { return }
            do {
                try await Task.sleep(nanoseconds: timeoutNanos)
            } catch {
                return
            }
            guard self.recommendationsTask != nil else { return }
            guard self.activeRecommendationsRefreshID == refreshID else { return }
            self.recommendationsSoftTimedOut = true
            self.recommendationsSoftTimeoutMessage = "Recommendations are taking longer than expected. We'll show them here as soon as they're ready."
            self.updateRecommendationsLoadingState()
        }
    }

    private func resetRecommendationsSoftTimeout() {
        recommendationsSoftTimeoutTask?.cancel()
        recommendationsSoftTimeoutTask = nil
        recommendationsSoftTimedOut = false
        recommendationsSoftTimeoutMessage = nil
    }

    private func clearRecommendationsSoftTimeout() {
        recommendationsSoftTimeoutTask?.cancel()
        recommendationsSoftTimeoutTask = nil
        recommendationsSoftTimedOut = false
        recommendationsSoftTimeoutMessage = nil
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/CoachViewModel.swift -->

### Packages/PulsumUI/Sources/PulsumUI/ConsentBannerView.swift
- bytes: 2389
- lines: 60
- sha256: 2c838b1b47dd2b59468c519b73a204014f0ba9e643851cd620935adf321d0a34
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/ConsentBannerView.swift -->
```swift
import SwiftUI

struct ConsentBannerView: View {
    let openSettings: () -> Void
    let dismiss: () -> Void

    private let bannerCopy = "Pulsum can optionally use GPT‑5 to phrase brief coaching text. If you allow cloud processing, Pulsum sends only minimized context (no journals, no raw health data, no identifiers). PII is redacted. You can turn this off anytime in Settings ▸ Cloud Processing."

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            HStack {
                Image(systemName: "lock.shield.fill")
                    .font(.pulsumTitle3)
                    .foregroundStyle(Color.pulsumBlueSoft)
                    .symbolRenderingMode(.hierarchical)
                Spacer()
                Button(action: dismiss) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title3)
                        .foregroundStyle(Color.pulsumTextSecondary)
                        .symbolRenderingMode(.hierarchical)
                }
                .accessibilityLabel("Dismiss cloud processing banner")
            }

            Text("Cloud processing is optional")
                .font(.pulsumHeadline)
                .foregroundStyle(Color.pulsumTextPrimary)

            Text(bannerCopy)
                .font(.pulsumCallout)
                .foregroundStyle(Color.pulsumTextSecondary)
                .lineSpacing(4)

            Button(action: openSettings) {
                Text("Review Settings")
                    .font(.pulsumCallout.weight(.semibold))
                    .foregroundStyle(Color.pulsumTextPrimary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, PulsumSpacing.sm)
            }
            .glassEffect(.regular.tint(Color.pulsumBlueSoft.opacity(0.7)).interactive())
        }
        .padding(PulsumSpacing.lg)
        .background {
            RoundedRectangle(cornerRadius: PulsumRadius.xl, style: .continuous)
                .fill(.regularMaterial)
                .overlay {
                    RoundedRectangle(cornerRadius: PulsumRadius.xl, style: .continuous)
                        .stroke(Color.white.opacity(0.3), lineWidth: 1)
                }
        }
        .shadow(
            color: Color.black.opacity(0.08),
            radius: 16,
            x: 0,
            y: 8
        )
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/ConsentBannerView.swift -->

### Packages/PulsumUI/Sources/PulsumUI/GlassEffect.swift
- bytes: 4944
- lines: 144
- sha256: c2ae598acc53f0de0730b7ece4407590bd105593018c4b76e001069fac6294b5
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/GlassEffect.swift -->
```swift
import SwiftUI

public struct GlassEffectStyle: Equatable {
    public enum Intensity: Equatable {
        case ultraThin
        case thin
        case regular
        case thick
        case ultraThick

        var material: Material {
            switch self {
            case .ultraThin: return .ultraThinMaterial
            case .thin: return .thinMaterial
            case .regular: return .regularMaterial
            case .thick: return .thickMaterial
            case .ultraThick: return .ultraThickMaterial
            }
        }

        var shadowRadius: CGFloat {
            switch self {
            case .ultraThin: return 6
            case .thin: return 8
            case .regular: return 12
            case .thick: return 16
            case .ultraThick: return 20
            }
        }
    }

    public static var ultraThin: GlassEffectStyle { GlassEffectStyle(intensity: .ultraThin) }
    public static var thin: GlassEffectStyle { GlassEffectStyle(intensity: .thin) }
    public static var regular: GlassEffectStyle { GlassEffectStyle(intensity: .regular) }
    public static var thick: GlassEffectStyle { GlassEffectStyle(intensity: .thick) }
    public static var ultraThick: GlassEffectStyle { GlassEffectStyle(intensity: .ultraThick) }

    public var intensity: Intensity = .regular
    public var tintColor: Color? = nil
    public var cornerRadius: CGFloat? = nil
    public var isInteractive: Bool = false

    public init(intensity: Intensity = .regular,
                tintColor: Color? = nil,
                cornerRadius: CGFloat? = nil,
                isInteractive: Bool = false) {
        self.intensity = intensity
        self.tintColor = tintColor
        self.cornerRadius = cornerRadius
        self.isInteractive = isInteractive
    }

    public func tint(_ color: Color) -> GlassEffectStyle {
        var copy = self
        copy.tintColor = color
        return copy
    }

    public func cornerRadius(_ value: CGFloat) -> GlassEffectStyle {
        var copy = self
        copy.cornerRadius = value
        return copy
    }

    public func interactive(_ value: Bool = true) -> GlassEffectStyle {
        var copy = self
        copy.isInteractive = value
        return copy
    }
}

private struct GlassEffectModifier: ViewModifier {
    @Environment(\.colorScheme) private var colorScheme

    let style: GlassEffectStyle
    private let defaultCornerRadius: CGFloat = 24

    func body(content: Content) -> some View {
        let radius = style.cornerRadius ?? defaultCornerRadius

        content
            .buttonStyle(GlassButtonStyle(style: style, cornerRadius: radius))
            .background(
                RoundedRectangle(cornerRadius: radius, style: .continuous)
                    .fill(style.intensity.material)
                    .overlay {
                        RoundedRectangle(cornerRadius: radius, style: .continuous)
                            .fill(style.tintColor ?? tintFallback)
                            .opacity(style.tintColor == nil ? 0.18 : 1)
                    }
                    .overlay {
                        RoundedRectangle(cornerRadius: radius, style: .continuous)
                            .strokeBorder(Color.white.opacity(colorScheme == .dark ? 0.25 : 0.3), lineWidth: 1)
                    }
                    .shadow(
                        color: Color.black.opacity(colorScheme == .dark ? 0.4 : 0.15),
                        radius: style.intensity.shadowRadius,
                        x: 0,
                        y: style.intensity.shadowRadius / 2
                    )
            )
            .contentShape(RoundedRectangle(cornerRadius: radius, style: .continuous))
    }

    private var tintFallback: Color {
        colorScheme == .dark ? Color.white.opacity(0.12) : Color.white.opacity(0.2)
    }
}

private struct GlassButtonStyle: ButtonStyle {
    let style: GlassEffectStyle
    let cornerRadius: CGFloat

    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed && style.isInteractive ? 0.96 : 1)
            .overlay(
                RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
                    .fill(Color.white.opacity(configuration.isPressed && style.isInteractive ? 0.2 : 0))
            )
            .animation(.spring(response: 0.35, dampingFraction: 0.7), value: configuration.isPressed)
    }
}

public extension View {
    func glassEffect(_ style: GlassEffectStyle = .regular) -> some View {
        modifier(GlassEffectModifier(style: style))
    }
}

public struct GlassEffectContainer<Content: View>: View {
    private let content: Content

    public init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }

    public var body: some View {
        ZStack(alignment: .center) {
            content
        }
        .compositingGroup()
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/GlassEffect.swift -->

### Packages/PulsumUI/Sources/PulsumUI/HealthAccessRequirement.swift
- bytes: 2552
- lines: 58
- sha256: 2cfe945db7c4771a2ca998b35b036dccb454d096ce165ffb4443e2f4aea03c2b
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/HealthAccessRequirement.swift -->
```swift
import Foundation
import HealthKit

enum HealthAccessGrantState {
    case granted
    case denied
    case pending
}

struct HealthAccessRequirement: Identifiable, Equatable {
    let id: String
    let title: String
    let detail: String
    let iconName: String

    static let ordered: [HealthAccessRequirement] = [
        HealthAccessRequirement(id: HKQuantityTypeIdentifier.heartRateVariabilitySDNN.rawValue,
                                title: "Heart Rate Variability",
                                detail: "Captures nervous system recovery.",
                                iconName: "waveform.path.ecg"),
        HealthAccessRequirement(id: HKQuantityTypeIdentifier.heartRate.rawValue,
                                title: "Heart Rate",
                                detail: "Measures training load and exertion.",
                                iconName: "heart.fill"),
        HealthAccessRequirement(id: HKQuantityTypeIdentifier.restingHeartRate.rawValue,
                                title: "Resting Heart Rate",
                                detail: "Highlights baseline strain changes.",
                                iconName: "heart.text.square"),
        HealthAccessRequirement(id: HKCategoryTypeIdentifier.sleepAnalysis.rawValue,
                                title: "Sleep Analysis",
                                detail: "Understands time asleep and quality.",
                                iconName: "bed.double.fill"),
        HealthAccessRequirement(id: HKQuantityTypeIdentifier.respiratoryRate.rawValue,
                                title: "Respiratory Rate",
                                detail: "Tracks breathing patterns overnight.",
                                iconName: "lungs.fill"),
        HealthAccessRequirement(id: HKQuantityTypeIdentifier.stepCount.rawValue,
                                title: "Steps",
                                detail: "Counts movement and activity volume.",
                                iconName: "figure.walk")
    ]

    private static let lookup: [String: HealthAccessRequirement] = {
        var dictionary: [String: HealthAccessRequirement] = [:]
        for requirement in ordered {
            dictionary[requirement.id] = requirement
        }
        return dictionary
    }()

    static func descriptor(for sampleType: HKSampleType) -> HealthAccessRequirement? {
        lookup[sampleType.identifier]
    }

    static func descriptor(forIdentifier identifier: String) -> HealthAccessRequirement? {
        lookup[identifier]
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/HealthAccessRequirement.swift -->

### Packages/PulsumUI/Sources/PulsumUI/LiquidGlassComponents.swift
- bytes: 7132
- lines: 202
- sha256: dc0d1fc7d14677e5d0339a08bd00c7c5c8dc64e22cdfee7fcc6f8c47dffbeeb8
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/LiquidGlassComponents.swift -->
```swift
import SwiftUI

public struct LiquidGlassTabBar: View {
    public struct TabItem: Identifiable {
        public let id = UUID()
        public let icon: String
        public let title: String
        public let badge: Int?

        public init(icon: String, title: String, badge: Int? = nil) {
            self.icon = icon
            self.title = title
            self.badge = badge
        }
    }

    @Binding private var selectedTab: Int
    private let tabs: [TabItem]
    @Namespace private var namespace

    public init(selectedTab: Binding<Int>, tabs: [TabItem]) {
        self._selectedTab = selectedTab
        self.tabs = tabs
    }

    public var body: some View {
        GeometryReader { proxy in
            HStack(spacing: 12) {
                ForEach(Array(tabs.enumerated()), id: \.element.id) { index, tab in
                    tabButton(for: index, tab: tab)
                }
            }
            .padding(.leading, 18)
            .padding(.trailing, 20)
            .padding(.vertical, 14)
            .background { tabBarBackground }
            .frame(maxWidth: .infinity, alignment: .leading)
            .animation(.pulsumStandard, value: selectedTab)
            .contentShape(Rectangle())
            .gesture(
                DragGesture(minimumDistance: 0)
                    .onChanged { value in
                        updateSelection(for: value.location, in: proxy)
                    }
                    .onEnded { _ in }
            )
        }
        .frame(height: 82)
    }

    @ViewBuilder
    private func tabButton(for index: Int, tab: TabItem) -> some View {
        let isSelected = index == selectedTab

        Button {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                selectedTab = index
            }
        } label: {
            tabContent(for: tab, isSelected: isSelected)
        }
        .buttonStyle(.plain)
        .accessibilityLabel(tab.title)
        .accessibilityAddTraits(isSelected ? .isSelected : [])
    }

    private func tabContent(for tab: TabItem, isSelected: Bool) -> some View {
        VStack(alignment: .leading, spacing: 6) {
            ZStack(alignment: .topTrailing) {
                iconView(for: tab, isSelected: isSelected)
                    .frame(width: 28, height: 28)
                    .scaleEffect(isSelected ? 1.04 : 1.0)
                    .animation(.spring(response: 0.28, dampingFraction: 0.85), value: isSelected)

                if let badge = tab.badge, badge > 0 {
                    Text("\(badge)")
                        .font(.system(size: 10, weight: .bold))
                        .foregroundStyle(Color.white)
                        .padding(.horizontal, 5)
                        .padding(.vertical, 2)
                        .background(
                            Capsule()
                                .fill(Color.red.opacity(0.9))
                        )
                        .offset(x: 8, y: -8)
                }
            }

            Text(tab.title)
                .font(.caption)
                .fontWeight(isSelected ? .semibold : .medium)
                .foregroundStyle(isSelected ? Color.pulsumTextPrimary : Color.pulsumTextSecondary)
                .lineLimit(1)
        }
        .padding(.horizontal, 14)
        .padding(.vertical, 10)
        .frame(minWidth: 80, alignment: .leading)
        .contentShape(RoundedRectangle(cornerRadius: 18, style: .continuous))
        .background { tabBackground(isSelected: isSelected) }
    }

    @ViewBuilder
    private func tabBackground(isSelected: Bool) -> some View {
        let shape = RoundedRectangle(cornerRadius: 18, style: .continuous)

        if isSelected {
            shape
                .fill(Color.white.opacity(0.22))
                .overlay {
                    shape
                        .strokeBorder(Color.white.opacity(0.55), lineWidth: 1)
                }
                .overlay {
                    shape
                        .fill(selectionFill)
                        .blur(radius: 14)
                        .matchedGeometryEffect(id: "tabIndicator", in: namespace)
                }
                .shadow(color: Color.black.opacity(0.1), radius: 8, x: 0, y: 6)
        } else {
            shape
                .fill(Color.white.opacity(0.08))
                .overlay {
                    shape
                        .strokeBorder(Color.white.opacity(0.15), lineWidth: 1)
                }
                .shadow(color: Color.black.opacity(0.05), radius: 6, x: 0, y: 3)
        }
    }

    private var tabBarBackground: some View {
        RoundedRectangle(cornerRadius: 28, style: .continuous)
            .fill(Color.white.opacity(0.15))
            .overlay {
                RoundedRectangle(cornerRadius: 28, style: .continuous)
                    .strokeBorder(Color.white.opacity(0.35), lineWidth: 1)
            }
            .overlay(alignment: .topLeading) {
                RoundedRectangle(cornerRadius: 28, style: .continuous)
                    .fill(Color.white.opacity(0.35))
                    .blur(radius: 22)
                    .opacity(0.45)
                    .allowsHitTesting(false)
            }
            .shadow(color: Color.black.opacity(0.08), radius: 18, x: 0, y: 10)
    }

    private func iconView(for tab: TabItem, isSelected: Bool) -> some View {
        Group {
            if isSelected {
                Image(systemName: tab.icon)
                    .symbolRenderingMode(.hierarchical)
                    .foregroundStyle(selectionIconTint)
            } else {
                Image(systemName: tab.icon)
                    .symbolRenderingMode(.hierarchical)
                    .foregroundStyle(Color.secondary)
            }
        }
        .font(.system(size: 22, weight: .semibold))
    }

    private var selectionFill: LinearGradient {
        LinearGradient(
            colors: [
                Color.white.opacity(0.65),
                Color.white.opacity(0.2)
            ],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }

    private var selectionIconTint: some ShapeStyle {
        LinearGradient(
            colors: [
                Color.pulsumBlueSoft,
                Color.pulsumBlueSoft.opacity(0.55)
            ],
            startPoint: .top,
            endPoint: .bottom
        )
    }

    private func updateSelection(for location: CGPoint, in proxy: GeometryProxy) {
        guard !tabs.isEmpty else { return }

        let leadingInset: CGFloat = 18
        let trailingInset: CGFloat = 20
        let usableWidth = max(proxy.size.width - (leadingInset + trailingInset), 1)
        let adjustedX = max(0, min(location.x - leadingInset, usableWidth))
        let segmentWidth = usableWidth / CGFloat(tabs.count)

        let proposedIndex = min(tabs.count - 1, max(0, Int(adjustedX / segmentWidth)))

        if proposedIndex != selectedTab {
            withAnimation(.spring(response: 0.28, dampingFraction: 0.82)) {
                selectedTab = proposedIndex
            }
        }
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/LiquidGlassComponents.swift -->

### Packages/PulsumUI/Sources/PulsumUI/LiveWaveformLevels.swift
- bytes: 1660
- lines: 51
- sha256: a6783fc07f1f31a04489670c0b779d8a3cd9dda33c32624f3907fdb5810502ed
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/LiveWaveformLevels.swift -->
```swift
import SwiftUI

struct LiveWaveformLevels: RandomAccessCollection, MutableCollection, Sendable {
    typealias Index = Int
    private var storage: [CGFloat]
    private var writeIndex: Int = 0
    private var filledCount: Int = 0
    private(set) var samplesAppended: Int = 0

    init(capacity: Int) {
        precondition(capacity > 0, "capacity must be positive")
        storage = Array(repeating: 0, count: capacity)
    }

    var startIndex: Int { 0 }
    var endIndex: Int { filledCount }

    subscript(position: Int) -> CGFloat {
        get {
            precondition(position >= 0 && position < filledCount, "index out of range")
            let index = (writeIndex + storage.count - filledCount + position) % storage.count
            return storage[index]
        }
        set {
            precondition(position >= 0 && position < filledCount, "index out of range")
            let index = (writeIndex + storage.count - filledCount + position) % storage.count
            storage[index] = newValue
        }
    }

    var capacity: Int { storage.count }

    @inline(__always) private func clamp01(_ x: CGFloat) -> CGFloat {
        Swift.max(0, Swift.min(1, x))
    }

    mutating func append(_ value: CGFloat) {
        let clamped = clamp01(value)
        storage[writeIndex] = clamped
        writeIndex = (writeIndex + 1) % storage.count
        filledCount = Swift.min(filledCount + 1, storage.count)
        samplesAppended += 1
    }

    mutating func reset(with value: CGFloat = 0) {
        storage = Array(repeating: value, count: storage.count)
        writeIndex = 0
        filledCount = 0
        samplesAppended = 0
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/LiveWaveformLevels.swift -->

### Packages/PulsumUI/Sources/PulsumUI/OnboardingView.swift
- bytes: 14314
- lines: 375
- sha256: 935b7ba3d9ea8cfcf31311ca5efa42101887426f008f4bc7f27de2ad76b74e2d
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/OnboardingView.swift -->
```swift
import SwiftUI
import HealthKit
import PulsumAgents

struct OnboardingView: View {
    @Binding var isPresented: Bool
    let onComplete: () async -> Void
    var orchestrator: AgentOrchestrator?

    @State private var currentPage = 0
    @State private var isRequestingHealthKit = false
    @State private var healthKitError: String?
    @State private var healthAccessSummary: String = "Checking..."
    @State private var healthAccessStatuses: [String: HealthAccessGrantState] = Dictionary(
        uniqueKeysWithValues: HealthAccessRequirement.ordered.map { ($0.id, .pending) }
    )

    var body: some View {
        ZStack {
            // Light gradient background
            LinearGradient(
                colors: [Color.pulsumBackgroundBeige, Color.pulsumBackgroundCream],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()

            VStack(spacing: 0) {
                // Progress indicator
                HStack(spacing: PulsumSpacing.xs) {
                    ForEach(0..<3) { index in
                        Capsule()
                            .fill(index == currentPage ? Color.pulsumGreenSoft : Color.gray.opacity(0.3))
                            .frame(height: 4)
                            .frame(maxWidth: .infinity)
                    }
                }
                .padding(.horizontal, PulsumSpacing.xl)
                .padding(.top, PulsumSpacing.xl)

                // Content
                TabView(selection: $currentPage) {
                    welcomePage.tag(0)
                    healthKitPage.tag(1)
                    readyPage.tag(2)
                }
                .tabViewStyle(.page(indexDisplayMode: .never))
                .animation(.pulsumStandard, value: currentPage)
            }
        }
        .task {
            refreshHealthAccessStatus()
        }
    }

    // MARK: - Pages

    private var welcomePage: some View {
        VStack(spacing: PulsumSpacing.xxl) {
            Spacer()

            // Logo/Icon
            Image(systemName: "waveform.path.ecg")
                .font(.system(size: 80, weight: .semibold))
                .foregroundStyle(Color.pulsumGreenSoft)
                .symbolRenderingMode(.hierarchical)

            VStack(spacing: PulsumSpacing.lg) {
                Text("Welcome to Pulsum")
                    .font(.pulsumLargeTitle)
                    .foregroundStyle(Color.pulsumTextPrimary)
                    .multilineTextAlignment(.center)

                Text("Your personal recovery companion that helps you optimize your wellbeing using science-backed insights.")
                    .font(.pulsumBody)
                    .foregroundStyle(Color.pulsumTextSecondary)
                    .multilineTextAlignment(.center)
                    .lineSpacing(4)
                    .padding(.horizontal, PulsumSpacing.xl)
            }

            Spacer()

            Button {
                withAnimation(.pulsumStandard) {
                    currentPage = 1
                }
            } label: {
                Text("Get Started")
                    .font(.pulsumHeadline)
                    .foregroundStyle(Color.pulsumTextPrimary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, PulsumSpacing.md)
            }
            .glassEffect(.regular.tint(Color.pulsumGreenSoft.opacity(0.7)).interactive())
            .padding(.horizontal, PulsumSpacing.xl)
            .padding(.bottom, PulsumSpacing.xxl)
        }
    }

    private var healthKitPage: some View {
        VStack(spacing: PulsumSpacing.xxl) {
            Spacer()

            // Health icon
            Image(systemName: "heart.text.square.fill")
                .font(.system(size: 80, weight: .semibold))
                .foregroundStyle(Color.pulsumPinkSoft)
                .symbolRenderingMode(.hierarchical)

            VStack(spacing: PulsumSpacing.lg) {
                Text("Connect Your Health Data")
                    .font(.pulsumTitle)
                    .foregroundStyle(Color.pulsumTextPrimary)
                    .multilineTextAlignment(.center)

                Text("Pulsum analyzes your Heart Rate Variability, Heart Rate, Sleep, and Activity to provide personalized recommendations.")
                    .font(.pulsumBody)
                    .foregroundStyle(Color.pulsumTextSecondary)
                    .multilineTextAlignment(.center)
                    .lineSpacing(4)
                    .padding(.horizontal, PulsumSpacing.xl)

                Text(healthAccessSummary)
                    .font(.pulsumCallout)
                    .foregroundStyle(Color.pulsumTextSecondary)
                    .multilineTextAlignment(.center)

                // Data types list
                VStack(alignment: .leading, spacing: PulsumSpacing.sm) {
                    ForEach(HealthAccessRequirement.ordered) { requirement in
                        onboardingHealthRow(for: requirement,
                                            status: healthAccessStatuses[requirement.id] ?? .pending)
                    }
                }
                .padding(PulsumSpacing.lg)
                .background(Color.pulsumCardWhite)
                .cornerRadius(PulsumRadius.xl)
                .shadow(
                    color: PulsumShadow.small.color,
                    radius: PulsumShadow.small.radius,
                    x: PulsumShadow.small.x,
                    y: PulsumShadow.small.y
                )
                .padding(.horizontal, PulsumSpacing.xl)
            }

            if let error = healthKitError {
                HStack(spacing: PulsumSpacing.xs) {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .font(.pulsumCaption)
                        .foregroundStyle(Color.pulsumWarning)
                    Text(error)
                        .font(.pulsumCaption)
                        .foregroundStyle(Color.pulsumWarning)
                }
                .padding(.horizontal, PulsumSpacing.sm)
                .padding(.vertical, PulsumSpacing.xs)
                .background(Color.pulsumWarning.opacity(0.1))
                .cornerRadius(PulsumRadius.sm)
                .padding(.horizontal, PulsumSpacing.xl)
            }

            Spacer()

            VStack(spacing: PulsumSpacing.md) {
                Button {
                    Task {
                        await requestHealthKitAuthorization()
                    }
                } label: {
                    HStack {
                        if isRequestingHealthKit {
                            ProgressView()
                                .progressViewStyle(.circular)
                                .tint(Color.pulsumTextPrimary)
                            Text("Requesting...")
                                .font(.pulsumHeadline)
                                .foregroundStyle(Color.pulsumTextPrimary)
                        } else {
                            Text("Allow Health Data Access")
                                .font(.pulsumHeadline)
                                .foregroundStyle(Color.pulsumTextPrimary)
                        }
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, PulsumSpacing.md)
                }
                .glassEffect(.regular.tint(Color.pulsumPinkSoft.opacity(0.7)).interactive())
                .disabled(isRequestingHealthKit)

                Button {
                    withAnimation(.pulsumStandard) {
                        currentPage = 2
                    }
                } label: {
                    Text("Skip for Now")
                        .font(.pulsumCallout)
                        .foregroundStyle(Color.pulsumTextSecondary)
                }
            }
            .padding(.horizontal, PulsumSpacing.xl)
            .padding(.bottom, PulsumSpacing.xxl)
        }
    }

    private var readyPage: some View {
        VStack(spacing: PulsumSpacing.xxl) {
            Spacer()

            // Checkmark icon
            Image(systemName: "checkmark.circle.fill")
                .font(.system(size: 80, weight: .semibold))
                .foregroundStyle(Color.pulsumSuccess)
                .symbolRenderingMode(.hierarchical)

            VStack(spacing: PulsumSpacing.lg) {
                Text("You're All Set!")
                    .font(.pulsumTitle)
                    .foregroundStyle(Color.pulsumTextPrimary)
                    .multilineTextAlignment(.center)

                Text("Start your recovery journey with Pulsum. Record your daily Pulse, get personalized recommendations, and optimize your wellbeing.")
                    .font(.pulsumBody)
                    .foregroundStyle(Color.pulsumTextSecondary)
                    .multilineTextAlignment(.center)
                    .lineSpacing(4)
                    .padding(.horizontal, PulsumSpacing.xl)
            }

            Spacer()

            Button {
                Task {
                    await onComplete()
                    isPresented = false
                }
            } label: {
                Text("Start Using Pulsum")
                    .font(.pulsumHeadline)
                    .foregroundStyle(Color.pulsumTextPrimary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, PulsumSpacing.md)
            }
            .glassEffect(.regular.tint(Color.pulsumGreenSoft.opacity(0.7)).interactive())
            .padding(.horizontal, PulsumSpacing.xl)
            .padding(.bottom, PulsumSpacing.xxl)
        }
    }

    // MARK: - Helper Views

    private func onboardingHealthRow(for requirement: HealthAccessRequirement,
                                     status: HealthAccessGrantState) -> some View {
        HStack(spacing: PulsumSpacing.sm) {
            Image(systemName: requirement.iconName)
                .font(.pulsumTitle3)
                .foregroundStyle(Color.pulsumTextPrimary.opacity(0.8))
            VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                Text(requirement.title)
                    .font(.pulsumBody.weight(.semibold))
                    .foregroundStyle(Color.pulsumTextPrimary)
                Text(requirement.detail)
                    .font(.pulsumCaption)
                    .foregroundStyle(Color.pulsumTextSecondary)
            }
            Spacer()
            onboardingStatusBadge(for: status)
        }
    }

    // MARK: - HealthKit Authorization

    private func requestHealthKitAuthorization() async {
        isRequestingHealthKit = true
        healthKitError = nil

        if let orchestrator {
            do {
                let status = try await orchestrator.requestHealthAccess()
                applyHealthStatus(status)
                withAnimation(.pulsumStandard) {
                    currentPage = 2
                }
            } catch {
                healthKitError = error.localizedDescription
            }
            isRequestingHealthKit = false
            return
        }

        guard HKHealthStore.isHealthDataAvailable() else {
            healthKitError = "Health data is not available on this device"
            isRequestingHealthKit = false
            return
        }

        do {
            let healthStore = HKHealthStore()
            let readTypes = Set(HealthAccessRequirement.ordered.compactMap { requirement -> HKSampleType? in
                if let quantity = HKObjectType.quantityType(forIdentifier: HKQuantityTypeIdentifier(rawValue: requirement.id)) {
                    return quantity
                }
                if let category = HKObjectType.categoryType(forIdentifier: HKCategoryTypeIdentifier(rawValue: requirement.id)) {
                    return category
                }
                return nil
            })

            try await healthStore.requestAuthorization(toShare: [], read: readTypes)
            refreshHealthAccessStatus()
            withAnimation(.pulsumStandard) {
                currentPage = 2
            }
        } catch {
            healthKitError = error.localizedDescription
        }

        isRequestingHealthKit = false
    }

    private func refreshHealthAccessStatus() {
        guard let orchestrator else {
            healthAccessSummary = "Connect Pulsum to check permissions."
            return
        }
        Task {
            let status = await orchestrator.currentHealthAccessStatus()
            await MainActor.run {
                applyHealthStatus(status)
            }
        }
    }

    private func applyHealthStatus(_ status: HealthAccessStatus) {
        switch status.availability {
        case .available:
            if status.totalRequired > 0 {
                healthAccessSummary = "\(status.grantedCount)/\(status.totalRequired) granted"
            } else {
                healthAccessSummary = "Health data ready"
            }
        case .unavailable:
            healthAccessSummary = "Health data unavailable on this device"
        }

        var updated = healthAccessStatuses
        for requirement in HealthAccessRequirement.ordered {
            let identifier = requirement.id
            if status.granted.contains(where: { $0.identifier == identifier }) {
                updated[identifier] = .granted
            } else if status.denied.contains(where: { $0.identifier == identifier }) {
                updated[identifier] = .denied
            } else if status.notDetermined.contains(where: { $0.identifier == identifier }) {
                updated[identifier] = .pending
            }
        }
        healthAccessStatuses = updated
    }

    @ViewBuilder
    private func onboardingStatusBadge(for status: HealthAccessGrantState) -> some View {
        switch status {
        case .granted:
            Image(systemName: "checkmark.circle.fill")
                .foregroundStyle(Color.pulsumGreenSoft)
        case .denied:
            Image(systemName: "xmark.circle.fill")
                .foregroundStyle(Color.pulsumWarning)
        case .pending:
            Image(systemName: "questionmark.circle")
                .foregroundStyle(Color.pulsumTextSecondary)
        }
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/OnboardingView.swift -->

### Packages/PulsumUI/Sources/PulsumUI/PulseView.swift
- bytes: 16810
- lines: 427
- sha256: 39e60b6a4b94ef1230b77dc9cba30d327a2d3c246dfa51184fedd23d3237f4c7
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/PulseView.swift -->
```swift
import SwiftUI
import Observation
#if canImport(UIKit)
import UIKit
#endif

struct PulseView: View {
    @Bindable var viewModel: PulseViewModel
    @Binding var isPresented: Bool

    @State private var autoDismissTask: Task<Void, Never>?

    var body: some View {
        NavigationStack {
            ZStack {
                // Background gradient
                LinearGradient(
                    colors: [Color.pulsumBackgroundBeige, Color.pulsumBackgroundCream],
                    startPoint: .top,
                    endPoint: .bottom
                )
                .ignoresSafeArea()
                
                // Content
                ScrollView {
                    LazyVStack(alignment: .leading, spacing: PulsumSpacing.xl) {
                        journalSection
                        slidersSection
                    }
                    .padding(.horizontal, PulsumSpacing.lg)
                    .padding(.top, PulsumSpacing.md)
                    .padding(.bottom, PulsumSpacing.xxxl)
                }
                .scrollIndicators(.hidden)
            }
            .navigationTitle("Pulse Check-In")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button {
                        isPresented = false
                    } label: {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title3)
                            .foregroundStyle(Color.pulsumTextSecondary)
                            .symbolRenderingMode(.hierarchical)
                    }
                }
            }
            .toolbarBackground(.automatic, for: .navigationBar)
            .onDisappear { autoDismissTask?.cancel() }
            .onChange(of: viewModel.sliderSubmissionMessage) { _, message in
                guard message != nil else { return }
                autoDismissTask?.cancel()
                autoDismissTask = Task {
                    try? await Task.sleep(nanoseconds: 2_500_000_000)
                    if !Task.isCancelled {
                        isPresented = false
                    }
                }
            }
        }
    }

    private var journalSection: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            Text("Voice journal")
                .font(.pulsumHeadline)
                .foregroundStyle(Color.pulsumTextPrimary)

            if let toast = viewModel.savedToastMessage {
                SavedToastView(message: toast)
                    .accessibilityIdentifier("VoiceJournalSavedToast")
                    .transition(.move(edge: .top).combined(with: .opacity))
            }

            VoiceJournalButton(
                isRecording: viewModel.isRecording,
                isAnalyzing: viewModel.isAnalyzing,
                remaining: viewModel.recordingSecondsRemaining,
                waveformLevels: viewModel.waveformLevels,
                startAction: { viewModel.startRecording() },
                stopAction: { viewModel.stopRecording() }
            )
            
            // Transcript display
            if let transcript = viewModel.transcript,
               !transcript.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                VStack(alignment: .leading, spacing: PulsumSpacing.xs) {
                    HStack {
                        Text("Transcript")
                            .font(.pulsumFootnote)
                            .foregroundStyle(Color.pulsumTextSecondary)
                            .accessibilityIdentifier("VoiceJournalTranscriptLabel")
                        
                        if viewModel.isRecording {
                            Text("• LIVE")
                                .font(.pulsumFootnote)
                                .foregroundStyle(Color.pulsumError)
                                .fontWeight(.semibold)
                        }
                        
                        Spacer()
                        
                        Button("Clear") {
                            viewModel.clearTranscript()
                        }
                        .font(.pulsumCaption)
                        .foregroundStyle(Color.pulsumTextSecondary)
                    }
                    
                    Text(transcript)
                        .font(.pulsumBody)
                        .foregroundStyle(Color.pulsumTextPrimary)
                        .accessibilityIdentifier("VoiceJournalTranscriptText")
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(PulsumSpacing.sm)
                        .background {
                            RoundedRectangle(cornerRadius: PulsumRadius.md, style: .continuous)
                                .fill(Color.pulsumBackgroundBeige.opacity(0.3))
                        }
                }
                .animation(.pulsumStandard, value: transcript)
                .transition(.opacity.combined(with: .scale(scale: 0.95)))
            }

            if let error = viewModel.analysisError {
                InfoBubble(icon: "exclamationmark.triangle", text: error, tint: Color.pulsumWarning)
            }
        }
        .padding(PulsumSpacing.lg)
        .background {
            RoundedRectangle(cornerRadius: PulsumRadius.xl, style: .continuous)
                .fill(.regularMaterial)
                .overlay {
                    RoundedRectangle(cornerRadius: PulsumRadius.xl, style: .continuous)
                        .stroke(Color.white.opacity(0.3), lineWidth: 1)
                }
                .shadow(
                    color: Color.black.opacity(0.08),
                    radius: 16,
                    x: 0,
                    y: 6
                )
        }
    }

    private var slidersSection: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            Text("How are you feeling right now?")
                .font(.pulsumHeadline)
                .foregroundStyle(Color.pulsumTextPrimary)

            VStack(spacing: PulsumSpacing.sm) {
                sliderRow(title: "Stress", value: $viewModel.stressLevel, description: "1 = very calm, 7 = overwhelmed")
                sliderRow(title: "Energy", value: $viewModel.energyLevel, description: "1 = depleted, 7 = fully charged")
                sliderRow(title: "Sleep quality", value: $viewModel.sleepQualityLevel, description: "1 = poor, 7 = deeply restorative")
            }

            if let error = viewModel.sliderErrorMessage {
                InfoBubble(icon: "exclamationmark.octagon", text: error, tint: Color.pulsumWarning)
            }

            if let message = viewModel.sliderSubmissionMessage {
                InfoBubble(icon: "checkmark.circle.fill", text: message, tint: Color.pulsumSuccess)
            }

            Button {
                viewModel.submitInputs()
            } label: {
                Text(viewModel.isSubmittingInputs ? "Saving..." : "Save inputs")
                    .font(.pulsumHeadline)
                    .foregroundStyle(Color.pulsumTextPrimary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, PulsumSpacing.md)
            }
            .glassEffect(.regular.tint(Color.pulsumGreenSoft.opacity(0.8)).interactive())
            .disabled(viewModel.isSubmittingInputs)
        }
        .padding(PulsumSpacing.lg)
        .background {
            RoundedRectangle(cornerRadius: PulsumRadius.xl, style: .continuous)
                .fill(.regularMaterial)
                .overlay {
                    RoundedRectangle(cornerRadius: PulsumRadius.xl, style: .continuous)
                        .stroke(Color.white.opacity(0.3), lineWidth: 1)
                }
                .shadow(
                    color: Color.black.opacity(0.08),
                    radius: 16,
                    x: 0,
                    y: 6
                )
        }
    }

    private func sliderRow(title: String, value: Binding<Double>, description: String) -> some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.sm) {
            HStack {
                Text(title)
                    .font(.pulsumBody.weight(.semibold))
                    .foregroundStyle(Color.pulsumTextPrimary)
                Spacer()
                Text("\(Int(value.wrappedValue.rounded()))")
                    .font(.pulsumTitle3.weight(.bold))
                    .foregroundStyle(Color.pulsumGreenSoft)
                    .monospacedDigit()
            }
            
            Slider(value: value, in: 1...7, step: 1)
                .tint(Color.pulsumGreenSoft)
            
            Text(description)
                .font(.pulsumCaption)
                .foregroundStyle(Color.pulsumTextSecondary)
                .lineSpacing(2)
        }
        .padding(PulsumSpacing.md)
        .background {
            RoundedRectangle(cornerRadius: PulsumRadius.md, style: .continuous)
                .fill(Color.pulsumBackgroundBeige.opacity(0.3))
        }
    }
}

// Simple horizontal voice journal button
private struct VoiceJournalButton: View {
    let isRecording: Bool
    let isAnalyzing: Bool
    let remaining: Int
    let waveformLevels: LiveWaveformLevels
    let startAction: () -> Void
    let stopAction: () -> Void
    
    private let maxDuration: Double = 30
    
    var body: some View {
        HStack(spacing: PulsumSpacing.md) {
            if isRecording {
                // Recording state: waveform + stop button with progress
                waveformView
                
                ZStack {
                    // Progress ring background
                    Circle()
                        .stroke(Color.gray.opacity(0.2), lineWidth: 3)
                        .frame(width: 56, height: 56)
                    
                    // Progress ring foreground
                    Circle()
                        .trim(from: 0, to: CGFloat(maxDuration - Double(remaining)) / maxDuration)
                        .stroke(Color.pulsumGreenSoft, style: StrokeStyle(lineWidth: 3, lineCap: .round))
                        .frame(width: 56, height: 56)
                        .rotationEffect(.degrees(-90))
                        .animation(.linear(duration: 1), value: remaining)
                    
                    // Stop button
                    Button {
                        performPulseHaptic(.medium)
                        stopAction()
                    } label: {
                        ZStack {
                            Circle()
                                .fill(Color.pulsumError)
                                .frame(width: 48, height: 48)
                            
                            Image(systemName: "stop.fill")
                                .font(.system(size: 20, weight: .semibold))
                                .foregroundStyle(.white)
                        }
                    }
                    .accessibilityLabel("Stop recording")
                    .accessibilityHint("Double tap to stop recording")
                    .accessibilityIdentifier("VoiceJournalStopButton")
                }
            } else if isAnalyzing {
                // Processing state: spinner + text
                ProgressView()
                    .progressViewStyle(.circular)
                    .tint(Color.pulsumGreenSoft)
                    .scaleEffect(1.2)
                    .frame(width: 48, height: 48)
                
                VStack(alignment: .leading, spacing: 2) {
                    Text("Analyzing...")
                        .font(.pulsumHeadline)
                        .foregroundStyle(Color.pulsumTextPrimary)
                    
                    Text("Processing your journal entry")
                        .font(.pulsumFootnote)
                        .foregroundStyle(Color.pulsumTextSecondary)
                }
            } else {
                // Idle state: record button + text
                Button {
                    performPulseHaptic(.heavy)
                    startAction()
                } label: {
                    ZStack {
                        Circle()
                            .fill(Color.pulsumGreenSoft)
                            .frame(width: 48, height: 48)
                        
                        Image(systemName: "mic.fill")
                            .font(.system(size: 20, weight: .semibold))
                            .foregroundStyle(.white)
                    }
                }
                .accessibilityLabel("Record voice journal")
                .accessibilityHint("Double tap to start recording")
                .accessibilityIdentifier("VoiceJournalStartButton")
                
                VStack(alignment: .leading, spacing: 2) {
                    Text("Tap to record")
                        .font(.pulsumHeadline)
                        .foregroundStyle(Color.pulsumTextPrimary)
                    
                    Text("Up to 30 seconds")
                        .font(.pulsumFootnote)
                        .foregroundStyle(Color.pulsumTextSecondary)
                }
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .animation(.pulsumStandard, value: isRecording)
        .animation(.pulsumStandard, value: isAnalyzing)
    }
    
    private var waveformView: some View {
        Canvas { context, size in
            let width = size.width
            let height = size.height
            let barWidth: CGFloat = 2.5
            let barSpacing: CGFloat = 2
            let barCount = Swift.max(1, Int(width / (barWidth + barSpacing)))
            let samples = Array(waveformLevels.suffix(barCount))

            for (index, level) in samples.enumerated() {
                let x = CGFloat(index) * (barWidth + barSpacing)
                let normalizedLevel = Swift.max(0.05, Swift.min(1.0, level))
                let barHeight = height * normalizedLevel
                let y = (height - barHeight) / 2
                
                let rect = CGRect(x: x, y: y, width: barWidth, height: barHeight)
                let roundedRect = RoundedRectangle(cornerRadius: barWidth / 2)
                
                context.fill(
                    roundedRect.path(in: rect),
                    with: .color(Color.pulsumGreenSoft.opacity(0.8))
                )
            }
        }
        .frame(height: 40)
        .frame(maxWidth: .infinity)
    }
}

private struct InfoBubble: View {
    let icon: String
    let text: String
    let tint: Color

    var body: some View {
        HStack(alignment: .top, spacing: PulsumSpacing.sm) {
            Image(systemName: icon)
                .font(.pulsumHeadline)
                .foregroundStyle(tint)
            Text(text)
                .font(.pulsumCallout)
                .foregroundStyle(Color.pulsumTextPrimary)
        }
        .padding(PulsumSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background {
            RoundedRectangle(cornerRadius: PulsumRadius.md, style: .continuous)
                .fill(.thinMaterial)
                .overlay {
                    RoundedRectangle(cornerRadius: PulsumRadius.md, style: .continuous)
                        .stroke(Color.white.opacity(0.2), lineWidth: 0.5)
                }
        }
        .shadow(
            color: Color.black.opacity(0.06),
            radius: 8,
            x: 0,
            y: 3
        )
    }
}

private struct SavedToastView: View {
    let message: String

    var body: some View {
        HStack(spacing: PulsumSpacing.sm) {
            Image(systemName: "checkmark.seal.fill")
                .font(.pulsumHeadline)
                .foregroundStyle(Color.pulsumSuccess)
            Text(message)
                .font(.pulsumCallout)
                .foregroundStyle(Color.pulsumTextPrimary)
        }
        .padding(PulsumSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: PulsumRadius.md, style: .continuous)
                .fill(Color.pulsumBackgroundBeige.opacity(0.6))
        )
    }
}

private enum PulseHapticStyle { case medium, heavy }

#if canImport(UIKit)
private func performPulseHaptic(_ style: PulseHapticStyle) {
    let mapped: UIImpactFeedbackGenerator.FeedbackStyle = {
        switch style {
        case .medium: return .medium
        case .heavy: return .heavy
        }
    }()
    let generator = UIImpactFeedbackGenerator(style: mapped)
    generator.impactOccurred()
}
#else
private func performPulseHaptic(_ style: PulseHapticStyle) {}
#endif
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/PulseView.swift -->

### Packages/PulsumUI/Sources/PulsumUI/PulseViewModel.swift
- bytes: 9265
- lines: 255
- sha256: 4d96ff630c90fb50e3cda19fc0ad57e75ddb5e96a3b25929be81556ccb4efd9b
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/PulseViewModel.swift -->
```swift
import Foundation
import Observation
import PulsumAgents
import SwiftUI
import PulsumTypes

@MainActor
@Observable
final class PulseViewModel {
    private enum RecordingError: LocalizedError {
        case streamUnavailable

        var errorDescription: String? {
            switch self {
            case .streamUnavailable:
                return "Unable to access the microphone stream."
            }
        }
    }
    @ObservationIgnored private var orchestrator: AgentOrchestrator?
    @ObservationIgnored private var countdownTask: Task<Void, Never>?
    @ObservationIgnored private var recordingTask: Task<Void, Never>?
    @ObservationIgnored private var audioLevelTask: Task<Void, Never>?
    @ObservationIgnored private var toastTask: Task<Void, Never>?

    var isRecording = false
    var recordingSecondsRemaining: Int = 30
    var waveformLevels = LiveWaveformLevels(capacity: 180)
    var transcript: String?
    var sentimentScore: Double?
    var analysisError: String?
    var lastCapturedAt: Date?

    var stressLevel: Double = 4
    var energyLevel: Double = 4
    var sleepQualityLevel: Double = 4

    var isSubmittingInputs = false
    var sliderSubmissionMessage: String?
    var sliderErrorMessage: String?

    var isAnalyzing = false
    var onSafetyDecision: ((SafetyDecision) -> Void)?
    var savedToastMessage: String?

    func bind(orchestrator: AgentOrchestrator) {
        self.orchestrator = orchestrator
    }

    func startRecording(maxDuration: TimeInterval = 30) {
        guard let orchestrator else { return }
        guard !isRecording && !isAnalyzing else { return }
        cancelCountdown()
        toastTask?.cancel()
        savedToastMessage = nil
        analysisError = nil
        transcript = nil
        sentimentScore = nil
        lastCapturedAt = nil
        waveformLevels.reset()
        recordingSecondsRemaining = Int(maxDuration.rounded(.up))
        isRecording = true
        isAnalyzing = true
        recordingTask?.cancel()
        recordingTask = nil
        audioLevelTask?.cancel()
        audioLevelTask = nil

        countdownTask = Task { [weak self] in
            guard let self else { return }
            var remaining = maxDuration
            while remaining > 0 && !Task.isCancelled {
                try? await Task.sleep(nanoseconds: 1_000_000_000)
                remaining -= 1
                if !Task.isCancelled {
                    self.recordingSecondsRemaining = max(Int(remaining.rounded(.up)), 0)
                }
            }
        }

        recordingTask = Task { [weak self] in
            guard let self else { return }
            var latestTranscript = ""
            do {
                try await orchestrator.beginVoiceJournalRecording(maxDuration: maxDuration)

                guard let speechStream = orchestrator.voiceJournalSpeechStream,
                      let levelStream = orchestrator.voiceJournalAudioLevels else {
                    throw RecordingError.streamUnavailable
                }

                audioLevelTask = Task.detached { [weak self] in
                    guard let self else { return }
                    for await level in levelStream {
                        guard !Task.isCancelled else { break }
                        await MainActor.run {
                            self.waveformLevels.append(CGFloat(level))
                        }
                    }
                }

                for try await segment in speechStream {
                    guard !Task.isCancelled else { break }
                    latestTranscript = segment.transcript
                    orchestrator.updateVoiceJournalTranscript(latestTranscript)
                    transcript = latestTranscript
                }

                isRecording = false
                let response = try await orchestrator.finishVoiceJournalRecording(transcript: latestTranscript)
                handleJournalResponse(response)
            } catch {
                await handleRecordingFailure(error,
                                             orchestrator: orchestrator,
                                             latestTranscript: latestTranscript)
            }

            isRecording = false
            isAnalyzing = false
            cancelCountdown()
            recordingTask = nil
            audioLevelTask?.cancel()
            audioLevelTask = nil
        }
    }

    func stopRecording() {
        guard isRecording else { return }
        
        // Stop audio capture but keep processing state
        // The recording task will continue and save the transcript
        cancelCountdown()
        isRecording = false
        audioLevelTask?.cancel()
        audioLevelTask = nil
        
        // This signals the speech service to stop capturing audio
        // The transcript captured so far will be processed
        orchestrator?.stopVoiceJournalRecording()
        
        // isAnalyzing remains true - will be set to false when processing completes
        // recordingTask continues running to save the transcript
    }

    func submitInputs(for date: Date = Date()) {
        guard let orchestrator else { return }
        isSubmittingInputs = true
        sliderErrorMessage = nil
        sliderSubmissionMessage = nil
        Task { [weak self] in
            guard let self else { return }
            do {
                try await orchestrator.updateSubjectiveInputs(
                    date: date,
                    stress: stressLevel,
                    energy: energyLevel,
                    sleepQuality: sleepQualityLevel
                )
                self.sliderSubmissionMessage = "Thanks for checking in."
                self.scheduleSubmissionReset()
            } catch {
                self.sliderErrorMessage = error.localizedDescription
            }
            self.isSubmittingInputs = false
        }
    }

    func clearTranscript() {
        transcript = nil
        sentimentScore = nil
        analysisError = nil
        savedToastMessage = nil
        lastCapturedAt = nil
        toastTask?.cancel()
        toastTask = nil
    }

    private func scheduleSubmissionReset() {
        Task { [weak self] in
            try? await Task.sleep(nanoseconds: 2_000_000_000)
            guard let self else { return }
            self.sliderSubmissionMessage = nil
        }
    }

    private func handleJournalResponse(_ response: JournalCaptureResponse) {
        transcript = response.result.transcript
        sentimentScore = response.result.sentimentScore
        lastCapturedAt = Date()
        onSafetyDecision?(response.safety)
        analysisError = nil
        if response.result.embeddingPending {
            savedToastMessage = "Saved. We'll finish analyzing this entry soon."
            Diagnostics.log(level: .info,
                            category: .ui,
                            name: "ui.analysis.deferred",
                            fields: [
                                "reason": .safeString(.stage("journal_embeddings_pending",
                                                             allowed: ["embeddings_pending", "health_backfill_running", "library_index_deferred", "journal_embeddings_pending", "unknown"])),
                                "pending_journals": .int(1)
                            ])
        } else {
            savedToastMessage = "Saved to Journal"
        }
        toastTask?.cancel()
        toastTask = Task { [weak self] in
            try? await Task.sleep(nanoseconds: 3_000_000_000)
            await MainActor.run {
                self?.savedToastMessage = nil
            }
        }
    }

    private func handleRecordingFailure(_ error: Error,
                                        orchestrator: AgentOrchestrator,
                                        latestTranscript: String) async {
        analysisError = mapRecordingError(error)
        let fallback = latestTranscript.isEmpty ? (transcript ?? "") : latestTranscript
        let trimmed = fallback.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else {
            orchestrator.stopVoiceJournalRecording()
            return
        }
        if let response = try? await orchestrator.finishVoiceJournalRecording(transcript: trimmed) {
            handleJournalResponse(response)
        }
    }

    private func mapRecordingError(_ error: Error) -> String {
        if let sentimentError = error as? SentimentAgentError {
            switch sentimentError {
            case .noSpeechDetected:
                return "I couldn't hear anything. Let's try again."
            case .sessionAlreadyActive:
                return "Recording already in progress."
            case .noActiveRecording:
                return "No active recording to finish."
            }
        }
        // NOTE: keep UI layer decoupled from PulsumServices; lower layers surface user-facing copy via LocalizedError.
        return error.localizedDescription
    }

    private func cancelCountdown() {
        countdownTask?.cancel()
        countdownTask = nil
    }

    deinit {
        countdownTask?.cancel()
        recordingTask?.cancel()
        audioLevelTask?.cancel()
        toastTask?.cancel()
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/PulseViewModel.swift -->

### Packages/PulsumUI/Sources/PulsumUI/PulsumDesignSystem.swift
- bytes: 7850
- lines: 172
- sha256: 1161eba2b1c5fd1e7416822f23f46e26b55657d2ee00af5d9f06b5bd32edd348
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/PulsumDesignSystem.swift -->
```swift
import SwiftUI

// MARK: - Pulsum Design System
// Light, fresh, minimalistic aesthetic inspired by iOS 26 Liquid Glass principles

extension Color {
    // MARK: - Background Colors (Light, Fresh, Beige-based from maindesign.png)
    static let pulsumBackgroundBeige = Color(red: 0.96, green: 0.95, blue: 0.93) // #F5F3ED - warm beige primary
    static let pulsumBackgroundCream = Color(red: 0.98, green: 0.97, blue: 0.95) // #FAF8F2 - soft cream
    static let pulsumBackgroundLight = Color(red: 0.97, green: 0.96, blue: 0.94) // #F7F5F0 - light beige
    static let pulsumBackgroundPeach = Color(red: 0.99, green: 0.96, blue: 0.94) // #FCF5F0 - peachy tint

    // MARK: - Accent Colors (Soft & Energizing from mockups)
    static let pulsumMintGreen = Color(red: 0.83, green: 0.93, blue: 0.85) // #D4EED4 - mint green (chat bubbles)
    static let pulsumMintLight = Color(red: 0.91, green: 0.96, blue: 0.91) // #E8F5E8 - light mint
    static let pulsumBlueSoft = Color(red: 0.66, green: 0.84, blue: 0.95) // #A8D5F2 - soft blue
    static let pulsumPinkSoft = Color(red: 0.98, green: 0.89, blue: 0.89) // #FAE3E3 - soft pink (secondary)
    static let pulsumGreenSoft = Color(red: 0.48, green: 0.80, blue: 0.48) // #7ACC7A - soft green accent

    // MARK: - Text Colors (Dark on Light - high contrast)
    static let pulsumTextPrimary = Color(red: 0.17, green: 0.17, blue: 0.18) // #2C2C2E - dark charcoal
    static let pulsumTextSecondary = Color(red: 0.56, green: 0.56, blue: 0.58) // #8F8F94 - medium gray
    static let pulsumTextTertiary = Color(red: 0.74, green: 0.74, blue: 0.76) // #BCBCC0 - light gray

    // MARK: - Card & Surface Colors
    static let pulsumCardWhite = Color.white
    static let pulsumCardShadow = Color.black.opacity(0.06)
    static let pulsumCardShadowMedium = Color.black.opacity(0.08)
    static let pulsumCardBorder = Color.black.opacity(0.04)

    // MARK: - Semantic Colors
    static let pulsumSuccess = Color(red: 0.20, green: 0.78, blue: 0.35) // #34C759 - green
    static let pulsumWarning = Color(red: 1.0, green: 0.58, blue: 0.0) // #FF9500 - orange
    static let pulsumError = Color(red: 1.0, green: 0.23, blue: 0.19) // #FF3B30 - red
    static let pulsumInfo = Color(red: 0.04, green: 0.52, blue: 1.0) // #0A84FF - blue
}

// MARK: - Spacing System
enum PulsumSpacing {
    static let xxs: CGFloat = 4
    static let xs: CGFloat = 8
    static let sm: CGFloat = 12
    static let md: CGFloat = 16
    static let lg: CGFloat = 24
    static let xl: CGFloat = 32
    static let xxl: CGFloat = 48
    static let xxxl: CGFloat = 64
}

// MARK: - Corner Radius System
enum PulsumRadius {
    static let xs: CGFloat = 8
    static let sm: CGFloat = 12
    static let md: CGFloat = 16
    static let lg: CGFloat = 20
    static let xl: CGFloat = 24
    static let xxl: CGFloat = 28
    static let xxxl: CGFloat = 32
}

// MARK: - Typography Extensions
extension Font {
    // MARK: - Display Fonts
    static let pulsumLargeTitle = Font.system(size: 34, weight: .bold, design: .default)
    static let pulsumTitle = Font.system(size: 28, weight: .bold, design: .default)
    static let pulsumTitle2 = Font.system(size: 22, weight: .semibold, design: .default)
    static let pulsumTitle3 = Font.system(size: 20, weight: .semibold, design: .default)

    // MARK: - Body Fonts
    static let pulsumHeadline = Font.system(size: 17, weight: .semibold, design: .default)
    static let pulsumBody = Font.system(size: 17, weight: .regular, design: .default)
    static let pulsumCallout = Font.system(size: 16, weight: .regular, design: .default)
    static let pulsumSubheadline = Font.system(size: 15, weight: .regular, design: .default)
    static let pulsumFootnote = Font.system(size: 13, weight: .regular, design: .default)
    static let pulsumCaption = Font.system(size: 12, weight: .regular, design: .default)
    static let pulsumCaption2 = Font.system(size: 11, weight: .regular, design: .default)

    // MARK: - Data Display (Rounded for Metrics)
    static let pulsumDataXLarge = Font.system(size: 58, weight: .bold, design: .rounded)
    static let pulsumDataLarge = Font.system(size: 48, weight: .bold, design: .rounded)
    static let pulsumDataMedium = Font.system(size: 32, weight: .bold, design: .rounded)
    static let pulsumDataSmall = Font.system(size: 24, weight: .semibold, design: .rounded)
}

// MARK: - Animation Presets
extension Animation {
    static let pulsumQuick = Animation.spring(response: 0.3, dampingFraction: 0.75)
    static let pulsumStandard = Animation.spring(response: 0.4, dampingFraction: 0.8)
    static let pulsumSmooth = Animation.spring(response: 0.5, dampingFraction: 0.85)
    static let pulsumBouncy = Animation.spring(response: 0.5, dampingFraction: 0.6)
}

// MARK: - Shadow Styles
struct PulsumShadow {
    static let small = (color: Color.pulsumCardShadow, radius: CGFloat(8), x: CGFloat(0), y: CGFloat(2))
    static let medium = (color: Color.pulsumCardShadowMedium, radius: CGFloat(12), x: CGFloat(0), y: CGFloat(4))
    static let large = (color: Color.pulsumCardShadowMedium, radius: CGFloat(20), x: CGFloat(0), y: CGFloat(8))
}

// MARK: - View Modifiers
extension View {
    /// Applies Pulsum card style: white background with soft shadow
    func pulsumCardStyle(padding: CGFloat = 20, cornerRadius: CGFloat = PulsumRadius.xl) -> some View {
        self
            .padding(padding)
            .background(Color.pulsumCardWhite)
            .cornerRadius(cornerRadius)
            .shadow(
                color: PulsumShadow.medium.color,
                radius: PulsumShadow.medium.radius,
                x: PulsumShadow.medium.x,
                y: PulsumShadow.medium.y
            )
    }

    /// Applies Pulsum glass material style (for navigation/controls)
    func pulsumGlassMaterial(material: Material = .ultraThinMaterial) -> some View {
        self
            .background(material)
            .overlay(
                RoundedRectangle(cornerRadius: PulsumRadius.xl, style: .continuous)
                    .stroke(Color.white.opacity(0.2), lineWidth: 1)
            )
    }
    
    /// iOS 26 Liquid Glass floating card style
    func pulsumFloatingCard(padding: CGFloat = 20, cornerRadius: CGFloat = PulsumRadius.xl, useGlass: Bool = false) -> some View {
        self
            .padding(padding)
            .background {
                if useGlass {
                    RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
                        .fill(.ultraThinMaterial)
                        .overlay {
                            RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
                                .stroke(Color.white.opacity(0.3), lineWidth: 1)
                        }
                } else {
                    RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
                        .fill(Color.pulsumCardWhite)
                }
            }
            .shadow(
                color: Color.black.opacity(0.06),
                radius: 12,
                x: 0,
                y: 4
            )
    }
    
    /// iOS 26 toolbar button styling
    func pulsumToolbarButton() -> some View {
        self
            .symbolRenderingMode(.monochrome)
            .foregroundStyle(Color.pulsumTextPrimary)
    }
    
    /// iOS 26 interactive scale effect
    func pulsumInteractive() -> some View {
        self
            .buttonStyle(PulsumInteractiveButtonStyle())
    }
}

// MARK: - iOS 26 Interactive Button Style
struct PulsumInteractiveButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.96 : 1.0)
            .animation(.spring(response: 0.3, dampingFraction: 0.7), value: configuration.isPressed)
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/PulsumDesignSystem.swift -->

### Packages/PulsumUI/Sources/PulsumUI/PulsumRootView.swift
- bytes: 14723
- lines: 397
- sha256: ef68a69c7eb4fb2e188bf1c2ec38a22991c4e7718c9989c84bf8f6e694f3ba04
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/PulsumRootView.swift -->
```swift
import SwiftUI
import Observation
import Foundation
import PulsumAgents
import PulsumTypes

public struct PulsumRootView: View {
    @State private var viewModel: AppViewModel

    public init() {
        _viewModel = State(initialValue: AppViewModel())
    }

    init(viewModel: AppViewModel) {
        _viewModel = State(initialValue: viewModel)
    }

    public var body: some View {
        ZStack {
            MainContainerView(viewModel: viewModel)
                .blur(radius: viewModel.startupState == .ready ? 0 : 6)
                .allowsHitTesting(viewModel.startupState == .ready)
                .animation(AppRuntimeConfig.disableAnimations ? nil : .easeInOut(duration: 0.25),
                           value: viewModel.startupState)

            if viewModel.startupState != .ready {
                overlay(for: viewModel.startupState)
                    .transition(.opacity)
            }
        }
        .task { viewModel.start() }
        .onChange(of: viewModel.startupState) { _, newValue in
            let label: String
            switch newValue {
            case .idle: label = "idle"
            case .loading: label = "loading"
            case .ready: label = "ready"
            case .failed: label = "failed"
            case .blocked: label = "blocked"
            }
            Diagnostics.log(level: .info,
                            category: .ui,
                            name: "ui.startupState.changed",
                            fields: [
                                "state": .safeString(.stage(label, allowed: ["idle", "loading", "ready", "failed", "blocked"]))
                            ])
        }
    }

    @ViewBuilder
    private func overlay(for state: AppViewModel.StartupState) -> some View {
        switch state {
        case .idle, .loading:
            Color.black.opacity(0.15)
                .ignoresSafeArea()
                .overlay(alignment: .center) {
                    VStack(spacing: 12) {
                        ProgressView()
                            .progressViewStyle(.circular)
                        Text("Preparing Pulsum...")
                            .font(.callout)
                            .foregroundStyle(.secondary)
                    }
                    .padding(24)
                    .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 24, style: .continuous))
                }
        case .failed(let message):
            Color.black.opacity(0.15)
                .ignoresSafeArea()
                .overlay(alignment: .center) {
                    failureOverlay(message: message)
                }
        case .blocked(let message):
            Color.black.opacity(0.2)
                .ignoresSafeArea()
                .overlay(alignment: .center) {
                    blockedOverlay(message: message)
                }
        case .ready:
            EmptyView()
        }
    }

    private func failureOverlay(message: String) -> some View {
        VStack(spacing: 16) {
            Image(systemName: "exclamationmark.triangle")
                .font(.system(size: 52, weight: .semibold))
                .foregroundStyle(.orange)
            Text("Something went wrong")
                .font(.title2)
                .bold()
            Text(message)
                .font(.body)
                .multilineTextAlignment(.center)
                .foregroundStyle(.secondary)
            Button("Retry") {
                viewModel.retryStartup()
            }
            .buttonStyle(.borderedProminent)
        }
        .padding(24)
        .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 24, style: .continuous))
    }

    private func blockedOverlay(message: String) -> some View {
        VStack(spacing: 16) {
            Image(systemName: "externaldrive.badge.exclamationmark")
                .font(.system(size: 52, weight: .semibold))
                .foregroundStyle(.red)
            Text("Storage Not Secured")
                .font(.title2)
                .bold()
            Text(message)
                .font(.body)
                .multilineTextAlignment(.center)
                .foregroundStyle(.secondary)
            Button("Check Again") {
                viewModel.retryStartup()
            }
            .buttonStyle(.borderedProminent)
        }
        .padding(24)
        .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 24, style: .continuous))
    }
}

struct MainContainerView: View {
    @Bindable var viewModel: AppViewModel
    @Namespace private var transitionNamespace
    @State private var isUITestPresentingSettings = false

    var body: some View {
        ZStack {
            backgroundLayer

            TabView(selection: $viewModel.selectedTab) {
                mainTab
                    .tag(AppViewModel.Tab.main)
                insightsTab
                    .tag(AppViewModel.Tab.insights)
                coachTab
                    .tag(AppViewModel.Tab.coach)
            }
            .tabViewStyle(.automatic)
        }
        .sheet(isPresented: $viewModel.isPresentingPulse) {
            PulseView(
                viewModel: viewModel.pulseViewModel,
                isPresented: $viewModel.isPresentingPulse
            )
            .presentationDetents([.large])
        }
        .sheet(isPresented: settingsSheetBinding) {
            SettingsScreen(
                viewModel: viewModel.settingsViewModel,
                wellbeingState: viewModel.coachViewModel.wellbeingState,
                snapshotKind: viewModel.coachViewModel.snapshotKind
            )
        }
        .overlay {
            if viewModel.isShowingSafetyCard {
                SafetyCardView(message: viewModel.safetyMessage ?? "If in danger, call 911") {
                    viewModel.dismissSafetyCard()
                }
            }
        }
        .overlay {
            if viewModel.showConsentBanner {
                VStack {
                    ConsentBannerView(
                        openSettings: { presentSettings() },
                        dismiss: { viewModel.dismissConsentBanner() }
                    )
                    .padding(.horizontal, PulsumSpacing.lg)
                    .padding(.top, PulsumSpacing.md)
                    .transition(.move(edge: .top).combined(with: .opacity))
                    Spacer()
                }
            }
        }
        .overlay(alignment: .topLeading) {
            if AppRuntimeConfig.settingsHookEnabled {
                Button {
                    presentSettings()
                } label: {
                    Color.clear
                        .frame(width: 44, height: 44)
                }
                .contentShape(Rectangle())
                .accessibilityIdentifier("SettingsTestHookButton")
                .accessibilityElement()
            }
        }
    }

    private var settingsSheetBinding: Binding<Bool> {
        Binding(
            get: { viewModel.isPresentingSettings || isUITestPresentingSettings },
            set: { newValue in
                viewModel.isPresentingSettings = newValue
                isUITestPresentingSettings = newValue
            }
        )
    }

    @MainActor
    private func presentSettings() {
        viewModel.isPresentingSettings = true
        if AppRuntimeConfig.settingsHookEnabled {
            isUITestPresentingSettings = true
        }
    }

    private var backgroundLayer: some View {
        LinearGradient(
            colors: [
                Color.pulsumBackgroundBeige,
                Color.pulsumBackgroundCream
            ],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
        .ignoresSafeArea()
    }

    @ViewBuilder
    private var wellbeingCard: some View {
        switch viewModel.coachViewModel.wellbeingState {
        case let .ready(score, _):
            if let detailViewModel = viewModel.settingsViewModel.makeScoreBreakdownViewModel() {
                NavigationLink {
                    ScoreBreakdownScreen(viewModel: detailViewModel)
                } label: {
                    WellbeingScoreCard(score: score)
                }
                .buttonStyle(.plain)
            } else {
                WellbeingScoreCard(score: score)
            }
        case .loading:
            WellbeingScoreLoadingCard()
        case let .noData(reason):
            if viewModel.coachViewModel.snapshotKind == .placeholder, reason == .insufficientSamples {
                WellbeingPlaceholderCard()
            } else {
                WellbeingNoDataCard(reason: reason) {
                    Task { await viewModel.settingsViewModel.requestHealthKitAuthorization() }
                }
            }
        case let .error(message):
            WellbeingErrorCard(message: message) {
                viewModel.coachViewModel.reloadIfNeeded()
            }
        }
    }

    @ViewBuilder
    private var mainTab: some View {
        NavigationStack {
            ScrollView {
                LazyVStack(spacing: PulsumSpacing.xl) {
                    // Wellbeing Score Card
                    wellbeingCard
                }
                .frame(maxWidth: 520)
                .padding(.horizontal, PulsumSpacing.lg)
                .padding(.top, PulsumSpacing.lg)
                .padding(.bottom, PulsumSpacing.xxxl)
            }
            .scrollIndicators(.hidden)
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button { viewModel.isPresentingPulse = true } label: {
                        Label("Pulse", systemImage: "waveform.path.ecg").labelStyle(.titleAndIcon)
                    }
                    .pulsumToolbarButton()
                    .accessibilityIdentifier("PulseButton")
                    .accessibilityHidden(viewModel.selectedTab != .main)
                    .matchedTransitionSource(id: "pulseButton", in: transitionNamespace)
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button {
                        presentSettings()
                    } label: {
                        Image(systemName: "gearshape")
                            .frame(width: 44, height: 44, alignment: .center)
                            .contentShape(Rectangle())
                    }
                    .pulsumToolbarButton()
                    .accessibilityLabel("Settings")
                    .accessibilityIdentifier("SettingsButton")
                    .accessibilityElement()
                    .accessibilityHidden(viewModel.selectedTab != .main)
                }
            }
            .toolbarBackground(.automatic, for: .navigationBar)
        }
        .tabItem {
            Image(systemName: AppViewModel.Tab.main.iconName)
            Text(AppViewModel.Tab.main.displayName)
        }
    }

    @ViewBuilder
    private var insightsTab: some View {
        NavigationStack {
            InsightsScreen(
                viewModel: viewModel.coachViewModel,
                foundationStatus: viewModel.orchestrator?.foundationModelsStatus ?? "",
                consentGranted: viewModel.consentGranted,
                triggerSettings: { presentSettings() }
            )
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button {
                        viewModel.isPresentingPulse = true
                    } label: {
                        Label("Pulse", systemImage: "waveform.path.ecg")
                            .labelStyle(.titleAndIcon)
                    }
                    .pulsumToolbarButton()
                    .accessibilityIdentifier("PulseButton")
                    .accessibilityHidden(viewModel.selectedTab != .insights)
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button {
                        presentSettings()
                    } label: {
                        Image(systemName: "gearshape")
                            .frame(width: 44, height: 44, alignment: .center)
                            .contentShape(Rectangle())
                    }
                    .pulsumToolbarButton()
                    .accessibilityLabel("Settings")
                    .accessibilityIdentifier("SettingsButton")
                    .accessibilityElement()
                    .accessibilityHidden(viewModel.selectedTab != .insights)
                }
            }
            .toolbarBackground(.automatic, for: .navigationBar)
        }
        .tabItem {
            Image(systemName: AppViewModel.Tab.insights.iconName)
            Text(AppViewModel.Tab.insights.displayName)
        }
    }

    @ViewBuilder
    private var coachTab: some View {
        NavigationStack {
            CoachScreen(
                viewModel: viewModel.coachViewModel,
                showChatInput: true
            )
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button {
                        viewModel.isPresentingPulse = true
                    } label: {
                        Label("Pulse", systemImage: "waveform.path.ecg")
                            .labelStyle(.titleAndIcon)
                    }
                    .pulsumToolbarButton()
                    .accessibilityIdentifier("PulseButton")
                    .accessibilityHidden(viewModel.selectedTab != .coach)
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button {
                        presentSettings()
                    } label: {
                        Image(systemName: "gearshape")
                            .frame(width: 44, height: 44, alignment: .center)
                            .contentShape(Rectangle())
                    }
                    .pulsumToolbarButton()
                    .accessibilityLabel("Settings")
                    .accessibilityIdentifier("SettingsButton")
                    .accessibilityElement()
                    .accessibilityHidden(viewModel.selectedTab != .coach)
                }
            }
            .toolbarBackground(.automatic, for: .navigationBar)
        }
        .tabItem {
            Image(systemName: AppViewModel.Tab.coach.iconName)
            Text(AppViewModel.Tab.coach.displayName)
        }
    }

}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/PulsumRootView.swift -->

### Packages/PulsumUI/Sources/PulsumUI/SafetyCardView.swift
- bytes: 3064
- lines: 79
- sha256: 08166a48a28937cd545fa2faf66369993fc90823495946969ee0a881b9a43342
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/SafetyCardView.swift -->
```swift
import SwiftUI

struct SafetyCardView: View {
    let message: String
    let dismiss: () -> Void

    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .ignoresSafeArea()
                .transition(.opacity)
                .animation(.pulsumStandard, value: true)

            VStack(spacing: PulsumSpacing.lg) {
                // Warning Icon
                Image(systemName: "exclamationmark.triangle.fill")
                    .font(.system(size: 52, weight: .semibold))
                    .foregroundStyle(Color.pulsumError)
                    .symbolRenderingMode(.hierarchical)

                VStack(spacing: PulsumSpacing.sm) {
                    Text("We noticed something important")
                        .font(.pulsumTitle2)
                        .foregroundStyle(Color.pulsumTextPrimary)
                        .multilineTextAlignment(.center)

                    Text(message)
                        .font(.pulsumBody)
                        .foregroundStyle(Color.pulsumTextSecondary)
                        .multilineTextAlignment(.center)
                        .lineSpacing(4)
                }

                VStack(spacing: PulsumSpacing.md) {
                    // Emergency Call Button
                    Link(destination: URL(string: "tel://911")!) {
                        HStack {
                            Image(systemName: "phone.fill")
                                .font(.pulsumHeadline)
                            Text("Call 911")
                                .font(.pulsumHeadline)
                        }
                        .foregroundStyle(Color.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, PulsumSpacing.md)
                        .background(Color.pulsumError)
                        .cornerRadius(PulsumRadius.md)
                    }

                    // I'm Safe Button
                    Button(action: dismiss) {
                        Text("I'm safe")
                            .font(.pulsumBody)
                            .foregroundStyle(Color.pulsumTextPrimary)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, PulsumSpacing.sm)
                    }
                    .glassEffect(.regular.tint(Color.gray.opacity(0.3)).interactive())
                }
            }
            .padding(PulsumSpacing.xl)
            .background {
                RoundedRectangle(cornerRadius: PulsumRadius.xxl, style: .continuous)
                    .fill(.regularMaterial)
                    .overlay {
                        RoundedRectangle(cornerRadius: PulsumRadius.xxl, style: .continuous)
                            .stroke(Color.white.opacity(0.3), lineWidth: 1)
                    }
            }
            .shadow(
                color: Color.black.opacity(0.15),
                radius: 24,
                x: 0,
                y: 12
            )
            .padding(PulsumSpacing.lg)
        }
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/SafetyCardView.swift -->

### Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownView.swift
- bytes: 19557
- lines: 521
- sha256: 1a4886af1f25150fc36bf487290e8bb5f8275d8da3e16b0a36fe9e576bca238b
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownView.swift -->
```swift
import SwiftUI
import PulsumAgents

struct ScoreBreakdownScreen: View {
    @Environment(\.dismiss) private var dismiss
    @State private var viewModel: ScoreBreakdownViewModel

    init(viewModel: ScoreBreakdownViewModel) {
        _viewModel = State(initialValue: viewModel)
    }

    var body: some View {
        NavigationStack {
            ZStack {
                Color.pulsumBackgroundBeige.ignoresSafeArea()

                if viewModel.isLoading && viewModel.breakdown == nil {
                    ProgressView()
                        .progressViewStyle(.circular)
                } else {
                    ScrollView {
                        LazyVStack(alignment: .leading, spacing: PulsumSpacing.lg) {
                            if let breakdown = viewModel.breakdown {
                                SummaryCard(breakdown: breakdown)

                                if let highlights = viewModel.recommendationHighlights {
                                    RecommendationLogicCard(highlights: highlights)
                                }

                                if !viewModel.objectiveMetrics.isEmpty {
                                    MetricSection(title: "Objective signals",
                                                  caption: "Physiological measures compared against your rolling baseline.",
                                                  metrics: viewModel.objectiveMetrics)
                                }

                                if !viewModel.subjectiveMetrics.isEmpty {
                                    MetricSection(title: "Subjective check-in",
                                                  caption: "Sliders you provided during today's pulse.",
                                                  metrics: viewModel.subjectiveMetrics)
                                }

                                if !viewModel.sentimentMetrics.isEmpty {
                                    MetricSection(title: "Journal + sentiment",
                                                  caption: "On-device analysis of your latest journal entry.",
                                                  metrics: viewModel.sentimentMetrics)
                                }

                                if !breakdown.generalNotes.isEmpty {
                                    NotesCard(notes: breakdown.generalNotes)
                                }
                            } else if let message = viewModel.errorMessage {
                                ErrorStateView(message: message)
                            } else {
                                EmptyStateView()
                            }
                        }
                        .padding(.horizontal, PulsumSpacing.lg)
                        .padding(.bottom, PulsumSpacing.xxl)
                    }
                }
            }
            .navigationTitle("Score details")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title3)
                            .foregroundStyle(Color.pulsumTextSecondary)
                            .symbolRenderingMode(.hierarchical)
                    }
                }
            }
            .toolbarBackground(.automatic, for: .navigationBar)
            .task {
                await viewModel.refresh()
            }
        }
    }
}

private struct SummaryCard: View {
    let breakdown: ScoreBreakdown

    private var dateString: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter.string(from: breakdown.date)
    }

    private var topPositiveDriver: ScoreBreakdown.MetricDetail? {
        breakdown.metrics.max(by: { $0.contribution < $1.contribution })
    }

    private var topNegativeDriver: ScoreBreakdown.MetricDetail? {
        breakdown.metrics.min(by: { $0.contribution < $1.contribution })
    }

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.lg) {
            VStack(alignment: .leading, spacing: PulsumSpacing.xs) {
                Text("Today's wellbeing score")
                    .font(.pulsumHeadline)
                    .foregroundStyle(Color.pulsumTextPrimary)
                Text(dateString)
                    .font(.pulsumCaption)
                    .foregroundStyle(Color.pulsumTextSecondary)
            }

            VStack(spacing: PulsumSpacing.xs) {
                Text(breakdown.wellbeingScore.formatted(.number.precision(.fractionLength(2))))
                    .font(.pulsumDataXLarge)
                    .foregroundStyle(scoreColor(breakdown.wellbeingScore))
                Text(summaryCopy(for: breakdown.wellbeingScore))
                    .font(.pulsumCallout)
                    .foregroundStyle(Color.pulsumTextSecondary)
            }

            VStack(alignment: .leading, spacing: PulsumSpacing.xs) {
                Text("Top drivers")
                    .font(.pulsumSubheadline)
                    .foregroundStyle(Color.pulsumTextSecondary)
                VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                    if let positive = topPositiveDriver, positive.contribution > 0 {
                        DriverRow(prefix: "Lift", metric: positive, color: Color.pulsumGreenSoft)
                    }
                    if let negative = topNegativeDriver, negative.contribution < 0 {
                        DriverRow(prefix: "Drag", metric: negative, color: Color.pulsumWarning)
                    }
                }
            }

            Text("The score is a weighted blend of physiological z-scores, subjective sliders, and journal sentiment. Each contribution shown below is the weight × today's normalized value.")
                .font(.pulsumCaption)
                .foregroundStyle(Color.pulsumTextSecondary)
                .lineSpacing(2)
        }
        .pulsumCardStyle()
    }

    private func scoreColor(_ value: Double) -> Color {
        switch value {
        case ..<(-1): return Color.pulsumWarning
        case -1..<0.5: return Color.pulsumTextSecondary
        case 0.5..<1.5: return Color.pulsumGreenSoft
        default: return Color.pulsumSuccess
        }
    }

    private func summaryCopy(for value: Double) -> String {
        switch value {
        case ..<(-1): return "Focus on rest and low-load actions."
        case -1..<0.5: return "Holding steady around baseline."
        case 0.5..<1.5: return "Positive momentum building."
        default: return "Strong recovery signal today."
        }
    }
}

private struct DriverRow: View {
    let prefix: String
    let metric: ScoreBreakdown.MetricDetail
    let color: Color

    var body: some View {
        HStack(spacing: PulsumSpacing.xs) {
            Circle()
                .fill(color.opacity(0.2))
                .frame(width: 8, height: 8)
            Text("\(prefix): \(metric.name) \(formatContribution(metric.contribution))")
                .font(.pulsumCaption)
                .foregroundStyle(color)
        }
    }
}

private struct MetricSection: View {
    let title: String
    let caption: String
    let metrics: [ScoreBreakdown.MetricDetail]

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                Text(title)
                    .font(.pulsumHeadline)
                    .foregroundStyle(Color.pulsumTextPrimary)
                Text(caption)
                    .font(.pulsumCaption)
                    .foregroundStyle(Color.pulsumTextSecondary)
            }

            LazyVStack(spacing: PulsumSpacing.md) {
                ForEach(metrics) { metric in
                    MetricCard(detail: metric)
                }
            }
        }
    }
}

private struct MetricCard: View {
    let detail: ScoreBreakdown.MetricDetail

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            HStack(alignment: .top) {
                VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                    Text(detail.name)
                        .font(.pulsumHeadline)
                        .foregroundStyle(Color.pulsumTextPrimary)
                    if let valueLine = valueLine {
                        Text(valueLine)
                            .font(.pulsumCallout)
                            .foregroundStyle(Color.pulsumTextSecondary)
                    } else {
                        Text("No data today")
                            .font(.pulsumCallout)
                            .foregroundStyle(Color.pulsumTextTertiary)
                    }
                }
                Spacer()
                ContributionBadge(contribution: detail.contribution)
            }

            VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                if let zScoreLine = zScoreLine {
                    InfoRow(systemName: "chart.line.uptrend.xyaxis", text: zScoreLine)
                }
                if let coverageLine = coverageLine {
                    InfoRow(systemName: "stethoscope", text: coverageLine)
                }
                if let baselineLine = baselineLine {
                    InfoRow(systemName: "calendar", text: baselineLine)
                }
                if let ewmaLine = ewmaLine {
                    InfoRow(systemName: "waveform.path.ecg", text: ewmaLine)
                }
            }

            if !detail.notes.isEmpty {
                ForEach(detail.notes, id: \.self) { note in
                    NoteRow(text: note)
                }
            }

            Text(detail.explanation)
                .font(.pulsumCaption)
                .foregroundStyle(Color.pulsumTextSecondary)
                .lineSpacing(2)
        }
        .pulsumCardStyle(padding: PulsumSpacing.lg)
    }

    private var valueLine: String? {
        guard let value = detail.value else { return nil }
        return formatValue(value, unit: detail.unit)
    }

    private var zScoreLine: String? {
        guard let zScore = detail.zScore else { return nil }
        let formatted = formatSigned(value: zScore, decimals: 2)
        return "Z-score vs baseline: \(formatted)"
    }

    private var coverageLine: String? {
        guard let coverage = detail.coverage else { return nil }
        let daysLabel = coverage.daysWithSamples == 1 ? "day" : "days"
        let sampleLabel = coverage.sampleCount == 1 ? "data point" : "data points"
        return "Health data: \(coverage.daysWithSamples) \(daysLabel), \(coverage.sampleCount) \(sampleLabel)"
    }

    private var baselineLine: String? {
        guard let median = detail.baselineMedian else { return nil }
        let prefix: String
        if let days = detail.rollingWindowDays {
            prefix = "Rolling baseline (\(days)d median):"
        } else {
            prefix = "Rolling baseline median:"
        }
        let value = formatValue(median, unit: detail.unit) ?? String(format: "%.2f", median)
        return "\(prefix) \(value)"
    }

    private var ewmaLine: String? {
        guard let ewma = detail.baselineEwma else { return nil }
        let value = formatValue(ewma, unit: detail.unit) ?? String(format: "%.2f", ewma)
        return "EWMA trend (λ=0.2): \(value)"
    }
}

private struct NotesCard: View {
    let notes: [String]

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.sm) {
            Text("Data notes")
                .font(.pulsumHeadline)
                .foregroundStyle(Color.pulsumTextPrimary)
            ForEach(notes, id: \.self) { note in
                NoteRow(text: note)
            }
        }
        .pulsumCardStyle()
    }
}

private struct RecommendationLogicCard: View {
    let highlights: RecommendationHighlights

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            Text("How recommendations use this")
                .font(.pulsumHeadline)
                .foregroundStyle(Color.pulsumTextPrimary)

            Text("The Coach agent builds a retrieval query from the wellbeing score plus the strongest signals below, then ranks activities with the RecRanker model.")
                .font(.pulsumCaption)
                .foregroundStyle(Color.pulsumTextSecondary)
                .lineSpacing(2)

            if !highlights.lifts.isEmpty {
                BulletList(title: "Signals lifting you", details: highlights.lifts, color: Color.pulsumGreenSoft)
            }

            if !highlights.drags.isEmpty {
                BulletList(title: "Signals needing support", details: highlights.drags, color: Color.pulsumWarning)
            }

            Text("Cards are prioritized when they address the most urgent drags while reinforcing the current lifts. Updating your pulse inputs or new HealthKit data will reshuffle this analysis on the next sync.")
                .font(.pulsumCaption)
                .foregroundStyle(Color.pulsumTextSecondary)
                .lineSpacing(2)
        }
        .pulsumCardStyle()
    }
}

private struct BulletList: View {
    let title: String
    let details: [ScoreBreakdown.MetricDetail]
    let color: Color

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.xs) {
            Text(title)
                .font(.pulsumSubheadline)
                .foregroundStyle(color)
            ForEach(details) { detail in
                HStack(alignment: .top, spacing: PulsumSpacing.xs) {
                    Circle()
                        .fill(color.opacity(0.2))
                        .frame(width: 6, height: 6)
                        .padding(.top, 6)
                    VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                        Text(detail.name)
                            .font(.pulsumCallout)
                            .foregroundStyle(Color.pulsumTextPrimary)
                        Text(contributionLine(for: detail))
                            .font(.pulsumCaption)
                            .foregroundStyle(Color.pulsumTextSecondary)
                    }
                }
            }
        }
    }

    private func contributionLine(for detail: ScoreBreakdown.MetricDetail) -> String {
        let contribution = formatContribution(detail.contribution)
        if let explanation = detail.explanation.split(separator: "\n").first {
            return "\(contribution) – \(explanation)"
        }
        return contribution
    }
}

private struct ContributionBadge: View {
    let contribution: Double

    var body: some View {
        Text(formatContribution(contribution))
            .font(.pulsumCaption)
            .fontWeight(.semibold)
            .padding(.vertical, PulsumSpacing.xxs)
            .padding(.horizontal, PulsumSpacing.sm)
            .background(badgeBackground)
            .foregroundStyle(badgeForeground)
            .clipShape(Capsule())
    }

    private var badgeBackground: Color {
        if contribution > 0.05 {
            return Color.pulsumGreenSoft.opacity(0.15)
        } else if contribution < -0.05 {
            return Color.pulsumWarning.opacity(0.15)
        } else {
            return Color.pulsumBlueSoft.opacity(0.1)
        }
    }

    private var badgeForeground: Color {
        if contribution > 0.05 {
            return Color.pulsumGreenSoft
        } else if contribution < -0.05 {
            return Color.pulsumWarning
        } else {
            return Color.pulsumTextSecondary
        }
    }
}

private struct InfoRow: View {
    let systemName: String
    let text: String

    var body: some View {
        HStack(alignment: .center, spacing: PulsumSpacing.xs) {
            Image(systemName: systemName)
                .font(.pulsumCaption)
                .foregroundStyle(Color.pulsumBlueSoft)
            Text(text)
                .font(.pulsumCaption)
                .foregroundStyle(Color.pulsumTextSecondary)
        }
    }
}

private struct NoteRow: View {
    let text: String

    var body: some View {
        HStack(alignment: .top, spacing: PulsumSpacing.xs) {
            Image(systemName: "exclamationmark.triangle.fill")
                .font(.pulsumCaption)
                .foregroundStyle(Color.pulsumWarning)
            Text(text)
                .font(.pulsumCaption)
                .foregroundStyle(Color.pulsumWarning)
                .fixedSize(horizontal: false, vertical: true)
        }
    }
}

private struct ErrorStateView: View {
    let message: String

    var body: some View {
        VStack(spacing: PulsumSpacing.md) {
            Image(systemName: "exclamationmark.triangle")
                .font(.pulsumTitle2)
                .foregroundStyle(Color.pulsumWarning)
            Text("Unable to load score details")
                .font(.pulsumHeadline)
                .foregroundStyle(Color.pulsumTextPrimary)
            Text(message)
                .font(.pulsumCallout)
                .foregroundStyle(Color.pulsumTextSecondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, PulsumSpacing.lg)
        }
        .frame(maxWidth: .infinity, alignment: .center)
        .padding(.top, PulsumSpacing.xl)
    }
}

private struct EmptyStateView: View {
    var body: some View {
        VStack(spacing: PulsumSpacing.md) {
            Image(systemName: "waveform.path.ecg")
                .font(.pulsumTitle2)
                .foregroundStyle(Color.pulsumBlueSoft)
            Text("No metrics yet")
                .font(.pulsumHeadline)
                .foregroundStyle(Color.pulsumTextPrimary)
            Text("We will show a full breakdown after Pulsum completes the first nightly sync.")
                .font(.pulsumCallout)
                .foregroundStyle(Color.pulsumTextSecondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, PulsumSpacing.lg)
        }
        .frame(maxWidth: .infinity, alignment: .center)
        .padding(.top, PulsumSpacing.xl)
    }
}

// MARK: - Formatting Helpers

private func formatValue(_ value: Double, unit: String?) -> String? {
    guard let unit else { return formatSigned(value: value, decimals: 2) }
    switch unit {
    case "ms":
        return String(format: "%.0f ms", value)
    case "bpm":
        return String(format: "%.1f bpm", value)
    case "breaths/min":
        return String(format: "%.1f breaths/min", value)
    case "steps":
        return "\(Int(round(value))) steps"
    case "h":
        return String(format: "%.1f h", value)
    case "(1-7)":
        return String(format: "%.1f / 7", value)
    default:
        return formatSigned(value: value, decimals: 2)
    }
}

private func formatSigned(value: Double, decimals: Int) -> String {
    let formatter = NumberFormatter()
    formatter.numberStyle = .decimal
    formatter.maximumFractionDigits = decimals
    formatter.minimumFractionDigits = decimals
    let formatted = formatter.string(from: NSNumber(value: abs(value))) ?? String(format: "%.*f", decimals, abs(value))
    return value >= 0 ? "+\(formatted)" : "-\(formatted)"
}

private func formatContribution(_ contribution: Double) -> String {
    formatSigned(value: contribution, decimals: 2)
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownView.swift -->

### Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownViewModel.swift
- bytes: 2037
- lines: 67
- sha256: 7371c226b1fdaf6935cdd7f6ac13be49f9cb3ac6c9ef942f21b2e560b9396710
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownViewModel.swift -->
```swift
import Foundation
import Observation
import PulsumAgents

@MainActor
@Observable
final class ScoreBreakdownViewModel {
    @ObservationIgnored private let orchestrator: AgentOrchestrator

    var breakdown: ScoreBreakdown?
    var isLoading = false
    var errorMessage: String?

    init(orchestrator: AgentOrchestrator) {
        self.orchestrator = orchestrator
    }

    var recommendationHighlights: RecommendationHighlights? {
        guard let details = breakdown?.metrics else { return nil }
        let lifts = details
            .filter { $0.contribution > 0 }
            .sorted(by: { $0.contribution > $1.contribution })
            .prefix(3)
        let drags = details
            .filter { $0.contribution < 0 }
            .sorted(by: { abs($0.contribution) > abs($1.contribution) })
            .prefix(3)
        guard !lifts.isEmpty || !drags.isEmpty else { return nil }
        return RecommendationHighlights(lifts: Array(lifts), drags: Array(drags))
    }

    var objectiveMetrics: [ScoreBreakdown.MetricDetail] {
        breakdown?.metrics.filter { $0.kind == .objective } ?? []
    }

    var subjectiveMetrics: [ScoreBreakdown.MetricDetail] {
        breakdown?.metrics.filter { $0.kind == .subjective } ?? []
    }

    var sentimentMetrics: [ScoreBreakdown.MetricDetail] {
        breakdown?.metrics.filter { $0.kind == .sentiment } ?? []
    }

    func refresh() async {
        isLoading = true
        defer { isLoading = false }
        do {
            breakdown = try await orchestrator.scoreBreakdown()
            errorMessage = nil
        } catch {
            breakdown = nil
            errorMessage = mapError(error)
        }
    }

    private func mapError(_ error: Error) -> String {
        if (error as NSError).domain == NSURLErrorDomain {
            return "Network connection appears offline."
        }
        return error.localizedDescription
    }
}

struct RecommendationHighlights {
    let lifts: [ScoreBreakdown.MetricDetail]
    let drags: [ScoreBreakdown.MetricDetail]
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownViewModel.swift -->

### Packages/PulsumUI/Sources/PulsumUI/SettingsView.swift
- bytes: 52576
- lines: 1123
- sha256: b82c715ad71b2047f1454d60d4fd2bba58152cc483fdba5efdad60296dda614f
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/SettingsView.swift -->
```swift
import SwiftUI
import Observation
import PulsumAgents
import PulsumTypes
#if canImport(UIKit)
import UIKit
#endif

struct SettingsScreen: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.openURL) private var openURL
    @Bindable var viewModel: SettingsViewModel
    let wellbeingState: WellbeingScoreState
    let snapshotKind: WellbeingSnapshotKind
    private let cloudSectionId = "SettingsCloudSection"

    private var consentBinding: Binding<Bool> {
        return Binding(
            get: { viewModel.consentGranted },
            set: { viewModel.toggleConsent($0) }
        )
    }

    var body: some View {
        ZStack {
            NavigationStack {
                ScrollViewReader { proxy in
                    ScrollView {
                        LazyVStack(spacing: PulsumSpacing.lg) {
                        // Wellbeing Score Display (moved from MainView)
                        wellbeingScoreSection

                        // Cloud Processing Section
                        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
                            Text("Cloud Processing")
                                .font(.pulsumHeadline)
                                .foregroundStyle(Color.pulsumTextPrimary)
                                .padding(.horizontal, PulsumSpacing.lg)

                            VStack(alignment: .leading, spacing: PulsumSpacing.md) {
                                HStack(alignment: .top, spacing: PulsumSpacing.sm) {
                                    VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                                        Text("Use GPT-5 phrasing")
                                            .font(.pulsumBody)
                                            .foregroundStyle(Color.pulsumTextPrimary)
                                        Text("Pulsum only sends minimized context (no journals, no identifiers, no raw health samples). Turn this off anytime.")
                                            .font(.pulsumCaption)
                                            .foregroundStyle(Color.pulsumTextSecondary)
                                            .lineSpacing(2)
                                    }
                                    .contentShape(Rectangle())
                                    .onTapGesture {
                                        consentBinding.wrappedValue.toggle()
                                    }

                                    Spacer(minLength: PulsumSpacing.sm)

                                    Toggle(isOn: consentBinding) {
                                        EmptyView()
                                    }
                                        .toggleStyle(.switch)
                                        .labelsHidden()
                                        .tint(Color.pulsumGreenSoft)
                                        .accessibilityLabel("Use GPT-5 phrasing")
                                        .accessibilityHint("Pulsum only sends minimized context (no journals, no identifiers, no raw health samples). Turn this off anytime.")
                                        .accessibilityIdentifier("CloudConsentToggle")
                                        .accessibilityValue(viewModel.consentGranted ? "1" : "0")
                                }

                                if let updated = relativeDate(for: viewModel.lastConsentUpdated) {
                                    Text("Updated \(updated)")
                                        .font(.pulsumFootnote)
                                        .foregroundStyle(Color.pulsumTextTertiary)
                                }

                                Divider()

                                VStack(alignment: .leading, spacing: PulsumSpacing.sm) {
                                    VStack(alignment: .leading, spacing: PulsumSpacing.xs) {
                                        Text("GPT-5 API Key")
                                            .font(.pulsumCallout.weight(.semibold))
                                            .foregroundStyle(Color.pulsumTextPrimary)
                                        SecureField("sk-...", text: $viewModel.gptAPIKeyDraft)
                                            .textFieldStyle(.roundedBorder)
                                            .textInputAutocapitalization(.never)
                                            .autocorrectionDisabled()
                                            .font(.pulsumBody)
                                            .foregroundStyle(Color.pulsumTextPrimary)
                                            .accessibilityIdentifier("CloudAPIKeyField")
                                    }

                                    HStack(spacing: PulsumSpacing.sm) {
                                        Button {
                                            Task { await viewModel.saveAPIKey(viewModel.gptAPIKeyDraft) }
                                        } label: {
                                            Text("Save Key")
                                                .font(.pulsumCallout.weight(.semibold))
                                                .foregroundStyle(Color.pulsumTextPrimary)
                                                .frame(maxWidth: .infinity)
                                        }
                                        .glassEffect(.regular.tint(Color.pulsumGreenSoft.opacity(0.6)).interactive())
                                        .disabled(viewModel.gptAPIKeyDraft.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty || viewModel.isTestingAPIKey)

                                        Button {
                                            Task { await viewModel.testCurrentAPIKey() }
                                        } label: {
                                            if viewModel.isTestingAPIKey {
                                                ProgressView()
                                                    .progressViewStyle(.circular)
                                                    .tint(Color.pulsumTextPrimary)
                                                    .frame(maxWidth: .infinity)
                                            } else {
                                                Text("Test Connection")
                                                    .font(.pulsumCallout.weight(.semibold))
                                                    .foregroundStyle(Color.pulsumTextPrimary)
                                                    .frame(maxWidth: .infinity)
                                            }
                                        }
                                        .glassEffect(.regular.tint(Color.pulsumBlueSoft.opacity(0.5)).interactive())
                                        .disabled(viewModel.isTestingAPIKey)
                                        .accessibilityIdentifier("CloudTestConnectionButton")
                                    }

                                    HStack(spacing: PulsumSpacing.sm) {
                                        gptStatusBadge(isWorking: viewModel.isGPTAPIWorking,
                                                       status: viewModel.gptAPIStatus)
                                        Text(viewModel.gptAPIStatus)
                                            .font(.pulsumFootnote)
                                            .foregroundStyle(Color.pulsumTextSecondary)
                                            .lineSpacing(2)
                                    }
                                }
                            }
                            .padding(PulsumSpacing.lg)
                            .background(Color.pulsumCardWhite)
                            .cornerRadius(PulsumRadius.xl)
                            .shadow(
                                color: PulsumShadow.small.color,
                                radius: PulsumShadow.small.radius,
                                x: PulsumShadow.small.x,
                                y: PulsumShadow.small.y
                            )
                        }
                        .id(cloudSectionId)

                        // HealthKit Section
                        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
                        Text("Apple HealthKit")
                            .font(.pulsumHeadline)
                            .foregroundStyle(Color.pulsumTextPrimary)
                            .padding(.horizontal, PulsumSpacing.lg)

                        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
                            HStack(alignment: .top, spacing: PulsumSpacing.sm) {
                                Image(systemName: "heart.text.square.fill")
                                    .font(.pulsumTitle3)
                                    .foregroundStyle(Color.pulsumPinkSoft)
                                    .symbolRenderingMode(.hierarchical)
                                VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                                    Text("Health Data Access")
                                        .font(.pulsumHeadline)
                                        .foregroundStyle(Color.pulsumTextPrimary)
                                    Text(viewModel.healthKitSummary)
                                        .font(.pulsumCallout)
                                        .foregroundStyle(Color.pulsumTextSecondary)
                                        .lineSpacing(2)
                                        .accessibilityIdentifier("HealthAccessSummaryLabel")
                                }
                            }

                            if let detail = viewModel.missingHealthKitDetail {
                                Text(detail)
                                    .font(.pulsumCaption)
                                    .foregroundStyle(Color.pulsumTextSecondary)
                                    .padding(.horizontal, PulsumSpacing.xs)
                                    .padding(.vertical, PulsumSpacing.xxs)
                                    .background(Color.pulsumBackgroundCream.opacity(0.6))
                                    .cornerRadius(PulsumRadius.sm)
                                    .accessibilityIdentifier("HealthAccessMissingLabel")
                            }

                            if viewModel.showHealthKitUnavailableBanner {
                                HStack(spacing: PulsumSpacing.xs) {
                                    Image(systemName: "exclamationmark.triangle.fill")
                                        .font(.pulsumCaption)
                                        .foregroundStyle(Color.pulsumWarning)
                                    Text("Health data is unavailable on this device.")
                                        .font(.pulsumCaption)
                                        .foregroundStyle(Color.pulsumWarning)
                                }
                                .padding(.horizontal, PulsumSpacing.sm)
                                .padding(.vertical, PulsumSpacing.xs)
                                .background(Color.pulsumWarning.opacity(0.1))
                                .cornerRadius(PulsumRadius.sm)
                            }

                            if let success = viewModel.healthKitSuccessMessage {
                                HStack {
                                    Image(systemName: "checkmark.seal.fill")
                                        .foregroundStyle(Color.pulsumGreenSoft)
                                    Text(success)
                                        .font(.pulsumCaption)
                                        .foregroundStyle(Color.pulsumGreenSoft)
                                    Spacer()
                                }
                                .padding(.horizontal, PulsumSpacing.sm)
                                .padding(.vertical, PulsumSpacing.xs)
                                .background(Color.pulsumGreenSoft.opacity(0.12))
                                .cornerRadius(PulsumRadius.sm)
                            }

                            Divider()
                                .padding(.vertical, PulsumSpacing.xs)

                            VStack(spacing: PulsumSpacing.sm) {
                                ForEach(viewModel.healthAccessRows) { row in
                                    HStack(spacing: PulsumSpacing.sm) {
                                        Image(systemName: row.iconName)
                                            .font(.pulsumTitle3)
                                            .foregroundStyle(Color.pulsumTextPrimary.opacity(0.7))
                                        VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                                            Text(row.title)
                                                .font(.pulsumCallout.weight(.semibold))
                                                .foregroundStyle(Color.pulsumTextPrimary)
                                            Text(row.detail)
                                                .font(.pulsumFootnote)
                                                .foregroundStyle(Color.pulsumTextSecondary)
                                        }
                                        Spacer()
                                        statusBadge(for: row.status)
                                    }
                                    .padding(.vertical, PulsumSpacing.xs)
                                    .accessibilityIdentifier("HealthAccessRow-\(row.id)")
                                }
                            }

                            if let error = viewModel.healthKitError {
                                HStack(spacing: PulsumSpacing.xs) {
                                    Image(systemName: "exclamationmark.triangle.fill")
                                        .font(.pulsumCaption)
                                        .foregroundStyle(Color.pulsumWarning)
                                    Text(error)
                                        .font(.pulsumCaption)
                                        .foregroundStyle(Color.pulsumWarning)
                                }
                                .padding(.horizontal, PulsumSpacing.sm)
                                .padding(.vertical, PulsumSpacing.xs)
                                .background(Color.pulsumWarning.opacity(0.1))
                                .cornerRadius(PulsumRadius.sm)
                            }

                            Divider()
                                .padding(.vertical, PulsumSpacing.xs)

                            Button {
                                Task {
                                    await viewModel.requestHealthKitAuthorization()
                                }
                            } label: {
                                HStack {
                                    if viewModel.isRequestingHealthKitAuthorization {
                                        ProgressView()
                                            .progressViewStyle(.circular)
                                            .tint(Color.pulsumTextPrimary)
                                        Text("Requesting...")
                                            .font(.pulsumCallout.weight(.semibold))
                                            .foregroundStyle(Color.pulsumTextPrimary)
                                    } else {
                                        Text("Request Health Data Access")
                                            .font(.pulsumCallout.weight(.semibold))
                                            .foregroundStyle(Color.pulsumTextPrimary)
                                    }
                                }
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, PulsumSpacing.sm)
                            }
                                    .glassEffect(.regular.tint(Color.pulsumPinkSoft.opacity(0.6)).interactive())
                                    .disabled(viewModel.isRequestingHealthKitAuthorization || !viewModel.canRequestHealthKitAccess)
                                    .accessibilityIdentifier("HealthAccessRequestButton")

                                Text("Pulsum needs access to Heart Rate Variability, Heart Rate, Resting Heart Rate, Respiratory Rate, Steps, and Sleep data to provide personalized recovery recommendations.")
                                    .font(.pulsumFootnote)
                                    .foregroundStyle(Color.pulsumTextSecondary)
                                    .lineSpacing(3)

                                Divider()
                                    .padding(.vertical, PulsumSpacing.xs)

                            VStack(alignment: .leading, spacing: PulsumSpacing.xs) {
                                Text("Health access status")
                                    .font(.pulsumFootnote.weight(.semibold))
                                    .foregroundStyle(Color.pulsumTextSecondary)
                                Text(viewModel.healthKitDebugSummary.isEmpty ? "Tap Refresh to fetch status" : viewModel.healthKitDebugSummary)
                                    .font(.system(.footnote, design: .monospaced))
                                    .foregroundStyle(Color.pulsumTextPrimary)
                                    .textSelection(.enabled)
                                    .accessibilityIdentifier("HealthAccessDebugSummaryLabel")
                                HStack(spacing: PulsumSpacing.sm) {
                                    Button("Refresh Status") {
                                        viewModel.refreshHealthAccessStatus()
                                    }
                                    .font(.pulsumFootnote.weight(.semibold))
                                    .foregroundStyle(Color.pulsumTextPrimary)
                                    .glassEffect(.regular.tint(Color.pulsumBlueSoft.opacity(0.5)).interactive())
                                    Button("Copy") {
                                        copyToClipboard(viewModel.healthKitDebugSummary)
                                    }
                                    .font(.pulsumFootnote.weight(.semibold))
                                    .foregroundStyle(Color.pulsumTextPrimary)
                                    .glassEffect(.regular.tint(Color.pulsumTextSecondary.opacity(0.3)).interactive())
                                    .accessibilityIdentifier("HealthAccessCopyButton")
                                }
                            }

                            Divider()
                                .padding(.vertical, PulsumSpacing.xs)

                            VStack(alignment: .leading, spacing: PulsumSpacing.xs) {
                                Text("App debug log")
                                    .font(.pulsumFootnote.weight(.semibold))
                                    .foregroundStyle(Color.pulsumTextSecondary)
                                Text(viewModel.debugLogSnapshot.isEmpty ? "Tap Refresh Log to capture recent events" : viewModel.debugLogSnapshot)
                                    .font(.system(.footnote, design: .monospaced))
                                    .foregroundStyle(Color.pulsumTextPrimary)
                                    .textSelection(.enabled)
                                    .accessibilityIdentifier("DebugLogSnapshotLabel")
                                    .frame(maxHeight: 160, alignment: .topLeading)
                                    .lineLimit(nil)
                                HStack(spacing: PulsumSpacing.sm) {
                                    Button("Refresh Log") {
                                        Task { await viewModel.refreshDebugLog() }
                                    }
                                    .font(.pulsumFootnote.weight(.semibold))
                                    .foregroundStyle(Color.pulsumTextPrimary)
                                    .glassEffect(.regular.tint(Color.pulsumBlueSoft.opacity(0.5)).interactive())
                                    Button("Copy Log") {
                                        copyToClipboard(viewModel.debugLogSnapshot)
                                    }
                                    .font(.pulsumFootnote.weight(.semibold))
                                    .foregroundStyle(Color.pulsumTextPrimary)
                                    .glassEffect(.regular.tint(Color.pulsumTextSecondary.opacity(0.3)).interactive())
                                    .accessibilityIdentifier("DebugLogCopyButton")
                                }
                            }
                        }
                        .padding(PulsumSpacing.lg)
                        .background(Color.pulsumCardWhite)
                        .cornerRadius(PulsumRadius.xl)
                        .shadow(
                            color: PulsumShadow.small.color,
                            radius: PulsumShadow.small.radius,
                            x: PulsumShadow.small.x,
                            y: PulsumShadow.small.y
                        )
                    }

                    // AI Models Section
                    VStack(alignment: .leading, spacing: PulsumSpacing.md) {
                        Text("AI Models")
                            .font(.pulsumHeadline)
                            .foregroundStyle(Color.pulsumTextPrimary)
                            .padding(.horizontal, PulsumSpacing.lg)

                        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
                            // Apple Intelligence
                            HStack(alignment: .top, spacing: PulsumSpacing.sm) {
                                Image(systemName: "sparkles")
                                    .font(.pulsumTitle3)
                                    .foregroundStyle(Color.pulsumBlueSoft)
                                VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                                    Text("Apple Intelligence")
                                        .font(.pulsumHeadline)
                                        .foregroundStyle(Color.pulsumTextPrimary)
                                    Text(viewModel.foundationModelsStatus)
                                        .font(.pulsumCallout)
                                        .foregroundStyle(Color.pulsumTextSecondary)
                                        .lineSpacing(2)
                                }
                            }

                            if needsEnableLink(status: viewModel.foundationModelsStatus) {
#if os(macOS)
                                Link(destination: URL(string: "x-apple.systempreferences:com.apple.AppleIntelligence-Settings")!) {
                                    appleIntelligenceLinkContent()
                                }
#else
                                Button {
                                    openAppleIntelligenceSettings()
                                } label: {
                                    appleIntelligenceLinkContent()
                                }
                                .accessibilityIdentifier("AppleIntelligenceLinkButton")
#endif
                            }

                        }
                        .padding(PulsumSpacing.lg)
                        .background(Color.pulsumCardWhite)
                        .cornerRadius(PulsumRadius.xl)
                        .shadow(
                            color: PulsumShadow.small.color,
                            radius: PulsumShadow.small.radius,
                            x: PulsumShadow.small.x,
                            y: PulsumShadow.small.y
                        )
                    }

                    // Safety Section
                    VStack(alignment: .leading, spacing: PulsumSpacing.md) {
                        Text("Safety")
                            .font(.pulsumHeadline)
                            .foregroundStyle(Color.pulsumTextPrimary)
                            .padding(.horizontal, PulsumSpacing.lg)

                        VStack(spacing: PulsumSpacing.sm) {
                            Link(destination: URL(string: "tel://911")!) {
                                HStack {
                                    Text("If you're in crisis, dial 911")
                                        .font(.pulsumBody)
                                        .foregroundStyle(Color.pulsumError)
                                    Spacer()
                                    Image(systemName: "phone.fill")
                                        .foregroundStyle(Color.pulsumError)
                                }
                            }

                            Divider()

                            Link(destination: URL(string: "tel://988")!) {
                                HStack {
                                    Text("988 Suicide & Crisis Lifeline")
                                        .font(.pulsumBody)
                                        .foregroundStyle(Color.pulsumTextPrimary)
                                    Spacer()
                                    Image(systemName: "phone.fill")
                                        .foregroundStyle(Color.pulsumTextSecondary)
                                }
                            }
                        }
                        .padding(PulsumSpacing.lg)
                        .background(Color.pulsumCardWhite)
                        .cornerRadius(PulsumRadius.xl)
                        .shadow(
                            color: PulsumShadow.small.color,
                            radius: PulsumShadow.small.radius,
                            x: PulsumShadow.small.x,
                            y: PulsumShadow.small.y
                        )
                    }

                    // Privacy Section
                    VStack(alignment: .leading, spacing: PulsumSpacing.md) {
                        Text("Privacy")
                            .font(.pulsumHeadline)
                            .foregroundStyle(Color.pulsumTextPrimary)
                            .padding(.horizontal, PulsumSpacing.lg)

                        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
                            Link(destination: URL(string: "https://pulsum.ai/privacy")!) {
                                HStack {
                                    Text("Privacy policy")
                                        .font(.pulsumBody)
                                        .foregroundStyle(Color.pulsumBlueSoft)
                                    Spacer()
                                    Image(systemName: "arrow.up.right")
                                        .font(.pulsumCaption)
                                        .foregroundStyle(Color.pulsumTextSecondary)
                                }
                            }

                            Text("Pulsum stores all health data on-device with NSFileProtectionComplete and never uploads your journals.")
                                .font(.pulsumFootnote)
                                .foregroundStyle(Color.pulsumTextSecondary)
                                .lineSpacing(3)
                        }
                        .padding(PulsumSpacing.lg)
                        .background(Color.pulsumCardWhite)
                        .cornerRadius(PulsumRadius.xl)
                        .shadow(
                            color: PulsumShadow.small.color,
                            radius: PulsumShadow.small.radius,
                            x: PulsumShadow.small.x,
                            y: PulsumShadow.small.y
                        )
                    }

                    diagnosticsSection

#if DEBUG
                    if viewModel.diagnosticsVisible {
                        DiagnosticsPanel(routeHistory: viewModel.routeHistory,
                                         coverageSummary: viewModel.lastCoverageSummary,
                                         cloudError: viewModel.lastCloudError,
                                         healthStatusSummary: viewModel.healthKitDebugSummary)
                            .transition(.opacity)
                    }
#endif
                        }
                        .padding(PulsumSpacing.lg)
                        .padding(.bottom, PulsumSpacing.xxl)
                    }
                    .onAppear {
                        guard AppRuntimeConfig.isUITesting else { return }
                        DispatchQueue.main.async {
                            withAnimation(.none) {
                                proxy.scrollTo(cloudSectionId, anchor: .top)
                            }
                        }
                    }
                    .background(Color.pulsumBackgroundBeige.ignoresSafeArea())
#if DEBUG
                    .navigationBarTitleDisplayMode(.inline)
                    .toolbar {
                        ToolbarItem(placement: .principal) {
                            Text("Settings")
                                .font(.pulsumHeadline)
                                .foregroundStyle(Color.pulsumTextPrimary)
                                .onTapGesture(count: 3) {
                                    viewModel.toggleDiagnosticsVisibility()
                                }
                        }
                        ToolbarItem(placement: .cancellationAction) {
                            Button {
                                dismiss()
                            } label: {
                                Image(systemName: "xmark.circle.fill")
                                    .font(.title3)
                                    .foregroundStyle(Color.pulsumTextSecondary)
                                    .symbolRenderingMode(.hierarchical)
                            }
                            .accessibilityLabel("Close Settings")
                        }
                    }
                    .toolbarBackground(.automatic, for: .navigationBar)
#else
                    .navigationTitle("Settings")
                    .navigationBarTitleDisplayMode(.large)
                    .toolbar {
                        ToolbarItem(placement: .cancellationAction) {
                            Button {
                                dismiss()
                            } label: {
                                Image(systemName: "xmark.circle.fill")
                                    .font(.title3)
                                    .foregroundStyle(Color.pulsumTextSecondary)
                                    .symbolRenderingMode(.hierarchical)
                            }
                            .accessibilityLabel("Close Settings")
                        }
                    }
                    .toolbarBackground(.automatic, for: .navigationBar)
#endif
                    .task {
                        viewModel.refreshFoundationStatus()
                        viewModel.refreshHealthAccessStatus()
                        if !AppRuntimeConfig.isUITesting {
                            await viewModel.testCurrentAPIKey()
                        }
                    }
                    .onEscapeDismiss {
                        dismiss()
                    }
                }
            }
        }
        .accessibilityIdentifier("SettingsSheetRoot")
        .accessibilityElement(children: .contain)
        .onDisappear {
            AppRuntimeConfig.synchronizeUITestDefaults()
        }
    }

    private func needsEnableLink(status: String) -> Bool {
        status.localizedCaseInsensitiveContains("enable") || status.localizedCaseInsensitiveContains("require")
    }

    private func copyToClipboard(_ text: String) {
#if canImport(UIKit)
        UIPasteboard.general.string = text
#endif
    }

    private var diagnosticsSection: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            HStack {
                Text("Diagnostics")
                    .font(.pulsumHeadline)
                    .foregroundStyle(Color.pulsumTextPrimary)
                Spacer()
                Text(viewModel.diagnosticsConfig.enabled ? "On" : "Off")
                    .font(.pulsumCaption)
                    .foregroundStyle(Color.pulsumTextSecondary)
            }

            Text("Session ID: \(viewModel.diagnosticsSessionId.uuidString)")
                .font(.pulsumCaption2)
                .foregroundStyle(Color.pulsumTextSecondary)
                .textSelection(.enabled)

            Toggle("Enable diagnostics", isOn: Binding(get: {
                viewModel.diagnosticsConfig.enabled
            }, set: { enabled in
                viewModel.updateDiagnosticsEnabled(enabled)
            }))

            Toggle("Persist to disk", isOn: Binding(get: {
                viewModel.diagnosticsConfig.persistToDisk
            }, set: { persist in
                viewModel.updateDiagnosticsPersistence(persist)
            }))

            Toggle("Mirror to OSLog", isOn: Binding(get: {
                viewModel.diagnosticsConfig.mirrorToOSLog
            }, set: { mirror in
                viewModel.updateDiagnosticsOSLog(mirror)
            }))

            Toggle("Enable signposts", isOn: Binding(get: {
                viewModel.diagnosticsConfig.enableSignposts
            }, set: { enable in
                viewModel.updateDiagnosticsSignposts(enable)
            }))

            HStack(spacing: PulsumSpacing.md) {
                Button {
                    Task { await viewModel.exportDiagnosticsReport() }
                } label: {
                    if viewModel.isExportingDiagnostics {
                        ProgressView()
                    } else {
                        Text("Export diagnostics report")
                    }
                }
                .buttonStyle(.borderedProminent)

                if let url = viewModel.diagnosticsExportURL {
                    ShareLink("Share", item: url)
                        .buttonStyle(.bordered)
                }
            }

            Button(role: .destructive) {
                Task { await viewModel.clearDiagnostics() }
            } label: {
                Text("Clear diagnostics")
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
            .buttonStyle(.bordered)

            Text("May include sensitive metadata (counts/dates). Does not include journal text or raw HealthKit samples.")
                .font(.pulsumCaption2)
                .foregroundStyle(Color.pulsumTextSecondary)
        }
        .padding(PulsumSpacing.lg)
        .background(Color.pulsumCardWhite)
        .cornerRadius(PulsumRadius.xl)
        .shadow(
            color: PulsumShadow.small.color,
            radius: PulsumShadow.small.radius,
            x: PulsumShadow.small.x,
            y: PulsumShadow.small.y
        )
    }

    @ViewBuilder
    private var wellbeingScoreSection: some View {
        switch wellbeingState {
        case let .ready(score, _):
            if let detailViewModel = viewModel.makeScoreBreakdownViewModel() {
                NavigationLink {
                    ScoreBreakdownScreen(viewModel: detailViewModel)
                } label: {
                    WellbeingScoreCard(score: score)
                }
                .buttonStyle(.plain)
            } else {
                WellbeingScoreCard(score: score)
            }
        case .loading:
            WellbeingScoreLoadingCard()
        case let .noData(reason):
            if snapshotKind == .placeholder, reason == .insufficientSamples {
                WellbeingPlaceholderCard()
            } else {
                WellbeingNoDataCard(reason: reason) {
                    Task { await viewModel.requestHealthKitAuthorization() }
                }
            }
        case let .error(message):
            WellbeingErrorCard(message: message)
        }
    }

    private func relativeDate(for date: Date) -> String? {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .short
        return formatter.localizedString(for: date, relativeTo: Date())
    }

    @ViewBuilder
    private func appleIntelligenceLinkContent() -> some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
            HStack(spacing: PulsumSpacing.xs) {
                Text("Enable Apple Intelligence in Settings")
                    .font(.pulsumCallout)
                    .foregroundStyle(Color.pulsumBlueSoft)
                Image(systemName: "arrow.up.right")
                    .font(.pulsumCaption)
                    .foregroundStyle(Color.pulsumBlueSoft)
            }
            Text("Opens system Settings so you can turn on Apple Intelligence for GPT-5 routing.")
                .font(.pulsumFootnote)
                .foregroundStyle(Color.pulsumTextSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }

    @ViewBuilder
    private func statusBadge(for status: HealthAccessGrantState) -> some View {
        let (icon, color, label): (String, Color, String) = {
            switch status {
            case .granted:
                return ("checkmark.circle.fill", Color.pulsumGreenSoft, "Granted")
            case .denied:
                return ("xmark.circle.fill", Color.pulsumWarning, "Denied")
            case .pending:
                return ("questionmark.circle", Color.pulsumTextSecondary, "Pending")
            }
        }()

        HStack(spacing: PulsumSpacing.xxs) {
            Image(systemName: icon)
                .foregroundStyle(color)
                .symbolRenderingMode(.hierarchical)
            Text(label)
                .font(.pulsumCaption.weight(.semibold))
                .foregroundStyle(color)
        }
        .padding(.horizontal, PulsumSpacing.xs)
        .padding(.vertical, PulsumSpacing.xxs)
        .background(color.opacity(0.12))
        .cornerRadius(PulsumRadius.sm)
        .accessibilityIdentifier("CloudAPIStatusBadge")
    }

    private func gptStatusBadge(isWorking: Bool, status: String) -> some View {
        let (label, color): (String, Color) = {
            if isWorking {
                return ("OK", Color.pulsumGreenSoft)
            }
            if status.localizedCaseInsensitiveContains("missing") {
                return ("Missing", Color.pulsumTextSecondary)
            }
            return ("Check", Color.pulsumWarning)
        }()
        return HStack(spacing: PulsumSpacing.xxs) {
            Circle()
                .fill(color)
                .frame(width: 8, height: 8)
            Text(label)
                .font(.pulsumCaption.weight(.semibold))
                .foregroundStyle(color)
        }
        .padding(.horizontal, PulsumSpacing.xs)
        .padding(.vertical, PulsumSpacing.xxs)
        .background(color.opacity(0.12))
        .cornerRadius(PulsumRadius.sm)
        .accessibilityElement(children: .combine)
    }

    private func openAppleIntelligenceSettings() {
        let forceFallback = AppRuntimeConfig.forceSettingsFallback
#if canImport(UIKit)
        if !forceFallback,
           let settingsURL = URL(string: UIApplication.openSettingsURLString) {
            UIApplication.shared.open(settingsURL, options: [:]) { success in
                if success {
                    logOpenedURL(settingsURL)
                } else {
                    openSupportArticle()
                }
            }
            return
        }
#endif
        openSupportArticle()
    }

    private func logOpenedURL(_ url: URL) {
        guard AppRuntimeConfig.captureSettingsURLs else { return }
        let defaults = UserDefaults(suiteName: "ai.pulsum.uiautomation")
        defaults?.set(url.absoluteString, forKey: "LastOpenedURL")
    }

    private func openSupportArticle() {
        guard let supportURL = URL(string: "https://support.apple.com/en-us/HT213969") else { return }
        logOpenedURL(supportURL)
        _ = openURL(supportURL)
    }
}

private extension View {
    func onEscapeDismiss(_ action: @escaping () -> Void) -> some View {
        Group {
            if #available(iOS 17.0, macOS 14.0, *) {
                self.onKeyPress(.escape) {
                    action()
                    return .handled
                }
            } else {
                self
            }
        }
    }
}

#if DEBUG
private struct DiagnosticsPanel: View {
    let routeHistory: [String]
    let coverageSummary: String
    let cloudError: String
    let healthStatusSummary: String

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            Text("Diagnostics")
                .font(.pulsumHeadline)
                .foregroundStyle(Color.pulsumTextPrimary)

            VStack(alignment: .leading, spacing: PulsumSpacing.sm) {
                Text("Last routes")
                    .font(.pulsumCallout.weight(.semibold))
                    .foregroundStyle(Color.pulsumTextSecondary)

                if routeHistory.isEmpty {
                    Text("No recent routing data")
                        .font(.pulsumCaption)
                        .foregroundStyle(Color.pulsumTextTertiary)
                } else {
                    ForEach(routeHistory, id: \.self) { line in
                        Text(line)
                            .font(.pulsumCaption)
                            .foregroundStyle(Color.pulsumTextSecondary)
                    }
                }

                Text("Coverage: \(coverageSummary)")
                    .font(.pulsumCaption)
                    .foregroundStyle(Color.pulsumTextSecondary)

                Text("Health access: \(healthStatusSummary)")
                    .font(.pulsumCaption)
                    .foregroundStyle(Color.pulsumTextSecondary)
                    .textSelection(.enabled)

                Text("Last cloud error: \(cloudError)")
                    .font(.pulsumCaption)
                    .foregroundStyle(Color.pulsumWarning)
                    .lineLimit(3)
            }
        }
        .padding(PulsumSpacing.lg)
        .background(Color.pulsumCardWhite)
        .cornerRadius(PulsumRadius.xl)
        .shadow(
            color: PulsumShadow.small.color,
            radius: PulsumShadow.small.radius,
            x: PulsumShadow.small.x,
            y: PulsumShadow.small.y
        )
        .overlay(alignment: .topLeading) {
            Text("DEBUG")
                .font(.pulsumCaption2.weight(.bold))
                .foregroundStyle(Color.pulsumBlueSoft)
                .padding(.horizontal, PulsumSpacing.xs)
                .padding(.vertical, PulsumSpacing.xxs)
        }
        .accessibilityIdentifier("DiagnosticsPanel")
    }
}
#endif

// MARK: - Wellbeing Score Loading Card
struct WellbeingScoreLoadingCard: View {
    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                Text("Wellbeing score")
                    .font(.pulsumHeadline)
                    .foregroundStyle(Color.pulsumTextPrimary)
                Text("Calculated nightly from your data")
                    .font(.pulsumCaption)
                    .foregroundStyle(Color.pulsumTextSecondary)
            }

            HStack(alignment: .center, spacing: PulsumSpacing.lg) {
                VStack(alignment: .leading, spacing: PulsumSpacing.xs) {
                    HStack(spacing: PulsumSpacing.sm) {
                        ProgressView()
                            .progressViewStyle(.circular)
                            .tint(Color.pulsumGreenSoft)
                        Text("Calculating...")
                            .font(.pulsumTitle)
                            .foregroundStyle(Color.pulsumTextSecondary)
                    }
                    Text("Complete your first Pulse check-in")
                        .font(.pulsumCallout)
                        .foregroundStyle(Color.pulsumTextSecondary)
                }
                Spacer()
            }

            Text("Your score will appear here after your first nightly sync. Record a Pulse check-in to begin tracking your wellbeing.")
                .font(.pulsumCaption)
                .foregroundStyle(Color.pulsumTextSecondary)
                .lineSpacing(2)
        }
        .padding(PulsumSpacing.lg)
        .background(Color.pulsumCardWhite)
        .cornerRadius(PulsumRadius.xl)
        .shadow(
            color: PulsumShadow.medium.color,
            radius: PulsumShadow.medium.radius,
            x: PulsumShadow.medium.x,
            y: PulsumShadow.medium.y
        )
    }
}

struct WellbeingPlaceholderCard: View {
    private let detail = "Health data may take a moment on first run. We'll update once your first sync completes."

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                Text("Wellbeing score")
                    .font(.pulsumHeadline)
                Text("Warming up")
                    .font(.pulsumTitle3)
                    .foregroundStyle(Color.pulsumTextPrimary)
                Text(detail)
                    .font(.pulsumCallout)
                    .foregroundStyle(Color.pulsumTextSecondary)
                    .lineSpacing(2)
            }
        }
        .padding(PulsumSpacing.lg)
        .background(Color.pulsumCardWhite)
        .cornerRadius(PulsumRadius.xl)
        .shadow(
            color: PulsumShadow.medium.color,
            radius: PulsumShadow.medium.radius,
            x: PulsumShadow.medium.x,
            y: PulsumShadow.medium.y
        )
    }
}

struct WellbeingNoDataCard: View {
    let reason: WellbeingNoDataReason
    var requestAccess: (() -> Void)?

    private var copy: (title: String, detail: String) {
        switch reason {
        case .healthDataUnavailable:
            return ("Health data unavailable",
                    "Health data is not available on this device. Try again on a device with Health access.")
        case .permissionsDeniedOrPending:
            return ("Health access needed",
                    "Pulsum needs permission to read Heart Rate Variability, Heart Rate, Resting Heart Rate, Respiratory Rate, Steps, and Sleep to compute your score.")
        case .insufficientSamples:
            return ("Waiting for data",
                    "We don't have enough recent Health data yet. Record a Pulse check-in or allow some time for HealthKit to sync.")
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                Text("Wellbeing score")
                    .font(.pulsumHeadline)
                Text(copy.title)
                    .font(.pulsumTitle3)
                    .foregroundStyle(Color.pulsumTextPrimary)
                Text(copy.detail)
                    .font(.pulsumCallout)
                    .foregroundStyle(Color.pulsumTextSecondary)
                    .lineSpacing(2)
            }

            if let requestAccess, reason == .permissionsDeniedOrPending {
                Button {
                    requestAccess()
                } label: {
                    Text("Request Health Data Access")
                        .font(.pulsumCallout.weight(.semibold))
                        .foregroundStyle(Color.pulsumTextPrimary)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, PulsumSpacing.sm)
                }
                .glassEffect(.regular.tint(Color.pulsumPinkSoft.opacity(0.6)).interactive())
            }
        }
        .padding(PulsumSpacing.lg)
        .background(Color.pulsumCardWhite)
        .cornerRadius(PulsumRadius.xl)
        .shadow(
            color: PulsumShadow.medium.color,
            radius: PulsumShadow.medium.radius,
            x: PulsumShadow.medium.x,
            y: PulsumShadow.medium.y
        )
    }
}

struct WellbeingErrorCard: View {
    let message: String
    var retry: (() -> Void)? = nil

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                Text("Wellbeing score")
                    .font(.pulsumHeadline)
                Text("Something went wrong")
                    .font(.pulsumTitle3)
                    .foregroundStyle(Color.pulsumWarning)
                Text(message)
                    .font(.pulsumCallout)
                    .foregroundStyle(Color.pulsumTextSecondary)
                    .lineSpacing(2)
            }

            if let retry {
                Button {
                    retry()
                } label: {
                    Text("Try again")
                        .font(.pulsumCallout.weight(.semibold))
                        .foregroundStyle(Color.pulsumTextPrimary)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, PulsumSpacing.sm)
                }
                .glassEffect(.regular.tint(Color.pulsumBlueSoft.opacity(0.6)).interactive())
            }
        }
        .padding(PulsumSpacing.lg)
        .background(Color.pulsumCardWhite)
        .cornerRadius(PulsumRadius.xl)
        .shadow(
            color: PulsumShadow.medium.color,
            radius: PulsumShadow.medium.radius,
            x: PulsumShadow.medium.x,
            y: PulsumShadow.medium.y
        )
    }
}

// MARK: - Wellbeing Score Card
struct WellbeingScoreCard: View {
    let score: Double

    var body: some View {
        VStack(alignment: .leading, spacing: PulsumSpacing.md) {
            VStack(alignment: .leading, spacing: PulsumSpacing.xxs) {
                Text("Wellbeing score")
                    .font(.pulsumHeadline)
                    .foregroundStyle(Color.pulsumTextPrimary)
                Text("Calculated nightly from your data")
                    .font(.pulsumCaption)
                    .foregroundStyle(Color.pulsumTextSecondary)
            }

            HStack(alignment: .center, spacing: PulsumSpacing.lg) {
                VStack(alignment: .leading, spacing: PulsumSpacing.xs) {
                    Text(score.formatted(.number.precision(.fractionLength(2))))
                        .font(.pulsumDataLarge)
                        .foregroundStyle(scoreColor)
                    Text(interpretedScore)
                        .font(.pulsumCallout)
                        .foregroundStyle(Color.pulsumTextSecondary)
                }
                Spacer()
                Image(systemName: "chevron.right")
                    .font(.pulsumTitle3)
                    .foregroundStyle(Color.pulsumTextTertiary)
            }

            Text("Tap for the full breakdown, including objective recovery signals and your subjective check-in inputs.")
                .font(.pulsumCaption)
                .foregroundStyle(Color.pulsumTextSecondary)
                .lineSpacing(2)
        }
        .padding(PulsumSpacing.lg)
        .background(Color.pulsumCardWhite)
        .cornerRadius(PulsumRadius.xl)
        .shadow(
            color: PulsumShadow.medium.color,
            radius: PulsumShadow.medium.radius,
            x: PulsumShadow.medium.x,
            y: PulsumShadow.medium.y
        )
    }

    private var scoreColor: Color {
        switch score {
        case ..<(-1): return Color.pulsumWarning
        case -1..<0.5: return Color.pulsumTextSecondary
        case 0.5..<1.5: return Color.pulsumGreenSoft
        default: return Color.pulsumSuccess
        }
    }

    private var interpretedScore: String {
        switch score {
        case ..<(-1): return "Let's go gentle today"
        case -1..<0.5: return "Maintaining base"
        case 0.5..<1.5: return "Positive momentum"
        default: return "Strong recovery"
        }
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/SettingsView.swift -->

### Packages/PulsumUI/Sources/PulsumUI/SettingsViewModel.swift
- bytes: 18440
- lines: 498
- sha256: cac45f27eaf85f7714d0872d767294a4f142df4740aa27a344991a4c2858bb9c
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Sources/PulsumUI/SettingsViewModel.swift -->
```swift
import Foundation
import Observation
import PulsumAgents
import HealthKit
import PulsumTypes
import PulsumServices
#if canImport(UIKit)
import UIKit
#endif

@MainActor
@Observable
final class SettingsViewModel {
    @ObservationIgnored private var orchestrator: AgentOrchestrator?
    private(set) var foundationModelsStatus: String = ""
    var consentGranted: Bool
    var lastConsentUpdated: Date = Date()
    var healthKitDebugSummary: String = ""

    struct HealthAccessRow: Identifiable, Equatable {
        let id: String
        let title: String
        let detail: String
        let iconName: String
        let status: HealthAccessGrantState
    }

    // HealthKit State
    private(set) var healthKitSummary: String = "Checking..."
    private(set) var missingHealthKitDetail: String?
    private(set) var healthAccessRows: [HealthAccessRow] = HealthAccessRequirement.ordered.map {
        HealthAccessRow(id: $0.id,
                        title: $0.title,
                        detail: $0.detail,
                        iconName: $0.iconName,
                        status: .pending)
    }
    private(set) var showHealthKitUnavailableBanner: Bool = false
    private(set) var isRequestingHealthKitAuthorization: Bool = false
    private(set) var canRequestHealthKitAccess: Bool = true
    private(set) var healthKitError: String?
    private(set) var healthKitSuccessMessage: String?
    @ObservationIgnored private var healthKitSuccessTask: Task<Void, Never>?
    private var lastHealthAccessStatus: HealthAccessStatus?
    private var awaitingToastAfterRequest: Bool = false
    private var didApplyInitialStatus: Bool = false
    var debugLogSnapshot: String = ""
    var diagnosticsConfig: DiagnosticsConfig = Diagnostics.currentConfig()
    var diagnosticsSessionId: UUID = Diagnostics.sessionId
    var diagnosticsExportURL: URL?
    var isExportingDiagnostics = false

    // GPT-5 API Status
    private(set) var gptAPIStatus: String = "Missing API key"
    private(set) var isGPTAPIWorking: Bool = false
    var gptAPIKeyDraft: String = ""
    private(set) var isTestingAPIKey: Bool = false

    var onConsentChanged: ((Bool) -> Void)?

#if DEBUG
    var diagnosticsVisible: Bool = false
    var routeHistory: [String] = []
    var lastCoverageSummary: String = "—"
    var lastCloudError: String = "None"
    @ObservationIgnored private var routeTask: Task<Void, Never>?
    @ObservationIgnored private var errorTask: Task<Void, Never>?
    private let diagnosticsHistoryLimit = 5
#endif

    init(initialConsent: Bool) {
        self.consentGranted = initialConsent
#if DEBUG
        setupDiagnosticsObservers()
#endif
        refreshDiagnosticsConfig()
    }

    func bind(orchestrator: AgentOrchestrator) {
        self.orchestrator = orchestrator
        foundationModelsStatus = orchestrator.foundationModelsStatus
        if let stored = orchestrator.currentLLMAPIKey() {
            gptAPIKeyDraft = stored
            if !stored.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                Task { await testCurrentAPIKey() }
            } else {
                gptAPIStatus = "Missing API key"
                isGPTAPIWorking = false
            }
        } else {
            gptAPIStatus = "Missing API key"
            isGPTAPIWorking = false
        }
        refreshHealthAccessStatus()
        refreshDiagnosticsConfig()
    }

    func refreshFoundationStatus() {
        guard let orchestrator else { return }
        foundationModelsStatus = orchestrator.foundationModelsStatus
    }

    func refreshHealthAccessStatus() {
        guard let orchestrator else {
            healthKitSummary = "Agent unavailable"
            canRequestHealthKitAccess = false
            return
        }
        Task { [weak self] in
            guard let self else { return }
            let status = await orchestrator.currentHealthAccessStatus()
            await MainActor.run {
                self.applyHealthStatus(status)
                self.healthKitDebugSummary = Self.debugSummary(from: status)
                self.debugLogSnapshot = ""
            }
        }
    }

    func requestHealthKitAuthorization() async {
        guard let orchestrator else {
            healthKitError = "Agent unavailable"
            return
        }
        isRequestingHealthKitAuthorization = true
        awaitingToastAfterRequest = true
        healthKitError = nil
        defer { isRequestingHealthKitAuthorization = false }

        do {
            let status = try await orchestrator.requestHealthAccess()
            applyHealthStatus(status)
            healthKitDebugSummary = Self.debugSummary(from: status)
        } catch let serviceError as HealthKitServiceError {
            healthKitError = serviceError.localizedDescription
            let status = await orchestrator.currentHealthAccessStatus()
            applyHealthStatus(status)
            healthKitDebugSummary = Self.debugSummary(from: status)
        } catch {
            healthKitError = error.localizedDescription
            let status = await orchestrator.currentHealthAccessStatus()
            applyHealthStatus(status)
            healthKitDebugSummary = Self.debugSummary(from: status)
        }
    }

    func refreshDebugLog() async {
        guard let orchestrator else {
            debugLogSnapshot = "Debug log unavailable (orchestrator not ready)"
            return
        }
        let snapshot = await orchestrator.debugLogSnapshot()
        await MainActor.run {
            debugLogSnapshot = snapshot.isEmpty ? "No events captured yet." : snapshot
        }
    }

    func toggleConsent(_ newValue: Bool) {
        guard consentGranted != newValue else { return }
        consentGranted = newValue
        lastConsentUpdated = Date()
        onConsentChanged?(newValue)
        AppRuntimeConfig.synchronizeUITestDefaults()
    }

    func refreshConsent(_ value: Bool) {
        consentGranted = value
        lastConsentUpdated = Date()
    }

    func refreshDiagnosticsConfig() {
        diagnosticsConfig = Diagnostics.currentConfig()
        diagnosticsSessionId = Diagnostics.sessionId
    }

    func updateDiagnosticsEnabled(_ enabled: Bool) {
        diagnosticsConfig.enabled = enabled
        Diagnostics.updateConfig(diagnosticsConfig)
    }

    func updateDiagnosticsPersistence(_ persist: Bool) {
        diagnosticsConfig.persistToDisk = persist
        Diagnostics.updateConfig(diagnosticsConfig)
    }

    func updateDiagnosticsOSLog(_ mirror: Bool) {
        diagnosticsConfig.mirrorToOSLog = mirror
        Diagnostics.updateConfig(diagnosticsConfig)
    }

    func updateDiagnosticsSignposts(_ enable: Bool) {
        diagnosticsConfig.enableSignposts = enable
        Diagnostics.updateConfig(diagnosticsConfig)
    }

    func exportDiagnosticsReport() async {
        isExportingDiagnostics = true
        diagnosticsExportURL = nil
        defer { isExportingDiagnostics = false }

        let config = diagnosticsConfig
        let sessionId = diagnosticsSessionId
        let locale = Locale.current.identifier
        let appVersion = Self.appVersion()
        let buildNumber = Self.buildNumber()
        let deviceModel = Self.deviceModel()
        let osVersion = Self.osVersion()
        let snapshot: DiagnosticsSnapshot
        if let orchestrator {
            do {
                let snapshotResult = try await withHardTimeout(seconds: 2) {
                    await orchestrator.diagnosticsSnapshot()
                }
                switch snapshotResult {
                case .value(let value):
                    snapshot = value
                case .timedOut:
                    snapshot = DiagnosticsSnapshot()
                    debugLogSnapshot = "Diagnostics snapshot timed out; exporting partial report."
                }
            } catch {
                snapshot = DiagnosticsSnapshot()
                debugLogSnapshot = "Diagnostics snapshot failed: \(error.localizedDescription)"
            }
        } else {
            snapshot = DiagnosticsSnapshot()
        }

        let exportTask = Task.detached(priority: .utility) { () async -> URL? in
            if config.persistToDisk {
                await Diagnostics.flushPersistence()
            }
            let logTail: [String]
            if config.persistToDisk {
                logTail = await Diagnostics.persistedLogTail(maxLines: config.logTailLinesForExport)
            } else {
                logTail = await DebugLogBuffer.shared.tail(maxLines: config.logTailLinesForExport)
            }

            let sessionsIncluded = Self.extractSessionIds(from: logTail)

            let context = DiagnosticsReportContext(appVersion: appVersion,
                                                   buildNumber: buildNumber,
                                                   deviceModel: deviceModel,
                                                   osVersion: osVersion,
                                                   locale: locale,
                                                   sessionId: sessionId,
                                                   diagnosticsEnabled: config.enabled,
                                                   persistenceEnabled: config.persistToDisk,
                                                   sessionsIncluded: sessionsIncluded.isEmpty ? nil : sessionsIncluded)

            return try? DiagnosticsReportBuilder.buildReport(context: context,
                                                             snapshot: snapshot,
                                                             logTail: logTail)
        }

        diagnosticsExportURL = await exportTask.value
    }

    func clearDiagnostics() async {
        await Diagnostics.clearDiagnostics()
        debugLogSnapshot = ""
        diagnosticsExportURL = nil
    }

    @MainActor
    func saveAPIKey(_ key: String) async {
        guard let orchestrator else {
            gptAPIStatus = "Agent unavailable"
            isGPTAPIWorking = false
            return
        }
        let trimmedKey = key.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedKey.isEmpty else {
            gptAPIStatus = "Missing API key"
            isGPTAPIWorking = false
            return
        }
        gptAPIStatus = "Saving..."
        do {
            try orchestrator.setLLMAPIKey(trimmedKey)
            gptAPIKeyDraft = trimmedKey
            isGPTAPIWorking = false
            gptAPIStatus = "API key saved"
        } catch {
            isGPTAPIWorking = false
            gptAPIStatus = "Missing or invalid API key"
        }
    }

    @MainActor
    func testCurrentAPIKey() async {
        if AppRuntimeConfig.isUITesting {
            let trimmed = gptAPIKeyDraft.trimmingCharacters(in: .whitespacesAndNewlines)
            isTestingAPIKey = false
            isGPTAPIWorking = !trimmed.isEmpty
            gptAPIStatus = trimmed.isEmpty ? "Missing API key" : "UI testing: skipped"
            return
        }
        guard let orchestrator else {
            gptAPIStatus = "Agent unavailable"
            isGPTAPIWorking = false
            return
        }
        isTestingAPIKey = true
        defer { isTestingAPIKey = false }
        gptAPIStatus = "Testing..."
        isGPTAPIWorking = false
        do {
            let ok = try await orchestrator.testLLMAPIConnection()
            isGPTAPIWorking = ok
            gptAPIStatus = ok ? "OpenAI reachable" : "OpenAI ping failed"
        } catch {
            isGPTAPIWorking = false
            gptAPIStatus = "Missing or invalid API key"
        }
    }

    func makeScoreBreakdownViewModel() -> ScoreBreakdownViewModel? {
        guard let orchestrator else { return nil }
        return ScoreBreakdownViewModel(orchestrator: orchestrator)
    }

    private func applyHealthStatus(_ status: HealthAccessStatus) {
        let wasFullyGrantedOptional = lastHealthAccessStatus?.isFullyGranted
        lastHealthAccessStatus = status

        switch status.availability {
        case .available:
            if status.totalRequired > 0 {
                healthKitSummary = "\(status.grantedCount)/\(status.totalRequired) granted"
            } else {
                healthKitSummary = "Ready"
            }
            showHealthKitUnavailableBanner = false
            canRequestHealthKitAccess = true
            let missingTitles = status.missingTypes.compactMap { HealthAccessRequirement.descriptor(for: $0)?.title }
            if missingTitles.isEmpty {
                missingHealthKitDetail = nil
            } else {
                missingHealthKitDetail = "Missing: \(missingTitles.joined(separator: ", "))"
            }
        case .unavailable(let reason):
            healthKitSummary = "Health data unavailable"
            showHealthKitUnavailableBanner = true
            missingHealthKitDetail = reason
            canRequestHealthKitAccess = false
        }

        healthAccessRows = HealthAccessRequirement.ordered.map { descriptor in
            HealthAccessRow(id: descriptor.id,
                            title: descriptor.title,
                            detail: descriptor.detail,
                            iconName: descriptor.iconName,
                            status: rowStatus(for: descriptor.id, status: status))
        }

        let transitionedToFull = (wasFullyGrantedOptional == false) && status.isFullyGranted
        if status.isFullyGranted && (transitionedToFull || awaitingToastAfterRequest) && didApplyInitialStatus {
            awaitingToastAfterRequest = false
            emitHealthKitSuccessToast()
        } else if !status.isFullyGranted {
            cancelHealthKitSuccessToast()
        }

        if !didApplyInitialStatus {
            didApplyInitialStatus = true
        }
    }

    private func rowStatus(for identifier: String, status: HealthAccessStatus) -> HealthAccessGrantState {
        if status.granted.contains(where: { $0.identifier == identifier }) {
            return .granted
        }
        if status.denied.contains(where: { $0.identifier == identifier }) {
            return .denied
        }
        if status.notDetermined.contains(where: { $0.identifier == identifier }) {
            return .pending
        }
        return .pending
    }

    private func emitHealthKitSuccessToast() {
        healthKitSuccessMessage = "Health data connected"
        healthKitSuccessTask?.cancel()
        healthKitSuccessTask = Task { [weak self] in
            try? await Task.sleep(nanoseconds: 2_500_000_000)
            await MainActor.run {
                self?.healthKitSuccessMessage = nil
            }
        }
    }

    private func cancelHealthKitSuccessToast() {
        healthKitSuccessTask?.cancel()
        healthKitSuccessTask = nil
        healthKitSuccessMessage = nil
    }

    func debugHealthStatusSnapshot() -> String {
        healthKitDebugSummary
    }

    private static func debugSummary(from status: HealthAccessStatus) -> String {
        let granted = status.granted.map(\.identifier).sorted().joined(separator: ", ")
        let denied = status.denied.map(\.identifier).sorted().joined(separator: ", ")
        let pending = status.notDetermined.map(\.identifier).sorted().joined(separator: ", ")
        return "Granted: [\(granted)] | Denied: [\(denied)] | Pending: [\(pending)] | Availability: \(status.availability)"
    }

    private static func appVersion() -> String {
        Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String ?? "unknown"
    }

    private static func buildNumber() -> String {
        Bundle.main.object(forInfoDictionaryKey: "CFBundleVersion") as? String ?? "unknown"
    }

    private static func deviceModel() -> String {
        #if canImport(UIKit)
        return UIDevice.current.model
        #else
        return "mac"
        #endif
    }

    private static func osVersion() -> String {
        #if canImport(UIKit)
        return UIDevice.current.systemVersion
        #else
        return ProcessInfo.processInfo.operatingSystemVersionString
        #endif
    }

    nonisolated private static func extractSessionIds(from logTail: [String]) -> [String] {
        var sessions: [String] = []
        for line in logTail {
            guard let range = line.range(of: "app.session.start session=") else { continue }
            let after = line[range.upperBound...]
            if let id = after.split(separator: " ").first {
                let value = String(id)
                if !sessions.contains(value) {
                    sessions.append(value)
                }
            }
        }
        return sessions
    }

#if DEBUG
    func toggleDiagnosticsVisibility() {
        diagnosticsVisible.toggle()
    }

    private func setupDiagnosticsObservers() {
        let center = NotificationCenter.default

        routeTask = Task { [weak self] in
            for await note in center.notifications(named: .pulsumChatRouteDiagnostics) {
                guard let self else { continue }
                await MainActor.run {
                    if let route = note.userInfo?["route"] as? String {
                        routeHistory.insert(route, at: 0)
                        if routeHistory.count > diagnosticsHistoryLimit {
                            routeHistory.removeLast(routeHistory.count - diagnosticsHistoryLimit)
                        }
                    }

                    if let top = note.userInfo?["top"] as? Double,
                       let median = note.userInfo?["median"] as? Double,
                       let count = note.userInfo?["count"] as? Int {
                        lastCoverageSummary = "matches=\(count) top=\(String(format: "%.2f", top)) median=\(String(format: "%.2f", median))"
                    } else {
                        lastCoverageSummary = "–"
                    }
                }
            }
        }

        errorTask = Task { [weak self] in
            for await note in center.notifications(named: .pulsumChatCloudError) {
                guard let self else { continue }
                await MainActor.run {
                    if let message = note.userInfo?["message"] as? String {
                        lastCloudError = message
                    }
                }
            }
        }
    }

    deinit {
        routeTask?.cancel()
        errorTask?.cancel()
    }
#endif
}
```
<!-- END_FILE: Packages/PulsumUI/Sources/PulsumUI/SettingsViewModel.swift -->

### Packages/PulsumUI/Tests/PulsumUITests/CoachViewModelTests.swift
- bytes: 15247
- lines: 360
- sha256: 1f92845207e46e2859bc514f587f03291800e7452be52123224b4966350d29ba
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Tests/PulsumUITests/CoachViewModelTests.swift -->
```swift
import XCTest
@testable import PulsumAgents
import PulsumTypes
@testable import PulsumUI

// Run with: xcodebuild test -scheme PulsumUI -destination 'platform=iOS Simulator,name=iPhone 15'

@MainActor
final class CoachViewModelTests: XCTestCase {
    func testSnapshotReadyBeforeRecommendationsComplete() async {
        let snapshot = WellbeingSnapshotResponse(
            wellbeingState: .ready(score: 0.72, contributions: ["z_hrv": 0.12]),
            snapshotKind: .real,
            dayString: "2025-10-23"
        )
        let response = RecommendationResponse(
            cards: [RecommendationCard(id: "r1", title: "Card A", body: "Body", caution: nil, sourceBadge: "Local")],
            wellbeingScore: 0,
            contributions: [:],
            wellbeingState: .noData(.insufficientSamples),
            notice: nil
        )
        let orchestrator = TestCoachOrchestrator(
            snapshotResponse: snapshot,
            recommendationsResponses: [response],
            recommendationsDelay: 200_000_000
        )
        let viewModel = CoachViewModel(recommendationsDebounceNanoseconds: 0)
        viewModel.bind(orchestrator: orchestrator, consentProvider: { true })

        await viewModel.refreshRecommendations()
        XCTAssertEqual(viewModel.wellbeingState, snapshot.wellbeingState)
        XCTAssertTrue(viewModel.isLoadingCards)
        XCTAssertTrue(viewModel.recommendations.isEmpty)

        try? await Task.sleep(nanoseconds: 50_000_000)
        XCTAssertTrue(viewModel.isLoadingCards)

        try? await Task.sleep(nanoseconds: 250_000_000)
        XCTAssertFalse(viewModel.isLoadingCards)
        XCTAssertEqual(viewModel.recommendations, response.cards)
    }

    func testRefreshStormCoalescesRecommendationsAndKeepsWellbeingReady() async {
        let snapshot = WellbeingSnapshotResponse(
            wellbeingState: .ready(score: 0.61, contributions: ["z_steps": -0.05]),
            snapshotKind: .real,
            dayString: "2025-10-23"
        )
        let first = RecommendationResponse(
            cards: [RecommendationCard(id: "r1", title: "Card A", body: "Body", caution: nil, sourceBadge: "Local")],
            wellbeingScore: 0,
            contributions: [:],
            wellbeingState: .noData(.insufficientSamples),
            notice: nil
        )
        let second = RecommendationResponse(
            cards: [RecommendationCard(id: "r2", title: "Card B", body: "Body", caution: nil, sourceBadge: "Local")],
            wellbeingScore: 0,
            contributions: [:],
            wellbeingState: .noData(.insufficientSamples),
            notice: nil
        )
        let orchestrator = TestCoachOrchestrator(
            snapshotResponse: snapshot,
            recommendationsResponses: [first, second],
            recommendationsDelay: 200_000_000
        )
        let viewModel = CoachViewModel(recommendationsDebounceNanoseconds: 0)
        viewModel.bind(orchestrator: orchestrator, consentProvider: { true })

        await viewModel.refreshRecommendations()
        try? await Task.sleep(nanoseconds: 20_000_000)

        let refreshTasks = (0..<5).map { _ in
            Task { await viewModel.refreshRecommendations() }
        }
        for task in refreshTasks {
            await task.value
        }

        if case .loading = viewModel.wellbeingState {
            XCTFail("Wellbeing state should not return to loading after initial load.")
        }

        try? await Task.sleep(nanoseconds: 500_000_000)
        XCTAssertEqual(orchestrator.maxConcurrentRecommendations, 1)
        XCTAssertEqual(orchestrator.recommendationsCallCount, 2)
    }

    func testStaleRecommendationResultsApplyWhenEmpty() async {
        let snapshot = WellbeingSnapshotResponse(
            wellbeingState: .ready(score: 0.55, contributions: ["z_sleepDebt": -0.2]),
            snapshotKind: .real,
            dayString: "2025-10-23"
        )
        let stale = RecommendationResponse(
            cards: [RecommendationCard(id: "stale", title: "Old", body: "Body", caution: nil, sourceBadge: "Local")],
            wellbeingScore: 0,
            contributions: [:],
            wellbeingState: .noData(.insufficientSamples),
            notice: nil
        )
        let fresh = RecommendationResponse(
            cards: [RecommendationCard(id: "fresh", title: "New", body: "Body", caution: nil, sourceBadge: "Local")],
            wellbeingScore: 0,
            contributions: [:],
            wellbeingState: .noData(.insufficientSamples),
            notice: nil
        )
        let orchestrator = TestCoachOrchestrator(
            snapshotResponse: snapshot,
            recommendationsResponses: [stale, fresh],
            recommendationsDelay: 150_000_000
        )
        let viewModel = CoachViewModel(recommendationsDebounceNanoseconds: 0)
        viewModel.bind(orchestrator: orchestrator, consentProvider: { true })

        let firstCompleted = expectation(description: "first recommendations completed")
        let secondCompleted = expectation(description: "second recommendations completed")
        orchestrator.onRecommendationsComplete = { (callIndex: Int) in
            if callIndex == 1 {
                firstCompleted.fulfill()
            }
            if callIndex == 2 {
                secondCompleted.fulfill()
            }
        }

        Task { await viewModel.refreshRecommendations() }
        try? await Task.sleep(nanoseconds: 20_000_000)
        Task { await viewModel.refreshRecommendations() }

        await fulfillment(of: [firstCompleted], timeout: 1.0)
        XCTAssertEqual(viewModel.recommendations, stale.cards)

        await fulfillment(of: [secondCompleted], timeout: 1.0)
        XCTAssertEqual(viewModel.recommendations, fresh.cards)
    }

    func testStaleRecommendationResultsIgnoredWhenCardsExist() async {
        let snapshot = WellbeingSnapshotResponse(
            wellbeingState: .ready(score: 0.66, contributions: ["z_steps": 0.12]),
            snapshotKind: .real,
            dayString: "2025-10-23"
        )
        let initial = RecommendationResponse(
            cards: [RecommendationCard(id: "current", title: "Current", body: "Body", caution: nil, sourceBadge: "Local")],
            wellbeingScore: 0,
            contributions: [:],
            wellbeingState: .noData(.insufficientSamples),
            notice: nil
        )
        let stale = RecommendationResponse(
            cards: [RecommendationCard(id: "stale", title: "Old", body: "Body", caution: nil, sourceBadge: "Local")],
            wellbeingScore: 0,
            contributions: [:],
            wellbeingState: .noData(.insufficientSamples),
            notice: nil
        )
        let fresh = RecommendationResponse(
            cards: [RecommendationCard(id: "fresh", title: "New", body: "Body", caution: nil, sourceBadge: "Local")],
            wellbeingScore: 0,
            contributions: [:],
            wellbeingState: .noData(.insufficientSamples),
            notice: nil
        )
        let orchestrator = TestCoachOrchestrator(
            snapshotResponse: snapshot,
            recommendationsResponses: [initial, stale, fresh],
            recommendationsDelay: 150_000_000
        )
        let viewModel = CoachViewModel(recommendationsDebounceNanoseconds: 0)
        viewModel.bind(orchestrator: orchestrator, consentProvider: { true })

        await viewModel.refreshRecommendations()
        try? await Task.sleep(nanoseconds: 250_000_000)
        XCTAssertEqual(viewModel.recommendations, initial.cards)

        let staleCompleted = expectation(description: "stale recommendations completed")
        let freshCompleted = expectation(description: "fresh recommendations completed")
        orchestrator.onRecommendationsComplete = { (callIndex: Int) in
            if callIndex == 2 {
                staleCompleted.fulfill()
            }
            if callIndex == 3 {
                freshCompleted.fulfill()
            }
        }

        Task { await viewModel.refreshRecommendations() }
        try? await Task.sleep(nanoseconds: 20_000_000)
        Task { await viewModel.refreshRecommendations() }

        await fulfillment(of: [staleCompleted], timeout: 1.0)
        XCTAssertEqual(viewModel.recommendations, initial.cards)

        await fulfillment(of: [freshCompleted], timeout: 1.0)
        XCTAssertEqual(viewModel.recommendations, fresh.cards)
    }

    func testRecommendationsSoftTimeoutStopsSpinnerAndAppliesLater() async {
        let snapshot = WellbeingSnapshotResponse(
            wellbeingState: .ready(score: 0.72, contributions: ["z_hrv": 0.12]),
            snapshotKind: .real,
            dayString: "2025-10-23"
        )
        let response = RecommendationResponse(
            cards: [RecommendationCard(id: "slow", title: "Slow", body: "Body", caution: nil, sourceBadge: "Local")],
            wellbeingScore: 0,
            contributions: [:],
            wellbeingState: .noData(.insufficientSamples),
            notice: nil
        )
        let orchestrator = TestCoachOrchestrator(
            snapshotResponse: snapshot,
            recommendationsResponses: [response],
            recommendationsDelay: 300_000_000
        )
        let viewModel = CoachViewModel(recommendationsDebounceNanoseconds: 0,
                                       recommendationsSoftTimeoutSeconds: 0.05)
        viewModel.bind(orchestrator: orchestrator, consentProvider: { true })

        await viewModel.refreshRecommendations()
        XCTAssertTrue(viewModel.isLoadingCards)

        try? await Task.sleep(nanoseconds: 80_000_000)
        XCTAssertFalse(viewModel.isLoadingCards)
        XCTAssertEqual(viewModel.recommendationsSoftTimeoutMessage,
                       "Recommendations are taking longer than expected. We'll show them here as soon as they're ready.")

        try? await Task.sleep(nanoseconds: 300_000_000)
        XCTAssertEqual(viewModel.recommendations, response.cards)
        XCTAssertNil(viewModel.recommendationsSoftTimeoutMessage)
    }

    func testPlaceholderSnapshotShowsWarmingUpNotice() async {
        let snapshot = WellbeingSnapshotResponse(
            wellbeingState: .noData(.insufficientSamples),
            snapshotKind: .placeholder,
            dayString: "2025-10-23"
        )
        let orchestrator = TestCoachOrchestrator(
            snapshotResponse: snapshot,
            recommendationsResponses: []
        )
        let viewModel = CoachViewModel(recommendationsDebounceNanoseconds: 0)
        viewModel.bind(orchestrator: orchestrator, consentProvider: { true })

        await viewModel.refreshRecommendations()

        XCTAssertEqual(viewModel.snapshotKind, .placeholder)
        XCTAssertEqual(viewModel.wellbeingState, .noData(.insufficientSamples))
        XCTAssertEqual(viewModel.wellbeingNotice?.text,
                       "Warming up... Health data may take a moment on first run.")
    }

    func testSnapshotKindSemantics() async throws {
        let noneSnapshot = WellbeingSnapshotResponse(
            wellbeingState: .noData(.insufficientSamples),
            snapshotKind: .none,
            dayString: nil
        )
        let realSnapshot = WellbeingSnapshotResponse(
            wellbeingState: .ready(score: 0.42, contributions: ["z_steps": 0.2]),
            snapshotKind: .real,
            dayString: "2025-10-23"
        )

        let noneOrchestrator = TestCoachOrchestrator(
            snapshotResponse: noneSnapshot,
            recommendationsResponses: []
        )
        let noneViewModel = CoachViewModel(recommendationsDebounceNanoseconds: 0)
        noneViewModel.bind(orchestrator: noneOrchestrator, consentProvider: { true })

        await noneViewModel.refreshRecommendations()
        XCTAssertEqual(noneViewModel.snapshotKind, .none)
        XCTAssertNil(noneViewModel.wellbeingScore)
        XCTAssertEqual(noneViewModel.wellbeingNotice?.text,
                       "We're waiting for enough Health data to personalize your picks.")

        let realOrchestrator = TestCoachOrchestrator(
            snapshotResponse: realSnapshot,
            recommendationsResponses: []
        )
        let realViewModel = CoachViewModel(recommendationsDebounceNanoseconds: 0)
        realViewModel.bind(orchestrator: realOrchestrator, consentProvider: { true })

        await realViewModel.refreshRecommendations()
        XCTAssertEqual(realViewModel.snapshotKind, .real)
        let score = try XCTUnwrap(realViewModel.wellbeingScore)
        XCTAssertEqual(score, 0.42, accuracy: 0.0001)
        XCTAssertNil(realViewModel.wellbeingNotice)
    }
}

@MainActor
private final class TestCoachOrchestrator: CoachOrchestrating {
    let snapshotResponse: WellbeingSnapshotResponse
    let recommendationsResponses: [RecommendationResponse]
    let snapshotDelay: UInt64
    let recommendationsDelay: UInt64

    private(set) var recommendationsCallCount = 0
    private(set) var maxConcurrentRecommendations = 0
    private var activeRecommendations = 0

    var onRecommendationsComplete: ((Int) -> Void)?

    init(snapshotResponse: WellbeingSnapshotResponse,
         recommendationsResponses: [RecommendationResponse],
         snapshotDelay: UInt64 = 0,
         recommendationsDelay: UInt64 = 0) {
        self.snapshotResponse = snapshotResponse
        self.recommendationsResponses = recommendationsResponses
        self.snapshotDelay = snapshotDelay
        self.recommendationsDelay = recommendationsDelay
    }

    func wellbeingSnapshotState(consentGranted: Bool) async throws -> WellbeingSnapshotResponse {
        _ = consentGranted
        if snapshotDelay > 0 {
            try await Task.sleep(nanoseconds: snapshotDelay)
        }
        return snapshotResponse
    }

    func recommendations(consentGranted: Bool) async throws -> RecommendationResponse {
        _ = consentGranted
        recommendationsCallCount += 1
        activeRecommendations += 1
        maxConcurrentRecommendations = max(maxConcurrentRecommendations, activeRecommendations)
        let callIndex = recommendationsCallCount
        defer {
            activeRecommendations -= 1
            onRecommendationsComplete?(callIndex)
        }
        if recommendationsDelay > 0 {
            try await Task.sleep(nanoseconds: recommendationsDelay)
        }
        if callIndex <= recommendationsResponses.count {
            return recommendationsResponses[callIndex - 1]
        }
        return recommendationsResponses.last ?? RecommendationResponse(cards: [],
                                                                      wellbeingScore: 0,
                                                                      contributions: [:],
                                                                      wellbeingState: .noData(.insufficientSamples),
                                                                      notice: nil)
    }

    func logCompletion(momentId: String) async throws -> CheerEvent {
        CheerEvent(message: "Nice work!", haptic: .success, timestamp: Date())
    }

    func chat(userInput: String, consentGranted: Bool) async throws -> String {
        _ = (userInput, consentGranted)
        return "OK"
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Tests/PulsumUITests/CoachViewModelTests.swift -->

### Packages/PulsumUI/Tests/PulsumUITests/LiveWaveformBufferTests.swift
- bytes: 1167
- lines: 36
- sha256: f486d8f7c57dacbb1dbb1d35790e8435838f5edfafe02951773ff6ba92e9d5f0
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Tests/PulsumUITests/LiveWaveformBufferTests.swift -->
```swift
import XCTest
@testable import PulsumUI

final class LiveWaveformBufferTests: XCTestCase {
    func testRingBufferMaintainsLatestSamples() {
        var buffer = LiveWaveformLevels(capacity: 8)
        (0..<20).forEach { buffer.append(CGFloat($0)) }

        XCTAssertEqual(buffer.count, 8)
        XCTAssertEqual(buffer.samplesAppended, 20)
        XCTAssertEqual(Array(buffer), Array(repeating: 1, count: 8).map { CGFloat($0) })
    }

    func testWaveformPerfFeed30Seconds() {
        var buffer = LiveWaveformLevels(capacity: 180)
        let sampleCount = 1800
        let samples = (0..<sampleCount).map { _ in CGFloat.random(in: 0...1) }

        measure(metrics: [XCTClockMetric(), XCTMemoryMetric()]) {
            buffer.reset()
            for sample in samples {
                buffer.append(sample)
            }
        }

        XCTAssertEqual(buffer.samplesAppended, sampleCount)
        XCTAssertEqual(buffer.count, buffer.capacity)
    }

    func testClampBehavior() {
        var buffer = LiveWaveformLevels(capacity: 4)
        buffer.append(-3)
        buffer.append(2)
        XCTAssertEqual(Array(buffer), [CGFloat(0), CGFloat(1)])
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Tests/PulsumUITests/LiveWaveformBufferTests.swift -->

### Packages/PulsumUI/Tests/PulsumUITests/PulsumRootViewTests.swift
- bytes: 200
- lines: 9
- sha256: ac73ba9dcfeeec01c6a8c73a881d33a5d6ca035473e16db272520f9d148e2042
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Tests/PulsumUITests/PulsumRootViewTests.swift -->
```swift
import XCTest
@testable import PulsumUI

@MainActor
final class PulsumRootViewTests: XCTestCase {
    func testRootViewHealthCheckPrecondition() {
        XCTAssertNotNil(PulsumRootView.self)
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Tests/PulsumUITests/PulsumRootViewTests.swift -->

### Packages/PulsumUI/Tests/PulsumUITests/SettingsViewModelHealthAccessTests.swift
- bytes: 5680
- lines: 132
- sha256: 08166e9adb87d147e1d2b564c717fa67cf6c86e877b8cf2eb47d742292378678
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Tests/PulsumUITests/SettingsViewModelHealthAccessTests.swift -->
```swift
@testable import PulsumAgents
@testable import PulsumServices
@testable import PulsumUI
import PulsumData
import PulsumML
import PulsumTypes
import XCTest

@MainActor
final class SettingsViewModelHealthAccessTests: XCTestCase {
    func testRequestHealthKitAuthorizationRefreshesStatus() async throws {
        let requiredTypes = HealthKitService.orderedReadSampleTypes
        if requiredTypes.isEmpty {
            throw XCTSkip("HealthKit sample types unavailable on this platform")
        }
        let pending = HealthAccessStatus(required: requiredTypes,
                                         granted: [],
                                         denied: [],
                                         notDetermined: Set(requiredTypes),
                                         availability: .available)
        let granted = HealthAccessStatus(required: requiredTypes,
                                         granted: Set(requiredTypes),
                                         denied: [],
                                         notDetermined: [],
                                         availability: .available)

        let dataAgent = HealthStatusDataAgentStub(statuses: [pending, granted])
        let orchestrator = try makeOrchestrator(dataAgent: dataAgent)
        let viewModel = SettingsViewModel(initialConsent: false)

        viewModel.bind(orchestrator: orchestrator)
        viewModel.refreshHealthAccessStatus()
        try await Task.sleep(nanoseconds: 100_000_000)

        XCTAssertEqual(viewModel.healthKitSummary, "0/\(requiredTypes.count) granted")

        await viewModel.requestHealthKitAuthorization()

        XCTAssertEqual(viewModel.healthKitSummary, "\(requiredTypes.count)/\(requiredTypes.count) granted")
        XCTAssertFalse(viewModel.showHealthKitUnavailableBanner)
    }

    private func makeOrchestrator(dataAgent: any DataAgentProviding) throws -> AgentOrchestrator {
        let coachAgent = try CoachAgent(container: TestCoreDataStack.makeContainer(),
                                        vectorIndex: VectorIndexStub(),
                                        libraryImporter: LibraryImporter(),
                                        llmGateway: LLMGateway(),
                                        shouldIngestLibrary: false)
        return AgentOrchestrator(
            dataAgent: dataAgent,
            sentimentAgent: SentimentAgentStub(),
            coachAgent: coachAgent,
            safetyAgent: SafetyAgent(),
            cheerAgent: CheerAgent(),
            topicGate: TopicGateStub(),
            afmAvailable: false
        )
    }
}

private actor HealthStatusDataAgentStub: DataAgentProviding {
    private var statuses: [HealthAccessStatus]

    init(statuses: [HealthAccessStatus]) {
        self.statuses = statuses
    }

    func start() async throws {}
    func setDiagnosticsTraceId(_ traceId: UUID?) async {}
    func latestFeatureVector() async throws -> FeatureVectorSnapshot? { nil }
    func recordSubjectiveInputs(date: Date, stress: Double, energy: Double, sleepQuality: Double) async throws {}
    func scoreBreakdown() async throws -> ScoreBreakdown? { nil }
    func reprocessDay(date: Date) async throws {}
    func diagnosticsBackfillCounts() async -> (warmCompleted: Int, fullCompleted: Int) { (0, 0) }
    func latestSnapshotMetadata() async -> (dayString: String?, score: Double?) { (nil, nil) }

    func currentHealthAccessStatus() async -> HealthAccessStatus {
        statuses.first ?? HealthAccessStatus(required: [],
                                             granted: [],
                                             denied: [],
                                             notDetermined: [],
                                             availability: .available)
    }

    func requestHealthAccess() async throws -> HealthAccessStatus {
        if statuses.count > 1 {
            statuses = Array(statuses.dropFirst())
        }
        return await currentHealthAccessStatus()
    }

    func restartIngestionAfterPermissionsChange() async throws -> HealthAccessStatus {
        return await currentHealthAccessStatus()
    }
}

private final class SentimentAgentStub: SentimentAgentProviding {
    var audioLevels: AsyncStream<Float>? { nil }
    var speechStream: AsyncThrowingStream<SpeechSegment, Error>? { nil }

    func beginVoiceJournal(maxDuration: TimeInterval) async throws {}
    func finishVoiceJournal(transcript: String?) async throws -> JournalResult {
        throw SentimentAgentError.noActiveRecording
    }

    func recordVoiceJournal(maxDuration: TimeInterval) async throws -> JournalResult {
        throw SentimentAgentError.noActiveRecording
    }

    func importTranscript(_ transcript: String) async throws -> JournalResult {
        throw SentimentAgentError.noActiveRecording
    }

    func requestAuthorization() async throws {}
    func stopRecording() {}
    func updateTranscript(_ transcript: String) {}
    func latestTranscriptSnapshot() -> String { "" }
    func reprocessPendingJournals(traceId: UUID?) async {}
    func pendingEmbeddingCount() async -> Int { 0 }
}

private struct TopicGateStub: TopicGateProviding {
    func classify(_ text: String) async throws -> GateDecision {
        GateDecision(isOnTopic: true, reason: "stub", confidence: 0.99, topic: nil)
    }
}

private final class VectorIndexStub: VectorIndexProviding, @unchecked Sendable {
    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float] { [] }
    func removeMicroMoment(id: String) async throws {}
    func searchMicroMoments(query: String, topK: Int) async throws -> [VectorMatch] { [] }
}
```
<!-- END_FILE: Packages/PulsumUI/Tests/PulsumUITests/SettingsViewModelHealthAccessTests.swift -->

### Packages/PulsumUI/Tests/PulsumUITests/TestCoreDataStack.swift
- bytes: 829
- lines: 22
- sha256: feb5ec8d0101e452e0b8bc1f88becd48f5a1fdf0d85ec2ed6a4a49a198efcfab
- trailing_newline: true

<!-- BEGIN_FILE: Packages/PulsumUI/Tests/PulsumUITests/TestCoreDataStack.swift -->
```swift
import CoreData
import PulsumData

final class TestCoreDataStack {
    static func makeContainer() -> NSPersistentContainer {
        let container = NSPersistentContainer(name: "Pulsum", managedObjectModel: PulsumManagedObjectModel.shared)
        let description = NSPersistentStoreDescription()
        description.type = NSInMemoryStoreType
        description.shouldAddStoreAsynchronously = false
        container.persistentStoreDescriptions = [description]

        container.loadPersistentStores { _, error in
            if let error {
                fatalError("Test Core Data store error: \(error)")
            }
        }

        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
        return container
    }
}
```
<!-- END_FILE: Packages/PulsumUI/Tests/PulsumUITests/TestCoreDataStack.swift -->

### Pulsum.xcodeproj/project.pbxproj
- bytes: 33055
- lines: 786
- sha256: ecd457b3ddfbb407baa47741c4827f32e48205ee6dd03f201b73841f832951d4
- trailing_newline: true

<!-- BEGIN_FILE: Pulsum.xcodeproj/project.pbxproj -->
```text
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 77;
	objects = {

/* Begin PBXBuildFile section */
		910D1C8BDF7B4BE0A79330B5 /* PrivacyInfo.xcprivacy in Resources */ = {isa = PBXBuildFile; fileRef = 163A3F3C451B4A0D810BEBDC /* PrivacyInfo.xcprivacy */; };
		94293E602E8CD700003E5840 /* streak_low_poly_copy.splineswift in Resources */ = {isa = PBXBuildFile; fileRef = 94293E5F2E8CD700003E5840 /* streak_low_poly_copy.splineswift */; };
		9429413D2E8E32C7003E5840 /* podcastrecommendations 2.json in Resources */ = {isa = PBXBuildFile; fileRef = 9429413C2E8E32C7003E5840 /* podcastrecommendations 2.json */; };
		945EC8922E8AD321001CCF2E /* PulsumUI in Frameworks */ = {isa = PBXBuildFile; productRef = C9EBA0CEFE7A4C389A2E4FB8 /* PulsumUI */; };
		945EC8932E8AD321001CCF2E /* PulsumAgents in Frameworks */ = {isa = PBXBuildFile; productRef = A95AA2EDA6C84DD4AFB06BA9 /* PulsumAgents */; };
		945EC8942E8AD321001CCF2E /* PulsumData in Frameworks */ = {isa = PBXBuildFile; productRef = A53933ECCEA4440495B0FCB3 /* PulsumData */; };
		945EC8952E8AD321001CCF2E /* PulsumServices in Frameworks */ = {isa = PBXBuildFile; productRef = 789E650BC257425BBE5CEDCB /* PulsumServices */; };
		945EC8962E8AD321001CCF2E /* PulsumML in Frameworks */ = {isa = PBXBuildFile; productRef = 0F767ADA6BE24721A5249B90 /* PulsumML */; };
		945EC8982E8AD321001CCF2E /* PulsumUI in Frameworks */ = {isa = PBXBuildFile; productRef = C9EBA0CEFE7A4C389A2E4FB8 /* PulsumUI */; };
		945EC8992E8AD321001CCF2E /* PulsumAgents in Frameworks */ = {isa = PBXBuildFile; productRef = A95AA2EDA6C84DD4AFB06BA9 /* PulsumAgents */; };
		945EC89A2E8AD321001CCF2E /* PulsumData in Frameworks */ = {isa = PBXBuildFile; productRef = A53933ECCEA4440495B0FCB3 /* PulsumData */; };
		945EC89B2E8AD321001CCF2E /* PulsumServices in Frameworks */ = {isa = PBXBuildFile; productRef = 789E650BC257425BBE5CEDCB /* PulsumServices */; };
		945EC89C2E8AD321001CCF2E /* PulsumML in Frameworks */ = {isa = PBXBuildFile; productRef = 0F767ADA6BE24721A5249B90 /* PulsumML */; };
		945EC89D2E8AD321001CCF2E /* PulsumUI in Frameworks */ = {isa = PBXBuildFile; productRef = C9EBA0CEFE7A4C389A2E4FB8 /* PulsumUI */; };
		945EC89E2E8AD321001CCF2E /* PulsumAgents in Frameworks */ = {isa = PBXBuildFile; productRef = A95AA2EDA6C84DD4AFB06BA9 /* PulsumAgents */; };
		945EC89F2E8AD321001CCF2E /* PulsumData in Frameworks */ = {isa = PBXBuildFile; productRef = A53933ECCEA4440495B0FCB3 /* PulsumData */; };
		945EC8A02E8AD321001CCF2E /* PulsumServices in Frameworks */ = {isa = PBXBuildFile; productRef = 789E650BC257425BBE5CEDCB /* PulsumServices */; };
		945EC8A12E8AD321001CCF2E /* PulsumML in Frameworks */ = {isa = PBXBuildFile; productRef = 0F767ADA6BE24721A5249B90 /* PulsumML */; };
		94BC8DDA2F26A8540043ADE0 /* PulsumTypes in Frameworks */ = {isa = PBXBuildFile; productRef = E2F3A4B5C6D7E8090A1B2C3D /* PulsumTypes */; };
		F3A4B5C6D7E8090A1B2C3D4E /* PulsumTypes in Frameworks */ = {isa = PBXBuildFile; productRef = E2F3A4B5C6D7E8090A1B2C3D /* PulsumTypes */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		941192932E8A01FF0078B278 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 941192782E8A01FF0078B278 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 9411927F2E8A01FF0078B278;
			remoteInfo = Pulsum;
		};
		9411929D2E8A01FF0078B278 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 941192782E8A01FF0078B278 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 9411927F2E8A01FF0078B278;
			remoteInfo = Pulsum;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXFileReference section */
		163A3F3C451B4A0D810BEBDC /* PrivacyInfo.xcprivacy */ = {isa = PBXFileReference; lastKnownFileType = text.xml; name = PrivacyInfo.xcprivacy; path = Pulsum/PrivacyInfo.xcprivacy; sourceTree = SOURCE_ROOT; };
		941192802E8A01FF0078B278 /* Pulsum.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Pulsum.app; sourceTree = BUILT_PRODUCTS_DIR; };
		941192922E8A01FF0078B278 /* PulsumTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = PulsumTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		9411929C2E8A01FF0078B278 /* PulsumUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = PulsumUITests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		94293E5F2E8CD700003E5840 /* streak_low_poly_copy.splineswift */ = {isa = PBXFileReference; lastKnownFileType = file; path = streak_low_poly_copy.splineswift; sourceTree = "<group>"; };
		9429413C2E8E32C7003E5840 /* podcastrecommendations 2.json */ = {isa = PBXFileReference; lastKnownFileType = text.json; path = "podcastrecommendations 2.json"; sourceTree = "<group>"; };
		PULSUM_CONFIG_XCCONFIG /* Config.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Config.xcconfig; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedBuildFileExceptionSet section */
		94ED5A1B2EC11F86000D7A2E /* Exceptions for "Pulsum" folder in "Pulsum" target */ = {
			isa = PBXFileSystemSynchronizedBuildFileExceptionSet;
			membershipExceptions = (
				PrivacyInfo.xcprivacy,
			);
			target = 9411927F2E8A01FF0078B278 /* Pulsum */;
		};
/* End PBXFileSystemSynchronizedBuildFileExceptionSet section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		941192822E8A01FF0078B278 /* Pulsum */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			exceptions = (
				94ED5A1B2EC11F86000D7A2E /* Exceptions for "Pulsum" folder in "Pulsum" target */,
			);
			path = Pulsum;
			sourceTree = "<group>";
		};
		941192952E8A01FF0078B278 /* PulsumTests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = PulsumTests;
			sourceTree = "<group>";
		};
		9411929F2E8A01FF0078B278 /* PulsumUITests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = PulsumUITests;
			sourceTree = "<group>";
		};
		9A7E0B7E2F7C4B2F00A1B2C3 /* Packages/PulsumUI/Tests/PulsumUITests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = Packages/PulsumUI/Tests/PulsumUITests;
			sourceTree = "<group>";
		};
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		9411927D2E8A01FF0078B278 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				94BC8DDA2F26A8540043ADE0 /* PulsumTypes in Frameworks */,
				945EC8962E8AD321001CCF2E /* PulsumML in Frameworks */,
				945EC8952E8AD321001CCF2E /* PulsumServices in Frameworks */,
				945EC8942E8AD321001CCF2E /* PulsumData in Frameworks */,
				945EC8932E8AD321001CCF2E /* PulsumAgents in Frameworks */,
				945EC8922E8AD321001CCF2E /* PulsumUI in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		9411928F2E8A01FF0078B278 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				945EC89B2E8AD321001CCF2E /* PulsumServices in Frameworks */,
				945EC8992E8AD321001CCF2E /* PulsumAgents in Frameworks */,
				945EC8982E8AD321001CCF2E /* PulsumUI in Frameworks */,
				945EC89C2E8AD321001CCF2E /* PulsumML in Frameworks */,
				945EC89A2E8AD321001CCF2E /* PulsumData in Frameworks */,
				F3A4B5C6D7E8090A1B2C3D4E /* PulsumTypes in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		941192992E8A01FF0078B278 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				945EC8A02E8AD321001CCF2E /* PulsumServices in Frameworks */,
				945EC89E2E8AD321001CCF2E /* PulsumAgents in Frameworks */,
				945EC89D2E8AD321001CCF2E /* PulsumUI in Frameworks */,
				945EC8A12E8AD321001CCF2E /* PulsumML in Frameworks */,
				945EC89F2E8AD321001CCF2E /* PulsumData in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		941192772E8A01FF0078B278 = {
			isa = PBXGroup;
			children = (
				9429413C2E8E32C7003E5840 /* podcastrecommendations 2.json */,
				941192822E8A01FF0078B278 /* Pulsum */,
				941192952E8A01FF0078B278 /* PulsumTests */,
				9411929F2E8A01FF0078B278 /* PulsumUITests */,
				941192812E8A01FF0078B278 /* Products */,
				94293E5F2E8CD700003E5840 /* streak_low_poly_copy.splineswift */,
				9474366B2EA5CDF00042A3D9 /* Recovered References */,
			);
			sourceTree = "<group>";
		};
		941192812E8A01FF0078B278 /* Products */ = {
			isa = PBXGroup;
			children = (
				941192802E8A01FF0078B278 /* Pulsum.app */,
				941192922E8A01FF0078B278 /* PulsumTests.xctest */,
				9411929C2E8A01FF0078B278 /* PulsumUITests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		9474366B2EA5CDF00042A3D9 /* Recovered References */ = {
			isa = PBXGroup;
			children = (
				PULSUM_CONFIG_XCCONFIG /* Config.xcconfig */,
				163A3F3C451B4A0D810BEBDC /* PrivacyInfo.xcprivacy */,
				9A7E0B7E2F7C4B2F00A1B2C3 /* Packages/PulsumUI/Tests/PulsumUITests */,
			);
			name = "Recovered References";
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		9411927F2E8A01FF0078B278 /* Pulsum */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 941192A62E8A01FF0078B278 /* Build configuration list for PBXNativeTarget "Pulsum" */;
			buildPhases = (
				9411927C2E8A01FF0078B278 /* Sources */,
				9411927D2E8A01FF0078B278 /* Frameworks */,
				9411927E2E8A01FF0078B278 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				941192822E8A01FF0078B278 /* Pulsum */,
			);
			name = Pulsum;
			packageProductDependencies = (
				C9EBA0CEFE7A4C389A2E4FB8 /* PulsumUI */,
				A95AA2EDA6C84DD4AFB06BA9 /* PulsumAgents */,
				A53933ECCEA4440495B0FCB3 /* PulsumData */,
				789E650BC257425BBE5CEDCB /* PulsumServices */,
				0F767ADA6BE24721A5249B90 /* PulsumML */,
				E2F3A4B5C6D7E8090A1B2C3D /* PulsumTypes */,
			);
			productName = Pulsum;
			productReference = 941192802E8A01FF0078B278 /* Pulsum.app */;
			productType = "com.apple.product-type.application";
		};
		941192912E8A01FF0078B278 /* PulsumTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 941192A92E8A01FF0078B278 /* Build configuration list for PBXNativeTarget "PulsumTests" */;
			buildPhases = (
				9411928E2E8A01FF0078B278 /* Sources */,
				9411928F2E8A01FF0078B278 /* Frameworks */,
				941192902E8A01FF0078B278 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				941192942E8A01FF0078B278 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				941192952E8A01FF0078B278 /* PulsumTests */,
				9A7E0B7E2F7C4B2F00A1B2C3 /* Packages/PulsumUI/Tests/PulsumUITests */,
			);
			name = PulsumTests;
			packageProductDependencies = (
				C9EBA0CEFE7A4C389A2E4FB8 /* PulsumUI */,
				A95AA2EDA6C84DD4AFB06BA9 /* PulsumAgents */,
				A53933ECCEA4440495B0FCB3 /* PulsumData */,
				789E650BC257425BBE5CEDCB /* PulsumServices */,
				0F767ADA6BE24721A5249B90 /* PulsumML */,
			);
			productName = PulsumTests;
			productReference = 941192922E8A01FF0078B278 /* PulsumTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		9411929B2E8A01FF0078B278 /* PulsumUITests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 941192AC2E8A01FF0078B278 /* Build configuration list for PBXNativeTarget "PulsumUITests" */;
			buildPhases = (
				941192982E8A01FF0078B278 /* Sources */,
				941192992E8A01FF0078B278 /* Frameworks */,
				9411929A2E8A01FF0078B278 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				9411929E2E8A01FF0078B278 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				9411929F2E8A01FF0078B278 /* PulsumUITests */,
			);
			name = PulsumUITests;
			packageProductDependencies = (
				C9EBA0CEFE7A4C389A2E4FB8 /* PulsumUI */,
				A95AA2EDA6C84DD4AFB06BA9 /* PulsumAgents */,
				A53933ECCEA4440495B0FCB3 /* PulsumData */,
				789E650BC257425BBE5CEDCB /* PulsumServices */,
				0F767ADA6BE24721A5249B90 /* PulsumML */,
			);
			productName = PulsumUITests;
			productReference = 9411929C2E8A01FF0078B278 /* PulsumUITests.xctest */;
			productType = "com.apple.product-type.bundle.ui-testing";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		941192782E8A01FF0078B278 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 2600;
				LastUpgradeCheck = 2600;
				TargetAttributes = {
					9411927F2E8A01FF0078B278 = {
						CreatedOnToolsVersion = 26.0;
					};
					941192912E8A01FF0078B278 = {
						CreatedOnToolsVersion = 26.0;
						TestTargetID = 9411927F2E8A01FF0078B278;
					};
					9411929B2E8A01FF0078B278 = {
						CreatedOnToolsVersion = 26.0;
						TestTargetID = 9411927F2E8A01FF0078B278;
					};
				};
			};
			buildConfigurationList = 9411927B2E8A01FF0078B278 /* Build configuration list for PBXProject "Pulsum" */;
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 941192772E8A01FF0078B278;
			minimizedProjectReferenceProxies = 1;
			packageReferences = (
				34D4537F967F427A8CC60E41 /* XCLocalSwiftPackageReference "Packages/PulsumUI" */,
				A6D66678B3C7485B9B4C18C2 /* XCLocalSwiftPackageReference "Packages/PulsumAgents" */,
				8B350B6393B14442A408462B /* XCLocalSwiftPackageReference "Packages/PulsumData" */,
				AC96D4BBAB3448A2A2619700 /* XCLocalSwiftPackageReference "Packages/PulsumServices" */,
				300FFDA27B1942B2BBA23181 /* XCLocalSwiftPackageReference "Packages/PulsumML" */,
				D1A2B3C4D5E6F70809101112 /* XCLocalSwiftPackageReference "Packages/PulsumTypes" */,
				94BC8E002F26AFC90043ADE0 /* XCRemoteSwiftPackageReference "spline-ios" */,
			);
			preferredProjectObjectVersion = 77;
			productRefGroup = 941192812E8A01FF0078B278 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				9411927F2E8A01FF0078B278 /* Pulsum */,
				941192912E8A01FF0078B278 /* PulsumTests */,
				9411929B2E8A01FF0078B278 /* PulsumUITests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		9411927E2E8A01FF0078B278 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				910D1C8BDF7B4BE0A79330B5 /* PrivacyInfo.xcprivacy in Resources */,
				9429413D2E8E32C7003E5840 /* podcastrecommendations 2.json in Resources */,
				94293E602E8CD700003E5840 /* streak_low_poly_copy.splineswift in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		941192902E8A01FF0078B278 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		9411929A2E8A01FF0078B278 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		9411927C2E8A01FF0078B278 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		9411928E2E8A01FF0078B278 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		941192982E8A01FF0078B278 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		941192942E8A01FF0078B278 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 9411927F2E8A01FF0078B278 /* Pulsum */;
			targetProxy = 941192932E8A01FF0078B278 /* PBXContainerItemProxy */;
		};
		9411929E2E8A01FF0078B278 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 9411927F2E8A01FF0078B278 /* Pulsum */;
			targetProxy = 9411929D2E8A01FF0078B278 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin XCBuildConfiguration section */
		941192A42E8A01FF0078B278 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEVELOPMENT_TEAM = X6FJFZCXY3;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 26.0;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		941192A52E8A01FF0078B278 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				DEVELOPMENT_TEAM = X6FJFZCXY3;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 26.0;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		941192A72E8A01FF0078B278 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = PULSUM_CONFIG_XCCONFIG /* Config.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = Pulsum/Pulsum.entitlements;
				CODE_SIGN_IDENTITY = "Apple Development";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = X6FJFZCXY3;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_ITSAppUsesNonExemptEncryption = NO;
				INFOPLIST_KEY_NSHealthShareUsageDescription = "Pulsum reads key wellness metrics like HRV and sleep to personalize your coaching.";
				INFOPLIST_KEY_NSHealthUpdateUsageDescription = "Pulsum references your recent trends to surface the most helpful guidance.";
				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Pulsum uses the microphone to capture on-device voice journals.";
				INFOPLIST_KEY_NSSpeechRecognitionUsageDescription = "Pulsum transcribes your voice journals on-device to keep coaching relevant.";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = ai.pulsum.Pulsum;
				PRODUCT_NAME = "$(TARGET_NAME)";
				PROVISIONING_PROFILE_SPECIFIER = "";
				STRING_CATALOG_GENERATE_SYMBOLS = YES;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_DEFAULT_ACTOR_ISOLATION = MainActor;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		941192A82E8A01FF0078B278 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = PULSUM_CONFIG_XCCONFIG /* Config.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = Pulsum/Pulsum.entitlements;
				CODE_SIGN_IDENTITY = "Apple Development";
				CODE_SIGN_STYLE = Automatic;
				COPY_PHASE_STRIP = YES;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = X6FJFZCXY3;
				DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT = NO;
				ENABLE_BITCODE = NO;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_ITSAppUsesNonExemptEncryption = NO;
				INFOPLIST_KEY_NSHealthShareUsageDescription = "Pulsum reads key wellness metrics like HRV and sleep to personalize your coaching.";
				INFOPLIST_KEY_NSHealthUpdateUsageDescription = "Pulsum references your recent trends to surface the most helpful guidance.";
				INFOPLIST_KEY_NSMicrophoneUsageDescription = "Pulsum uses the microphone to capture on-device voice journals.";
				INFOPLIST_KEY_NSSpeechRecognitionUsageDescription = "Pulsum transcribes your voice journals on-device to keep coaching relevant.";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				OTHER_SWIFT_FLAGS = "$(inherited) -DRELEASE_LOG_AUDIT";
				PRODUCT_BUNDLE_IDENTIFIER = ai.pulsum.Pulsum;
				PRODUCT_NAME = "$(TARGET_NAME)";
				PROVISIONING_PROFILE_SPECIFIER = "";
				STRING_CATALOG_GENERATE_SYMBOLS = YES;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_DEFAULT_ACTOR_ISOLATION = MainActor;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
		941192AA2E8A01FF0078B278 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGNING_ALLOWED = NO;
				CODE_SIGNING_REQUIRED = NO;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = X6FJFZCXY3;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 26.0;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = ai.pulsum.PulsumTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				STRING_CATALOG_GENERATE_SYMBOLS = NO;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Pulsum.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Pulsum";
			};
			name = Debug;
		};
		941192AB2E8A01FF0078B278 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = X6FJFZCXY3;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 26.0;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = ai.pulsum.PulsumTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				STRING_CATALOG_GENERATE_SYMBOLS = NO;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Pulsum.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Pulsum";
			};
			name = Release;
		};
		941192AD2E8A01FF0078B278 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGNING_ALLOWED = NO;
				CODE_SIGNING_REQUIRED = NO;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = X6FJFZCXY3;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				OTHER_SWIFT_FLAGS = "$(inherited) -D PULSUM_UITESTS";
				PRODUCT_BUNDLE_IDENTIFIER = ai.pulsum.PulsumUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				STRING_CATALOG_GENERATE_SYMBOLS = NO;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_TARGET_NAME = Pulsum;
			};
			name = Debug;
		};
		941192AE2E8A01FF0078B278 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = X6FJFZCXY3;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				OTHER_SWIFT_FLAGS = "$(inherited) -D PULSUM_UITESTS";
				PRODUCT_BUNDLE_IDENTIFIER = ai.pulsum.PulsumUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				STRING_CATALOG_GENERATE_SYMBOLS = NO;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_TARGET_NAME = Pulsum;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		9411927B2E8A01FF0078B278 /* Build configuration list for PBXProject "Pulsum" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				941192A42E8A01FF0078B278 /* Debug */,
				941192A52E8A01FF0078B278 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		941192A62E8A01FF0078B278 /* Build configuration list for PBXNativeTarget "Pulsum" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				941192A72E8A01FF0078B278 /* Debug */,
				941192A82E8A01FF0078B278 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		941192A92E8A01FF0078B278 /* Build configuration list for PBXNativeTarget "PulsumTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				941192AA2E8A01FF0078B278 /* Debug */,
				941192AB2E8A01FF0078B278 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		941192AC2E8A01FF0078B278 /* Build configuration list for PBXNativeTarget "PulsumUITests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				941192AD2E8A01FF0078B278 /* Debug */,
				941192AE2E8A01FF0078B278 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */

/* Begin XCLocalSwiftPackageReference section */
		300FFDA27B1942B2BBA23181 /* XCLocalSwiftPackageReference "Packages/PulsumML" */ = {
			isa = XCLocalSwiftPackageReference;
			relativePath = Packages/PulsumML;
		};
		34D4537F967F427A8CC60E41 /* XCLocalSwiftPackageReference "Packages/PulsumUI" */ = {
			isa = XCLocalSwiftPackageReference;
			relativePath = Packages/PulsumUI;
		};
		8B350B6393B14442A408462B /* XCLocalSwiftPackageReference "Packages/PulsumData" */ = {
			isa = XCLocalSwiftPackageReference;
			relativePath = Packages/PulsumData;
		};
		A6D66678B3C7485B9B4C18C2 /* XCLocalSwiftPackageReference "Packages/PulsumAgents" */ = {
			isa = XCLocalSwiftPackageReference;
			relativePath = Packages/PulsumAgents;
		};
		AC96D4BBAB3448A2A2619700 /* XCLocalSwiftPackageReference "Packages/PulsumServices" */ = {
			isa = XCLocalSwiftPackageReference;
			relativePath = Packages/PulsumServices;
		};
		D1A2B3C4D5E6F70809101112 /* XCLocalSwiftPackageReference "Packages/PulsumTypes" */ = {
			isa = XCLocalSwiftPackageReference;
			relativePath = Packages/PulsumTypes;
		};
/* End XCLocalSwiftPackageReference section */

/* Begin XCRemoteSwiftPackageReference section */
		94BC8E002F26AFC90043ADE0 /* XCRemoteSwiftPackageReference "spline-ios" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/splinetool/spline-ios";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 0.2.48;
			};
		};
/* End XCRemoteSwiftPackageReference section */

/* Begin XCSwiftPackageProductDependency section */
		0F767ADA6BE24721A5249B90 /* PulsumML */ = {
			isa = XCSwiftPackageProductDependency;
			package = 300FFDA27B1942B2BBA23181 /* XCLocalSwiftPackageReference "Packages/PulsumML" */;
			productName = PulsumML;
		};
		789E650BC257425BBE5CEDCB /* PulsumServices */ = {
			isa = XCSwiftPackageProductDependency;
			package = AC96D4BBAB3448A2A2619700 /* XCLocalSwiftPackageReference "Packages/PulsumServices" */;
			productName = PulsumServices;
		};
		A53933ECCEA4440495B0FCB3 /* PulsumData */ = {
			isa = XCSwiftPackageProductDependency;
			package = 8B350B6393B14442A408462B /* XCLocalSwiftPackageReference "Packages/PulsumData" */;
			productName = PulsumData;
		};
		A95AA2EDA6C84DD4AFB06BA9 /* PulsumAgents */ = {
			isa = XCSwiftPackageProductDependency;
			package = A6D66678B3C7485B9B4C18C2 /* XCLocalSwiftPackageReference "Packages/PulsumAgents" */;
			productName = PulsumAgents;
		};
		C9EBA0CEFE7A4C389A2E4FB8 /* PulsumUI */ = {
			isa = XCSwiftPackageProductDependency;
			package = 34D4537F967F427A8CC60E41 /* XCLocalSwiftPackageReference "Packages/PulsumUI" */;
			productName = PulsumUI;
		};
		E2F3A4B5C6D7E8090A1B2C3D /* PulsumTypes */ = {
			isa = XCSwiftPackageProductDependency;
			package = D1A2B3C4D5E6F70809101112 /* XCLocalSwiftPackageReference "Packages/PulsumTypes" */;
			productName = PulsumTypes;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = 941192782E8A01FF0078B278 /* Project object */;
}
```
<!-- END_FILE: Pulsum.xcodeproj/project.pbxproj -->

### Pulsum.xcodeproj/project.xcworkspace/contents.xcworkspacedata
- bytes: 135
- lines: 7
- sha256: 7f3b00b5c3fdb45242d7b87e1e5c4e25d1fa8129a16c94295ecc4e8ea2235c5f
- trailing_newline: true

<!-- BEGIN_FILE: Pulsum.xcodeproj/project.xcworkspace/contents.xcworkspacedata -->
```text
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>
```
<!-- END_FILE: Pulsum.xcodeproj/project.xcworkspace/contents.xcworkspacedata -->

### Pulsum.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved
- bytes: 389
- lines: 15
- sha256: a7848d1ef8ea143fe0cd5e1e320a357226c0764a47eddfacafd56364bd565b44
- trailing_newline: true

<!-- BEGIN_FILE: Pulsum.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved -->
```text
{
  "originHash" : "a58160c7002dd52a4fb9dcd31ec0b0d771321ae796dbc509dbd76bdc78344c8e",
  "pins" : [
    {
      "identity" : "spline-ios",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/splinetool/spline-ios",
      "state" : {
        "revision" : "977bdfd566d6f13934ae9ecdb7b0a702a65f08ec",
        "version" : "0.2.48"
      }
    }
  ],
  "version" : 3
}
```
<!-- END_FILE: Pulsum.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved -->

### Pulsum.xcodeproj/xcshareddata/xcschemes/Pulsum.xcscheme
- bytes: 6236
- lines: 163
- sha256: 9f651a6bed8b1d7ffb97f157588dbd92c60d578f8f99fe5d7d702433c7b3757b
- trailing_newline: true

<!-- BEGIN_FILE: Pulsum.xcodeproj/xcshareddata/xcschemes/Pulsum.xcscheme -->
```text
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "2600"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "9411927F2E8A01FF0078B278"
               BuildableName = "Pulsum.app"
               BlueprintName = "Pulsum"
               ReferencedContainer = "container:Pulsum.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
      <EnvironmentVariables>
         <EnvironmentVariable
            key = "UITEST_USE_STUB_LLM"
            value = "1"
            isEnabled = "YES">
         </EnvironmentVariable>
         <EnvironmentVariable
            key = "UITEST_FAKE_SPEECH"
            value = "1"
            isEnabled = "YES">
         </EnvironmentVariable>
         <EnvironmentVariable
            key = "UITEST_AUTOGRANT"
            value = "1"
            isEnabled = "YES">
         </EnvironmentVariable>
      </EnvironmentVariables>
      <Testables>
         <TestableReference
            skipped = "YES"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "941192912E8A01FF0078B278"
               BuildableName = "PulsumTests.xctest"
               BlueprintName = "PulsumTests"
               ReferencedContainer = "container:Pulsum.xcodeproj">
            </BuildableReference>
         </TestableReference>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "9411929B2E8A01FF0078B278"
               BuildableName = "PulsumUITests.xctest"
               BlueprintName = "PulsumUITests"
               ReferencedContainer = "container:Pulsum.xcodeproj">
            </BuildableReference>
         </TestableReference>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "PulsumAgentsTests"
               BuildableName = "PulsumAgentsTests.xctest"
               BlueprintName = "PulsumAgentsTests"
               ReferencedContainer = "container:Packages/PulsumAgents">
            </BuildableReference>
         </TestableReference>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "PulsumServicesTests"
               BuildableName = "PulsumServicesTests.xctest"
               BlueprintName = "PulsumServicesTests"
               ReferencedContainer = "container:Packages/PulsumServices">
            </BuildableReference>
         </TestableReference>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "PulsumDataTests"
               BuildableName = "PulsumDataTests.xctest"
               BlueprintName = "PulsumDataTests"
               ReferencedContainer = "container:Packages/PulsumData">
            </BuildableReference>
         </TestableReference>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "PulsumMLTests"
               BuildableName = "PulsumMLTests.xctest"
               BlueprintName = "PulsumMLTests"
               ReferencedContainer = "container:Packages/PulsumML">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "9411927F2E8A01FF0078B278"
            BuildableName = "Pulsum.app"
            BlueprintName = "Pulsum"
            ReferencedContainer = "container:Pulsum.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "9411927F2E8A01FF0078B278"
            BuildableName = "Pulsum.app"
            BlueprintName = "Pulsum"
            ReferencedContainer = "container:Pulsum.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
```
<!-- END_FILE: Pulsum.xcodeproj/xcshareddata/xcschemes/Pulsum.xcscheme -->

### Pulsum.xcodeproj/xcshareddata/xcschemes/PulsumUI.xcscheme
- bytes: 3254
- lines: 89
- sha256: 06ce7082ff8644fc2f8b8767ff0e9d8899172565336682c3bad6a03c61d9b033
- trailing_newline: true

<!-- BEGIN_FILE: Pulsum.xcodeproj/xcshareddata/xcschemes/PulsumUI.xcscheme -->
```text
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "2600"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "NO"
            buildForArchiving = "NO"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "9411927F2E8A01FF0078B278"
               BuildableName = "Pulsum.app"
               BlueprintName = "Pulsum"
               ReferencedContainer = "container:Pulsum.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "NO">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "941192912E8A01FF0078B278"
               BuildableName = "PulsumTests.xctest"
               BlueprintName = "PulsumTests"
               ReferencedContainer = "container:Pulsum.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "9411927F2E8A01FF0078B278"
            BuildableName = "Pulsum.app"
            BlueprintName = "Pulsum"
            ReferencedContainer = "container:Pulsum.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "9411927F2E8A01FF0078B278"
            BuildableName = "Pulsum.app"
            BlueprintName = "Pulsum"
            ReferencedContainer = "container:Pulsum.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
```
<!-- END_FILE: Pulsum.xcodeproj/xcshareddata/xcschemes/PulsumUI.xcscheme -->

### Pulsum.xcodeproj/xcuserdata/martin.demel.xcuserdatad/xcschemes/xcschememanagement.plist
- bytes: 780
- lines: 37
- sha256: 6c4e94a784e358121076a4a10776f73c999cf9db7991a0383488faddc8d4d49a
- trailing_newline: true

<!-- BEGIN_FILE: Pulsum.xcodeproj/xcuserdata/martin.demel.xcuserdatad/xcschemes/xcschememanagement.plist -->
```text
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>Pulsum.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
		<key>PulsumUI.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>1</integer>
		</dict>
	</dict>
	<key>SuppressBuildableAutocreation</key>
	<dict>
		<key>9411927F2E8A01FF0078B278</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>941192912E8A01FF0078B278</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>9411929B2E8A01FF0078B278</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
	</dict>
</dict>
</plist>
```
<!-- END_FILE: Pulsum.xcodeproj/xcuserdata/martin.demel.xcuserdatad/xcschemes/xcschememanagement.plist -->

### Pulsum/Assets.xcassets/AccentColor.colorset/Contents.json
- bytes: 123
- lines: 11
- sha256: 9af65086fa30b49252fae1a1225731691de794f7775af74d71befeb507d12b7c
- trailing_newline: true

<!-- BEGIN_FILE: Pulsum/Assets.xcassets/AccentColor.colorset/Contents.json -->
```text
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
```
<!-- END_FILE: Pulsum/Assets.xcassets/AccentColor.colorset/Contents.json -->

### Pulsum/Assets.xcassets/AppIcon.appiconset/Contents.json
- bytes: 713
- lines: 38
- sha256: 98031466eb3dba8313b641e0195d5d40e48cb1c62f75024233205d8f5541530d
- trailing_newline: true

<!-- BEGIN_FILE: Pulsum/Assets.xcassets/AppIcon.appiconset/Contents.json -->
```text
{
  "images" : [
    {
      "filename" : "iconnew 2.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "filename" : "iconnew 1.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "filename" : "iconnew.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
```
<!-- END_FILE: Pulsum/Assets.xcassets/AppIcon.appiconset/Contents.json -->

### Pulsum/Assets.xcassets/Contents.json
- bytes: 63
- lines: 6
- sha256: 0fd49ba3c3585c709678e0046a821c3c60685ec7063720d30d3a3448be3a208b
- trailing_newline: true

<!-- BEGIN_FILE: Pulsum/Assets.xcassets/Contents.json -->
```text
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
```
<!-- END_FILE: Pulsum/Assets.xcassets/Contents.json -->

### Pulsum/Pulsum.entitlements
- bytes: 310
- lines: 10
- sha256: 3a0fe663304785c4f157a6a2dd599ff9c1abbd87138e73bb313b5141f3e27618
- trailing_newline: true

<!-- BEGIN_FILE: Pulsum/Pulsum.entitlements -->
```text
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.developer.healthkit</key>
	<true/>
	<key>com.apple.developer.healthkit.background-delivery</key>
	<true/>
</dict>
</plist>
```
<!-- END_FILE: Pulsum/Pulsum.entitlements -->

### Pulsum/PulsumApp.swift
- bytes: 671
- lines: 33
- sha256: 319bcf6b0555e6950c97ba34e3499196e77e45c9b66d665d61a6eb6effc96d8c
- trailing_newline: true

<!-- BEGIN_FILE: Pulsum/PulsumApp.swift -->
```swift
//
//  PulsumApp.swift
//  Pulsum
//
//  Created by Martin Demel on 9/28/25.
//

import SwiftUI
import PulsumUI
import PulsumTypes

@main
struct PulsumApp: App {
    init() {
#if canImport(UIKit)
        if AppRuntimeConfig.disableAnimations {
            UIView.setAnimationsEnabled(false)
        }
#endif
    }

    var body: some Scene {
        WindowGroup {
            PulsumRootView()
                .transaction { transaction in
                    if AppRuntimeConfig.disableAnimations {
                        transaction.disablesAnimations = true
                        transaction.animation = nil
                    }
                }
        }
    }
}
```
<!-- END_FILE: Pulsum/PulsumApp.swift -->

### PulsumTests/PulsumTests.swift
- bytes: 294
- lines: 17
- sha256: ff425d00e00d0177eb9adf347bb47c5f3e51fea00ab0c81e6b824b98d4c18ec9
- trailing_newline: true

<!-- BEGIN_FILE: PulsumTests/PulsumTests.swift -->
```swift
//
//  PulsumTests.swift
//  PulsumTests
//
//  Created by Martin Demel on 9/28/25.
//

import Testing
@testable import Pulsum

struct PulsumTests {

    @Test func example() async throws {
        // Write your test here and use APIs like `#expect(...)` to check expected conditions.
    }

}
```
<!-- END_FILE: PulsumTests/PulsumTests.swift -->

### PulsumUITests/FirstRunPermissionsUITests.swift
- bytes: 377
- lines: 13
- sha256: d41560e3b75825aa75fa20c679183fe68cd685fbe3fea86b60033222e9bc762c
- trailing_newline: true

<!-- BEGIN_FILE: PulsumUITests/FirstRunPermissionsUITests.swift -->
```swift
import XCTest

final class FirstRunPermissionsUITests: PulsumUITestCase {
    func testFirstRun_authorizeSpeechAndMic() throws {
        launchPulsum()
        try openPulseSheetOrSkip()
        startVoiceJournal()

        XCTAssertTrue(app.buttons["VoiceJournalStopButton"].exists, "Stop control should be visible once recording begins.")

        stopVoiceJournal()
    }
}
```
<!-- END_FILE: PulsumUITests/FirstRunPermissionsUITests.swift -->

### PulsumUITests/Gate3_HealthAccessUITests.swift
- bytes: 3511
- lines: 85
- sha256: 90566f99ef7a2ae9ab9790d4fcd5216a60fcb05b692f9f57bdbf1811db06d3bd
- trailing_newline: true

<!-- BEGIN_FILE: PulsumUITests/Gate3_HealthAccessUITests.swift -->
```swift
import XCTest

private let partialHealthAccessOverride = [
    "HKQuantityTypeIdentifierHeartRateVariabilitySDNN=authorized",
    "HKQuantityTypeIdentifierHeartRate=authorized",
    "HKQuantityTypeIdentifierRestingHeartRate=authorized",
    "HKQuantityTypeIdentifierRespiratoryRate=authorized",
    "HKQuantityTypeIdentifierStepCount=authorized",
    "HKCategoryTypeIdentifierSleepAnalysis=denied"
].joined(separator: ",")

final class Gate3_HealthAccessUITests: PulsumUITestCase {
    func testPartialHealthAccessStatusVisibleInSettings() {
        launchPulsum(additionalEnvironment: [
            "PULSUM_HEALTHKIT_STATUS_OVERRIDE": partialHealthAccessOverride
        ])
        guard openSettingsSheetOrSkip() else { return }

        let summary = app.staticTexts["HealthAccessSummaryLabel"]
        XCTAssertTrue(summary.waitForExistence(timeout: 5))
        XCTAssertTrue(summary.label.contains("5/6"), "Summary should reflect partial access.")

        let missing = app.staticTexts["HealthAccessMissingLabel"]
        XCTAssertTrue(missing.exists)
        XCTAssertTrue(missing.label.contains("Sleep"))

        dismissSettingsSheet()
    }

    func testRequestHealthAccessButtonGrantsAllTypes() {
        launchPulsum(additionalEnvironment: [
            "PULSUM_HEALTHKIT_STATUS_OVERRIDE": partialHealthAccessOverride,
            "PULSUM_HEALTHKIT_REQUEST_BEHAVIOR": "grantAll"
        ])
        guard openSettingsSheetOrSkip() else { return }

        let button = app.buttons["HealthAccessRequestButton"]
        XCTAssertTrue(button.exists)
        button.tap()

        let successToast = app.staticTexts["Health data connected"]
        let toastAppeared = successToast.waitForExistence(timeout: 5)
        XCTAssertTrue(toastAppeared, "Success toast should appear after access is granted.")

        let summary = app.staticTexts["HealthAccessSummaryLabel"]
        XCTAssertTrue(summary.waitForExistence(timeout: 5))
        XCTAssertTrue(summary.label.contains("6/6"), "Summary label after grant: \(summary.label)")

        if ProcessInfo.processInfo.environment["UITEST_CAPTURE_TREE"] == "1" {
            let summaryAttachment = XCTAttachment(string: "Summary after request: \(summary.label)")
            summaryAttachment.name = "HealthAccessSummaryDebug"
            summaryAttachment.lifetime = .keepAlways
            add(summaryAttachment)

            let treeAttachment = XCTAttachment(string: app.debugDescription)
            treeAttachment.name = "AppDebugTree"
            treeAttachment.lifetime = .keepAlways
            add(treeAttachment)
        }

        dismissSettingsSheet()
    }

    func testNoToastOnInitialFullyGranted() {
        let allGranted = [
            "HKQuantityTypeIdentifierHeartRateVariabilitySDNN=authorized",
            "HKQuantityTypeIdentifierHeartRate=authorized",
            "HKQuantityTypeIdentifierRestingHeartRate=authorized",
            "HKQuantityTypeIdentifierRespiratoryRate=authorized",
            "HKQuantityTypeIdentifierStepCount=authorized",
            "HKCategoryTypeIdentifierSleepAnalysis=authorized"
        ].joined(separator: ",")

        launchPulsum(additionalEnvironment: [
            "PULSUM_HEALTHKIT_STATUS_OVERRIDE": allGranted
        ])

        guard openSettingsSheetOrSkip() else { return }

        let successToast = app.staticTexts["Health data connected"]
        XCTAssertFalse(successToast.exists, "Toast must not appear on initial fully granted state.")

        dismissSettingsSheet()
    }
}
```
<!-- END_FILE: PulsumUITests/Gate3_HealthAccessUITests.swift -->

### PulsumUITests/Gate4_CloudConsentUITests.swift
- bytes: 2683
- lines: 64
- sha256: a8f40af7689341d8f74e49cf59f8ac1e7f9b9574a678846f1e39a1a68ee44f63
- trailing_newline: true

<!-- BEGIN_FILE: PulsumUITests/Gate4_CloudConsentUITests.swift -->
```swift
import XCTest

final class Gate4_CloudConsentUITests: PulsumUITestCase {
    func test_enter_key_and_test_connection_shows_ok_status() {
        launchPulsum()
        guard openSettingsSheetOrSkip() else { return }

        let secureKeyField = app.secureTextFields["CloudAPIKeyField"]
        let textKeyField = app.textFields["CloudAPIKeyField"]
        let keyField = secureKeyField.waitForExistence(timeout: 2) ? secureKeyField : textKeyField
        XCTAssertTrue(keyField.waitForExistence(timeout: 5), "Cloud API key field missing.")
        keyField.tapWhenHittable(timeout: 3)
        keyField.typeText("sk-test-ui-123")

        let saveButton = app.buttons["Save Key"]
        XCTAssertTrue(saveButton.waitForExistence(timeout: 3), "Save Key button missing.")
        saveButton.tapWhenHittable(timeout: 3)

        let testButton = app.buttons["CloudTestConnectionButton"]
        XCTAssertTrue(testButton.waitForExistence(timeout: 3), "Test Connection button missing.")
        testButton.tapWhenHittable(timeout: 3)

        let statusText = app.staticTexts["OpenAI reachable"]
        XCTAssertTrue(statusText.waitForExistence(timeout: 5), "API status did not report OpenAI reachable.")

        dismissSettingsSheet()
    }

    func test_open_ai_enablement_link_falls_back_to_support_url() {
        let defaults = UserDefaults(suiteName: "ai.pulsum.uiautomation")
        defaults?.removeObject(forKey: "LastOpenedURL")

        launchPulsum(additionalEnvironment: [
            "UITEST_CAPTURE_URLS": "1",
            "UITEST_FORCE_SETTINGS_FALLBACK": "1"
        ])
        guard openSettingsSheetOrSkip() else { return }

        let linkButton = app.buttons["AppleIntelligenceLinkButton"]
        XCTAssertTrue(linkButton.waitForExistence(timeout: 3))
        linkButton.tap()

        let expectation = XCTNSPredicateExpectation(predicate: NSPredicate { _, _ in
            let value = defaults?.string(forKey: "LastOpenedURL")
            return value == "https://support.apple.com/en-us/HT213969"
        }, object: nil)
        let result = XCTWaiter().wait(for: [expectation], timeout: 4)
        XCTAssertEqual(result, .completed, "Support URL was not opened.")

        dismissSettingsSheet()
    }

    func test_escape_key_dismisses_settings_if_supported() {
        launchPulsum()
        guard openSettingsSheetOrSkip() else { return }

        let closeButton = app.buttons["Close Settings"]
        XCTAssertTrue(closeButton.waitForExistence(timeout: 3))

        app.typeKey(XCUIKeyboardKey.escape, modifierFlags: [])

        XCTAssertTrue(closeButton.waitForDisappearance(timeout: 3), "Settings sheet did not dismiss after Escape key.")
    }
}
```
<!-- END_FILE: PulsumUITests/Gate4_CloudConsentUITests.swift -->

### PulsumUITests/JournalFlowUITests.swift
- bytes: 1622
- lines: 33
- sha256: ead6295b343969695cb7a05956390421153285a219b82ad6e32dd6e61770bc8b
- trailing_newline: true

<!-- BEGIN_FILE: PulsumUITests/JournalFlowUITests.swift -->
```swift
import XCTest

final class JournalFlowUITests: PulsumUITestCase {
    func testRecordStreamFinish_showsSavedToastAndTranscript() throws {
        launchPulsum()
        try openPulseSheetOrSkip()
        startVoiceJournal()

        let transcriptElement = waitForTranscriptText()
        let transcript = transcriptElement.label
        XCTAssertFalse(transcript.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty, "Transcript should stream text while recording.")
        XCTAssertTrue(transcript.contains("Energy feels steady"), "Stub speech should surface deterministic content.")

        stopVoiceJournal()
        XCTAssertTrue(app.staticTexts["Tap to record"].waitForExistence(timeout: 4), "Idle state should return after finishing.")

        let savedToast = app.staticTexts["VoiceJournalSavedToast"]
        XCTAssertTrue(savedToast.waitForExistence(timeout: 3), "Saved toast should appear after finishing.")
        XCTAssertTrue(app.staticTexts["VoiceJournalTranscriptText"].exists, "Transcript should remain visible after analysis.")
        XCTAssertTrue(savedToast.waitForDisappearance(timeout: 4), "Saved toast should dismiss automatically.")
    }

    func testSecondStartIsGuarded_noDuplicateSession() throws {
        launchPulsum()
        try openPulseSheetOrSkip()
        startVoiceJournal()

        XCTAssertFalse(app.buttons["VoiceJournalStartButton"].exists, "Start button should not be visible while recording.")

        stopVoiceJournal()
        XCTAssertTrue(app.buttons["VoiceJournalStartButton"].waitForExistence(timeout: 4), "Start control should return after stopping.")
    }
}
```
<!-- END_FILE: PulsumUITests/JournalFlowUITests.swift -->

### PulsumUITests/PulsumUITestCase.swift
- bytes: 8479
- lines: 233
- sha256: df73604121d1c10563f6750f9d6f36744b7797f50f37a268cfaf7c86e97e0511
- trailing_newline: true

<!-- BEGIN_FILE: PulsumUITests/PulsumUITestCase.swift -->
```swift
import XCTest
import Foundation

class PulsumUITestCase: XCTestCase {
    var app: XCUIApplication!

    private let defaultEnvironment: [String: String] = [
        "UITEST": "1",
        "UITEST_USE_STUB_LLM": "1",
        "UITEST_DISABLE_CLOUD_KEYCHAIN": "1",
        "UITEST_FAKE_SPEECH": "1",
        "UITEST_AUTOGRANT": "1",
        "UITEST_HIDE_CONSENT_BANNER": "1",
        "UITEST_SETTINGS_HOOK": "1",
        "PULSUM_COACH_API_KEY": "test_key"
    ]

    override func setUpWithError() throws {
        try super.setUpWithError()
        continueAfterFailure = false

        registerInterruptionMonitors()
    }

    override func tearDownWithError() throws {
        app?.terminate()
        app = nil
        try super.tearDownWithError()
    }

    func launchPulsum(additionalEnvironment: [String: String] = [:]) {
        app = XCUIApplication()
        app.launchArguments.append("-ui_testing")
        var merged = defaultEnvironment
        additionalEnvironment.forEach { merged[$0.key] = $0.value }
        merged.forEach { key, value in
            app.launchEnvironment[key] = value
        }
        app.launch()
        triggerInterruptionHandlers()
        waitForHome()
    }

    func waitForHome(timeout: TimeInterval = 15) {
        let pulseButton = app.buttons["PulseButton"]
        XCTAssertTrue(pulseButton.waitForExistence(timeout: timeout), "Pulse entry point did not appear.")
        XCTAssertTrue(pulseButton.waitForHittable(timeout: timeout), "Pulse entry point is not hittable.")
    }

    func openPulseSheetOrSkip() throws {
        let pulseButton = app.buttons["PulseButton"]
        XCTAssertTrue(pulseButton.waitForExistence(timeout: 8), "Pulse button missing.")
        pulseButton.tapWhenHittable(timeout: 6)
        let sheetMarker = app.staticTexts["Voice journal"]
        if !sheetMarker.waitForExistence(timeout: 6) {
            pulseButton.tapWhenHittable(timeout: 6)
        }
        guard app.staticTexts["Voice journal"].waitForExistence(timeout: 6) else {
            throw XCTSkip("Pulse sheet did not open.")
        }
    }

    func startVoiceJournal() {
        let startButton = app.buttons["VoiceJournalStartButton"]
        XCTAssertTrue(startButton.waitForExistence(timeout: 4), "Voice journal start button missing.")
        startButton.tapWhenHittable(timeout: 3)
        triggerInterruptionHandlers()
        XCTAssertTrue(app.buttons["VoiceJournalStopButton"].waitForExistence(timeout: 4), "Recording UI did not activate.")
    }

    func stopVoiceJournal() {
        let stopButton = app.buttons["VoiceJournalStopButton"]
        if stopButton.exists {
            stopButton.tap()
        }
    }

    @discardableResult
    func waitForTranscriptText(timeout: TimeInterval = 5) -> XCUIElement {
        let transcript = app.staticTexts["VoiceJournalTranscriptText"]
        XCTAssertTrue(transcript.waitForExistence(timeout: timeout), "Transcript did not appear.")
        return transcript
    }

    @discardableResult
    func openSettingsSheetOrSkip() -> Bool {
        let sheetMarker = app.otherElements["SettingsSheetRoot"]
        if sheetMarker.exists {
            return true
        }
        let settingsButtons = app.buttons.matching(identifier: "SettingsButton")
        let settingsButton = firstHittableElement(in: settingsButtons, timeout: 6)
        if let settingsButton {
            settingsButton.tapWhenHittable(timeout: 2)
        } else {
            let hookButton = firstHittableElement(in: app.buttons.matching(identifier: "SettingsTestHookButton"),
                                                  timeout: 2)
            hookButton?.tapWhenHittable(timeout: 2)
        }
        let sheet = app.sheets.firstMatch
        let opened = sheet.waitForExistence(timeout: 6) || sheetMarker.waitForExistence(timeout: 2)
        if !opened {
            settingsButton?.tapWhenHittable(timeout: 2)
        }
        if !sheet.exists && !sheetMarker.exists {
            let hookButton = firstHittableElement(in: app.buttons.matching(identifier: "SettingsTestHookButton"),
                                                  timeout: 2)
            hookButton?.tapWhenHittable(timeout: 2)
        }
        guard sheet.exists || sheetMarker.waitForExistence(timeout: 6) else {
            recordSettingsSheetFailure()
            XCTFail("Settings sheet did not open.")
            return false
        }
        return true
    }

    func dismissSettingsSheet() {
        let closeButton = app.buttons["Close Settings"]
        if closeButton.exists {
            closeButton.tap()
        } else {
            app.swipeDown()
        }
    }

    private func registerInterruptionMonitors() {
        addUIInterruptionMonitor(withDescription: "Speech and Microphone Permissions") { alert in
            guard Self.alertContainsPermissionText(alert) else { return false }
            return Self.tapAllowButton(in: alert)
        }

        addUIInterruptionMonitor(withDescription: "System Alerts") { alert in
            return Self.tapAllowButton(in: alert)
        }
    }

    private func triggerInterruptionHandlers(maxAttempts: Int = 3) {
        guard app != nil else { return }
        for _ in 0..<maxAttempts {
            if app.alerts.firstMatch.waitForExistence(timeout: 1) {
                app.tap()
            } else {
                break
            }
        }
    }

    private func recordSettingsSheetFailure() {
        let screenshot = XCTAttachment(screenshot: app.screenshot())
        screenshot.name = "SettingsSheetMissing"
        screenshot.lifetime = .keepAlways
        add(screenshot)

        let debugAttachment = XCTAttachment(string: app.debugDescription)
        debugAttachment.name = "SettingsSheetDebugDescription"
        debugAttachment.lifetime = .keepAlways
        add(debugAttachment)
    }

    private func firstHittableElement(in query: XCUIElementQuery,
                                      timeout: TimeInterval) -> XCUIElement? {
        let deadline = Date().addingTimeInterval(timeout)
        while Date() < deadline {
            let count = query.count
            if count > 0 {
                for index in 0..<count {
                    let element = query.element(boundBy: index)
                    if element.exists && element.isHittable {
                        return element
                    }
                }
            }
            RunLoop.current.run(until: Date().addingTimeInterval(0.1))
        }
        let fallback = query.firstMatch
        return fallback.exists ? fallback : nil
    }

    private static func tapAllowButton(in alert: XCUIElement) -> Bool {
        let positiveButtons = [
            "Allow",
            "OK",
            "Continue",
            "Allow While Using App",
            "Allow Once",
            "Always Allow"
        ]
        for label in positiveButtons {
            let button = alert.buttons[label]
            if button.exists {
                button.tap()
                return true
            }
        }
        return false
    }

    private static func alertContainsPermissionText(_ alert: XCUIElement) -> Bool {
        let keywords = ["microphone", "speech recognition", "speech", "dictation"]
        let alertText = ([alert.label] + alert.staticTexts.allElementsBoundByIndex.map { $0.label })
            .joined(separator: " ")
            .lowercased()
        return keywords.contains { alertText.contains($0) }
    }
}

extension XCUIElement {
    func waitForDisappearance(timeout: TimeInterval) -> Bool {
        let predicate = NSPredicate(format: "exists == false")
        let expectation = XCTNSPredicateExpectation(predicate: predicate, object: self)
        let result = XCTWaiter().wait(for: [expectation], timeout: timeout)
        return result == .completed
    }

    func waitForHittable(timeout: TimeInterval) -> Bool {
        let predicate = NSPredicate(format: "exists == true && hittable == true")
        let expectation = XCTNSPredicateExpectation(predicate: predicate, object: self)
        let result = XCTWaiter().wait(for: [expectation], timeout: timeout)
        return result == .completed
    }

    func tapWhenHittable(timeout: TimeInterval) {
        if waitForHittable(timeout: timeout) {
            tap()
            return
        }

        guard exists else { return }
        let coordinate = coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5))
        coordinate.tap()
    }
}
```
<!-- END_FILE: PulsumUITests/PulsumUITestCase.swift -->

### PulsumUITests/PulsumUITestsLaunchTests.swift
- bytes: 814
- lines: 33
- sha256: e9eb2ddd05dd7f31d5d230bbd7157e486733be81e019e0a55c047e4d54022e2e
- trailing_newline: true

<!-- BEGIN_FILE: PulsumUITests/PulsumUITestsLaunchTests.swift -->
```swift
//
//  PulsumUITestsLaunchTests.swift
//  PulsumUITests
//
//  Created by Martin Demel on 9/28/25.
//

import XCTest

final class PulsumUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
```
<!-- END_FILE: PulsumUITests/PulsumUITestsLaunchTests.swift -->

### PulsumUITests/SettingsAndCoachUITests.swift
- bytes: 5084
- lines: 148
- sha256: 68b0ccb7ff45bc6eb9de0b432ee4edf207325204f7f694ef0d88e8e3693b4b1e
- trailing_newline: true

<!-- BEGIN_FILE: PulsumUITests/SettingsAndCoachUITests.swift -->
```swift
import XCTest
import Foundation

final class SettingsAndCoachUITests: PulsumUITestCase {
    func testCoachChat_withStub_returnsGroundedReply() {
        launchPulsum()
        guard enableCloudConsentIfNeeded() else { return }

        let coachTab = app.tabBars.buttons["Coach"]
        XCTAssertTrue(coachTab.waitForExistence(timeout: 5), "Coach tab is unavailable.")
        coachTab.tap()

        let chatField = app.textFields["Ask Pulsum anything about your recovery"]
        XCTAssertTrue(chatField.waitForExistence(timeout: 5), "Chat input missing.")
        chatField.tap()
        chatField.typeText("How should I wind down after work?")

        let sendButton = app.buttons["CoachSendButton"]
        XCTAssertTrue(sendButton.exists, "Send button missing.")
        sendButton.tap()

        let stubReply = app.staticTexts["CoachAssistantMessage"]
        XCTAssertTrue(stubReply.waitForExistence(timeout: 8), "Stubbed reply did not render.")
        XCTAssertTrue(stubReply.label.contains("Stub response"), "Stubbed reply text missing.")
    }

    func testCloudConsentToggle_existsAndPersists() {
        launchPulsum()
        guard openSettingsSheetOrSkip() else { return }

        guard let toggle = findConsentToggle() else {
            XCTFail("Cloud consent toggle not present yet.")
            return
        }
        guard let initialValue = toggleValue(toggle) else {
            XCTFail("Consent toggle value unreadable.")
            return
        }
        tapConsentToggle(toggle)

        let expectedValue = !initialValue
        assertConsentValue(expectedValue, message: "Toggle did not change value.")

        dismissSettingsSheet()
        app.terminate()

        launchPulsum()
        guard openSettingsSheetOrSkip() else { return }

        guard findConsentToggle() != nil else {
            XCTFail("Consent toggle missing after relaunch.")
            return
        }
        assertConsentValue(expectedValue, message: "Consent state did not persist across launches.")
    }

    private func findConsentToggle(timeout: TimeInterval = 5) -> XCUIElement? {
        let toggle = app.switches["CloudConsentToggle"]
        if toggle.waitForExistence(timeout: timeout) {
            return toggle
        }
        let fallback = app.otherElements["CloudConsentToggle"]
        if fallback.waitForExistence(timeout: timeout) {
            return fallback
        }
        return nil
    }

    @discardableResult
    private func enableCloudConsentIfNeeded() -> Bool {
        guard openSettingsSheetOrSkip() else { return false }
        guard let toggle = findConsentToggle() else {
            XCTFail("Consent toggle not found.")
            return false
        }
        guard let currentValue = toggleValue(toggle) else {
            XCTFail("Consent toggle value unreadable.")
            dismissSettingsSheet()
            return false
        }
        if currentValue == false {
            tapConsentToggle(toggle)
        }
        dismissSettingsSheet()
        return true
    }

    private func toggleValue(_ toggle: XCUIElement) -> Bool? {
        if let raw = toggle.value as? String {
            switch raw.lowercased() {
            case "1", "on", "true":
                return true
            case "0", "off", "false":
                return false
            default:
                return nil
            }
        }
        if let number = toggle.value as? NSNumber {
            return number.boolValue
        }
        if let value = toggle.value as? Bool {
            return value
        }
        return nil
    }

    private func waitForConsentValue(_ expectedValue: Bool, timeout: TimeInterval) -> Bool {
        let deadline = Date().addingTimeInterval(timeout)
        while Date() < deadline {
            if let toggle = findConsentToggle(timeout: 0.2),
               let value = toggleValue(toggle),
               value == expectedValue {
                return true
            }
            RunLoop.current.run(until: Date().addingTimeInterval(0.1))
        }
        return false
    }

    private func tapConsentToggle(_ toggle: XCUIElement? = nil) {
        if let toggle = toggle ?? findConsentToggle(timeout: 2) {
            toggle.tapWhenHittable(timeout: 3)
            return
        }
        let label = app.staticTexts["Use GPT-5 phrasing"]
        if label.exists {
            label.tapWhenHittable(timeout: 3)
        }
    }

    private func assertConsentValue(_ expectedValue: Bool, message: String) {
        guard waitForConsentValue(expectedValue, timeout: 3) else {
            let screenshot = XCTAttachment(screenshot: app.screenshot())
            screenshot.name = "ConsentToggleFailure"
            screenshot.lifetime = .keepAlways
            add(screenshot)

            let debugAttachment = XCTAttachment(string: app.debugDescription)
            debugAttachment.name = "ConsentToggleDebugDescription"
            debugAttachment.lifetime = .keepAlways
            add(debugAttachment)

            XCTFail(message)
            return
        }
    }
}
```
<!-- END_FILE: PulsumUITests/SettingsAndCoachUITests.swift -->

### baseline 5_2/baseline_file_inventory_5_2.json
- bytes: 112809
- lines: 2553
- sha256: cd5b216c0abf7c3affddd362da0ca1d9ed0d2d34df9414d2d9221639cf738591
- trailing_newline: false

<!-- BEGIN_FILE: baseline 5_2/baseline_file_inventory_5_2.json -->
````text
{
  "root": "/Users/martin.demel/Desktop/PULSUM/Pulsum",
  "file_count": 269,
  "ext_counts": {
    "(no_ext)": 4,
    ".entitlements": 1,
    ".gif": 1,
    ".jpg": 1,
    ".json": 8,
    ".md": 39,
    ".mlmodel": 2,
    ".mom": 1,
    ".omo": 1,
    ".pbxproj": 1,
    ".pdf": 18,
    ".plist": 2,
    ".png": 8,
    ".resolved": 1,
    ".sh": 7,
    ".splineswift": 2,
    ".swift": 155,
    ".template": 1,
    ".txt": 1,
    ".usdz": 1,
    ".xcprivacy": 6,
    ".xcscheme": 1,
    ".xcworkspacedata": 1,
    ".yaml": 1,
    ".yml": 3,
    ".zlist": 1
  },
  "large_files": [
    {
      "path": "main.gif",
      "size": 21811312
    },
    {
      "path": "Docs/a-practical-guide-to-building-with-gpt-5.pdf",
      "size": 12010712
    },
    {
      "path": "a-practical-guide-to-building-agents.pdf",
      "size": 7335065
    },
    {
      "path": "ios support documents/Landmarks_ Building an app with Liquid Glass _ Apple Developer Documentation.pdf",
      "size": 7313354
    },
    {
      "path": "codex_inventory.json",
      "size": 5085530
    },
    {
      "path": "ios support documents/Adopting Liquid Glass _ Apple Developer Documentation.pdf",
      "size": 4863584
    },
    {
      "path": "ios support documents/Liquid Glass _ Apple Developer Documentation.pdf",
      "size": 4276716
    },
    {
      "path": "coverage_ledger.json",
      "size": 4256208
    },
    {
      "path": "ChatGPT for engineers - Resource _ OpenAI Academy.pdf",
      "size": 3977697
    },
    {
      "path": "MAINDESIGN.png",
      "size": 3873254
    },
    {
      "path": "sha256.txt",
      "size": 2838664
    },
    {
      "path": "ios app mockup.png",
      "size": 2821699
    },
    {
      "path": "ios support documents/Landmarks_ Applying a background extension effect _ Apple Developer Documentation.pdf",
      "size": 2098656
    },
    {
      "path": "ios support documents/Landmarks_ Displaying custom activity badges _ Apple Developer Documentation.pdf",
      "size": 1873402
    },
    {
      "path": "files.zlist",
      "size": 1796350
    },
    {
      "path": "ios support documents/Landmarks_ Extending horizontal scrolling under a sidebar or inspector _ Apple Developer Documentation.pdf",
      "size": 1632595
    },
    {
      "path": "ios support documents/Landmarks_ Refining the system provided Liquid Glass effect in toolbars _ Apple Developer Documentation.pdf",
      "size": 1398959
    },
    {
      "path": "ios support documents/iOS & iPadOS 26 Release Notes _ Apple Developer Documentation.pdf",
      "size": 1210570
    },
    {
      "path": "ios support documents/Improving the safety of generative model output _ Apple Developer Documentation.pdf",
      "size": 1137316
    },
    {
      "path": "iconlogo.png",
      "size": 1075847
    },
    {
      "path": "Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew 1.png",
      "size": 1003595
    },
    {
      "path": "Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew 2.png",
      "size": 1003595
    },
    {
      "path": "Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew.png",
      "size": 1003595
    },
    {
      "path": "iconnew.png",
      "size": 1003595
    }
  ],
  "files": [
    {
      "path": ".github/coderabbit.yaml",
      "size": 2912,
      "binary": false,
      "reason": null,
      "ext": ".yaml",
      "mime": null,
      "sample": "# CodeRabbit Configuration for Pulsum\n# https://docs.coderabbit.ai/guides/review-instructions/\n# Language and Frameworks\nlanguage: en-US\nearly_access: true"
    },
    {
      "path": ".github/workflows/auto-merge.yml",
      "size": 3598,
      "binary": false,
      "reason": null,
      "ext": ".yml",
      "mime": null,
      "sample": "name: Auto Merge PR\n# OPTIONAL: Automatically merges PRs after CodeRabbit approval\n# This is disabled by default for safety. Enable it by uncommenting the 'on' triggers below.\n# Uncomment the lines below to enable auto-merge:\n# on:"
    },
    {
      "path": ".github/workflows/auto-pr.yml",
      "size": 2608,
      "binary": false,
      "reason": null,
      "ext": ".yml",
      "mime": null,
      "sample": "name: Auto Create Pull Request\n# Automatically creates a PR when you push a feature branch\n# This enables CodeRabbit to review your changes\non:\n  push:"
    },
    {
      "path": ".github/workflows/test-harness.yml",
      "size": 484,
      "binary": false,
      "reason": null,
      "ext": ".yml",
      "mime": null,
      "sample": "name: gate-tests\non:\n  push:\n    branches: [ main, gate1-testing-harness ]\n  pull_request:"
    },
    {
      "path": ".gitignore",
      "size": 766,
      "binary": false,
      "reason": null,
      "ext": "",
      "mime": null,
      "sample": "# macOS\n.DS_Store\n*.swp\n# Xcode user data\nxcuserdata/"
    },
    {
      "path": "CLAUDE.md",
      "size": 14300,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# CLAUDE.md\n## Commands\n- Lint: swiftformat --lint .\n- Format: swiftformat .\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository."
    },
    {
      "path": "COMPREHENSIVE_BUG_ANALYSIS.md",
      "size": 41993,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# PULSUM iOS App - Comprehensive Architectural Bug Analysis\n**Generated:** November 11, 2025  \n**Analyst:** iOS Swift Architect  \n**Scope:** Full codebase review including all packages, UI, agents, services, data layers\n---"
    },
    {
      "path": "ChatGPT for engineers - Resource _ OpenAI Academy.pdf",
      "size": 3977697,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "Config.xcconfig.template",
      "size": 274,
      "binary": false,
      "reason": null,
      "ext": ".template",
      "mime": null,
      "sample": "// Pulsum Build Configuration Template\n// Copy this file to Config.xcconfig if you need local overrides.\n// Secrets are never stored here. Provide `PULSUM_COACH_API_KEY` via the environment (e.g., launchctl setenv) instead.\nOPENAI_API_KEY = YOUR_OPENAI_API_KEY_HERE"
    },
    {
      "path": "Docs/a-practical-guide-to-building-with-gpt-5.pdf",
      "size": 12010712,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "Docs/architecture copy.md",
      "size": 111481,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum - Complete Architecture Documentation\n**Generated:** October 1, 2025\n**iOS Target:** iOS 26+\n**Swift Version:** 6.2\n**Status:** Milestone 4 Complete (UI & Experience Build)"
    },
    {
      "path": "Docs/architecture_short copy.md",
      "size": 28182,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum - Architecture Documentation (Condensed)\n**Generated:** October 1, 2025\n**iOS Target:** iOS 26+\n**Swift Version:** 6.2\n**Status:** Milestone 4 Complete"
    },
    {
      "path": "Docs/chat1.md",
      "size": 10249,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum Project \u2013 Progress Summary (Chat Session)\n## Context\n- Role: Principal iOS architect implementing Pulsum per `instructions.md` spec (iOS 26, Liquid Glass, agent-first).\n- Milestones 0\u20132 completed; Milestone 3 currently in progress with substantial groundwork in place.\n## Milestone 0 \u2013 Repository Audit"
    },
    {
      "path": "Docs/chat2.md",
      "size": 6235,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum Project \u2013 Continuation Log (Chat 2)\n## Milestone Status Snapshot (as of Chat 2)\n- **Milestone 0 \u2013 Repository Audit:** Complete. Read entire template project, assets, and support docs.\n- **Milestone 1 \u2013 Architecture & Scaffolding:** Complete. Created package layout (`PulsumUI`, `PulsumAgents`, `PulsumData`, `PulsumServices`, `PulsumML`), documented design (`Docs/architecture_and_scaffolding.md`), enabled required capabilities in Xcode project, and set up persistence strategy.\n- **Milestone 2 \u2013 Data & Services Foundations:** Complete. Core Data model built; persistence stack secured (`NSFileProtectionComplete`); HealthKit, Speech, LibraryImporter, VectorIndexManager, EmbeddingService, and KeychainService implemented with tests."
    },
    {
      "path": "GITHUB_WORKFLOW.md",
      "size": 17816,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# GitHub Workflow Guide for Pulsum\n**A complete guide to version control, branching, pull requests, and automated code review with CodeRabbit.**\n---\n## Table of Contents\n1. [Git & GitHub Basics](#git--github-basics)"
    },
    {
      "path": "MAINDESIGN.png",
      "size": 3873254,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".png",
      "mime": "image/png",
      "sample": null
    },
    {
      "path": "Packages/PulsumAgents/Package.swift",
      "size": 1351,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "// swift-tools-version: 6.1\nimport PackageDescription\nlet package = Package(\n    name: \"PulsumAgents\",\n    platforms: ["
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/AgentOrchestrator.swift",
      "size": 46339,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport CoreData\n#if canImport(FoundationModels)\nimport FoundationModels\n#endif"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/BackfillStateStore.swift",
      "size": 5866,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport os.log\nimport PulsumData\nprotocol BackfillStateStoring: Sendable {\n    func loadState() -> BackfillProgress?"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/CheerAgent.swift",
      "size": 1255,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n@MainActor\npublic final class CheerAgent {\n    private let calendar = Calendar(identifier: .gregorian)\n    public init() {}"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent+Coverage.swift",
      "size": 4128,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport PulsumData\nimport PulsumTypes\npublic enum CoveragePassKind {\n    case strong"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent.swift",
      "size": 32137,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport CoreData\n#if canImport(FoundationModels)\nimport FoundationModels\n#endif"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/DataAgent.swift",
      "size": 175266,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n@preconcurrency import CoreData\nimport HealthKit\n@preconcurrency import PulsumData\nimport PulsumML"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/EstimatorStateStore.swift",
      "size": 3955,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport os.log\nimport PulsumData\nimport PulsumML\nprotocol EstimatorStateStoring: Sendable {"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/HealthAccessStatus.swift",
      "size": 1451,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n@preconcurrency import HealthKit\n/// Consolidated authorization surface for Pulsum's HealthKit ingestion.\n/// `HKSampleType` is not marked `Sendable`, so the struct uses `@unchecked Sendable`.\npublic struct HealthAccessStatus: @unchecked Sendable {"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/PrivacyInfo.xcprivacy",
      "size": 559,
      "binary": false,
      "reason": null,
      "ext": ".xcprivacy",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>NSPrivacyAccessedAPITypes</key>"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/PulsumAgents.swift",
      "size": 855,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n#if canImport(FoundationModels)\nimport FoundationModels\n#endif\nimport PulsumData"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/RecRankerStateStore.swift",
      "size": 3865,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport os.log\nimport PulsumData\nimport PulsumML\npublic protocol RecRankerStateStoring: Sendable {"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/SafetyAgent.swift",
      "size": 3376,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n#if canImport(FoundationModels)\nimport FoundationModels\n#endif\nimport PulsumML"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/SentimentAgent.swift",
      "size": 15796,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport CoreData\n#if canImport(FoundationModels)\nimport FoundationModels\n#endif"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/WellbeingScoreState.swift",
      "size": 383,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic enum WellbeingNoDataReason: Equatable, Sendable {\n    case healthDataUnavailable\n    case permissionsDeniedOrPending\n    case insufficientSamples"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/AgentSystemTests.swift",
      "size": 2866,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\nimport CoreData\n@testable import PulsumAgents\n@testable import PulsumData\n@testable import PulsumServices"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailAcceptanceTests.swift",
      "size": 10884,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Testing\nimport CoreData\n@testable import PulsumAgents\n@testable import PulsumServices\n@testable import PulsumData"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailTests.swift",
      "size": 9152,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Testing\nimport Foundation\n@testable import PulsumAgents\n@testable import PulsumML\n@testable import PulsumData"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/DebugLogBufferTests.swift",
      "size": 901,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "@testable import PulsumAgents\nimport PulsumTypes\nimport XCTest\nfinal class DebugLogBufferTests: XCTestCase {\n    func testRingBufferEvictsOldEntries() async {"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_JournalSessionTests.swift",
      "size": 1347,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumAgents\n@testable import PulsumServices\nimport PulsumTypes\nfinal class Gate2_JournalSessionTests: XCTestCase {"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_OrchestratorLLMKeyAPITests.swift",
      "size": 6112,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "#if DEBUG\nimport Foundation\nimport XCTest\n@testable import PulsumAgents\n@testable import PulsumServices"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate2_TypesWiringTests.swift",
      "size": 354,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\nimport PulsumTypes\nfinal class Gate2_TypesWiringTests: XCTestCase {\n    func testSpeechSegmentInit() {\n        let segment = SpeechSegment(transcript: \"hello\", isFinal: true, confidence: 0.9)"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_FreshnessBusTests.swift",
      "size": 2654,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "@testable import PulsumAgents\n@testable import PulsumData\nimport PulsumTypes\nimport XCTest\nfinal class Gate3_FreshnessBusTests: XCTestCase {"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_HealthAccessStatusTests.swift",
      "size": 4613,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "@testable import PulsumAgents\n@testable import PulsumData\n@testable import PulsumServices\nimport HealthKit\nimport XCTest"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate3_IngestionIdempotenceTests.swift",
      "size": 2104,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "@testable import PulsumAgents\n@testable import PulsumData\n@testable import PulsumServices\nimport XCTest\nfinal class Gate3_IngestionIdempotenceTests: XCTestCase {"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_ConsentRoutingTests.swift",
      "size": 3246,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Testing\n@testable import PulsumServices\nstruct Gate4_ConsentRoutingTests {\n    @Test(\"Consent OFF forces on-device generator\")\n    func consentOffFallsBackLocal() async {"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_LLMKeyTests.swift",
      "size": 1489,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "#if DEBUG\nimport Foundation\nimport XCTest\n@testable import PulsumAgents\n@testable import PulsumServices"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate4_RoutingTests.swift",
      "size": 4119,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Testing\nimport CoreData\n@testable import PulsumAgents\n@testable import PulsumData\nstruct Gate4_RoutingTests {"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_EmbeddingAvailabilityDegradationTests.swift",
      "size": 2835,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "@testable import PulsumAgents\n@testable import PulsumData\n@testable import PulsumML\nimport XCTest\n@MainActor"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_RecRankerLearningTests.swift",
      "size": 2945,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumAgents\n@testable import PulsumData\n@testable import PulsumML\n@testable import PulsumServices"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_RecRankerPersistenceTests.swift",
      "size": 3207,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "@testable import PulsumAgents\n@testable import PulsumData\nimport PulsumML\nimport PulsumServices\nimport XCTest"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_SentimentJournalingFallbackTests.swift",
      "size": 1532,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "@testable import PulsumAgents\n@testable import PulsumData\nimport PulsumML\nimport XCTest\n@MainActor"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_StateEstimatorPersistenceTests.swift",
      "size": 1887,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumAgents\n@testable import PulsumML\n// swiftlint:disable:next type_name\nfinal class Gate6_StateEstimatorPersistenceTests: XCTestCase {"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_StateEstimatorWeightsAndLabelsTests.swift",
      "size": 2798,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumAgents\n@testable import PulsumML\n// swiftlint:disable:next type_name\nfinal class Gate6_StateEstimatorWeightsAndLabelsTests: XCTestCase {"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_WellbeingBackfillPhasingTests.swift",
      "size": 14962,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "@testable import PulsumAgents\n@testable import PulsumData\n@testable import PulsumServices\nimport CoreData\nimport HealthKit"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_WellbeingStateMappingTests.swift",
      "size": 2119,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "@testable import PulsumAgents\n@testable import PulsumServices\nimport HealthKit\nimport XCTest\n// swiftlint:disable:next type_name"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/HealthKitServiceStub.swift",
      "size": 5672,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport HealthKit\n@testable import PulsumServices\nfinal class HealthKitServiceStub: HealthKitServicing, @unchecked Sendable {\n    var isHealthDataAvailable: Bool = true"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/TestCoreDataStack.swift",
      "size": 904,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport CoreData\n@testable import PulsumData\npublic final class TestCoreDataStack {\n    public static func makeContainer() -> NSPersistentContainer {"
    },
    {
      "path": "Packages/PulsumData/Package.swift",
      "size": 1075,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "// swift-tools-version: 6.1\nimport PackageDescription\nlet package = Package(\n    name: \"PulsumData\",\n    platforms: ["
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/Bundle+PulsumDataResources.swift",
      "size": 295,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n#if SWIFT_PACKAGE\nextension Bundle {\n    static var pulsumDataResources: Bundle { .module }\n}"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/DataStack.swift",
      "size": 7193,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport CoreData\nimport os.log\npublic enum PulsumDataError: LocalizedError {\n    case storeInitializationFailed(underlying: Error)"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/EvidenceScorer.swift",
      "size": 957,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic enum EvidenceBadge: String {\n    case strong = \"Strong\"\n    case medium = \"Medium\"\n    case weak = \"Weak\""
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/LibraryImporter.swift",
      "size": 16785,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport CoreData\nimport CryptoKit\nimport PulsumML\nimport PulsumTypes"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/Model/ManagedObjects.swift",
      "size": 5027,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import CoreData\n@objc(JournalEntry)\npublic final class JournalEntry: NSManagedObject {\n    @NSManaged public var id: UUID\n    @NSManaged public var date: Date"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/PrivacyInfo.xcprivacy",
      "size": 559,
      "binary": false,
      "reason": null,
      "ext": ".xcprivacy",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>NSPrivacyAccessedAPITypes</key>"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/PulsumData.swift",
      "size": 1973,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport CoreData\n/// Facade exposing Pulsum's persistent data infrastructure.\npublic enum PulsumData {\n    /// Shared Core Data stack configured for on-device only storage."
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/PulsumManagedObjectModel.swift",
      "size": 4539,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import CoreData\nimport Foundation\n/// Canonical Pulsum Core Data model loader. Uses the packaged `.momd` from PulsumData resources\n/// and exposes a singleton instance so tests and production share the same model pointer.\npublic enum PulsumManagedObjectModel {"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/Resources/Pulsum.xcdatamodeld/.xccurrentversion",
      "size": 259,
      "binary": false,
      "reason": null,
      "ext": "",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>_XCCurrentVersionName</key>"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/Resources/Pulsum.xcdatamodeld/Pulsum.xcdatamodel/contents",
      "size": 7741,
      "binary": false,
      "reason": null,
      "ext": "",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<model type=\"com.apple.IDECoreDataModeler.DataModel\" documentVersion=\"1.0\" lastSavedToolsVersion=\"1\" systemVersion=\"11A491\" minimumToolsVersion=\"Automatic\" sourceLanguage=\"Swift\" usedWithCloudKit=\"false\" userDefinedModelVersionIdentifier=\"\">\n    <entity name=\"JournalEntry\" representedClassName=\"JournalEntry\" syncable=\"YES\">\n        <attribute name=\"id\" optional=\"NO\" attributeType=\"UUID\" usesScalarValueType=\"NO\"/>\n        <attribute name=\"date\" optional=\"NO\" attributeType=\"Date\" usesScalarValueType=\"NO\"/>"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/Resources/PulsumCompiled.momd/Pulsum.mom",
      "size": 8979,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".mom",
      "mime": null,
      "sample": null
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/Resources/PulsumCompiled.momd/Pulsum.omo",
      "size": 22072,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".omo",
      "mime": null,
      "sample": null
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/Resources/PulsumCompiled.momd/VersionInfo.plist",
      "size": 743,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".plist",
      "mime": null,
      "sample": null
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/VectorIndex.swift",
      "size": 16784,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport os.log\nprotocol VectorIndexFileHandle: AnyObject {\n    func seekToEnd() throws -> UInt64\n    func seek(toOffset offset: UInt64) throws"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/VectorIndexManager.swift",
      "size": 2023,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport PulsumML\npublic protocol VectorIndexProviding: AnyObject, Sendable {\n    @discardableResult\n    func upsertMicroMoment(id: String, title: String, detail: String?, tags: [String]?) async throws -> [Float]"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/DataStackSecurityTests.swift",
      "size": 1093,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumData\nfinal class DataStackSecurityTests: XCTestCase {\n    func testDebugApplyBackupExclusionMarksDirectories() throws {\n        let temporaryRoot = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/Gate0_DataStackSecurityTests.swift",
      "size": 994,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumData\nfinal class Gate0_DataStackSecurityTests: XCTestCase {\n    func testPHIDirectoriesAreExcludedFromBackup() throws {\n        let root = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/Gate5_LibraryImporterAtomicityTests.swift",
      "size": 8203,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import CoreData\nimport CryptoKit\nimport XCTest\n@testable import PulsumData\n@testable import PulsumML"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/Gate5_LibraryImporterPerfTests.swift",
      "size": 1220,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import CoreData\nimport XCTest\n@testable import PulsumData\nfinal class Gate5_LibraryImporterPerfTests: XCTestCase {\n    func testCoreDataReadCompletesQuicklyDuringImport() async throws {"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexConcurrencyTests.swift",
      "size": 2600,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumData\nfinal class Gate5_VectorIndexConcurrencyTests: XCTestCase {\n    func testConcurrentShardOperationsRemainDeterministic() async throws {\n        let tempDirectory = FileManager.default.temporaryDirectory"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexFileHandleTests.swift",
      "size": 2516,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumData\nfinal class Gate5_VectorIndexFileHandleTests: XCTestCase {\n    func testCloseFailureIsSurfacedToCaller() async throws {\n        let directory = FileManager.default.temporaryDirectory"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/Gate5_VectorIndexManagerActorTests.swift",
      "size": 1957,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumData\n@testable import PulsumML\nfinal class Gate5_VectorIndexManagerActorTests: XCTestCase {\n    func testManagerAllowsConcurrentAccessFromBackgroundTasks() async throws {"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/LibraryImporterTests.swift",
      "size": 2484,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import CoreData\nimport XCTest\n@testable import PulsumData\nfinal actor HappyPathIndexStub: VectorIndexProviding {\n    private(set) var upsertedIds: [String] = []"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/PulsumDataBootstrapTests.swift",
      "size": 1166,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\nimport CoreData\n@testable import PulsumData\nfinal class PulsumDataBootstrapTests: XCTestCase {\n    func testPersistentContainerLoadsPulsumModel() {"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/Resources/podcasts_sample.json",
      "size": 785,
      "binary": false,
      "reason": null,
      "ext": ".json",
      "mime": "application/json",
      "sample": "[\n  {\n    \"episodeNumber\": \"001\",\n    \"episodeTitle\": \"Sample Episode\",\n    \"recommendations\": ["
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/VectorIndexTests.swift",
      "size": 817,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumData\nfinal class VectorIndexTests: XCTestCase {\n    func testUpsertAndSearch() async throws {\n        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(\"VectorIndexTests-\\(UUID().uuidString)\", isDirectory: true)"
    },
    {
      "path": "Packages/PulsumML/Package.swift",
      "size": 1249,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "// swift-tools-version: 6.1\nimport PackageDescription\nlet package = Package(\n    name: \"PulsumML\",\n    platforms: ["
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsAvailability.swift",
      "size": 1504,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n#if canImport(FoundationModels) && os(iOS)\nimport FoundationModels\n#endif\npublic enum AFMStatus {"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsStub.swift",
      "size": 1997,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n// TEMPORARY: Foundation Models stubs for current Xcode compatibility\n// Remove when iOS 26 SDK becomes available\n#if !canImport(FoundationModels)\n// Stub Foundation Models types for compilation compatibility"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/AFM/README_FoundationModels.md",
      "size": 2256,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Foundation Models Integration - iOS 26 Ready\n## Current Status\nFoundation Models implementation is **COMPLETE** but temporarily disabled due to current Xcode not supporting iOS 26 SDK.\n## Files Ready for iOS 26 Activation\nWhen iOS 26 SDK becomes available in Xcode, rename these files to enable Foundation Models:"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/BaselineMath.swift",
      "size": 1478,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic enum BaselineMath {\n    public struct RobustStats {\n        public let median: Double\n        public let mad: Double"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Bundle+PulsumMLResources.swift",
      "size": 271,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n#if SWIFT_PACKAGE\nextension Bundle {\n    static var pulsumMLResources: Bundle { .module }\n}"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Embedding/AFMTextEmbeddingProvider.swift",
      "size": 1984,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport NaturalLanguage\n/// Opportunistic AFM/NL embedding provider.\n///\n/// This provider only attempts contextual embeddings when Apple Intelligence reports `.ready`."
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Embedding/CoreMLEmbeddingFallbackProvider.swift",
      "size": 2240,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport CoreML\nimport NaturalLanguage\nimport os.log\n/// Reliable on-device fallback embedding provider backed by the bundled Core ML model."
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingError.swift",
      "size": 401,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic enum EmbeddingError: LocalizedError {\n    case generatorUnavailable\n    case emptyResult\n    public var errorDescription: String? {"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingService.swift",
      "size": 15632,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport os\nimport PulsumTypes\n/// Central access point for on-device embeddings with AFM primary and hash fallback.\npublic final class EmbeddingService {"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Embedding/TextEmbeddingProviding.swift",
      "size": 184,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic protocol TextEmbeddingProviding {\n    /// Returns a 384-dimensional embedding for the supplied text.\n    func embedding(for text: String) throws -> [Float]\n}"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Placeholder.swift",
      "size": 380,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic enum PulsumML {\n    public static let version = \"0.1.0\"\n    public static func embedding(for text: String) throws -> [Float] {\n        try EmbeddingService.shared.embedding(for: text)"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/PrivacyInfo.xcprivacy",
      "size": 559,
      "binary": false,
      "reason": null,
      "ext": ".xcprivacy",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>NSPrivacyAccessedAPITypes</key>"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/RecRanker.swift",
      "size": 6038,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic struct RecommendationFeatures {\n    public let id: String\n    public let wellbeingScore: Double\n    public let evidenceStrength: Double"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Resources/PulsumFallbackEmbedding.mlmodel",
      "size": 410814,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".mlmodel",
      "mime": null,
      "sample": null
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Resources/PulsumSentimentCoreML.mlmodel",
      "size": 5491,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".mlmodel",
      "mime": null,
      "sample": null
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Resources/README_CreateModel.md",
      "size": 645,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Creating Core ML Sentiment Model\nTo create the required `PulsumSentimentCoreML.mlmodel`:\n1. Ensure Xcode tooling is installed (CreateML is required).\n2. From this directory run `swift CreateSentimentModel.swift`.\n3. Move the generated `PulsumSentimentCoreML.mlmodel` into this folder (overwriting any previous version)."
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Safety/FoundationModelsSafetyProvider.swift",
      "size": 3521,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n#if canImport(FoundationModels) && os(iOS)\nimport FoundationModels\n@available(iOS 26.0, *)\n@Generable enum SafetyRating: String, CaseIterable {"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/SafetyLocal.swift",
      "size": 8643,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport os\npublic enum SafetyClassification: Equatable {\n    case safe\n    case caution(reason: String)"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/AFMSentimentProvider.swift",
      "size": 2809,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nfinal class AFMSentimentProvider: SentimentProviding {\n    private let embeddingService: EmbeddingService\n    private let positiveAnchors: [[Float]]\n    private let negativeAnchors: [[Float]]"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/CoreMLSentimentProvider.swift",
      "size": 1404,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport NaturalLanguage\nimport CoreML\nfinal class CoreMLSentimentProvider: SentimentProviding {\n    private let model: NLModel"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/FoundationModelsSentimentProvider.swift",
      "size": 2445,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n#if canImport(FoundationModels) && os(iOS)\nimport FoundationModels\n@available(iOS 26.0, *)\n@Generable enum SentimentLabel: String, CaseIterable {"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/NaturalLanguageSentimentProvider.swift",
      "size": 721,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport NaturalLanguage\nfinal class NaturalLanguageSentimentProvider: SentimentProviding {\n    func sentimentScore(for text: String) async throws -> Double {\n        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/PIIRedactor.swift",
      "size": 1502,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport NaturalLanguage\npublic enum PIIRedactor {\n    public static func redact(_ transcript: String) -> String {\n        guard !transcript.isEmpty else { return transcript }"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentProviding.swift",
      "size": 556,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic protocol SentimentProviding {\n    /// Produces a sentiment score in the range [-1, 1].\n    func sentimentScore(for text: String) async throws -> Double\n}"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentService.swift",
      "size": 1298,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic final class SentimentService {\n    private let providers: [SentimentProviding]\n    public init(providers: [SentimentProviding]? = nil) {\n        if let providers, !providers.isEmpty {"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/StateEstimator.swift",
      "size": 3885,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic struct StateEstimatorConfig {\n    public let learningRate: Double\n    public let regularization: Double\n    public let weightCap: ClosedRange<Double>"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/TopicGate/EmbeddingTopicGateProvider.swift",
      "size": 7192,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport os\n/// Fallback topic gate using embedding similarity against wellbeing knowledge base\npublic final class EmbeddingTopicGateProvider: TopicGateProviding, @unchecked Sendable {\n    private let embeddingService: EmbeddingService"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/TopicGate/FoundationModelsTopicGateProvider.swift",
      "size": 2714,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n#if canImport(FoundationModels) && os(iOS)\nimport FoundationModels\n@available(iOS 26.0, *)\n@Generable"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/TopicGate/TopicGateProviding.swift",
      "size": 1017,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n/// Decision from the topic gate classifier\npublic struct GateDecision: Sendable {\n    public let isOnTopic: Bool\n    public let reason: String"
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/EmbeddingServiceAvailabilityTests.swift",
      "size": 2565,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumML\nfinal class EmbeddingServiceAvailabilityTests: XCTestCase {\n    func testReprobesAfterCooldown() {\n        let provider = MutableEmbeddingProvider(response: .failure(EmbeddingError.generatorUnavailable))"
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/EmbeddingServiceFallbackTests.swift",
      "size": 942,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumML\nfinal class EmbeddingServiceFallbackTests: XCTestCase {\n    func testFallsBackWhenPrimaryUnavailable() throws {\n        let fallback = MockEmbeddingProvider(vector: Array(repeating: Float(0.25), count: 4))"
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/Gate0_EmbeddingServiceFallbackTests.swift",
      "size": 1379,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumML\nprivate struct MockEmbeddingProvider: TextEmbeddingProviding {\n    enum Mode {\n        case succeeds([Float])"
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/Gate6_EmbeddingProviderContextualTests.swift",
      "size": 2450,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumML\nfinal class Gate6_EmbeddingProviderContextualTests: XCTestCase {\n    func testEmbeddingServiceRejectsZeroVector() {\n        let service = EmbeddingService.debugInstance("
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/PackageEmbedTests.swift",
      "size": 5284,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumML\nfinal class PackageEmbedTests: XCTestCase {\n    func testVersionStringIsPresent() {\n        XCTAssertFalse(PulsumML.version.isEmpty)"
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/SafetyLocalTests.swift",
      "size": 1062,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumML\nfinal class SafetyLocalTests: XCTestCase {\n    func testCrisisKeywordTriggersCrisisClassification() {\n        let safety = SafetyLocal()"
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/TopicGateMarginTests.swift",
      "size": 1909,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Testing\n@testable import PulsumML\nprivate func makeMarginTopicGateProvider() -> EmbeddingTopicGateProvider {\n    let embeddingService = EmbeddingService.debugInstance(\n        primary: KeywordEmbeddingProvider(dimension: 4),"
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/TopicGateTests.swift",
      "size": 5366,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Testing\nimport Foundation\n@testable import PulsumML\nprivate func makeTopicGateProvider() -> EmbeddingTopicGateProvider {\n    let embeddingService = EmbeddingService.debugInstance("
    },
    {
      "path": "Packages/PulsumServices/Package.swift",
      "size": 1067,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "// swift-tools-version: 6.1\nimport PackageDescription\nlet package = Package(\n    name: \"PulsumServices\",\n    platforms: ["
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/BuildFlags.swift",
      "size": 732,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n// Gate-1b: UITest seam hardening\n// Shared entry point so all services know if UITest seams are compiled in.\nenum BuildFlags {\n#if DEBUG || PULSUM_UITESTS"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/Bundle+PulsumServicesResources.swift",
      "size": 311,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n#if SWIFT_PACKAGE\nextension Bundle {\n    static var pulsumServicesResources: Bundle { .module }\n}"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/CoachPhrasingSchema.swift",
      "size": 2365,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n/// Canonical strict schema for GPT\u20115 structured coach phrasing.\n/// All fields are 'required' (strict JSON mode), but semantically-optional\n/// ones (\"refusalReason\", \"nextAction\", \"intentTopic\") must allow empty \"\".\npublic enum CoachPhrasingSchema {"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/FoundationModelsCoachGenerator.swift",
      "size": 4895,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n#if canImport(FoundationModels) && os(iOS)\nimport FoundationModels\n#endif\nimport PulsumML"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/HealthKitAnchorStore.swift",
      "size": 3144,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport HealthKit\nimport PulsumData\nimport PulsumTypes\n/// Persists HealthKit query anchors on-device with complete file protection."
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/HealthKitService.swift",
      "size": 33385,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\n@preconcurrency import HealthKit\nimport PulsumTypes\npublic protocol HealthKitObservationToken: AnyObject {}\n#if canImport(HealthKit)"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/KeychainService.swift",
      "size": 3074,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport Security\npublic protocol KeychainStoring: Sendable {\n    func setSecret(_ value: Data, for key: String) throws\n    func secret(for key: String) throws -> Data?"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/LLMGateway.swift",
      "size": 36927,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport os.log\nimport PulsumData\nimport PulsumML\nimport PulsumTypes"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/Placeholder.swift",
      "size": 543,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport PulsumData\nimport PulsumML\npublic enum PulsumServices {\n    private static let healthKitInstance = HealthKitService()"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/PrivacyInfo.xcprivacy",
      "size": 559,
      "binary": false,
      "reason": null,
      "ext": ".xcprivacy",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>NSPrivacyAccessedAPITypes</key>"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/SpeechService.swift",
      "size": 20854,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport Speech\n#if os(iOS)\nimport AVFoundation\n#endif"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_LLMGatewayTests.swift",
      "size": 1803,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport XCTest\n@testable import PulsumServices\nprivate final class InMemoryKeychainStore: KeychainStoring, @unchecked Sendable {\n    private var storage: [String: Data] = [:]"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_SpeechServiceAuthorizationTests.swift",
      "size": 3744,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "#if os(iOS)\nimport Speech\nimport XCTest\n@testable import PulsumServices\nprivate struct MockSpeechAuthorizationProvider: SpeechAuthorizationProviding {"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/Gate0_SpeechServiceLoggingTests.swift",
      "size": 1087,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumServices\nfinal class Gate0_SpeechServiceLoggingTests: XCTestCase {\n    func testReleaseBuildDisablesTranscriptLogging() throws {\n#if RELEASE_LOG_AUDIT"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/Gate1_LLMGatewayUITestSeams.swift",
      "size": 946,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumServices\nfinal class Gate1_LLMGatewayUITestSeams: XCTestCase {\n    func testStubPingShortCircuits_whenFlagOn() async throws {\n        guard ProcessInfo.processInfo.environment[\"UITEST_USE_STUB_LLM\"] == \"1\" else {"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/Gate1_SpeechFakeBackendTests.swift",
      "size": 965,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumServices\nfinal class Gate1_SpeechFakeBackendTests: XCTestCase {\n    func testFakeBackendStreamsScriptedSegments_whenFlagOn() async throws {\n        guard ProcessInfo.processInfo.environment[\"UITEST_FAKE_SPEECH\"] == \"1\" else {"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/Gate2_ModernSpeechBackendTests.swift",
      "size": 1311,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumServices\nfinal class Gate2_ModernSpeechBackendTests: XCTestCase {\n    func testModernBackendRespectsFeatureFlag() async throws {\n#if os(iOS)"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/Gate4_LLMGatewayPingSeams.swift",
      "size": 628,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumServices\nfinal class Gate4_LLMGatewayPingSeams: XCTestCase {\n    func testStubPingShortCircuitsWhenFlagEnabled() async throws {\n        let previous = getenv(\"UITEST_USE_STUB_LLM\").flatMap { String(cString: $0) }"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/HealthKitAnchorStoreTests.swift",
      "size": 1910,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\nimport HealthKit\n@testable import PulsumServices\nfinal class HealthKitAnchorStoreTests: XCTestCase {\n    func testPersistAndLoadAnchor() throws {"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/KeychainServiceTests.swift",
      "size": 490,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumServices\nfinal class KeychainServiceTests: XCTestCase {\n    func testRoundTripSecret() throws {\n        let service = KeychainService()"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewaySchemaTests.swift",
      "size": 11668,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Testing\nimport Foundation\n@testable import PulsumServices\n/// Tests for LLMGateway structured output schema validation (Wall 2)\nstruct LLMGatewaySchemaTests {"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewayTests.swift",
      "size": 11616,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n#if canImport(Darwin)\nimport Darwin\n#else\nimport Glibc"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/PulsumServicesDependencyTests.swift",
      "size": 506,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumServices\nfinal class PulsumServicesDependencyTests: XCTestCase {\n    func testStorageMetadataAndEmbeddingVersion() {\n        let metadata = PulsumServices.storageMetadata()"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/SpeechServiceTests.swift",
      "size": 2765,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\nimport Speech\n@testable import PulsumServices\nfinal class SpeechServiceAuthorizationTests: XCTestCase {\n    func testRequestAuthorizationSucceedsWhenPermissionsGranted() async throws {"
    },
    {
      "path": "Packages/PulsumServices/Tests/Support/LLMURLProtocolStub.swift",
      "size": 3599,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nfinal class LLMURLProtocolStub: URLProtocol {\n    nonisolated(unsafe) static var handler: ((URLRequest) -> (Int, Data))?\n    nonisolated(unsafe) static var respondWithSchemaError: Bool = false\n    nonisolated(unsafe) static var invocationCount: Int = 0"
    },
    {
      "path": "Packages/PulsumTypes/Package.swift",
      "size": 541,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "// swift-tools-version: 6.1\nimport PackageDescription\nlet package = Package(\n    name: \"PulsumTypes\",\n    platforms: ["
    },
    {
      "path": "Packages/PulsumTypes/Sources/PulsumTypes/DebugLog.swift",
      "size": 1279,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic actor DebugLogBuffer {\n    public static let shared = DebugLogBuffer()\n    private var lines: [String] = []\n    private let maxLines = 30_000"
    },
    {
      "path": "Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsLogger.swift",
      "size": 20058,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Dispatch\nimport Foundation\nimport OSLog\nimport os.signpost\npublic enum Diagnostics {"
    },
    {
      "path": "Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsReport.swift",
      "size": 6190,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic struct DiagnosticsReportContext: Sendable {\n    public let appVersion: String\n    public let buildNumber: String\n    public let deviceModel: String"
    },
    {
      "path": "Packages/PulsumTypes/Sources/PulsumTypes/DiagnosticsTypes.swift",
      "size": 8588,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic enum DiagnosticsLevel: Int, Codable, Comparable, Sendable {\n    case debug = 0\n    case info = 1\n    case warn = 2"
    },
    {
      "path": "Packages/PulsumTypes/Sources/PulsumTypes/Notifications.swift",
      "size": 393,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic extension Notification.Name {\n    static let pulsumScoresUpdated = Notification.Name(\"pulsumScoresUpdated\")\n    static let pulsumChatRouteDiagnostics = Notification.Name(\"com.pulsum.chatRouteDiagnostics\")\n    static let pulsumChatCloudError = Notification.Name(\"com.pulsum.chatCloudError\")"
    },
    {
      "path": "Packages/PulsumTypes/Sources/PulsumTypes/SpeechTypes.swift",
      "size": 360,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\npublic struct SpeechSegment: Sendable, Equatable {\n    public let transcript: String\n    public let isFinal: Bool\n    public let confidence: Float?"
    },
    {
      "path": "Packages/PulsumTypes/Tests/DiagnosticsLoggerTests.swift",
      "size": 9748,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumTypes\nfinal class DiagnosticsLoggerTests: XCTestCase {\n    override func setUp() async throws {\n        await Diagnostics.clearDiagnostics()"
    },
    {
      "path": "Packages/PulsumUI/Package.swift",
      "size": 982,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "// swift-tools-version: 6.1\nimport PackageDescription\nlet package = Package(\n    name: \"PulsumUI\",\n    platforms: ["
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/AppViewModel.swift",
      "size": 21144,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport CoreData\nimport Observation\nimport PulsumAgents\nimport PulsumData"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/CoachView.swift",
      "size": 15984,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\nimport Observation\nimport PulsumAgents\npublic struct ChatInputView: View {\n    @Bindable var viewModel: CoachViewModel"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/CoachViewModel.swift",
      "size": 18139,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport Observation\nimport os\nimport PulsumAgents\n#if canImport(FoundationModels) && os(iOS)"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/ConsentBannerView.swift",
      "size": 2389,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\nstruct ConsentBannerView: View {\n    let openSettings: () -> Void\n    let dismiss: () -> Void\n    private let bannerCopy = \"Pulsum can optionally use GPT\u20115 to phrase brief coaching text. If you allow cloud processing, Pulsum sends only minimized context (no journals, no raw health data, no identifiers). PII is redacted. You can turn this off anytime in Settings \u25b8 Cloud Processing.\""
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/GlassEffect.swift",
      "size": 4944,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\npublic struct GlassEffectStyle: Equatable {\n    public enum Intensity: Equatable {\n        case ultraThin\n        case thin"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/HealthAccessRequirement.swift",
      "size": 2552,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport HealthKit\nenum HealthAccessGrantState {\n    case granted\n    case denied"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/LiquidGlassComponents.swift",
      "size": 7132,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\npublic struct LiquidGlassTabBar: View {\n    public struct TabItem: Identifiable {\n        public let id = UUID()\n        public let icon: String"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/LiveWaveformLevels.swift",
      "size": 1660,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\nstruct LiveWaveformLevels: RandomAccessCollection, MutableCollection, Sendable {\n    typealias Index = Int\n    private var storage: [CGFloat]\n    private var writeIndex: Int = 0"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/OnboardingView.swift",
      "size": 14314,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\nimport HealthKit\nimport PulsumAgents\nstruct OnboardingView: View {\n    @Binding var isPresented: Bool"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/PrivacyInfo.xcprivacy",
      "size": 559,
      "binary": false,
      "reason": null,
      "ext": ".xcprivacy",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>NSPrivacyAccessedAPITypes</key>"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/PulseView.swift",
      "size": 16810,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\nimport Observation\n#if canImport(UIKit)\nimport UIKit\n#endif"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/PulseViewModel.swift",
      "size": 9265,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport Observation\nimport PulsumAgents\nimport SwiftUI\nimport PulsumTypes"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/PulsumDesignSystem.swift",
      "size": 7850,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\n// MARK: - Pulsum Design System\n// Light, fresh, minimalistic aesthetic inspired by iOS 26 Liquid Glass principles\nextension Color {\n    // MARK: - Background Colors (Light, Fresh, Beige-based from maindesign.png)"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/PulsumRootView.swift",
      "size": 12723,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\nimport Observation\nimport Foundation\nimport PulsumAgents\nimport PulsumTypes"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/SafetyCardView.swift",
      "size": 3064,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\nstruct SafetyCardView: View {\n    let message: String\n    let dismiss: () -> Void\n    var body: some View {"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownView.swift",
      "size": 19557,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\nimport PulsumAgents\nstruct ScoreBreakdownScreen: View {\n    @Environment(\\.dismiss) private var dismiss\n    @State private var viewModel: ScoreBreakdownViewModel"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownViewModel.swift",
      "size": 2037,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport Observation\nimport PulsumAgents\n@MainActor\n@Observable"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/SettingsView.swift",
      "size": 50036,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\nimport Observation\nimport PulsumAgents\nimport PulsumTypes\n#if canImport(UIKit)"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/SettingsViewModel.swift",
      "size": 18057,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import Foundation\nimport Observation\nimport PulsumAgents\nimport HealthKit\nimport PulsumTypes"
    },
    {
      "path": "Packages/PulsumUI/Tests/PulsumUITests/LiveWaveformBufferTests.swift",
      "size": 1167,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumUI\nfinal class LiveWaveformBufferTests: XCTestCase {\n    func testRingBufferMaintainsLatestSamples() {\n        var buffer = LiveWaveformLevels(capacity: 8)"
    },
    {
      "path": "Packages/PulsumUI/Tests/PulsumUITests/PulsumRootViewTests.swift",
      "size": 200,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\n@testable import PulsumUI\n@MainActor\nfinal class PulsumRootViewTests: XCTestCase {\n    func testRootViewHealthCheckPrecondition() {"
    },
    {
      "path": "Packages/PulsumUI/Tests/PulsumUITests/SettingsViewModelHealthAccessTests.swift",
      "size": 5680,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "@testable import PulsumAgents\n@testable import PulsumServices\n@testable import PulsumUI\nimport PulsumData\nimport PulsumML"
    },
    {
      "path": "Pulsum.xcodeproj/project.pbxproj",
      "size": 32398,
      "binary": false,
      "reason": null,
      "ext": ".pbxproj",
      "mime": null,
      "sample": "// !$*UTF8*$!\n{\n\tarchiveVersion = 1;\n\tclasses = {\n\t};"
    },
    {
      "path": "Pulsum.xcodeproj/project.xcworkspace/contents.xcworkspacedata",
      "size": 135,
      "binary": false,
      "reason": null,
      "ext": ".xcworkspacedata",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Workspace\n   version = \"1.0\">\n   <FileRef\n      location = \"self:\">"
    },
    {
      "path": "Pulsum.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved",
      "size": 133,
      "binary": false,
      "reason": null,
      "ext": ".resolved",
      "mime": null,
      "sample": "{\n  \"originHash\" : \"733ca631ca5ff7c5629976dd280e4b23b29dd4e0b98be4c4ace5d56d057b1386\",\n  \"pins\" : [\n  ],\n  \"version\" : 3"
    },
    {
      "path": "Pulsum.xcodeproj/xcshareddata/xcschemes/Pulsum.xcscheme",
      "size": 6236,
      "binary": false,
      "reason": null,
      "ext": ".xcscheme",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Scheme\n   LastUpgradeVersion = \"2600\"\n   version = \"1.7\">\n   <BuildAction"
    },
    {
      "path": "Pulsum.xcodeproj/xcuserdata/martin.demel.xcuserdatad/xcschemes/xcschememanagement.plist",
      "size": 670,
      "binary": false,
      "reason": null,
      "ext": ".plist",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>SchemeUserState</key>"
    },
    {
      "path": "Pulsum/Assets.xcassets/AccentColor.colorset/Contents.json",
      "size": 123,
      "binary": false,
      "reason": null,
      "ext": ".json",
      "mime": "application/json",
      "sample": "{\n  \"colors\" : [\n    {\n      \"idiom\" : \"universal\"\n    }"
    },
    {
      "path": "Pulsum/Assets.xcassets/AppIcon.appiconset/Contents.json",
      "size": 713,
      "binary": false,
      "reason": null,
      "ext": ".json",
      "mime": "application/json",
      "sample": "{\n  \"images\" : [\n    {\n      \"filename\" : \"iconnew 2.png\",\n      \"idiom\" : \"universal\","
    },
    {
      "path": "Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew 1.png",
      "size": 1003595,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".png",
      "mime": "image/png",
      "sample": null
    },
    {
      "path": "Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew 2.png",
      "size": 1003595,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".png",
      "mime": "image/png",
      "sample": null
    },
    {
      "path": "Pulsum/Assets.xcassets/AppIcon.appiconset/iconnew.png",
      "size": 1003595,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".png",
      "mime": "image/png",
      "sample": null
    },
    {
      "path": "Pulsum/Assets.xcassets/Contents.json",
      "size": 63,
      "binary": false,
      "reason": null,
      "ext": ".json",
      "mime": "application/json",
      "sample": "{\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }"
    },
    {
      "path": "Pulsum/PrivacyInfo.xcprivacy",
      "size": 559,
      "binary": false,
      "reason": null,
      "ext": ".xcprivacy",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>NSPrivacyAccessedAPITypes</key>"
    },
    {
      "path": "Pulsum/Pulsum.entitlements",
      "size": 310,
      "binary": false,
      "reason": null,
      "ext": ".entitlements",
      "mime": null,
      "sample": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>com.apple.developer.healthkit</key>"
    },
    {
      "path": "Pulsum/PulsumApp.swift",
      "size": 239,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "//\n//  PulsumApp.swift\n//  Pulsum\n//\n//  Created by Martin Demel on 9/28/25."
    },
    {
      "path": "PulsumTests/PulsumTests.swift",
      "size": 294,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "//\n//  PulsumTests.swift\n//  PulsumTests\n//\n//  Created by Martin Demel on 9/28/25."
    },
    {
      "path": "PulsumUITests/FirstRunPermissionsUITests.swift",
      "size": 377,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\nfinal class FirstRunPermissionsUITests: PulsumUITestCase {\n    func testFirstRun_authorizeSpeechAndMic() throws {\n        launchPulsum()\n        try openPulseSheetOrSkip()"
    },
    {
      "path": "PulsumUITests/Gate3_HealthAccessUITests.swift",
      "size": 3478,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\nprivate let partialHealthAccessOverride = [\n    \"HKQuantityTypeIdentifierHeartRateVariabilitySDNN=authorized\",\n    \"HKQuantityTypeIdentifierHeartRate=authorized\",\n    \"HKQuantityTypeIdentifierRestingHeartRate=authorized\","
    },
    {
      "path": "PulsumUITests/Gate4_CloudConsentUITests.swift",
      "size": 2491,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\nfinal class Gate4_CloudConsentUITests: PulsumUITestCase {\n    func test_enter_key_and_test_connection_shows_ok_pill() throws {\n        launchPulsum()\n        try openSettingsSheetOrSkip()"
    },
    {
      "path": "PulsumUITests/JournalFlowUITests.swift",
      "size": 1622,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\nfinal class JournalFlowUITests: PulsumUITestCase {\n    func testRecordStreamFinish_showsSavedToastAndTranscript() throws {\n        launchPulsum()\n        try openPulseSheetOrSkip()"
    },
    {
      "path": "PulsumUITests/PulsumUITestCase.swift",
      "size": 4236,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\nclass PulsumUITestCase: XCTestCase {\n    var app: XCUIApplication!\n    private let defaultEnvironment = [\n        \"UITEST_USE_STUB_LLM\": \"1\","
    },
    {
      "path": "PulsumUITests/PulsumUITestsLaunchTests.swift",
      "size": 814,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "//\n//  PulsumUITestsLaunchTests.swift\n//  PulsumUITests\n//\n//  Created by Martin Demel on 9/28/25."
    },
    {
      "path": "PulsumUITests/SettingsAndCoachUITests.swift",
      "size": 2395,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import XCTest\nfinal class SettingsAndCoachUITests: PulsumUITestCase {\n    func testCoachChat_withStub_returnsGroundedReply() throws {\n        launchPulsum()\n        try enableCloudConsentIfNeeded()"
    },
    {
      "path": "README.md",
      "size": 20926,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "<p align=\"center\">\n  <img src=\"logo2.png\" alt=\"Pulsum Logo\" width=\"120\" height=\"120\" style=\"border-radius: 24px;\">\n</p>\n<h1 align=\"center\">Pulsum</h1>\n<p align=\"center\">"
    },
    {
      "path": "a-practical-guide-to-building-agents.pdf",
      "size": 7335065,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "agents.md",
      "size": 15581,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# CLAUDE.md\n## Commands\n- Lint: swiftformat --lint .\n- Format: swiftformat .\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository."
    },
    {
      "path": "architecture.md",
      "size": 52430,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "## 1. Title & Commit Info\n- Repo: Pulsum \u2014 Revision: working tree (no VCS tag)\n- Generated on: 2025-10-26T01:14:51Z UTC\n## 2. Executive Summary\n- Pulsum is an iOS 26+ wellbeing coach that boots an `AgentOrchestrator` to connect data ingestion, sentiment capture, safety vetting, and coaching agents behind the SwiftUI front end. Gate 3 added `HealthAccessStatus` + notification seams so DataAgent gates observers on per-type authorization, exposes structured status data to Settings/Onboarding, and uses a single `.pulsumScoresUpdated` bus (journals, sliders, and HealthKit samples) to refresh wellbeing/coach surfaces immediately; the UI now treats wellbeing readiness as a snapshot-only path and loads recommendations asynchronously with debounced/coalesced refreshes so the score card never blocks on the recommendation pipeline. Snapshot responses carry a `WellbeingSnapshotKind` (none/placeholder/real) so the UI can render an explicit warm-up state, and recommendation fetches are hard-timeout bounded with a non-blocking fallback. (Packages/PulsumUI/Sources/PulsumUI/AppViewModel.swift:45-175; Packages/PulsumUI/Sources/PulsumUI/CoachViewModel.swift:1-320; Packages/PulsumAgents/Sources/PulsumAgents/AgentOrchestrator.swift:65-540; Packages/PulsumAgents/Sources/PulsumAgents/DataAgent.swift:58-220)"
    },
    {
      "path": "architecture_short.md",
      "size": 6026,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum Architecture Snapshot\n## Core Principles\n- Agent-first wellness platform where a single `AgentOrchestrator` coordinates specialized agents (Data, Sentiment, Coach, Safety, Cheer) to keep all decision-making ML-driven and consistent with privacy policies.\n- ML-over-rules philosophy: recommendations, chat tone, and scoring rely on learned models (StateEstimator, RecRanker, AFM-guided generation) with deterministic logic limited to statistical baselining.\n- Privacy-first execution: health data, transcripts, embeddings, and vector indexes stay on-device under `NSFileProtectionComplete`; GPT-5 cloud calls only occur with explicit consent and minimal context."
    },
    {
      "path": "audit_gate_0_and_1.md",
      "size": 11496,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum \u2013 Gate 0 & Gate 1 Audit\n## Executive Summary\n- Overall status: PASS \u2014 Gate 0 security blockers and Gate 1 harness requirements are fully satisfied with auditable evidence.\n- What passed at a glance: \u2705 Secrets purged + key precedence tests, \u2705 Privacy manifests + validator script, \u2705 Speech entitlement/mic preflight/PHI logging guards, \u2705 Release build parity + platform guards, \u2705 Data protection + typed AFM stubs, \u2705 FoundationModels gating + deterministic scheme/CI harness.\n- What needs work: None detected for Gate 0/1 scope (residual risks move to later gates per fix.md)."
    },
    {
      "path": "bugs.md",
      "size": 101926,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum Bug Audit\n**Scan Context:** Repo Pulsum @ working tree | UTC 2025-10-26T19:30:00Z\n**Changes in this pass:** Added:11  Updated:15  Obsolete:0  Duplicates:0\n**Coverage Summary:** PulsumApp{files_read:5,lines:727} PulsumUI{files_read:16,lines:4847} PulsumAgents{files_read:8,lines:2563} PulsumServices{files_read:9,lines:3142} PulsumData{files_read:7,lines:1841} PulsumML{files_read:12,lines:2094} Config/Assets{files_read:9} Tests{files_read:6,all_empty_stubs}\n## Quick Readout"
    },
    {
      "path": "bugsplan.md",
      "size": 6076,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum Bug Remediation Plan\n## Guiding Principles\n- Tackle production blockers and compliance exposure first, then restore the end-to-end wellbeing loop, and finally address UX polish and resiliency gaps.\n- When a bug represents a broken contract or security/privacy exposure, fix it in the earliest feasible phase and add automated tests or monitors to prevent regression.\n- After each phase, run the full SwiftPM test suite plus targeted manual checks (voice journal, HealthKit ingestion, GPT consent) before moving forward."
    },
    {
      "path": "calculations.md",
      "size": 11215,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum Scoring Calculations\nThis document captures how Pulsum derives every score that surfaces in the app today. It covers the raw signal preparation, normalization, model weighting, and storage pathways for:\n1. Objective health metrics (Heart Rate Variability, Nocturnal HR, Resting HR, Sleep Debt, Respiratory Rate, Steps)\n2. Subjective pulse inputs (Stress, Energy, Sleep Quality)\n3. Voice journal sentiment"
    },
    {
      "path": "coderabit.md",
      "size": 9620,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# CodeRabbit Validation Report\n**Scan Context:** Manual review of Pulsum working tree @ 2025-10-26.  \n**Docs Covered:** `architecture.md`, `todolist.md`, `bugs.md`, `agents.md`, `instructions.md`.  \n**Swift Coverage:** Key modules in `PulsumAgents`, `PulsumServices`, `PulsumUI`, and Xcode project settings inspected to validate review feedback.\n## Quick Readout"
    },
    {
      "path": "codex_inventory.json",
      "size": 5085530,
      "binary": false,
      "reason": null,
      "ext": ".json",
      "mime": "application/json",
      "sample": "[\n  {\n    \"path\": \".DS_Store\",\n    \"size\": 18436,\n    \"mtime\": 1761443965.0257926,"
    },
    {
      "path": "core/pulsum/review.md",
      "size": 28896,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum vs. Demo Apps SwiftUI Architecture Review\n- Date: 2025-11-02\n- Repo root: Pulsum\n- Commit: 1ceeac6\n## Executive Summary"
    },
    {
      "path": "core/pulsum/status.md",
      "size": 6156,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "**Title & Metadata**\n- Pulsum \u2014 App Status & Stage\n- Date: 2025-11-02\n- Repo root: /Users/martin.demel/Desktop/PULSUM/Pulsum\n**Executive Summary**"
    },
    {
      "path": "coverage_ledger.json",
      "size": 4256208,
      "binary": false,
      "reason": null,
      "ext": ".json",
      "mime": "application/json",
      "sample": "[\n  {\n    \"path\": \".DS_Store\",\n    \"sha256\": \"b1c65921cae6e5efda7bd58d8d9a6c2af81fe8a1ed050e2c58f332ebcad6ff26\",\n    \"status\": \"summarize_only\","
    },
    {
      "path": "files.zlist",
      "size": 1796350,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".zlist",
      "mime": null,
      "sample": null
    },
    {
      "path": "gate2_summary.md",
      "size": 6966,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Gate 2 Summary \u2014 Voice Journaling End-to-End\nThis document freezes the state of Gate\u202f2 (Voice Journaling) as of 2025\u201111\u201112. It records the architectural changes, test coverage, and CI wiring required to keep the gate green in the future.\n---\n## 1. Shared Types & Notifications\n**Package:** `Packages/PulsumTypes`"
    },
    {
      "path": "gate3_summary.md",
      "size": 3509,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Gate 3 \u2014 HealthKit Ingestion & UI Freshness\n## Problem (BUG\u20110024 / 0037 / 0040 / 0043)\n- HealthKit authorization logic was all-or-nothing, so denied/not-determined types still started observers and Settings couldn\u2019t show partial status.\n- Restarting ingestion after the user re-granted access duplicated observers and left revoked types running.\n- `AgentOrchestrator.postScoresUpdated` was removed but nothing replaced it, so `.pulsumScoresUpdated` never fired after HealthKit ingest or manual recomputes."
    },
    {
      "path": "gate4_summary.md",
      "size": 5142,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Gate 4 \u2014 RAG / LLM Wiring & Consent UX\n## Problem (BUG\u20110004 / 0008 / 0010 / 0023 / 0041)\n- Guardrail payloads sent to GPT\u20115 omitted micro\u2011moment context, violating the minimized\u2011context contract and letting cloud replies drift off-topic.\n- Fallback routing probed feature keys that don\u2019t exist in `FeatureVectorSnapshot`, so \u201cdata-dominant\u201d decisions always defaulted to `subj_energy`.\n- Settings had no working Apple Intelligence CTA, no runtime GPT key storage, and no deterministic Save/Test UX; ESC key dismissal crashed because `.onKeyPress` closures returned `Void`."
    },
    {
      "path": "gate5_summary.md",
      "size": 6266,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Gate 5 \u2014 Vector Index Safety & Data I/O Integrity\n## Problem (BUG\u20110012 / 0017 / 0013 / 0022 / 0036)\n- Vector index shards used double\u2011checked locking with unsynchronized dictionary reads, so concurrent search/upsert/remove could race shard initialization and corrupt on\u2011disk data (S0).\n- `FileHandle.close()` failures in shard writes were swallowed with `try?`, leading to silent descriptor leaks and undetected I/O corruption (S1).\n- `LibraryImporter` performed `Data(contentsOf:)` + JSON decoding inside `context.perform`, blocking Core Data\u2019s serial queue and freezing UI work whenever podcasts were imported (S2)."
    },
    {
      "path": "gate6_analysis.md",
      "size": 7375,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "## Summary\n- Embedding stack is now opportunistic AFM with a hardened CoreML fallback: zero vectors throw, availability is probed once, and coverage only fails closed when all on-device providers are down.\n- Wellbeing pipeline now normalizes/clamps inputs (including sentiment), uses recovery-positive seeds, persists the StateEstimator, and drives a new wellbeing state model so UI surfaces clear loading/no-data/denied/error states instead of spinning forever.\n- Personalization and health UX tightened: RecRanker learns from feedback, HealthKit request/denied/unavailable paths are surfaced consistently across main/insights/settings, and docs/tests lock the Gate 6 fixes.\n## Changes by Area"
    },
    {
      "path": "gate6_summary.md",
      "size": 7045,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Gate 6 \u2014 ML correctness & personalization\n## Code changes\n- `Packages/PulsumAgents/Sources/PulsumAgents/DataAgent.swift`, `Packages/PulsumAgents/Tests/PulsumAgentsTests/Gate6_WellbeingBackfillPhasingTests.swift`: `start()`/`requestHealthAccess()` now perform a 2-day bootstrap synchronously for a fast first score, then schedule the 7-day warm-start + 30-day backfill in the background. Snapshot notifications are debounced to a single `.pulsumScoresUpdated` per batch with per-batch log summaries.\n- `Packages/PulsumUI/Sources/PulsumUI/CoachViewModel.swift`: keeps wellbeing state in the last known value after the first load so background backfill no longer flips the main card back to \u201cCalculating\u2026\u201d.\n- `Packages/PulsumAgents/Sources/PulsumAgents/DebugLogBuffer.swift`: increased capacity (2000 lines) and added test-only reset; `DebugLogBufferTests` guard ring buffer behavior."
    },
    {
      "path": "gates.md",
      "size": 32829,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "Got it \u2014 I read **every line** of your `bugs.md` (43 bugs) and the companion `architecture.md` spec and used them as the source of truth for the plan below. Nothing in this plan is guessed; where the documents themselves raise unknowns (e.g., the iOS Settings deep link for Apple Intelligence), I call that out so we can decide before coding.  \n---\n## Gate Progress Tracker\n| Gate | Focus | Status | Notes |\n| --- | --- | --- | --- |"
    },
    {
      "path": "gates_learnings.md",
      "size": 5798,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "Short version: yes, everything looks merged correctly now, and what you\u2019re seeing in the branch list is totally normal. Let\u2019s capture the \u201cgate playbook\u201d so future Gates don\u2019t turn into another multi-day odyssey.\nI\u2019ll break it into three parts you can reuse in prompts: branching + commits, testing/CI, and docs/gates alignment.\n\u2e3b\n1. Branching & commits \u2013 how to structure future Gates\nUse this pattern for every new Gate (3, 4, \u2026):"
    },
    {
      "path": "geminibugs.md",
      "size": 6328,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Gemini 3 Technical Audit (`geminibugs.md`)\n## 1. Architecture Consistency Check\n- **Status:** Critical Deviations\n- **Analysis:** The codebase generally follows the modular architecture defined in `architecture.md` with clear separation of Agents, Services, and Data. However, key \"Modern\" features relying on iOS 26+ are implemented as stubs or disabled, violating the functional promise of the architecture.\n- **Violations:**"
    },
    {
      "path": "github_cheat_sheet.md",
      "size": 7722,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# GitHub How-To (Pulsum) \u2014 Printable Cheat Sheet\nA compact guide to the **what/why/how** of Git & GitHub for your Pulsum repo, with **copy-pasteable commands**. Keep this next to your keyboard.\n---\n## 1) Core words (what they mean)\n* **Repository (repo)**: Your project\u2019s versioned database (local and on GitHub)."
    },
    {
      "path": "github_master_gate.md",
      "size": 8926,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum \u2014 Gate-by-Gate GitHub Playbook (for \u201cOpenAI Codex 5 High\u201d)\nA single, detailed, **copy\u2011pasteable** guide for how you (and your AI assistants) should branch, commit, PR, merge, tag, and verify **each Gate** (Gate 1, Gate 2, \u2026) using the **same best practices** we finalized for **Gate 0**\u2014with corrections for pitfalls we hit.\n---\n## 0) Principles this document enforces\n* **One Gate = One PR** from a **dedicated branch**; use **Squash & Merge**."
    },
    {
      "path": "gpt5_1_prompt_guide.md",
      "size": null,
      "binary": true,
      "reason": "read error: [Errno 2] No such file or directory: '/Users/martin.demel/Desktop/PULSUM/Pulsum/gpt5_1_prompt_guide.md'",
      "ext": ".md",
      "mime": "text/markdown",
      "sample": null
    },
    {
      "path": "iconlogo.png",
      "size": 1075847,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".png",
      "mime": "image/png",
      "sample": null
    },
    {
      "path": "iconnew.png",
      "size": 1003595,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".png",
      "mime": "image/png",
      "sample": null
    },
    {
      "path": "infinity_blubs_copy.splineswift",
      "size": 272828,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".splineswift",
      "mime": null,
      "sample": null
    },
    {
      "path": "instructions.md",
      "size": 32807,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "Pulsum \u2014 Final Production Build Spec (iOS 26, Liquid Glass, Agent\u2011First)\nROLE\nYou are a principal iOS architect and staff\u2011level Swift engineer. Build a production, App\u2011Store\u2011ready version of Pulsum\u2014no placeholders, no mock UIs, no fake backends. Every feature must function end\u2011to\u2011end.\nInitially, analyze the entire codebase, including all folders and subfolders, as well as all files within these folders, to understand what is already available from the Xcode project. Do not skip lines; read it all. I have also added instructions.md that have these instructions and you can read it whenever required to ensure you adhere 100%. Create a todolist.md file where you will track all the details and activities as you split this work into several milestones. That way, if required, I can use the next chat window to continue from where you left off. Ensure you always update the todolist.md file when completing such work or task part.\n\u2e3b"
    },
    {
      "path": "inventory.json",
      "size": 43254,
      "binary": false,
      "reason": null,
      "ext": ".json",
      "mime": "application/json",
      "sample": "{\n  \"root\": \"/Users/martin.demel/Desktop/PULSUM/Pulsum\",\n  \"generated_at\": \"2025-10-26T01:02:02.195681Z\",\n  \"total_files\": 150,\n  \"entries\": ["
    },
    {
      "path": "ios app mockup.png",
      "size": 2821699,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".png",
      "mime": "image/png",
      "sample": null
    },
    {
      "path": "ios support documents/Adding intelligent app features with generative models _ Apple Developer Documentation.pdf",
      "size": 101354,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/Adopting Liquid Glass _ Apple Developer Documentation.pdf",
      "size": 4863584,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/Foundation Models _ Apple Developer Documentation.pdf",
      "size": 790023,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/Generating content and performing tasks with Foundation Models _ Apple Developer Documentation.pdf",
      "size": 721092,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/Improving the safety of generative model output _ Apple Developer Documentation.pdf",
      "size": 1137316,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/Landmarks_ Applying a background extension effect _ Apple Developer Documentation.pdf",
      "size": 2098656,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/Landmarks_ Building an app with Liquid Glass _ Apple Developer Documentation.pdf",
      "size": 7313354,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/Landmarks_ Displaying custom activity badges _ Apple Developer Documentation.pdf",
      "size": 1873402,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/Landmarks_ Extending horizontal scrolling under a sidebar or inspector _ Apple Developer Documentation.pdf",
      "size": 1632595,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/Landmarks_ Refining the system provided Liquid Glass effect in toolbars _ Apple Developer Documentation.pdf",
      "size": 1398959,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/Liquid Glass _ Apple Developer Documentation.pdf",
      "size": 4276716,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/Support languages and locales with Foundation Models _ Apple Developer Documentation.pdf",
      "size": 388923,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/SystemLanguageModel _ Apple Developer Documentation.pdf",
      "size": 351666,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/aGenerating content and performing tasks with Foundation Models _ Apple Developer Documentation.pdf",
      "size": 720230,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support documents/iOS & iPadOS 26 Release Notes _ Apple Developer Documentation.pdf",
      "size": 1210570,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".pdf",
      "mime": "application/pdf",
      "sample": null
    },
    {
      "path": "ios support files/glow.swift",
      "size": 4626,
      "binary": false,
      "reason": null,
      "ext": ".swift",
      "mime": null,
      "sample": "import SwiftUI\nstruct GlowEffect: View {\n    @State private var gradientStops: [Gradient.Stop] = GlowEffect.generateGradientStops()\n    var body: some View {\n        ZStack {"
    },
    {
      "path": "liquidglass.md",
      "size": 48367,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum iOS App - Liquid Glass Design Implementation Guide\n**Target:** iOS 26+ | **Design Language:** Liquid Glass | **Date:** September 30, 2025  \n**Purpose:** Complete reference for Claude Code to rework Pulsum app with Apple's Liquid Glass design system\n---\n## Table of Contents"
    },
    {
      "path": "logo.jpg",
      "size": 152344,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".jpg",
      "mime": "image/jpeg",
      "sample": null
    },
    {
      "path": "logo2.png",
      "size": 585439,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".png",
      "mime": "image/png",
      "sample": null
    },
    {
      "path": "main.gif",
      "size": 21811312,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".gif",
      "mime": "image/gif",
      "sample": null
    },
    {
      "path": "mainanimation.usdz",
      "size": 47388,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".usdz",
      "mime": null,
      "sample": null
    },
    {
      "path": "openai_summary_chat_gate4.md",
      "size": 110834,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "Now you have to create prompt for the gate 4 below are the instructions. think ultrahrad. learn form the past prompts and inforkmations.\nWrite me detailed prompt that would follow the guidelines, the scope defined in the gate 4 and will incorporate all the lessons learned from the previous implenetnations, especially around testing,. ensuring that its implemented properly, testing is performed correctly and linekd correctly and the bugs or issues in the gate 4 are fixed correctly. furthermore the ficxes needs to be aligned with the architecture.md and todolist.md and other documents in the project folder. read all the docuemnt. Below is example of the prompt for gate 0 so you can use it to start with but ehnacne it with what you have learend that needs to be addressed. The prompt below is only for reference purpose, do not exxecute the prompt, just read it how you defined the prompt previously and you can use it for the prompt for the gate 4 but it must be aligned with the 2 pdf attached which defines the way the prompt should be! Read carefully the attached files. the gates.md has all the infromations for the gate 4. \ndefione clearly start and the end of the prompt, do not use the mnt/data as this is youres, all the filkes are in the same folder as the entire project! .\nBelow is a **copy\u2011paste prompt** you can run in your code agent (Codex / \u201chigh\u2011thinking 5\u201d) to implement **Gate 0 \u2014 Security & Build Blockers** end\u2011to\u2011end. I built it to follow OpenAI\u2019s **GPT\u20115 prompting** practices (explicit roles, evals, stepwise verification, and steerability settings) and the engineering prompt patterns recommended for code automation.  \nIt is grounded in your repo\u2019s **bugs.md** and **architecture.md**; the bug IDs and acceptance criteria below match those files and reference their evidence/locations so the agent has the exact anchors to modify.  "
    },
    {
      "path": "podcastrecommendations 2.json",
      "size": 52726,
      "binary": false,
      "reason": null,
      "ext": ".json",
      "mime": "application/json",
      "sample": " [\n  {\n    \"episodeNumber\": \"199\",\n    \"episodeTitle\": \"Arnold's Pump Club - #199 It Doesn't Fcking Matter\",\n    \"recommendations\": ["
    },
    {
      "path": "review_calculation_summary.md",
      "size": 253929,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "### Packages/PulsumServices/Sources/PulsumServices/HealthKitService.swift\n```swift\nimport Foundation\n@preconcurrency import HealthKit\npublic protocol HealthKitObservationToken: AnyObject {}"
    },
    {
      "path": "scripts/ci/build-release.sh",
      "size": 265,
      "binary": false,
      "reason": null,
      "ext": ".sh",
      "mime": "application/x-sh",
      "sample": "#!/usr/bin/env bash\nset -euo pipefail\nROOT_DIR=\"$(git rev-parse --show-toplevel 2>/dev/null || pwd)\"\ncd \"$ROOT_DIR\"\nxcodebuild -scheme Pulsum -configuration Release build \\"
    },
    {
      "path": "scripts/ci/check-privacy-manifests.sh",
      "size": 3291,
      "binary": false,
      "reason": null,
      "ext": ".sh",
      "mime": "application/x-sh",
      "sample": "#!/usr/bin/env bash\nset -euo pipefail\nROOT_DIR=\"$(git rev-parse --show-toplevel 2>/dev/null || pwd)\"\ncd \"$ROOT_DIR\"\nRED=\"\\033[31m\""
    },
    {
      "path": "scripts/ci/integrity.sh",
      "size": 8127,
      "binary": false,
      "reason": null,
      "ext": ".sh",
      "mime": "application/x-sh",
      "sample": "#!/usr/bin/env bash\nset -euo pipefail\nROOT_DIR=\"$(git rev-parse --show-toplevel 2>/dev/null || pwd)\"\ncd \"$ROOT_DIR\"\npass() { printf \"\\033[32m%s\\033[0m\\n\" \"$1\"; }"
    },
    {
      "path": "scripts/ci/scan-placeholders.sh",
      "size": 632,
      "binary": false,
      "reason": null,
      "ext": ".sh",
      "mime": "application/x-sh",
      "sample": "#!/usr/bin/env bash\nset -euo pipefail\nROOT_DIR=\"$(git rev-parse --show-toplevel 2>/dev/null || pwd)\"\ncd \"$ROOT_DIR\"\nRED=\"\\033[31m\""
    },
    {
      "path": "scripts/ci/scan-secrets.sh",
      "size": 1961,
      "binary": false,
      "reason": null,
      "ext": ".sh",
      "mime": "application/x-sh",
      "sample": "#!/usr/bin/env bash\nset -euo pipefail\nROOT_DIR=\"$(git rev-parse --show-toplevel 2>/dev/null || pwd)\"\ncd \"$ROOT_DIR\"\nRED=\"\\033[31m\""
    },
    {
      "path": "scripts/ci/test-harness.sh",
      "size": 8059,
      "binary": false,
      "reason": null,
      "ext": ".sh",
      "mime": "application/x-sh",
      "sample": "#!/usr/bin/env bash\nset -euo pipefail\nROOT_DIR=\"$(git rev-parse --show-toplevel 2>/dev/null || pwd)\"\ncd \"$ROOT_DIR\"\nexport COPYFILE_DISABLE=1"
    },
    {
      "path": "scripts/ci/ui-tests.sh",
      "size": 1319,
      "binary": false,
      "reason": null,
      "ext": ".sh",
      "mime": "application/x-sh",
      "sample": "#!/usr/bin/env bash\nset -euo pipefail\nSCHEME=${SCHEME:-Pulsum}\nCONFIG=${CONFIG:-Debug}\nDERIVED=${DERIVED:-Build}"
    },
    {
      "path": "sha256.txt",
      "size": 2838664,
      "binary": false,
      "reason": null,
      "ext": ".txt",
      "mime": "text/plain",
      "sample": "b1c65921cae6e5efda7bd58d8d9a6c2af81fe8a1ed050e2c58f332ebcad6ff26  .DS_Store\nbf958c047a166e897967eb1ea15f63756cec69a4721964dbc685c16d0ac90ce4  .claude/settings.local.json\nf03696726f48b362128f629b36624fd88aebce0a0fe328262535340984e2fbda  .github/coderabbit.yaml\n0512dcbd61988c4f4229dfa033be784b9be92295e1ce6c65d8f2a4f5fe219ab9  .github/workflows/auto-merge.yml\n3065d4e0b62f2faf6cef076c3e9b55e42546f861e8bb8ba4532d10124ae331d3  .github/workflows/auto-pr.yml"
    },
    {
      "path": "streak_low_poly_copy.splineswift",
      "size": 49425,
      "binary": true,
      "reason": "contains NUL bytes",
      "ext": ".splineswift",
      "mime": null,
      "sample": null
    },
    {
      "path": "terminal_1.md",
      "size": 529404,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "Last login: Mon Nov 10 22:31:55 on ttys006\n(base) martin.demel@Martins-MacBook-Pro ~ % cd desktop\n(base) martin.demel@Martins-MacBook-Pro desktop % cd pulsum\n(base) martin.demel@Martins-MacBook-Pro pulsum % cd pulsum\n(base) martin.demel@Martins-MacBook-Pro pulsum % xcodebuild test \\"
    },
    {
      "path": "terminal_new.md",
      "size": 715472,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "Last login: Mon Nov 10 22:14:17 on ttys006\n(base) martin.demel@Martins-MacBook-Pro ~ % cd desktop\n(base) martin.demel@Martins-MacBook-Pro desktop % cd pulsum\n(base) martin.demel@Martins-MacBook-Pro pulsum % cd pulsum\n(base) martin.demel@Martins-MacBook-Pro pulsum % # Clean + rebuild Release for Simulator with signing skipped"
    },
    {
      "path": "testfile",
      "size": 2,
      "binary": false,
      "reason": null,
      "ext": "",
      "mime": null,
      "sample": "hi"
    },
    {
      "path": "tests_automation.md",
      "size": 10355,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "Got it\u2014I understand. You want an automated \u201ctest-updater\u201d so when you land future gates (3, 4, 5, \u2026) the repo detects code changes, generates/updates the right tests, runs them, and proposes the patch without you hand-editing every test file.\nBelow is a practical blueprint that teams actually use, with safe human-in-the-loop controls. It combines:\n\t\u2022\tGatekeeper checks that force tests to exist (Danger + coverage),\n\t\u2022\tImpact detection to find what changed,\n\t\u2022\tAn AI test agent that drafts/update tests and opens a small follow-up PR,"
    },
    {
      "path": "todolist.md",
      "size": 23202,
      "binary": false,
      "reason": null,
      "ext": ".md",
      "mime": "text/markdown",
      "sample": "# Pulsum Production Build - TODO\n## Milestone 0 - Repository Audit (Complete)\n- [x] Reviewed all existing source files (`PulsumApp.swift`, `ContentView.swift`, `Persistence.swift`, Core Data model, assets)\n- [x] Inspected Xcode project settings (`Pulsum.xcodeproj`, workspace state, schemes)\n- [x] Cataloged support materials (`ios support documents`, `ios support files/glow.swift`, `json database/podcastrecommendations (38).json`, media assets)"
    }
  ]
}
````
<!-- END_FILE: baseline 5_2/baseline_file_inventory_5_2.json -->

### inventory.json
- bytes: 43254
- lines: 1191
- sha256: e9d5457fe71d90923cc6fbb67aa062c53c47d7fb716d87b5b390b72e1ac3d6bb
- trailing_newline: true

<!-- BEGIN_FILE: inventory.json -->
```text
{
  "root": "/Users/martin.demel/Desktop/PULSUM/Pulsum",
  "generated_at": "2025-10-26T01:02:02.195681Z",
  "total_files": 150,
  "entries": [
    {
      "path": "podcastrecommendations 2.json",
      "size": 52726,
      "mtime": 1759809611.3401027,
      "sha256": "50464a3a1673f4845622281d00ecf5099e62bd72d99099fe1ea7d218b0a1f35c",
      "read_intent": "read",
      "reason": "JSON resource"
    },
    {
      "path": "Config.xcconfig.template",
      "size": 265,
      "mtime": 1760906075.0978625,
      "sha256": "d75959e8c7c3d7dfda38118bb7367b04df93c6560e3134007f65f1aa862a213f",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": ".DS_Store",
      "size": 18436,
      "mtime": 1761438723.2901042,
      "sha256": "1a398ceb449cc415441ddd5593683a4cd7e6675c2b3f7ff639fa1991a46a2d15",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "ios app mockup.png",
      "size": 2821699,
      "mtime": 1759809611.2747805,
      "sha256": "a0d118c867dba9ef8f52097419c608d7912946fcd85e7584df81b189a38094ff",
      "read_intent": "summarize_only",
      "reason": "Image asset"
    },
    {
      "path": "a-practical-guide-to-building-agents.pdf",
      "size": 7335065,
      "mtime": 1759809611.2647758,
      "sha256": "1903c2b1837b206d1951d8a3d1124515aee1bebebd8f2448c630c75a6b0aad86",
      "read_intent": "summarize_only",
      "reason": "PDF asset"
    },
    {
      "path": "infinity_blubs_copy.splineswift",
      "size": 272828,
      "mtime": 1759809611.267177,
      "sha256": "fe4f7c35996a6a20cf60816d913b93aa18ca959e8b8ef3bb5acfa04dd704c461",
      "read_intent": "summarize_only",
      "reason": "Spline design asset"
    },
    {
      "path": "Config.xcconfig",
      "size": 394,
      "mtime": 1760906075.089506,
      "sha256": "e2c5860800919e53b398da5079492b06908df4b74ac1a34728bc6af5d037e33a",
      "read_intent": "read",
      "reason": "Build configuration"
    },
    {
      "path": ".gitignore",
      "size": 396,
      "mtime": 1760906075.1065257,
      "sha256": "d3c46a4b76a774dda3ff448241318cf82c4e3e8a3e9b680c4573880e1e96355e",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "logo.jpg",
      "size": 152344,
      "mtime": 1759809611.3379455,
      "sha256": "49ecea236ea825afed3f4dbe6f374299cbbb87aadbaaf5ce029c8c7c1ca34de2",
      "read_intent": "summarize_only",
      "reason": "Image asset"
    },
    {
      "path": "logo2.png",
      "size": 585439,
      "mtime": 1759809611.3391683,
      "sha256": "0cb9ec37668a50f75151942e2d993608f7a9507c805fabac700cae47805bfe46",
      "read_intent": "summarize_only",
      "reason": "Image asset"
    },
    {
      "path": "mainanimation.usdz",
      "size": 47388,
      "mtime": 1759809611.3398817,
      "sha256": "9dd79ebe7c92c39a772b39316f8dbf3c4c459721363aaee27215453374e9a0e3",
      "read_intent": "summarize_only",
      "reason": "3D asset"
    },
    {
      "path": "streak_low_poly_copy.splineswift",
      "size": 49425,
      "mtime": 1759809611.340577,
      "sha256": "60b540c0a7857b24f6406627dd3f64b7760d08037d4384aaaf4e99b66a7fd9b9",
      "read_intent": "summarize_only",
      "reason": "Spline design asset"
    },
    {
      "path": "inventory.json",
      "size": 43726,
      "mtime": 1761440471.798771,
      "sha256": "65710ef7d90de6b9b747288abc0ae48759761b690c9a2909a85ecc64fd98ee12",
      "read_intent": "read",
      "reason": "JSON resource"
    },
    {
      "path": "MAINDESIGN.png",
      "size": 3873254,
      "mtime": 1759809611.1664338,
      "sha256": "2b9e9954ae9bc6745f489cb2b13ca1107537986573244cfe11118addd2cd6975",
      "read_intent": "summarize_only",
      "reason": "Image asset"
    },
    {
      "path": "ios support files/glow.swift",
      "size": 4626,
      "mtime": 1759809611.3371205,
      "sha256": "59923efcc4ec5f2dabbd2dfd67bb10d0e73247d0334975d171ffa84fb5bd1535",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": ".claude/settings.local.json",
      "size": 481,
      "mtime": 1761279124.8097503,
      "sha256": "bf958c047a166e897967eb1ea15f63756cec69a4721964dbc685c16d0ac90ce4",
      "read_intent": "read",
      "reason": "JSON resource"
    },
    {
      "path": "Docs/FIX_SPLINE_CRASH_PROMPT.txt",
      "size": 2256,
      "mtime": 1759809611.1592872,
      "sha256": "830c45a76c6a7109f038d5f4b20c12e8de841df58fa29d5710cafa11e46008d3",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Docs/SPLINE_CLOUD_ONLY_PROMPT.txt",
      "size": 2599,
      "mtime": 1759809611.1620507,
      "sha256": "fe4d1c4b9260fa05f4d20e904f9b0fc373b74008236ef8aecedcd7ca9b29e117",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Docs/MILESTONE_4_UI_REDESIGN_PROMPT.txt",
      "size": 16927,
      "mtime": 1759809611.1607606,
      "sha256": "1894a5d99cc06be2d3b3bd42d7af88083e3ded0edb11763af831a21a2c2a5ae7",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Docs/COPY_PASTE_PROMPT_M4.txt",
      "size": 7909,
      "mtime": 1759809611.1587849,
      "sha256": "3bb28db4a085ece3d40d6c532327a802ceb07c6a2bc25a5aa28e3f28c8e655ba",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Packages/.DS_Store",
      "size": 8196,
      "mtime": 1759691780.1655834,
      "sha256": "dbb72c8c84423ef5f3fcf5649bf1afa0622c8f0022a364b17068b78a870643f4",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Packages/PulsumUI/.DS_Store",
      "size": 6148,
      "mtime": 1759598593.6671662,
      "sha256": "2cca71698fd0412f840443324b67c3416c8eae89ad4699212b0b25792ca96d10",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Packages/PulsumUI/Package.swift",
      "size": 814,
      "mtime": 1760031437.9958286,
      "sha256": "585083d098b01385e87f8a24fca024ee9d8127e7f37a05d62a440dd92a3036b2",
      "read_intent": "read",
      "reason": "Swift package manifest"
    },
    {
      "path": "Packages/PulsumUI/Tests/PulsumUITests/PulsumRootViewTests.swift",
      "size": 191,
      "mtime": 1759809611.1877763,
      "sha256": "b1108a5b5668d328870a81bf9095e4bff0d37c1a5521d0e048c8f4134ab54ec7",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/.DS_Store",
      "size": 6148,
      "mtime": 1759968726.0998168,
      "sha256": "53dab547b811d30d39c101d21efb48a102eb84666359dfc67a9ecf79fcbeb7a4",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/GlassEffect.swift",
      "size": 4944,
      "mtime": 1759809611.1850753,
      "sha256": "c2ae598acc53f0de0730b7ece4407590bd105593018c4b76e001069fac6294b5",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/PulseViewModel.swift",
      "size": 7353,
      "mtime": 1761437479.758582,
      "sha256": "e2ca1f57c41841d146e44ad69a78b9584bc9f090229e9b3c047fb96d5212b17e",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/SettingsView.swift",
      "size": 25058,
      "mtime": 1760906074.9474463,
      "sha256": "1948212450f9ed8622c26b71cae9a9a8e6d63bf94162cf21f529c9f7d4d84bd8",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/LiquidGlassComponents.swift",
      "size": 7132,
      "mtime": 1759809611.1852696,
      "sha256": "dc0d1fc7d14677e5d0339a08bd00c7c5c8dc64e22cdfee7fcc6f8c47dffbeeb8",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownView.swift",
      "size": 19034,
      "mtime": 1760906075.0460708,
      "sha256": "655d627ead4a94c2885f50628faa9e7e52dc5ead3acb2a6472b4a538693b64a7",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/SettingsViewModel.swift",
      "size": 7386,
      "mtime": 1760906075.183319,
      "sha256": "f278dd05deb7b183d07aea7d43a39ec12c317d5cb41105b95f68e1b0a9e6a0c0",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/PulsumDesignSystem.swift",
      "size": 7850,
      "mtime": 1760906074.8885448,
      "sha256": "1161eba2b1c5fd1e7416822f23f46e26b55657d2ee00af5d9f06b5bd32edd348",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/PulsumRootView.swift",
      "size": 9953,
      "mtime": 1760906075.064296,
      "sha256": "f088db87fa978494a888d5baefc94e2c041305490a95678cffb6ed8ba76002aa",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/ConsentBannerView.swift",
      "size": 2389,
      "mtime": 1760906074.906182,
      "sha256": "2c838b1b47dd2b59468c519b73a204014f0ba9e643851cd620935adf321d0a34",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/PulseView.swift",
      "size": 14986,
      "mtime": 1761437479.8886716,
      "sha256": "001dd9b7bf32930814fb1e41576e0976e1ca01204d64b125942d470ac3682cf5",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/CoachViewModel.swift",
      "size": 4976,
      "mtime": 1759809611.1845472,
      "sha256": "4522419d0d3a7289a2365060e779fecf5ec66ed93581253177c0bc8c587e5246",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/AppViewModel.swift",
      "size": 7277,
      "mtime": 1759973877.4582686,
      "sha256": "ee5895c8a22b9d4c8addf394019a063336f39f9c18d104412e44e6b957df533b",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/SafetyCardView.swift",
      "size": 3064,
      "mtime": 1760906074.9177492,
      "sha256": "08166a48a28937cd545fa2faf66369993fc90823495946969ee0a881b9a43342",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/ScoreBreakdownViewModel.swift",
      "size": 2037,
      "mtime": 1759809611.187047,
      "sha256": "7371c226b1fdaf6935cdd7f6ac13be49f9cb3ac6c9ef942f21b2e560b9396710",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/CoachView.swift",
      "size": 15398,
      "mtime": 1760906075.2534003,
      "sha256": "ce85b5da30533ea7544a1460d71c7f2ffa41560d8e207e1f86bc825d5ab15c6b",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/Sources/PulsumUI/OnboardingView.swift",
      "size": 11264,
      "mtime": 1759809611.185495,
      "sha256": "c5ea4d6beaa429640fdb06047222ba369284dc6f96e6c022ec6b30105e664e11",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumUI/.swiftpm/xcode/xcuserdata/martin.demel.xcuserdatad/xcschemes/xcschememanagement.plist",
      "size": 343,
      "mtime": 1760934638.615441,
      "sha256": "df00e59ce927f2bb8b331d47d40ee8e66198c9db2fe494118149474107581220",
      "read_intent": "read",
      "reason": "Property list"
    },
    {
      "path": "Packages/PulsumServices/.DS_Store",
      "size": 6148,
      "mtime": 1759464495.0936685,
      "sha256": "53b3bdf7a013918978f47a4459093e709b65514eae8ddc02d35fb4d8184aefc1",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Packages/PulsumServices/Package.swift",
      "size": 861,
      "mtime": 1760031437.89869,
      "sha256": "f002caff905dda0342f328427a2325f8e05e78d886038c597c1dba39fb9549c2",
      "read_intent": "read",
      "reason": "Swift package manifest"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewayTests.swift",
      "size": 9964,
      "mtime": 1759810004.4467058,
      "sha256": "d8142f57e793ac4a4f8c92bfdc99a7639a924fb5ea372d4ba874905c47dd6bad",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/HealthKitAnchorStoreTests.swift",
      "size": 1910,
      "mtime": 1759809611.1824086,
      "sha256": "cf5714930608e9fd3231b12e646de79837ecba7543a3760c295275c747ab5ed6",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/PulsumServicesDependencyTests.swift",
      "size": 506,
      "mtime": 1759809611.1831684,
      "sha256": "1df9d256c36836d2610cfc95c7ccddc27ed8cc5b3e85eae388bac384acb7f6f2",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/LLMGatewaySchemaTests.swift",
      "size": 7375,
      "mtime": 1759810004.467437,
      "sha256": "d5ea067803f60f483191e366aba5355edc66be5f5a21e2994ce7cdf467c5b320",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Tests/PulsumServicesTests/KeychainServiceTests.swift",
      "size": 490,
      "mtime": 1759809611.1825852,
      "sha256": "385fa2e3d8666fd9112ecddfccfd9c595c156d217d6e290872561811f28eb69c",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Tests/Support/LLMURLProtocolStub.swift",
      "size": 3583,
      "mtime": 1759809611.1834023,
      "sha256": "23c942a7972247f22a1af5a7f4778248af3cd4d6b783451f31c52d529b68d9a8",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Sources/.DS_Store",
      "size": 8196,
      "mtime": 1759628506.1195416,
      "sha256": "28bce63dc53e9887cf1e94ce4b263003f26138aa28231cccf590b29d6be1fbc3",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/KeychainService.swift",
      "size": 2857,
      "mtime": 1759809611.1811645,
      "sha256": "24778f8f97364a805d7dcb126be6a95f4f5c4cc55ded669e402a51f3fded6d3e",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/CoachPhrasingSchema.swift",
      "size": 2365,
      "mtime": 1759809611.180072,
      "sha256": "fb03e55fe72a1eabe811058bd87d6d58077a777e9794804f0394273f18c3d20b",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/HealthKitAnchorStore.swift",
      "size": 2676,
      "mtime": 1759809611.180765,
      "sha256": "764cde0834fb841207106f72ae68238256ecf73b622255fc2e770baf9ac62d68",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/FoundationModelsCoachGenerator.swift",
      "size": 4895,
      "mtime": 1760031438.3731122,
      "sha256": "60971352cdf6f3bac4be66adb8872ed0332fe5959aca07cbd457169ac38d0d73",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/HealthKitService.swift",
      "size": 9599,
      "mtime": 1759809611.1809936,
      "sha256": "e25ed111dad8e224268424a1e0b5bdb303cf410529a21a4a7916c398b4f5e1f8",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/LLMGateway.swift",
      "size": 29309,
      "mtime": 1760906075.1573079,
      "sha256": "b9ea933fbb566b2e2868844047c47ec5808345b9366c9f7af25991bff9efe545",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/SpeechService.swift",
      "size": 11776,
      "mtime": 1761437478.892006,
      "sha256": "4af43e63fbfda5af618598ad40a340cb89d9266b4f39c84eee83f0db12bffd3a",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/Placeholder.swift",
      "size": 543,
      "mtime": 1759809611.1815963,
      "sha256": "8939f52054e950b10a8b8936c3b7bd00d9da5254bea740a1aa0a04e347ea10b8",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/Sources/PulsumServices/DiagnosticsNotifications.swift",
      "size": 240,
      "mtime": 1759809611.180338,
      "sha256": "a8b83a1cdd7a2d53e06bd975c3e58b499cd5199dc7b0a07f4f130f94780759d9",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumServices/.swiftpm/xcode/xcuserdata/martin.demel.xcuserdatad/xcschemes/xcschememanagement.plist",
      "size": 349,
      "mtime": 1760925299.4380672,
      "sha256": "49854046ee2c2c607d2863a43e51a124accd4f1c0544012a819ac21c7d33dc0f",
      "read_intent": "read",
      "reason": "Property list"
    },
    {
      "path": "Packages/PulsumData/.DS_Store",
      "size": 6148,
      "mtime": 1759464495.0911777,
      "sha256": "e823f0b81869cdc6b92af386bc3e933167a8d3610dfbabdfc2a5a7f64e3f9d1e",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Packages/PulsumData/Package.swift",
      "size": 759,
      "mtime": 1760031437.864304,
      "sha256": "2125b2e2a0a810e14680f77eead1c5de50526b1e0f25bcc6e4360559f89a242b",
      "read_intent": "read",
      "reason": "Swift package manifest"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/PulsumDataBootstrapTests.swift",
      "size": 1166,
      "mtime": 1759809611.172149,
      "sha256": "bed04ed0334fbac69018d6d040c366cf9a8ff4b49f88e00c6dac60adbc4a1b20",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/LibraryImporterTests.swift",
      "size": 1292,
      "mtime": 1759809611.172009,
      "sha256": "2652eb06da2449680dbe99b8349ea024deaa750cb03c7be0e84486eed60d4a30",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/VectorIndexTests.swift",
      "size": 588,
      "mtime": 1759809611.1724966,
      "sha256": "67512dad12b68e710c97d3c155fc1cfb54b654745b165455d804bd67cf306473",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumData/Tests/PulsumDataTests/Resources/podcasts_sample.json",
      "size": 785,
      "mtime": 1759809611.1723433,
      "sha256": "6a63e871a113e1294d5958150892d674f9098a7bade4bd18931c7a8ec02f96da",
      "read_intent": "read",
      "reason": "JSON resource"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/VectorIndexManager.swift",
      "size": 1464,
      "mtime": 1759809611.1717665,
      "sha256": "4eeef318abf1f10edfa518682be2b01b0a5a5aca891b982c37963ddd9888d8f4",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/DataStack.swift",
      "size": 5966,
      "mtime": 1759809611.170639,
      "sha256": "3779d5b57efc30687ac98caa21901e86d4ef1bdfcb5d392a0ee5b678612553b4",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/VectorIndex.swift",
      "size": 14583,
      "mtime": 1759809611.1716244,
      "sha256": "a214853eb53e05c1aae13fd1c48d90d513b493f749ac3855d5363b1d7a315515",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/EvidenceScorer.swift",
      "size": 957,
      "mtime": 1759809611.1707828,
      "sha256": "0553ee1210ce86cfaaa494177ce1f3f4fc940f30fe660d9efcf787433f9673f0",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/LibraryImporter.swift",
      "size": 7726,
      "mtime": 1759809611.1710567,
      "sha256": "5b50d64185b3fc4ae2f79f3df7bd610a0338bd902255ccb977011b1dd9055311",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/PulsumData.swift",
      "size": 1790,
      "mtime": 1759809611.171445,
      "sha256": "15f617eb5ef2f161fbc8701c04e16b966a4476b7acc18ccbee685d6d7544937a",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/Model/ManagedObjects.swift",
      "size": 5027,
      "mtime": 1759809611.1712978,
      "sha256": "c668eb983b01fca16b00fe51ab395c8234b820a8f91e04099cab7a03b87f10da",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumData/.swiftpm/xcode/xcuserdata/martin.demel.xcuserdatad/xcschemes/xcschememanagement.plist",
      "size": 345,
      "mtime": 1760934638.7244642,
      "sha256": "966c52025741d1effce18ea3d7942ee138292c52f543d1a7ed02127ff3b3cf1a",
      "read_intent": "read",
      "reason": "Property list"
    },
    {
      "path": "Packages/PulsumAgents/.DS_Store",
      "size": 6148,
      "mtime": 1759461503.5619063,
      "sha256": "676c2a3d14fa299d3c059cfd9ea4deb91ce66c9611273da6ca7c589d9a3a277e",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Packages/PulsumAgents/Package.swift",
      "size": 992,
      "mtime": 1760031438.3220563,
      "sha256": "f5489da0c2eba694906e2ae6af83ec91ab9383aa2a52b7cfe35237d7d4cfb9a3",
      "read_intent": "read",
      "reason": "Swift package manifest"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/AgentSystemTests.swift",
      "size": 2612,
      "mtime": 1760031438.1647696,
      "sha256": "3e08b6dd780f678d0b7b71c66476e0c252bcdb63b7cd49fcba00cf3468137d92",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailAcceptanceTests.swift",
      "size": 8096,
      "mtime": 1759809611.169627,
      "sha256": "bf4b57c3a92039e245ecf2ea879555cfad525e7b56d0a342d570f2279726976c",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/ChatGuardrailTests.swift",
      "size": 8510,
      "mtime": 1759809611.169873,
      "sha256": "fdc8da64eceb4587767c9bba72a4273a82327415bc801e0629d19c6a3cc703ee",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/Tests/PulsumAgentsTests/TestCoreDataStack.swift",
      "size": 8593,
      "mtime": 1760031438.1956344,
      "sha256": "325440f475ab5088304f4c558927608cc57367cf67237ee5fa089c64c88e1a72",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/SentimentAgent.swift",
      "size": 7247,
      "mtime": 1761437478.9139874,
      "sha256": "4e07a7be23464f1678b23d34d6cb04be2190e6a1767ca32829788b10a811150e",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent+Coverage.swift",
      "size": 3748,
      "mtime": 1759809611.1677215,
      "sha256": "e9c2e3796178d2f4022127ec33bcfbcbbad09cc841f3fad8f39dc31c8afb583e",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/DataAgent.swift",
      "size": 55914,
      "mtime": 1760031438.2595024,
      "sha256": "47389217ae9390a8a2d9712444e5425f6f7d81ae3bcad22674e084e1f6e407b8",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/AgentOrchestrator.swift",
      "size": 23527,
      "mtime": 1761437479.9425135,
      "sha256": "145611068796e6bdcb5879c650a0a440817221ff485c18283e622bdbef2df387",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/PulsumAgents.swift",
      "size": 855,
      "mtime": 1760031438.0808668,
      "sha256": "919b178b1f5e8efd91958bce82d3fd0b7cbf9e36a67258fca205719d9ebf58ca",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/SafetyAgent.swift",
      "size": 2675,
      "mtime": 1760031438.3462822,
      "sha256": "df5e3e88e486b0941a77de7c3b23e5d4e922232e5370bf16db61035d6dbf6b48",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/CheerAgent.swift",
      "size": 1255,
      "mtime": 1760031438.0679965,
      "sha256": "a238c8f93627b3160af6095a401c582965aa587fd6acd03351cd186fdb1f899c",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/Sources/PulsumAgents/CoachAgent.swift",
      "size": 18482,
      "mtime": 1759809611.1679688,
      "sha256": "4e69ebd17afacd4dc4319a98c7f37cebfe2e6eeb1d46afe9d4bd2445b5ee42fb",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumAgents/.swiftpm/xcode/xcuserdata/martin.demel.xcuserdatad/xcschemes/xcschememanagement.plist",
      "size": 347,
      "mtime": 1760934638.5099962,
      "sha256": "400e7261567b2c66f00df6a6ef9609710b287dfed49a015de8f131a579611fd5",
      "read_intent": "read",
      "reason": "Property list"
    },
    {
      "path": "Packages/PulsumML/.DS_Store",
      "size": 6148,
      "mtime": 1759461498.211872,
      "sha256": "edeccffeff3abc3898b11156c1bcc993332bd88f98f99ce293d5dd524cb64b99",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Packages/PulsumML/Package.swift",
      "size": 1042,
      "mtime": 1760031438.2341661,
      "sha256": "da715c8ccb68f3619abce7ccbb84a4bf0c96f1ec1ca792bf025da022dc93dd65",
      "read_intent": "read",
      "reason": "Swift package manifest"
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/PackageEmbedTests.swift",
      "size": 2721,
      "mtime": 1759809611.1789534,
      "sha256": "df3ee129e8246b5a238156fb58a901df2c3c2963d023e84a821ade5e5a5f713f",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/TopicGateTests.swift",
      "size": 4455,
      "mtime": 1759809611.1795964,
      "sha256": "c332987b6df833cb7d190652c66379b6b475f4fb98f806ca26c9398497b8dbec",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/TopicGateMarginTests.swift",
      "size": 1292,
      "mtime": 1759809611.1793098,
      "sha256": "64a0fe5a5e3d765371fd2810a01d8b21bee3d1ce638d2b05cfbfebb70914c8e6",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Tests/PulsumMLTests/SafetyLocalTests.swift",
      "size": 1062,
      "mtime": 1759809611.179115,
      "sha256": "76fb751d8be17af00f3cf442d6dd5102020c259ab4d64d2dc3a3a0e894f13dd2",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/SafetyLocal.swift",
      "size": 6575,
      "mtime": 1759809611.176261,
      "sha256": "67b83d95d8fb6d274aa53f4467ac452435f3f148d9aed1edd980cd6515a9b065",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/StateEstimator.swift",
      "size": 3023,
      "mtime": 1759809611.177993,
      "sha256": "e07d876a3fea3dbbd331bd9402465e4eb71e0473eacf92f296c3f450ad528827",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/BaselineMath.swift",
      "size": 1478,
      "mtime": 1759809611.1736517,
      "sha256": "04a2a2371ae369542d5d792b812c753ff4bb560702dae336aef8ab1fd749bbf9",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Placeholder.swift",
      "size": 358,
      "mtime": 1759809611.1746778,
      "sha256": "9138cf8e32703915f9bfe588f627821a8dcd280ef0d3c7977b5c504ab5a50ffa",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/RecRanker.swift",
      "size": 5000,
      "mtime": 1759809611.174842,
      "sha256": "40752818d31aa5cc517e3bb0c99924d8ca134b8951316b8c5e05e0fa6e2bb1bc",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/TopicGate/TopicGateProviding.swift",
      "size": 1017,
      "mtime": 1759809611.1786346,
      "sha256": "a0f5256a0f83aa741bb31cd1b76c9e12f52ff21261997cc19a92a9b2dc7b8575",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/TopicGate/FoundationModelsTopicGateProvider.swift",
      "size": 2335,
      "mtime": 1759809611.178477,
      "sha256": "b239b2a812fd623b13c54196694ea2a84014808aa6b087d8084c9d7c866f89d5",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/TopicGate/EmbeddingTopicGateProvider.swift",
      "size": 6635,
      "mtime": 1759809611.1782913,
      "sha256": "5b234bb0e6fd3c013e1ce0f96b70d4ce9c320b0ae396703b6dab4ec1c9489130",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Resources/PulsumFallbackEmbedding.mlmodel",
      "size": 410814,
      "mtime": 1759809611.175312,
      "sha256": "45cdcd3973bf5235162dd8038467d9d8d6e535712d422a068eaa298b26ba3115",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Resources/PulsumSentimentCoreML.mlmodel",
      "size": 5491,
      "mtime": 1759809611.175671,
      "sha256": "e3a2ba1a2ae59335543216765bcedded2bec92170b40bdbb59c505d88da52934",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingService.swift",
      "size": 2704,
      "mtime": 1759809611.174404,
      "sha256": "645d8e1cd38ef97d05cb808252b69b534eb0589585fa6f06cd0be47f0ba6ad1f",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Embedding/EmbeddingError.swift",
      "size": 401,
      "mtime": 1759809611.1742468,
      "sha256": "5844e56cc3a6982e0cb9c7dfe5a1cb52305e37bf06e60e79eda952a9e065d023",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Embedding/TextEmbeddingProviding.swift",
      "size": 184,
      "mtime": 1759809611.174535,
      "sha256": "ed1277432b9d06cb1cb1824bacbeec59d895ce780c8280140695afe796246ab5",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Embedding/AFMTextEmbeddingProvider.swift",
      "size": 4397,
      "mtime": 1759809611.1738994,
      "sha256": "bfcffa0d81f216bce0aec01317ba82d05ef967e92e4491f7e935d39ac072172d",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Embedding/CoreMLEmbeddingFallbackProvider.swift",
      "size": 2427,
      "mtime": 1759809611.1740618,
      "sha256": "85bab243e12828f570fec20a772061d7011e5487dcebf7b0d3cd9fae929538d3",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsStub.swift",
      "size": 1994,
      "mtime": 1760031438.2063935,
      "sha256": "346e380690aa3d6807236cbe178685fe9d6659efe7de4fe67537e2f891e8dab1",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/AFM/FoundationModelsAvailability.swift",
      "size": 1504,
      "mtime": 1760031437.9394808,
      "sha256": "62494100fc9ae10975f9d5d33774f16b711d0d9d9a33469742124e94b0f585f7",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Safety/FoundationModelsSafetyProvider.swift",
      "size": 3459,
      "mtime": 1759809611.17611,
      "sha256": "f02b563b8d2f63c4b38063ee2176a0244ecfd9056cbf6a1f69ea3edd5462fc0f",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentService.swift",
      "size": 1298,
      "mtime": 1760031437.9747934,
      "sha256": "d6e476e54a4d7c8942ac814aa91c3e9b14f225d17117eabf421622a255dac823",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/AFMSentimentProvider.swift",
      "size": 2537,
      "mtime": 1760031437.807008,
      "sha256": "1e4b896c7847b53e11df343154013050989eabeac000bbec124b11df54c80e54",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/NaturalLanguageSentimentProvider.swift",
      "size": 721,
      "mtime": 1760031437.8533084,
      "sha256": "f1a4ccb297bcad228df67c8699ff45c5c3812a658202b047e057e5ade0b6794c",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/CoreMLSentimentProvider.swift",
      "size": 1400,
      "mtime": 1760031437.8317504,
      "sha256": "01beab66dc851392e9b8e21d79ed3ee86c8afbf458961faaa0c0229967ef7cc9",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/PIIRedactor.swift",
      "size": 1502,
      "mtime": 1759809611.1772969,
      "sha256": "e569fbeec0e7b15b77f98229582ce36cc636849abdf5dcef62aff81b65499847",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/SentimentProviding.swift",
      "size": 556,
      "mtime": 1760031437.7410467,
      "sha256": "cc7c462a2415e54cf5b0829d47d2911ea81e83065183347f1419fe883bace095",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/Sources/PulsumML/Sentiment/FoundationModelsSentimentProvider.swift",
      "size": 2218,
      "mtime": 1760031437.9186475,
      "sha256": "a262ac59a45b252ccc29ddb5719df73f16272820470f803dcbefe501f2b9c0e0",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Packages/PulsumML/.swiftpm/xcode/xcuserdata/martin.demel.xcuserdatad/xcschemes/xcschememanagement.plist",
      "size": 343,
      "mtime": 1760934637.8920803,
      "sha256": "fdf3b5cb79da3fae44c56f2e5589a956889a3c0275d54846a2a3cc3f5b0f0359",
      "read_intent": "read",
      "reason": "Property list"
    },
    {
      "path": ".github/coderabbit.yaml",
      "size": 2912,
      "mtime": 1759975832.4481301,
      "sha256": "f03696726f48b362128f629b36624fd88aebce0a0fe328262535340984e2fbda",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": ".github/workflows/auto-merge.yml",
      "size": 3598,
      "mtime": 1759975868.1466372,
      "sha256": "0512dcbd61988c4f4229dfa033be784b9be92295e1ce6c65d8f2a4f5fe219ab9",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": ".github/workflows/auto-pr.yml",
      "size": 2608,
      "mtime": 1759975848.0929596,
      "sha256": "3065d4e0b62f2faf6cef076c3e9b55e42546f861e8bb8ba4532d10124ae331d3",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "PulsumUITests/PulsumUITestsLaunchTests.swift",
      "size": 814,
      "mtime": 1759103615.9342058,
      "sha256": "e9eb2ddd05dd7f31d5d230bbd7157e486733be81e019e0a55c047e4d54022e2e",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "PulsumUITests/PulsumUITests.swift",
      "size": 1301,
      "mtime": 1759103615.9331603,
      "sha256": "ec2c04a16c2160a40da089eedb1555b9b7f8c9b8c4b30650d6ccc76b08d2fb66",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Pulsum.xcodeproj/project.pbxproj",
      "size": 29950,
      "mtime": 1760925511.0619545,
      "sha256": "49a79a523b33556eeb35d8a88ca5e6498127037a945e7079611a489fd042134d",
      "read_intent": "read",
      "reason": "Xcode project definition"
    },
    {
      "path": "Pulsum.xcodeproj/project.pbxproj.backup",
      "size": 31641,
      "mtime": 1760030905.0679762,
      "sha256": "2c14bd6ff4178f37c6bfb66b7122145a61418ca184b5bd4e09b1db8ede720cff",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Pulsum.xcodeproj/xcuserdata/martin.demel.xcuserdatad/xcschemes/xcschememanagement.plist",
      "size": 670,
      "mtime": 1759809611.2425253,
      "sha256": "6b03dc5f6c660fb87121f97633bfaa32468de8d7655b640dd5282e3e13659d4f",
      "read_intent": "read",
      "reason": "Property list"
    },
    {
      "path": "Pulsum.xcodeproj/project.xcworkspace/contents.xcworkspacedata",
      "size": 135,
      "mtime": 1759103616.0,
      "sha256": "7f3b00b5c3fdb45242d7b87e1e5c4e25d1fa8129a16c94295ecc4e8ea2235c5f",
      "read_intent": "read",
      "reason": "Workspace data"
    },
    {
      "path": "Pulsum.xcodeproj/project.xcworkspace/xcuserdata/martin.demel.xcuserdatad/UserInterfaceState.xcuserstate",
      "size": 97634,
      "mtime": 1761437050.827781,
      "sha256": "f019e5f2686baf5537031d99cefb2926bb3f8d370ac44519ab11fcc95831d2b5",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Pulsum.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved",
      "size": 133,
      "mtime": 1760906075.23189,
      "sha256": "8bf18dd4796cc007db891a77adc93ed0093046e45a2653a15a47e180a5079cc5",
      "read_intent": "read",
      "reason": "Swift package resolved versions"
    },
    {
      "path": "Pulsum.xcodeproj/xcshareddata/xcschemes/Pulsum.xcscheme",
      "size": 3837,
      "mtime": 1760934637.5847504,
      "sha256": "d0de317cfda800a7a4556bd2b20d1ac75f0cec0f91a3d7ca87414fdcfa5ac04e",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": ".vscode/settings.json",
      "size": 37,
      "mtime": 1759323072.0707552,
      "sha256": "6d24b0d571970e6716a61cc325add89c7003acf07228128ab62a725eead357a9",
      "read_intent": "read",
      "reason": "JSON resource"
    },
    {
      "path": "PulsumTests/PulsumTests.swift",
      "size": 294,
      "mtime": 1759103615.9088154,
      "sha256": "ff425d00e00d0177eb9adf347bb47c5f3e51fea00ab0c81e6b824b98d4c18ec9",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Pulsum/.DS_Store",
      "size": 6148,
      "mtime": 1759461498.2144403,
      "sha256": "4b25171370bb11d979f74be9d4d1005d89ea5ffce3cca81f2ccfa5077d9db0d8",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Pulsum/PulsumApp.swift",
      "size": 239,
      "mtime": 1759809611.2474809,
      "sha256": "029c3b42c425daa6b1a71b38cc55b64ff7b85ac93c97b64c89118d3cafcf29e4",
      "read_intent": "read",
      "reason": "Swift source"
    },
    {
      "path": "Pulsum/Pulsum.entitlements",
      "size": 310,
      "mtime": 1759809611.2470665,
      "sha256": "3a0fe663304785c4f157a6a2dd599ff9c1abbd87138e73bb313b5141f3e27618",
      "read_intent": "read",
      "reason": "Entitlements"
    },
    {
      "path": "Pulsum/Assets.xcassets/.DS_Store",
      "size": 6148,
      "mtime": 1759461493.0197654,
      "sha256": "cfd2ec1b89903f336dc718c9af7805867036ca31095162558123d780fbc2ecf4",
      "read_intent": "summarize_only",
      "reason": "Not required for detailed read"
    },
    {
      "path": "Pulsum/Assets.xcassets/Contents.json",
      "size": 63,
      "mtime": 1759287725.268601,
      "sha256": "0fd49ba3c3585c709678e0046a821c3c60685ec7063720d30d3a3448be3a208b",
      "read_intent": "read",
      "reason": "JSON resource"
    },
    {
      "path": "Pulsum/Assets.xcassets/AppIcon.appiconset/logo2_with_white_bg 1.png",
      "size": 471368,
      "mtime": 1759809611.2440794,
      "sha256": "1324789f541cec13a666285b3b48dfc9eabe94c04aaeb4c0c01b8ff642616356",
      "read_intent": "summarize_only",
      "reason": "Image asset"
    },
    {
      "path": "Pulsum/Assets.xcassets/AppIcon.appiconset/logo2_with_white_bg 2.png",
      "size": 471368,
      "mtime": 1759809611.2452815,
      "sha256": "1324789f541cec13a666285b3b48dfc9eabe94c04aaeb4c0c01b8ff642616356",
      "read_intent": "summarize_only",
      "reason": "Image asset"
    },
    {
      "path": "Pulsum/Assets.xcassets/AppIcon.appiconset/logo2_with_white_bg.png",
      "size": 471368,
      "mtime": 1759809611.2468565,
      "sha256": "1324789f541cec13a666285b3b48dfc9eabe94c04aaeb4c0c01b8ff642616356",
      "read_intent": "summarize_only",
      "reason": "Image asset"
    },
    {
      "path": "Pulsum/Assets.xcassets/AppIcon.appiconset/Contents.json",
      "size": 749,
      "mtime": 1759809611.2427783,
      "sha256": "0670fbf42754fed308e115f94562c52060c3ff7977adf215915b7814338bea3f",
      "read_intent": "read",
      "reason": "JSON resource"
    },
    {
      "path": "Pulsum/Assets.xcassets/AccentColor.colorset/Contents.json",
      "size": 123,
      "mtime": 1759103615.1138337,
      "sha256": "9af65086fa30b49252fae1a1225731691de794f7775af74d71befeb507d12b7c",
      "read_intent": "read",
      "reason": "JSON resource"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/Resources/Pulsum.xcdatamodeld/.xccurrentversion",
      "size": 259,
      "mtime": 1759103615.7772732,
      "sha256": "1139771d43c6b86db70dc760278d2b75b4e9593fdbce6deb0375024356b68f9d",
      "read_intent": "read",
      "reason": "Core Data current version marker"
    },
    {
      "path": "Packages/PulsumData/Sources/PulsumData/Resources/Pulsum.xcdatamodeld/Pulsum.xcdatamodel/contents",
      "size": 7741,
      "mtime": 1759809611.2473207,
      "sha256": "170131f2cff09976cc8d085ecb8da51f9e8484805fefa0c615b4460e55bbbe15",
      "read_intent": "read",
      "reason": "Core Data model contents"
    }
  ]
}
```
<!-- END_FILE: inventory.json -->

### ios support files/glow.swift
- bytes: 4626
- lines: 126
- sha256: 59923efcc4ec5f2dabbd2dfd67bb10d0e73247d0334975d171ffa84fb5bd1535
- trailing_newline: true

<!-- BEGIN_FILE: ios support files/glow.swift -->
```swift
import SwiftUI

struct GlowEffect: View {
    @State private var gradientStops: [Gradient.Stop] = GlowEffect.generateGradientStops()

    var body: some View {
        ZStack {
            EffectNoBlur(gradientStops: gradientStops, width: 6)
                .onAppear {
                    // Start a timer to update the gradient stops every second
                    Timer.scheduledTimer(withTimeInterval: 0.4, repeats: true) { _ in
                        withAnimation(.easeInOut(duration: 0.5)) {
                            gradientStops = GlowEffect.generateGradientStops()
                        }
                    }
                }
            Effect(gradientStops: gradientStops, width: 9, blur: 4)
                .onAppear {
                    // Start a timer to update the gradient stops every second
                    Timer.scheduledTimer(withTimeInterval: 0.4, repeats: true) { _ in
                        withAnimation(.easeInOut(duration: 0.6)) {
                            gradientStops = GlowEffect.generateGradientStops()
                        }
                    }
                }
            Effect(gradientStops: gradientStops, width: 11, blur: 12)
                .onAppear {
                    // Start a timer to update the gradient stops every second
                    Timer.scheduledTimer(withTimeInterval: 0.4, repeats: true) { _ in
                        withAnimation(.easeInOut(duration: 0.8)) {
                            gradientStops = GlowEffect.generateGradientStops()
                        }
                    }
                }
            Effect(gradientStops: gradientStops, width: 15, blur: 15)
                .onAppear {
                    // Start a timer to update the gradient stops every second
                    Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { _ in
                        withAnimation(.easeInOut(duration: 1)) {
                            gradientStops = GlowEffect.generateGradientStops()
                        }
                    }
                }
        }
    }
    
    // Function to generate random gradient stops
    static func generateGradientStops() -> [Gradient.Stop] {
        [
            Gradient.Stop(color: Color(hex: "BC82F3"), location: Double.random(in: 0...1)),
            Gradient.Stop(color: Color(hex: "F5B9EA"), location: Double.random(in: 0...1)),
            Gradient.Stop(color: Color(hex: "8D9FFF"), location: Double.random(in: 0...1)),
            Gradient.Stop(color: Color(hex: "FF6778"), location: Double.random(in: 0...1)),
            Gradient.Stop(color: Color(hex: "FFBA71"), location: Double.random(in: 0...1)),
            Gradient.Stop(color: Color(hex: "C686FF"), location: Double.random(in: 0...1))
        ].sorted { $0.location < $1.location }
    }
}

struct Effect: View {
    var gradientStops: [Gradient.Stop]
    var width: CGFloat
    var blur: CGFloat

    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 55)
                .strokeBorder(
                    AngularGradient(
                        gradient: Gradient(stops: gradientStops),
                        center: .center
                    ),
                    lineWidth: width
                )
                .frame(
                    width: UIScreen.main.bounds.width,
                    height: UIScreen.main.bounds.height
                )
                .padding(.top, -17)
                .blur(radius: blur)
        }
    }
}

struct EffectNoBlur: View {
    var gradientStops: [Gradient.Stop]
    var width: CGFloat

    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 55)
                .strokeBorder(
                    AngularGradient(
                        gradient: Gradient(stops: gradientStops),
                        center: .center
                    ),
                    lineWidth: width
                )
                .frame(
                    width: UIScreen.main.bounds.width,
                    height: UIScreen.main.bounds.height
                )
                .padding(.top, -26)
        }
    }
}

extension Color {
    init(hex: String) {
        let scanner = Scanner(string: hex)
        _ = scanner.scanString("#")
        
        var hexNumber: UInt64 = 0
        scanner.scanHexInt64(&hexNumber)
        
        let r = Double((hexNumber & 0xff0000) >> 16) / 255
        let g = Double((hexNumber & 0x00ff00) >> 8) / 255
        let b = Double(hexNumber & 0x0000ff) / 255
        
        self.init(red: r, green: g, blue: b)
    }
}

#Preview {
    GlowEffect()
}
```
<!-- END_FILE: ios support files/glow.swift -->

### podcastrecommendations 2.json
- bytes: 52726
- lines: 789
- sha256: 50464a3a1673f4845622281d00ecf5099e62bd72d99099fe1ea7d218b0a1f35c
- trailing_newline: true

<!-- BEGIN_FILE: podcastrecommendations 2.json -->
```text
 [
  {
    "episodeNumber": "199",
    "episodeTitle": "Arnold's Pump Club - #199 It Doesn't Fcking Matter",
    "recommendations": [
      {
        "timestamp": "approximate",
        "recommendation": "Focus your energy only on what truly matters",
        "shortDescription": "Arnold recommends that you stop caring about things that don't directly impact your health, your family's health, or your personal vision. Instead, conserve your mental energy for what is truly important.",
        "detailedDescription": "The episode discusses how people have been conditioned to care about everything, often wasting energy on trivial matters like celebrity gossip or fictional characters. Arnold suggests that our brains have a limited 'energy budget' each day, and spending it on things that don't matter leaves us drained and unable to pursue our goals or support others. He encourages listeners to adopt the mantra 'It doesn't fucking matter' for anything that doesn't impact their health, their family's health, or their vision. By doing so, you can reserve your energy for meaningful pursuits and be ready when something truly important arises.",
        "microActivity": "Whenever you feel yourself getting worked up about something trivial, pause and ask: 'Is this worth my battery?' If not, let it go.",
        "researchLink": "https://nida.nih.gov/research-topics/parents-educators/mind-matter-series/cocaine",
        "difficultyLevel": "Easy",
        "timeToComplete": "1 min (mental check-in)",
        "tags": [
          "mental health",
          "focus",
          "energy management",
          "mindfulness"
        ],
        "category": "Mental Health",
        "subcategory": "Stress Management"
      }
    ]
  },
  {
    "episodeNumber": "195",
    "episodeTitle": "Arnold's Pump Club - #195 Arnold Says This Trend Is Holding You",
    "recommendations": [
      {
        "timestamp": "approximate",
        "recommendation": "Stick with one fitness program and follow through",
        "shortDescription": "Avoid constantly switching workout programs. Instead, focus on following through with one plan for at least 90 days to see real progress.",
        "detailedDescription": "Arnold emphasizes that one of the biggest barriers to fitness progress is a lack of focus and follow through. Many people get distracted by new trends and switch programs too often, preventing real progress. He shares that in his 63 years of training, he has only used four main programs, sticking with each for years. Research and experience show that consistent effort on a single program leads to better results than frequently changing routines.",
        "microActivity": "Commit to your current workout plan for the next 90 days without switching.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/29564973/",
        "difficultyLevel": "Moderate",
        "timeToComplete": "90 days",
        "tags": [
          "focus",
          "consistency",
          "fitness",
          "progress"
        ],
        "category": "Fitness",
        "subcategory": "Training Adherence"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Perform full range of motion in every exercise",
        "shortDescription": "Don't cheat your reps. Make sure to complete the full stretch and flex in every movement for maximum benefit.",
        "detailedDescription": "Arnold observes that many people in the gym perform only partial reps, missing out on the full benefits of each exercise. He stresses the importance of completing the entire range of motion, as stopping short can limit progress and lead to dissatisfaction. This principle of follow-through applies not just in the gym but also in other areas of life, encouraging a habit of giving 100% effort.",
        "microActivity": "In your next workout, consciously perform every rep with a full range of motion.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/27398917/",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "form",
          "exercise",
          "range of motion",
          "focus"
        ],
        "category": "Fitness",
        "subcategory": "Exercise Technique"
      }
    ]
  },
  {
    "episodeNumber": "191",
    "episodeTitle": "Arnold's Pump Club - #191 Hard As Hell (And Worth It)",
    "recommendations": [
      {
        "timestamp": "approximate: 8-12 min",
        "recommendation": "Be brutally honest about your habits and adjust portions if your approach isn't working",
        "shortDescription": "If your current diet or fitness approach isn't delivering results, honestly assess your habits and make necessary changes, such as reducing portion sizes.",
        "detailedDescription": "Arnold emphasizes that many people deceive themselves about their eating habits, often overlooking small cheats or excessive portions. He advises that if your current approach isn't working, you must be your own biggest critic and make adjustments, especially with portion control. This process is difficult and uncomfortable, but it's essential for breaking long-standing habits and achieving your goals. The key is persistence through the hard phase until new habits become automatic.",
        "microActivity": "Track your meals for the next 3 days and honestly review your portion sizes and snack choices.",
        "researchLink": "https://www.reddit.com/r/productivity/comments/1cesrmd/how_do_you_actually_change_your_life/",
        "difficultyLevel": "Moderate",
        "timeToComplete": "15 min (initial review), ongoing",
        "tags": [
          "habits",
          "nutrition",
          "self-assessment",
          "portion control"
        ],
        "category": "Nutrition",
        "subcategory": "Behavior Change"
      },
      {
        "timestamp": "approximate: 18-21 min",
        "recommendation": "Drink coffee (without added sugar or high-calorie creamers) to help reduce risk of type 2 diabetes",
        "shortDescription": "Regular coffee consumption, especially without added sugars or creamers, is linked to a lower risk of developing type 2 diabetes.",
        "detailedDescription": "New research involving nearly 300,000 people over 34 years shows that each cup of coffee (without sugar or high-calorie creamers) is associated with a 10% reduced risk of type 2 diabetes. Both caffeinated and decaffeinated coffee offer benefits, likely due to polyphenols and antioxidants. Coffee may improve insulin sensitivity, lower glucose levels, and reduce inflammation. However, adding sugar or creamers can negate these benefits, and individuals should consider their own tolerance for caffeine.",
        "microActivity": "Swap your usual sweetened coffee for a plain black coffee or coffee with minimal milk.",
        "researchLink": "https://january.ai/blog/does-coffee-raise-blood-sugar",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "coffee",
          "diabetes",
          "nutrition",
          "beverages",
          "research"
        ],
        "category": "Nutrition",
        "subcategory": "Disease Prevention"
      }
    ]
  },
  {
    "episodeNumber": "192",
    "episodeTitle": "Arnold's Pump Club - #192 Are You Part Of The 10 Percent",
    "recommendations": [
      {
        "timestamp": "approximate: 00:07:00",
        "recommendation": "Try beetroot juice to boost endurance",
        "shortDescription": "Drinking about 1.5 ounces of beetroot juice before a workout can improve aerobic performance by around 5%.",
        "detailedDescription": "A recent study tested female endurance athletes and found that those who consumed about 1.5 ounces of beetroot juice before exercise improved their VO2 max by approximately 5% compared to a placebo group. The nitrates in beetroot juice help dilate blood vessels, increasing blood flow and allowing for better oxygen use. This makes beetroot juice a low-risk supplement for anyone looking to enhance endurance, without the side effects of stimulants. The benefits are accessible to both athletes and anyone wanting to improve their aerobic capacity.",
        "microActivity": "Drink a shot glass (about 1.5 oz) of beetroot juice before your next workout.",
        "researchLink": "https://ods.od.nih.gov/factsheets/ExerciseAndAthleticPerformance-HealthProfessional/",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "endurance",
          "supplements",
          "performance",
          "beetroot juice"
        ],
        "category": "Nutrition",
        "subcategory": "Supplements"
      },
      {
        "timestamp": "approximate: 00:02:00",
        "recommendation": "Commit to your fitness goals without waiting for sales or external motivation",
        "shortDescription": "Don't wait for the perfect moment or a discount to invest in your health; make a commitment to yourself and stick to it.",
        "detailedDescription": "Arnold emphasizes that real, lasting change comes from genuine commitment, not from waiting for sales or external motivators. He notes that joining a program or starting a new habit just because it's on sale often leads to less success. Instead, he encourages listeners to invest in themselves because they are worth it, and to use the remaining 92% of the year to make progress on their resolutions. This mindset shift is crucial for turning resolutions into reality and building long-term habits.",
        "microActivity": "Write down one fitness goal and commit to taking a small action toward it today, regardless of external incentives.",
        "researchLink": "https://library.samhsa.gov/sites/default/files/tip-35-pep19-02-01-003.pdf",
        "difficultyLevel": "Moderate",
        "timeToComplete": "10 min",
        "tags": [
          "motivation",
          "commitment",
          "habits",
          "resolutions"
        ],
        "category": "Mental Health",
        "subcategory": "Motivation"
      }
    ]
  },
  {
    "episodeNumber": "193",
    "episodeTitle": "Arnold's Pump Club - #193 Creatine And Cancer",
    "recommendations": [
      {
        "timestamp": "approximate",
        "recommendation": "Turn off your brain and take action",
        "shortDescription": "Stop overthinking and start doing. Overanalyzing can keep you from achieving your goals.",
        "detailedDescription": "Arnold emphasizes that while planning and having a vision are important, overthinking can paralyze you and prevent progress. He shares an example of helping someone achieve a big bench press goal by encouraging them to stop analyzing and just act. The advice is to become a 'genius' when making your plan, but a 'forehead'—someone who just does—when it's time to execute. By turning off your brain and taking action, you can overcome the mental barriers that stop you from making progress.",
        "microActivity": "Pick one small fitness or health action (like 10 push-ups or a short walk) and do it immediately without thinking further.",
        "researchLink": "https://www.nih.gov/news-events/nih-research-matters/brain-circuits-start-stop-action",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "mindset",
          "motivation",
          "overthinking",
          "action"
        ],
        "category": "Mental Health",
        "subcategory": "Mindset"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Increase dietary creatine intake for potential cancer protection",
        "shortDescription": "Higher dietary creatine intake is linked to a lower risk of cancer, especially as you age.",
        "detailedDescription": "A new study analyzing over a decade of U.S. health data found that adults with higher dietary creatine intake had a significantly lower risk of developing cancer. The effect was observed in both men and women, and was even stronger in older adults. For every 0.9 gram increase in creatine intake, cancer incidence in males decreased by 7%, and by 14% in those in their 70s and 80s. Creatine may help by supporting cellular energy metabolism, reducing oxidative stress, and protecting DNA. While the study focused on dietary sources (meat and fish), supplemental creatine could potentially offer even more protection, though more research is needed.",
        "microActivity": "Add a serving of creatine-rich food (like fish or red meat) to your next meal.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/38360233/",
        "difficultyLevel": "Moderate",
        "timeToComplete": "10 min (meal prep)",
        "tags": [
          "creatine",
          "cancer prevention",
          "nutrition",
          "research"
        ],
        "category": "Nutrition",
        "subcategory": "Supplements"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Consider using high-quality creatine supplements",
        "shortDescription": "Supplemental creatine may offer additional health benefits beyond muscle growth, including potential cancer protection.",
        "detailedDescription": "While the referenced study only looked at dietary creatine, Arnold suggests that supplemental creatine could be even more protective, pending further research. He recommends choosing a high-quality, third-party certified creatine supplement free from banned substances and heavy metals. He specifically mentions Momentous Creatine, which is trusted by athletes and professionals. Using a reputable supplement can help ensure safety and effectiveness as you seek potential health benefits.",
        "microActivity": "Research and purchase a reputable creatine supplement if appropriate for your health goals.",
        "researchLink": "https://ods.od.nih.gov/factsheets/ExerciseAndAthleticPerformance-HealthProfessional/",
        "difficultyLevel": "Moderate",
        "timeToComplete": "10 min (research/purchase)",
        "tags": [
          "creatine",
          "supplements",
          "nutrition",
          "health"
        ],
        "category": "Nutrition",
        "subcategory": "Supplements"
      }
    ]
  },
  {
    "episodeNumber": "194",
    "episodeTitle": "Arnold's Pump Club - #194 This Is Your Brain On Cannabis",
    "recommendations": [
      {
        "timestamp": "approximate",
        "recommendation": "Exercise at least four times per week for heart health",
        "shortDescription": "Aim for a minimum of four aerobic exercise sessions weekly to reduce risk of heart disease and maintain youthful arteries.",
        "detailedDescription": "Research shows that people who exercise at least four times per week have arteries similar to much younger individuals, reducing the risk of heart disease, stroke, and cognitive decline. The study compared lifelong exercise habits and found that frequency matters: those who exercised less than twice a week had stiffer arteries, a risk factor for several health issues. Any exercise is better than none, but consistent, frequent movement is key for cardiovascular health. Cardio can be as simple as brisk walking or any activity that elevates your heart rate.",
        "microActivity": "Schedule four short walks or cardio sessions into your weekly calendar.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/29321140/",
        "difficultyLevel": "Easy",
        "timeToComplete": "30 min per session",
        "tags": [
          "cardio",
          "heart health",
          "longevity",
          "exercise"
        ],
        "category": "Fitness",
        "subcategory": "Cardiovascular Health"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Delay regular cannabis use until adulthood to protect cognitive health",
        "shortDescription": "Avoid starting heavy cannabis use before age 18 to prevent increased risk of cognitive decline.",
        "detailedDescription": "A long-term study tracking over 5,000 men for four decades found that cannabis use did not accelerate cognitive decline in adults, provided regular use began after age 18. Intelligence scores remained similar between users and non-users, even among heavy users, unless cannabis use started early in life. Early, heavy use (before 18) was associated with greater cognitive decline, suggesting that delaying use can help preserve brain health.",
        "microActivity": "If considering cannabis, wait until after age 18 for regular use.",
        "researchLink": "https://nida.nih.gov/research-topics/cannabis-marijuana",
        "difficultyLevel": "Easy",
        "timeToComplete": "Ongoing lifestyle choice",
        "tags": [
          "cannabis",
          "cognitive health",
          "brain",
          "prevention"
        ],
        "category": "Mental Health",
        "subcategory": "Cognitive Health"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Incorporate planned diet breaks during weight loss",
        "shortDescription": "Take a one-week break from calorie restriction every 3-4 weeks to support metabolic health and make dieting more sustainable.",
        "detailedDescription": "A meta-analysis found that people who took periodic breaks from dieting (one to two weeks off every few weeks) lost weight at a similar rate to those who dieted continuously, but maintained a higher metabolic rate and found the process more sustainable. These breaks help prevent metabolic adaptation, which can slow fat loss and increase burnout. Diet breaks don't mean eating without limits, but allow for more flexibility and less stress, making long-term weight management easier.",
        "microActivity": "Plan a one-week diet break after every three weeks of calorie restriction.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/30153131/",
        "difficultyLevel": "Moderate",
        "timeToComplete": "1 week per break",
        "tags": [
          "diet",
          "weight loss",
          "metabolism",
          "nutrition"
        ],
        "category": "Nutrition",
        "subcategory": "Weight Management"
      }
    ]
  },
  {
    "episodeNumber": "196",
    "episodeTitle": "Arnold's Pump Club - #196 It's Time To Let It Go",
    "recommendations": [
      {
        "timestamp": "approximate",
        "recommendation": "Practice suppressing negative thoughts",
        "shortDescription": "Training your brain to suppress negative thoughts can improve mental health and reduce anxiety.",
        "detailedDescription": "Contrary to traditional beliefs, recent research shows that actively suppressing negative thoughts does not backfire. Instead, it can lead to significant improvements in mental health, including a 50% decrease in depression and anxiety symptoms. Suppressing negative thoughts helps weaken their impact over time, improving emotional resilience and cognitive flexibility. This approach does not mean ignoring all problems, but rather choosing not to dwell on certain stresses that may be worsened by overthinking.",
        "microActivity": "Set aside 5 minutes today to practice letting go of unwanted thoughts instead of dwelling on them.",
        "researchLink": "https://www.cam.ac.uk/research/news/suppressing-negative-thoughts-good-for-mental-health",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "mental health",
          "anxiety",
          "resilience",
          "cognitive flexibility"
        ],
        "category": "Mental Health",
        "subcategory": "Thought Management"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Consider creatine supplementation for health and performance",
        "shortDescription": "Creatine supplementation is safe for healthy individuals and offers multiple health benefits.",
        "detailedDescription": "A new study using advanced statistical analysis confirms that creatine supplementation does not harm kidney function in healthy people, even at higher doses or with long-term use. Creatine is not only beneficial for muscle strength and growth, but also supports brain health, cognitive function, and focus, especially when sleep deprived. Creatine monohydrate is the most researched and trusted form. However, individuals with pre-existing kidney disease should consult their doctor before supplementing.",
        "microActivity": "If interested and healthy, research creatine monohydrate and consider adding it to your supplement routine.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/38057834/",
        "difficultyLevel": "Moderate",
        "timeToComplete": "10 min (to research and decide)",
        "tags": [
          "supplements",
          "creatine",
          "kidney health",
          "muscle",
          "cognitive function"
        ],
        "category": "Fitness",
        "subcategory": "Supplementation"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Increase daily fiber intake, especially with psyllium husk",
        "shortDescription": "Consuming more fiber, particularly psyllium husk, can aid weight loss and improve satiety.",
        "detailedDescription": "Most people do not consume enough fiber, but research shows that adding 5-10 grams of psyllium husk before meals can help with weight loss, reduce body fat, and increase feelings of fullness. Psyllium slows nutrient absorption, helping regulate blood sugar and insulin, and reduces hunger and snacking. Pairing psyllium with a high-protein, fiber-rich diet can further enhance these benefits. Simple ways to add it include mixing psyllium into a protein shake or Greek yogurt.",
        "microActivity": "Add 2 tablespoons of psyllium husk to your next protein shake or yogurt.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/31433842/",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "nutrition",
          "fiber",
          "weight loss",
          "satiety",
          "psyllium"
        ],
        "category": "Nutrition",
        "subcategory": "Dietary Fiber"
      }
    ]
  },
  {
    "episodeNumber": "190",
    "episodeTitle": "Arnold's Pump Club - #190 Does Fasting Cause Hair Loss",
    "recommendations": [
      {
        "timestamp": "approximate",
        "recommendation": "If you use creatine, choose creatine monohydrate",
        "shortDescription": "Creatine monohydrate is the safest, most effective, and best-absorbed form of creatine. Avoid more expensive or less effective alternatives.",
        "detailedDescription": "Research has shown that creatine monohydrate is the gold standard for supplementation, supporting muscle strength, lean mass, and even cognitive benefits. Myths about bloating and absorption often lead people to buy inferior or more expensive forms, but these are not supported by science. Creatine monohydrate has decades of research backing its safety and efficacy. For best results, use creatine from brands with third-party certification to ensure purity and safety.",
        "microActivity": "Purchase and use 3-5g of creatine monohydrate daily from a reputable, third-party tested brand.",
        "researchLink": "https://www.mayoclinic.org/drugs-supplements-creatine/art-20347591",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "creatine",
          "supplements",
          "muscle",
          "performance",
          "cognition"
        ],
        "category": "Nutrition",
        "subcategory": "Supplements"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Prioritize getting at least 7 hours of sleep for weight management",
        "shortDescription": "Sleeping less than 6 hours per night increases the risk of weight gain and makes hunger harder to control.",
        "detailedDescription": "A Harvard study found that people who sleep less than 6 hours a night weigh more and are more likely to be overweight than those who sleep 7 or more hours. Sleep deprivation disrupts hormones that regulate appetite, leading to increased hunger and higher calorie intake. Improving your sleep can make it easier to manage your eating habits and support weight loss goals. Prioritizing sleep is a simple but powerful tool for better health.",
        "microActivity": "Set a bedtime alarm to remind yourself to wind down and aim for at least 7 hours of sleep tonight.",
        "researchLink": "https://www.hsph.harvard.edu/obesity-prevention-source/obesity-causes/sleep-and-obesity/",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min setup, ongoing habit",
        "tags": [
          "sleep",
          "weight loss",
          "hormones",
          "appetite",
          "health"
        ],
        "category": "Sleep",
        "subcategory": "Weight Management"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Don’t worry excessively about fasting and hair loss; effects are likely reversible",
        "shortDescription": "Recent research suggests fasting may temporarily suppress hair follicle growth, but normal cycles resume when regular eating returns.",
        "detailedDescription": "Animal and early human studies indicate that intermittent fasting can influence hair follicle regeneration by shifting the body's priorities to essential functions. This may suppress hair follicle stem cells and slow hair growth, but the effect appears reversible once a regular eating schedule is resumed. If you notice changes in hair growth while fasting, it's likely temporary and not a cause for major concern. Monitor your own experience and adjust your fasting routine if needed.",
        "microActivity": "If you notice hair thinning while fasting, try returning to a regular meal schedule for a few weeks and observe changes.",
        "researchLink": "https://nihrecord.nih.gov/2020/05/01/eating-disorder-damages-are-extensive-reversible",
        "difficultyLevel": "Easy",
        "timeToComplete": "Ongoing observation",
        "tags": [
          "fasting",
          "hair loss",
          "nutrition",
          "health"
        ],
        "category": "Nutrition",
        "subcategory": "Intermittent Fasting"
      }
    ]
  },
  {
    "episodeNumber": "200",
    "episodeTitle": "Arnold's Pump Club - #200 Don't Underestimate The Long Game",
    "recommendations": [
      {
        "timestamp": "approximate",
        "recommendation": "Focus on long-term habits over short-term results",
        "shortDescription": "Prioritize building consistent habits and routines rather than seeking quick fixes or rapid transformations.",
        "detailedDescription": "The episode highlights the story of James, who achieved significant health and fitness improvements by committing to consistent workouts over 100 weeks. Rather than chasing instant results or falling for 28-day transformations, the message is to invest in daily habits and routines. Consistency over time leads to real and sustainable transformation, while quick fixes rarely deliver lasting change. This mindset shift helps prevent discouragement and increases the likelihood of long-term success.",
        "microActivity": "Set a realistic, long-term fitness goal and commit to a daily or weekly habit that supports it.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/22939439/",
        "difficultyLevel": "Moderate",
        "timeToComplete": "Ongoing",
        "tags": [
          "habits",
          "consistency",
          "motivation",
          "long-term"
        ],
        "category": "Fitness",
        "subcategory": "Mindset"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Take short daytime naps to boost performance",
        "shortDescription": "Short naps (20–30 minutes) can improve mental and physical performance, including reaction time, accuracy, and endurance.",
        "detailedDescription": "A systematic review of 22 studies found that short daytime naps significantly enhance both cognitive and physical performance. Naps ranging from 20 to 90 minutes improved reaction time, cognitive processing, accuracy, and even endurance and sprint performance in athletes. Napping also reduced fatigue, likely by counteracting sleep debt. For most people, a 20–30 minute nap is ideal to gain benefits without experiencing grogginess, while longer naps may cause sleep inertia.",
        "microActivity": "Plan a 20–30 minute nap during your next free afternoon or weekend.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/37227190/",
        "difficultyLevel": "Easy",
        "timeToComplete": "20–30 min",
        "tags": [
          "napping",
          "performance",
          "recovery",
          "sleep"
        ],
        "category": "Sleep",
        "subcategory": "Napping"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Consider ubiquinol supplementation for workout recovery",
        "shortDescription": "Supplementing with ubiquinol (the active form of CoQ10) may speed up recovery, reduce inflammation, and improve endurance.",
        "detailedDescription": "Research suggests that ubiquinol supplementation can lower inflammation and oxidative stress in athletes undergoing intense training. It also improves red blood cell count and overall blood health, which supports better oxygen transport and endurance. Ubiquinol is more bioavailable than ubiquinone, meaning the body can use it more efficiently. For those seeking an extra recovery boost, 100–200 mg daily (preferably in the morning) is recommended, with 200 mg being the dose used in the referenced study.",
        "microActivity": "If interested, try adding a daily ubiquinol supplement (100–200 mg) to your morning routine.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/30871053/",
        "difficultyLevel": "Moderate",
        "timeToComplete": "5 min (daily supplement)",
        "tags": [
          "supplement",
          "recovery",
          "inflammation",
          "performance"
        ],
        "category": "Nutrition",
        "subcategory": "Supplements"
      }
    ]
  },
  {
    "episodeNumber": "198",
    "episodeTitle": "Arnold's Pump Club - #198 Inspiration Comes From Where You Least",
    "recommendations": [
      {
        "timestamp": "approximate",
        "recommendation": "Find and join a supportive fitness community",
        "shortDescription": "Surrounding yourself with a positive, encouraging community can help you push past your limits and achieve more than you thought possible.",
        "detailedDescription": "Arnold emphasizes that real progress in fitness often comes from being part of a community where people support, coach, and cheer each other on. The episode highlights stories of everyday people, like April Austin, who achieved personal records and overcame challenges by participating in the Pump Club community and working with coaches. The sense of belonging and encouragement helped them surpass their expectations and stay motivated, especially when progress was slow or difficult. Building or joining a community can provide accountability, inspiration, and practical advice, making your fitness journey more enjoyable and successful.",
        "microActivity": "Reach out to a local gym, online group, or fitness app and introduce yourself to the community.",
        "researchLink": "https://gwrymca.org/join",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "community",
          "motivation",
          "support",
          "fitness"
        ],
        "category": "Fitness",
        "subcategory": "Motivation"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Persist through challenges and setbacks",
        "shortDescription": "Progress in fitness is not always linear; persistence and consistency are key to overcoming obstacles and achieving your goals.",
        "detailedDescription": "Arnold shares the story of April Austin, who struggled with basic lunges but didn't give up. With time, coaching, and community support, she not only improved but eventually deadlifted 290 pounds at age 61. Her journey illustrates that setbacks are normal and improvement takes time. The most important thing is to keep going, even when progress feels slow or difficult. This mindset can help you break through plateaus and reach new personal bests.",
        "microActivity": "Identify one exercise you find challenging and commit to practicing it regularly for the next week.",
        "researchLink": "https://www.apa.org/topics/resilience",
        "difficultyLevel": "Moderate",
        "timeToComplete": "10 min",
        "tags": [
          "resilience",
          "persistence",
          "growth",
          "fitness"
        ],
        "category": "Mental Health",
        "subcategory": "Resilience"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Set progressive, achievable goals",
        "shortDescription": "Setting specific, incremental goals can keep you motivated and focused on continual improvement.",
        "detailedDescription": "April Austin didn’t stop after reaching her deadlift milestone—she immediately set her sights on the next goal (300 pounds). This approach of always having a new, realistic target helps maintain motivation and provides a clear path for progress. Breaking your larger fitness ambitions into smaller, achievable steps makes the journey less overwhelming and more rewarding, as you get to celebrate each success along the way.",
        "microActivity": "Write down your next small fitness goal and share it with a friend or community member.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/39680953/",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "goal-setting",
          "motivation",
          "progress",
          "fitness"
        ],
        "category": "Fitness",
        "subcategory": "Goal Setting"
      }
    ]
  },
  {
    "episodeNumber": "203",
    "episodeTitle": "Arnold's Pump Club - #203 Do Something About It",
    "recommendations": [
      {
        "timestamp": "00:02",
        "recommendation": "Focus on what you can control instead of complaining",
        "shortDescription": "Whenever you feel like complaining, pause and ask yourself what you can do about the situation. Take action, even if it's small, rather than wasting energy on things you can't control.",
        "detailedDescription": "Arnold emphasizes that people often waste time and energy complaining about things outside their control, whether it's politics, the food industry, or society in general. He encourages listeners to shift their mindset: instead of whining, identify actionable steps within your control and do them. This approach leads to a greater sense of optimism and positivity, as taking action—even small steps—feels far better than complaining and leads to real progress.",
        "microActivity": "Next time you catch yourself complaining, immediately identify one small action you can take to improve the situation and do it.",
        "researchLink": "https://www.franklincovey.com/courses/the-7-habits/habit-1/",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "mindset",
          "positivity",
          "action",
          "self-improvement"
        ],
        "category": "Mental Health",
        "subcategory": "Mindset"
      },
      {
        "timestamp": "00:10",
        "recommendation": "Cut off caffeine by early afternoon to protect your sleep",
        "shortDescription": "If you drink coffee, avoid consuming it late in the day to prevent sleep disturbances. Caffeine can stay in your system for about nine hours, so stopping early helps you sleep better.",
        "detailedDescription": "A new study found that while coffee drinkers tend to take more daily steps and experience no harm to heart health, drinking coffee later in the day can reduce sleep by an average of 36 minutes per night. People with genes that metabolize caffeine more slowly are even more affected. To avoid sleep issues, it's best to stop drinking coffee by early afternoon. This allows your body enough time to clear caffeine before bedtime, helping you maintain healthy sleep patterns.",
        "microActivity": "Set a reminder to have your last cup of coffee before 2 p.m.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/36870101/",
        "difficultyLevel": "Easy",
        "timeToComplete": "1 min",
        "tags": [
          "coffee",
          "sleep",
          "caffeine",
          "health"
        ],
        "category": "Sleep",
        "subcategory": "Sleep Hygiene"
      },
      {
        "timestamp": "00:18",
        "recommendation": "Track your small wins daily to boost motivation and performance",
        "shortDescription": "Write down your small achievements each day to increase your awareness of progress and boost motivation. This practice leads to more positive emotions and better performance.",
        "detailedDescription": "Research analyzing over 12,000 daily diary entries from professionals found that the most productive and successful people tracked their small wins each day. This practice enhances your 'inner work life'—a combination of emotions, motivation, and perception—leading to more motivation and better performance. Focusing on progress, rather than perfection, creates a domino effect that builds momentum and keeps you moving forward.",
        "microActivity": "At the end of each day, jot down at least one small win or progress you made.",
        "researchLink": "https://hbr.org/2011/05/the-power-of-small-wins",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "motivation",
          "productivity",
          "journaling",
          "mental health"
        ],
        "category": "Mental Health",
        "subcategory": "Motivation"
      }
    ]
  },
  {
    "episodeNumber": "197",
    "episodeTitle": "Arnold's Pump Club - #197 The Food That Helps Fight Microplastic",
    "recommendations": [
      {
        "timestamp": "00:03:00",
        "recommendation": "Increase daily fiber intake to reduce microplastic absorption",
        "shortDescription": "Consuming at least 30 grams of fiber per day can help your body trap and eliminate microplastics, reducing their absorption and potential harm.",
        "detailedDescription": "Research shows that individuals who eat more fiber have lower levels of microplastics in their bloodstream and tissues. Fiber acts as a natural barrier in the digestive tract, trapping microplastics and helping eliminate them before they enter circulation. The binding properties of fiber found in fruits, vegetables, whole grains, and legumes are particularly effective. Increasing fiber intake not only helps protect against microplastics but also supports gut health and lowers cholesterol.",
        "microActivity": "Add a serving of beans, berries, or oats to your next meal to boost fiber intake today.",
        "researchLink": "https://arnoldspumpclub.com/blogs/newsletter/the-food-that-protects-you-from-microplastics",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "fiber",
          "microplastics",
          "nutrition",
          "gut health"
        ],
        "category": "Nutrition",
        "subcategory": "Dietary Fiber"
      },
      {
        "timestamp": "00:07:00",
        "recommendation": "Aim for 7-9 hours of sleep per night to support muscle growth and recovery",
        "shortDescription": "Getting enough sleep is crucial for muscle protein synthesis, hormone balance, and overall recovery. Sleep deprivation can quickly impair progress.",
        "detailedDescription": "Studies indicate that even a single night of poor sleep can reduce muscle protein synthesis by 18%, decrease testosterone by 24%, and increase cortisol by 21%. These changes hinder muscle repair, growth, and fat loss. Consistent sleep schedules, reducing screen time before bed, and limiting afternoon caffeine can help improve sleep quality. Investing in a quality mattress, such as the Eight Sleep Pod, may further enhance sleep and recovery.",
        "microActivity": "Set a bedtime alarm to remind yourself to wind down 30 minutes before your target sleep time tonight.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/31430291/",
        "difficultyLevel": "Moderate",
        "timeToComplete": "10 min (to set up routines)",
        "tags": [
          "sleep",
          "recovery",
          "muscle growth",
          "hormones"
        ],
        "category": "Sleep",
        "subcategory": "Sleep Hygiene"
      },
      {
        "timestamp": "00:13:00",
        "recommendation": "Stop every set 1-2 reps short of failure for optimal muscle growth",
        "shortDescription": "Training to absolute failure isn't necessary for muscle growth and can lead to more fatigue and longer recovery times. Leaving 1-2 reps in reserve is just as effective and more sustainable.",
        "detailedDescription": "Research comparing training to failure with stopping a few reps short found similar muscle growth in both groups. However, those who trained to failure experienced more muscle fatigue and required longer recovery. By maintaining 1-2 reps in reserve, you can push hard while minimizing unnecessary fatigue and risk of burnout. Occasionally training to failure can help you gauge your limits, but most sets should stop just short of it.",
        "microActivity": "In your next workout, intentionally stop each set when you feel you could do 1-2 more reps with good form.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/19691365/",
        "difficultyLevel": "Moderate",
        "timeToComplete": "5 min (per workout)",
        "tags": [
          "strength training",
          "muscle growth",
          "fatigue",
          "workout"
        ],
        "category": "Fitness",
        "subcategory": "Strength Training"
      }
    ]
  },
  {
    "episodeNumber": "202",
    "episodeTitle": "Arnold's Pump Club - #202 It's Time For An Excuse Audit",
    "recommendations": [
      {
        "timestamp": "00:01:00",
        "recommendation": "Start resistance training at any age",
        "shortDescription": "It's never too late to begin resistance training. Even people in their 90s can gain muscle and strength with just a few weeks of consistent effort.",
        "detailedDescription": "Research shows that muscle and strength loss with age is not inevitable. In a study, regular 90-year-olds in a nursing home gained almost 10% more muscle mass and nearly tripled their strength after eight weeks of resistance training. This reversed a decade of muscle loss in just two months. Resistance training also improves bone health, reduces pain, lowers disease risk, and boosts mental health. The most important step is to stop making excuses and start moving, no matter your age or fitness level.",
        "microActivity": "Do 10 bodyweight squats or push-ups today, wherever you are.",
        "researchLink": "https://www.mayoclinic.org/healthy-lifestyle/tween-and-teen-health/in-depth/strength-training/art-20047758",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "fitness",
          "aging",
          "strength",
          "motivation"
        ],
        "category": "Fitness",
        "subcategory": "Resistance Training"
      },
      {
        "timestamp": "00:07:00",
        "recommendation": "Improve sleep by adjusting lifestyle, gut health, and bedroom temperature",
        "shortDescription": "Better sleep comes from healthy habits, a diverse gut microbiome, and a cool bedroom. These factors can help you fall asleep faster and wake up more refreshed.",
        "detailedDescription": "A large study found that sleep quality is linked to lifestyle choices (like reducing alcohol, stress, and device use), gut health (higher microbial diversity from fiber-rich foods and fermented foods), and bedroom temperature (cooler rooms promote deeper sleep). Poor gut health and warmer bedrooms were associated with more sleep disturbances. Simple changes like eating more fiber, avoiding late-night eating, and lowering your bedroom temperature can make a big difference in sleep quality.",
        "microActivity": "Tonight, set your bedroom temperature to around 65°F (18°C) before bed.",
        "researchLink": "https://www.nimh.nih.gov/health/publications/seasonal-affective-disorder",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "sleep",
          "lifestyle",
          "gut health",
          "environment"
        ],
        "category": "Sleep",
        "subcategory": "Sleep Hygiene"
      },
      {
        "timestamp": "00:13:00",
        "recommendation": "Take a break from mobile internet to boost focus and well-being",
        "shortDescription": "Turning off mobile internet on your phone can improve attention span, reduce stress, and increase life satisfaction.",
        "detailedDescription": "A recent study found that blocking mobile internet access (while keeping calls and texts) for a few weeks led to significant improvements in cognitive performance, mental health, and life satisfaction. Participants reported less stress, anxiety, and depressive symptoms, and spent more time on face-to-face interactions and healthy hobbies. Even a short break from constant connectivity can help your brain feel sharper and calmer.",
        "microActivity": "Turn off mobile data on your phone for the next 2 hours.",
        "researchLink": "https://www.npr.org/2025/02/24/nx-s1-5304417/smartphone-break-digital-detox-screen-addiction",
        "difficultyLevel": "Moderate",
        "timeToComplete": "2 hours",
        "tags": [
          "mental health",
          "focus",
          "digital detox",
          "well-being"
        ],
        "category": "Mental Health",
        "subcategory": "Digital Wellness"
      },
      {
        "timestamp": "00:18:00",
        "recommendation": "Perform acts of kindness to boost happiness and well-being",
        "shortDescription": "Frequent, intentional acts of kindness significantly improve emotional, psychological, and even physical well-being.",
        "detailedDescription": "A meta-analysis of 27 studies found that kindness has a powerful positive effect on well-being, comparable to gratitude or mindfulness. Direct, in-person acts of kindness (like helping a neighbor) are more effective than anonymous or monetary giving. The benefits of kindness compound over time, promoting social connection, purpose, and positive feedback loops that enhance happiness for both the giver and receiver.",
        "microActivity": "Do one kind thing for someone today, like helping a coworker or complimenting a friend.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/29702043/",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min",
        "tags": [
          "kindness",
          "well-being",
          "happiness",
          "social connection"
        ],
        "category": "Mental Health",
        "subcategory": "Positive Psychology"
      }
    ]
  },
  {
    "episodeNumber": "201",
    "episodeTitle": "Arnold's Pump Club - #201 Can Your Sleep Patterns Predict Alzhei",
    "recommendations": [
      {
        "timestamp": "approximate",
        "recommendation": "Create a consistent sleep schedule",
        "shortDescription": "Going to bed and waking up at the same time every day helps regulate your sleep cycles and optimize sleep quality.",
        "detailedDescription": "Research suggests that a regular sleep schedule supports your body's natural circadian rhythms, making it easier to fall asleep, achieve deep sleep, and wake up feeling refreshed. Consistency helps ensure you get enough REM and deep sleep, both of which are linked to better brain health and lower risk of cognitive decline. Irregular sleep patterns can disrupt these cycles, increasing your risk for neurodegenerative diseases like Alzheimer's. Setting a consistent bedtime and wake time—even on weekends—can have a significant long-term impact on your health.",
        "microActivity": "Set an alarm for your bedtime and wake time, and stick to it for the next week.",
        "researchLink": "https://newsinhealth.nih.gov/2021/04/good-sleep-good-health",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min (to set up schedule)",
        "tags": [
          "sleep",
          "brain health",
          "routine"
        ],
        "category": "Sleep",
        "subcategory": "Sleep Hygiene"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Shut off technology an hour before bed",
        "shortDescription": "Turning off screens at least an hour before bedtime can help improve your deep sleep and overall sleep quality.",
        "detailedDescription": "Exposure to blue light from phones, tablets, and computers can suppress melatonin production, making it harder to fall asleep and reducing the amount of deep, restorative sleep you get. By shutting off technology before bed, you allow your body to naturally wind down, making it easier to fall asleep quickly and enter REM and deep sleep stages sooner. This is especially important for brain health, as these sleep stages are crucial for clearing out harmful proteins linked to Alzheimer's.",
        "microActivity": "Set a reminder to turn off all screens one hour before your planned bedtime tonight.",
        "researchLink": "https://www.calm.com/blog/screen-time-before-bed",
        "difficultyLevel": "Easy",
        "timeToComplete": "1 min (to set reminder)",
        "tags": [
          "sleep",
          "technology",
          "melatonin"
        ],
        "category": "Sleep",
        "subcategory": "Sleep Hygiene"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Avoid eating 2–3 hours before bedtime",
        "shortDescription": "Finishing your last meal 2–3 hours before sleep can improve your sleep quality and help you fall asleep faster.",
        "detailedDescription": "Eating late at night can disrupt your sleep by increasing your body's metabolism and core temperature, making it harder to fall asleep and reducing time spent in deep sleep. Studies show that late-night eating is associated with more fragmented sleep and less REM sleep, both of which are linked to higher risk of cognitive decline. Giving your body time to digest before bed can help you enter deep sleep more quickly and improve overall sleep quality.",
        "microActivity": "Plan your dinner so you finish eating at least 2 hours before your bedtime tonight.",
        "researchLink": "https://pubmed.ncbi.nlm.nih.gov/32295235/",
        "difficultyLevel": "Easy",
        "timeToComplete": "5 min (to plan meal timing)",
        "tags": [
          "sleep",
          "nutrition",
          "routine"
        ],
        "category": "Sleep",
        "subcategory": "Sleep Hygiene"
      },
      {
        "timestamp": "approximate",
        "recommendation": "Sleep on a cool mattress to boost REM sleep",
        "shortDescription": "Using a cooling mattress can increase REM sleep by up to 22% during the first half of the night.",
        "detailedDescription": "Research has found that a cooler sleep environment helps you fall asleep faster, stay asleep longer, and spend more time in deep and REM sleep stages. In a study using the Eight Sleep Pod, participants experienced improved sleep quality, cardiovascular recovery, and reported feeling more rested and comfortable. Since REM and deep sleep are crucial for clearing harmful proteins from the brain, optimizing your sleep environment with a cooling mattress can be a powerful tool for long-term brain health.",
        "microActivity": "Lower your bedroom thermostat or use a cooling mattress pad tonight.",
        "researchLink": "https://www.healthline.com/nutrition/17-tips-to-sleep-better",
        "difficultyLevel": "Moderate",
        "timeToComplete": "5 min (to adjust environment)",
        "tags": [
          "sleep",
          "temperature",
          "brain health"
        ],
        "category": "Sleep",
        "subcategory": "Sleep Environment"
      }
    ]
  }
]
```
<!-- END_FILE: podcastrecommendations 2.json -->

### scripts/ci/build-release.sh
- bytes: 265
- lines: 11
- sha256: a69f051e9737687b0d7ec881017daf2a3145e107d5f0b45624f24010295413bd
- trailing_newline: true

<!-- BEGIN_FILE: scripts/ci/build-release.sh -->
```text
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT_DIR"

xcodebuild -scheme Pulsum -configuration Release build \
  CODE_SIGNING_ALLOWED=NO \
  CODE_SIGNING_REQUIRED=NO \
  CODE_SIGN_IDENTITY="" \
  "$@"
```
<!-- END_FILE: scripts/ci/build-release.sh -->

### scripts/ci/check-privacy-manifests.sh
- bytes: 3291
- lines: 97
- sha256: 82a42bed9dbe07dfb414e160182005120a5f0ebba1754ade5a8f11d52eeace1d
- trailing_newline: true

<!-- BEGIN_FILE: scripts/ci/check-privacy-manifests.sh -->
```text
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT_DIR"

RED="\033[31m"
NC="\033[0m"

die() {
  echo -e "${RED}privacy manifest check failed:${NC} $1" >&2
  exit 1
}

MANIFESTS=(
  Pulsum/PrivacyInfo.xcprivacy
  Packages/PulsumAgents/Sources/PulsumAgents/PrivacyInfo.xcprivacy
  Packages/PulsumData/Sources/PulsumData/PrivacyInfo.xcprivacy
  Packages/PulsumServices/Sources/PulsumServices/PrivacyInfo.xcprivacy
  Packages/PulsumML/Sources/PulsumML/PrivacyInfo.xcprivacy
  Packages/PulsumUI/Sources/PulsumUI/PrivacyInfo.xcprivacy
)

for manifest in "${MANIFESTS[@]}"; do
  [[ -f "$manifest" ]] || die "missing privacy manifest: $manifest"
done

python - <<'PY'
import os
import sys
import plistlib

REQUIRED = {
    "Pulsum/PrivacyInfo.xcprivacy": {
        "NSPrivacyAccessedAPICategoryFileTimestamp": {"C617.1"}
    },
    "Packages/PulsumAgents/Sources/PulsumAgents/PrivacyInfo.xcprivacy": {
        "NSPrivacyAccessedAPICategoryFileTimestamp": {"C617.1"}
    },
    "Packages/PulsumData/Sources/PulsumData/PrivacyInfo.xcprivacy": {
        "NSPrivacyAccessedAPICategoryFileTimestamp": {"C617.1"}
    },
    "Packages/PulsumServices/Sources/PulsumServices/PrivacyInfo.xcprivacy": {
        "NSPrivacyAccessedAPICategoryFileTimestamp": {"C617.1"}
    },
    "Packages/PulsumML/Sources/PulsumML/PrivacyInfo.xcprivacy": {
        "NSPrivacyAccessedAPICategoryFileTimestamp": {"C617.1"}
    },
    "Packages/PulsumUI/Sources/PulsumUI/PrivacyInfo.xcprivacy": {
        "NSPrivacyAccessedAPICategoryFileTimestamp": {"C617.1"}
    },
}

errors = []

for path, expectations in REQUIRED.items():
    if not os.path.exists(path):
        errors.append(f"missing manifest: {path}")
        continue
    with open(path, "rb") as handle:
        data = plistlib.load(handle)
    types = data.get("NSPrivacyAccessedAPITypes", [])
    entries = {
        entry.get("NSPrivacyAccessedAPIType"): set(entry.get("NSPrivacyAccessedAPITypeReasons", []))
        for entry in types
    }
    for api_type, expected in expectations.items():
        have = entries.get(api_type, set())
        if not expected.issubset(have):
            missing = ", ".join(sorted(expected - have))
            errors.append(f"{path}: {api_type} missing reasons: {missing}")

if errors:
    print("\n".join(errors))
    sys.exit(1)

print("privacy manifests: ✅ basic checks passed")
PY

RESOURCE_COUNT=$(rg --no-heading -n "PrivacyInfo\\.xcprivacy in Resources" Pulsum.xcodeproj/project.pbxproj | grep -v "PBXBuildFile" | wc -l | tr -d '[:space:]')
if [[ "${RESOURCE_COUNT:-0}" -ne 1 ]]; then
  die "expected exactly one 'PrivacyInfo.xcprivacy in Resources' entry in Pulsum target (found ${RESOURCE_COUNT:-0})"
fi

if [[ "${RUN_PRIVACY_REPORT:-0}" != "0" ]]; then
  if ! xcrun -f privacyreport >/dev/null 2>&1; then
    die "RUN_PRIVACY_REPORT is set but 'privacyreport' tool is unavailable"
  fi
  REPORT_DIR="${TMPDIR:-/tmp}/pulsum-privacy-report"
  rm -rf "$REPORT_DIR"
  mkdir -p "$REPORT_DIR"
  echo "[privacy-check] running xcrun privacyreport..."
  xcrun privacyreport generate --project Pulsum.xcodeproj --scheme Pulsum --output "$REPORT_DIR" >/dev/null
  echo "[privacy-check] report saved to $REPORT_DIR"
fi

echo "[privacy-check] ✅ manifests validated"
```
<!-- END_FILE: scripts/ci/check-privacy-manifests.sh -->

### scripts/ci/integrity.sh
- bytes: 8127
- lines: 228
- sha256: 0d7d2a6a62ba7e06ccec5e46b7e73c2d3e33ea125377718577367ea0127fe7c3
- trailing_newline: true

<!-- BEGIN_FILE: scripts/ci/integrity.sh -->
```text
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT_DIR"

pass() { printf "\033[32m%s\033[0m\n" "$1"; }
fail() { printf "\033[31m%s\033[0m\n" "$1"; exit 1; }
info() { printf "\033[36m%s\033[0m\n" "$1"; }

select_simulator_destination() {
  local desired_os="${PULSUM_SIM_OS:-26.0.1}"
  if ! command -v xcrun >/dev/null || ! command -v python3 >/dev/null; then
    printf "platform=iOS Simulator,name=iPhone SE (3rd generation),OS=%s" "$desired_os"
    return
  fi

  python3 - <<'PY'
import json, os, re, subprocess, sys
preferred = [
    "iPhone 16 Pro",
    "iPhone 16",
    "iPhone 16 Plus",
    "iPhone 15 Pro",
    "iPhone 15",
    "iPhone SE (3rd generation)"
]
desired = os.environ.get("PULSUM_SIM_OS", "26.0.1")
major = desired.split(".", 1)[0]
try:
    raw = subprocess.check_output(
        ["xcrun", "simctl", "list", "-j", "devices", "available"],
        text=True
    )
    data = json.loads(raw)
except (subprocess.CalledProcessError, json.JSONDecodeError):
    data = {}

entries = []
for runtime, devices in (data.get("devices") or {}).items():
    match = re.search(r"iOS[-\.](\d+)-(\d+)(?:-(\d+))?", runtime or "")
    if not match:
        continue
    parts = [match.group(1), match.group(2)]
    if match.group(3):
        parts.append(match.group(3))
    version = ".".join(parts)
    for device in devices or []:
        if device.get("isAvailable") and device.get("udid"):
            entries.append((device.get("name") or "", version, device["udid"]))

def pick_by_name(prefix):
    for name in preferred:
        for entry in entries:
            if entry[0] == name and entry[1].startswith(prefix):
                return entry
    return None

def pick_by_prefix(prefix):
    for entry in entries:
        if entry[1].startswith(prefix):
            return entry
    return None

selection = None
for prefix in (desired, major, "26", "18"):
    selection = pick_by_name(prefix) or pick_by_prefix(prefix)
    if selection:
        break

if not selection and entries:
    selection = entries[0]

if not selection:
    print(f"platform=iOS Simulator,name=iPhone SE (3rd generation),OS={desired}")
    sys.exit()

name, version, udid = selection
if udid:
    print(f"id={udid}")
else:
    print(f"platform=iOS Simulator,name={name},OS={version}")
PY
}

info "Pulsum integrity sweep"

info "Git sync"
git fetch origin >/dev/null 2>&1 || true
LOCAL_HEAD="$(git rev-parse HEAD)"
REMOTE_HEAD="$(git rev-parse origin/main)"
[ "$LOCAL_HEAD" = "$REMOTE_HEAD" ] || fail "local HEAD != origin/main"
pass "local HEAD matches origin/main"

info "Tag position (gate0-done-2025-11-09)"
if git rev-parse -q --verify refs/tags/gate0-done-2025-11-09 >/dev/null; then
  TAG_HEAD="$(git rev-parse gate0-done-2025-11-09^{})"
  [ "$TAG_HEAD" = "$LOCAL_HEAD" ] || fail "tag gate0-done-2025-11-09 != HEAD"
  pass "tag gate0-done-2025-11-09 points at HEAD"
else
  info "tag gate0-done-2025-11-09 not found (ok if not tagged)"
fi

info "Git integrity"
git fsck --no-reflogs >/dev/null 2>&1 || fail "git fsck failed"
if [ "${CI_ALLOW_DIRTY:-0}" = "1" ]; then
  info "CI_ALLOW_DIRTY=1 → skipping clean working tree enforcement"
else
  DIRTY_COUNT="$(git status --porcelain=v1 | wc -l | tr -d ' ')"
  [ "$DIRTY_COUNT" -eq 0 ] || fail "working tree has uncommitted changes"
  pass "working tree clean"
fi

info "Ignore hygiene"
TRACKED_BUILD="$(git ls-files Build | wc -l | tr -d ' ')"
[ "$TRACKED_BUILD" -eq 0 ] || fail "tracked files exist under Build/"
pass "no tracked files under Build/"

info "Project backup audit"
BACKUPS="$(git ls-files '*.pbxproj.backup' 2>/dev/null || true)"
if [ -n "$BACKUPS" ]; then
  printf '%s\n' "$BACKUPS"
  fail "found tracked *.pbxproj.backup files"
fi
pass "no *.pbxproj.backup files tracked"

info "PBX manifest uniqueness"
PBX_COUNTS="$(python3 - <<'PY'
import re
from pathlib import Path
text = Path("Pulsum.xcodeproj/project.pbxproj").read_text()
fr = len(re.findall(r'PBXFileReference[^\n]*PrivacyInfo\.xcprivacy', text))
br = len(re.findall(r'PBXBuildFile[^\n]*PrivacyInfo\.xcprivacy', text))
print(fr, br)
PY
)"
FR="${PBX_COUNTS% *}"
BR="${PBX_COUNTS#* }"
[ "$FR" -eq 1 ] && [ "$BR" -eq 1 ] || fail "expected FR=1 BR=1 for PrivacyInfo.xcprivacy, got FR=$FR BR=$BR"
pass "PrivacyInfo.xcprivacy counts FR=1 BR=1"

info "Dataset canonicality"
python3 - <<'PY' || fail "dataset hash check failed"
import hashlib, json, subprocess, sys
try:
    raw = subprocess.check_output([
        "git", "ls-files", "-z",
        "podcastrecommendations*.json", "json database/podcastrecommendations*.json"
    ], text=True)
except subprocess.CalledProcessError:
    raw = ""
paths = [p for p in raw.split("\x00") if p]
if not paths:
    print("no podcast dataset JSON found")
    sys.exit(1)
hashes = {}
for path in paths:
    with open(path, "rb") as fh:
        digest = hashlib.sha256(fh.read()).hexdigest()
    hashes.setdefault(digest, []).append(path)
print("dataset_hashes:", json.dumps(hashes, indent=2))
if len(hashes) != 1:
    print(f"expected single canonical dataset hash, found {len(hashes)}")
    sys.exit(1)
PY
pass "podcast dataset hash unique"

info "Secret scan (repo)"
if [ -x scripts/ci/scan-secrets.sh ]; then
  scripts/ci/scan-secrets.sh >/tmp/pulsum_secret_repo.log 2>&1 || { cat /tmp/pulsum_secret_repo.log; fail "secret scan (repo) failed"; }
  pass "secret scan (repo) passed"
else
  info "scripts/ci/scan-secrets.sh not found; skipped"
fi

info "Placeholder audit"
if [ -x scripts/ci/scan-placeholders.sh ]; then
  scripts/ci/scan-placeholders.sh >/tmp/pulsum_placeholder_scan.log 2>&1 || { cat /tmp/pulsum_placeholder_scan.log; fail "placeholder scan failed"; }
  pass "no forbidden placeholders"
else
  info "scripts/ci/scan-placeholders.sh not found; skipped"
fi

info "Privacy manifests"
if [ -x scripts/ci/check-privacy-manifests.sh ]; then
  scripts/ci/check-privacy-manifests.sh >/tmp/pulsum_privacy.log 2>&1 || { cat /tmp/pulsum_privacy.log; fail "privacy manifest check failed"; }
  pass "privacy manifests ok"
else
  info "scripts/ci/check-privacy-manifests.sh not found; skipped"
fi

info "Gate test harness"
if [ -x scripts/ci/test-harness.sh ]; then
  scripts/ci/test-harness.sh >/tmp/pulsum_gate_harness.log 2>&1 || { tail -n +1 /tmp/pulsum_gate_harness.log; fail "gate test harness failed"; }
  pass "dynamic gate suites executed"
else
  info "scripts/ci/test-harness.sh not found; skipped"
fi

info "Release build (signing disabled)"
DESTINATION="$(select_simulator_destination)"
info "Using simulator destination: $DESTINATION"
scripts/ci/build-release.sh -destination "$DESTINATION" -derivedDataPath Build >/tmp/pulsum_xcbuild.log 2>&1 || \
fail "xcodebuild Release failed; see /tmp/pulsum_xcbuild.log"
pass "Release build ok"

info "Gate-0 tests"
SVC_OK=0; DATA_OK=0; ML_OK=0
swift test --package-path Packages/PulsumServices -Xswiftc -strict-concurrency=complete --filter Gate0_  >/tmp/pulsum_services_tests.log 2>&1 && SVC_OK=1 || true
swift test --package-path Packages/PulsumData     -Xswiftc -strict-concurrency=complete --filter Gate0_  >/tmp/pulsum_data_tests.log     2>&1 && DATA_OK=1 || true
swift test --package-path Packages/PulsumML       -Xswiftc -strict-concurrency=complete --filter Gate0_  >/tmp/pulsum_ml_tests.log       2>&1 && ML_OK=1 || true
[ "$SVC_OK"  -eq 1 ] || { tail -n +1 /tmp/pulsum_services_tests.log; fail "PulsumServices Gate0_ tests failed"; }
[ "$DATA_OK" -eq 1 ] || { tail -n +1 /tmp/pulsum_data_tests.log;     fail "PulsumData Gate0_ tests failed"; }
[ "$ML_OK"   -eq 1 ] || { tail -n +1 /tmp/pulsum_ml_tests.log;       fail "PulsumML Gate0_ tests failed"; }
pass "Gate-0 tests ok"

info "Bundle secret rescan"
if [ -x scripts/ci/scan-secrets.sh ]; then
  APP_PATH="Build/Build/Products/Release-iphonesimulator/Pulsum.app"
  if [ -d "$APP_PATH" ]; then
    scripts/ci/scan-secrets.sh "$APP_PATH" >/tmp/pulsum_secret_bundle.log 2>&1 || { cat /tmp/pulsum_secret_bundle.log; fail "secret scan (bundle) failed"; }
    pass "secret scan (bundle) passed"
  else
    info "no built app bundle found; skipped bundle scan"
  fi
fi

pass "Integrity sweep completed"
```
<!-- END_FILE: scripts/ci/integrity.sh -->

### scripts/ci/scan-placeholders.sh
- bytes: 632
- lines: 26
- sha256: 3700f37820676a538f1b739cd1c4fea5dcfd5e8ca8d5ca8fc34b68e391bd0878
- trailing_newline: true

<!-- BEGIN_FILE: scripts/ci/scan-placeholders.sh -->
```text
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT_DIR"

RED="\033[31m"
NC="\033[0m"

die() {
  echo -e "${RED}placeholder scan failed:${NC} $1" >&2
  exit 1
}

PATTERN='(?i)\b(TODO|TBD|FIXME|lorem ipsum|placeholder|dummy)\b'

if rg --no-heading --line-number --color never --pcre2 "$PATTERN" \
  Pulsum Packages \
  --glob '!**/Tests/**' \
  --glob '!Docs/**' \
  --glob '!**/*.md' \
  --glob '!**/*.txt'; then
  die "remove the placeholder terms listed above (tests/docs are excluded automatically)"
fi

echo "[placeholder-scan] ✅ no forbidden placeholders detected"
```
<!-- END_FILE: scripts/ci/scan-placeholders.sh -->

### scripts/ci/scan-secrets.sh
- bytes: 1961
- lines: 66
- sha256: 005cacaeca4d20369d9ec637651fbe0a6c2d327f7ea0891a32fc78cc72b10438
- trailing_newline: true

<!-- BEGIN_FILE: scripts/ci/scan-secrets.sh -->
```text
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT_DIR"

RED="\033[31m"
NC="\033[0m"

die() {
  echo -e "${RED}secret scan failed:${NC} $1" >&2
  exit 1
}

echo "[secret-scan] scanning repository for leaked keys..."
SEARCH_PATHS=(Pulsum Packages Config.xcconfig Pulsum.xcodeproj)
REGEX_PATTERNS=(
  'sk-[A-Za-z0-9_-]{10,}'
  'sk-proj-[A-Za-z0-9_-]{5,}'
  'OPENAI_API_KEY\s*='
  'PULSUM_COACH_API_KEY\s*='
  'INFOPLIST_KEY_OPENAI_API_KEY'
)

for pattern in "${REGEX_PATTERNS[@]}"; do
  if rg --no-heading --line-number --color never --text --pcre2 -e "$pattern" "${SEARCH_PATHS[@]}" >/tmp/pulsum-secret-scan.log; then
    cat /tmp/pulsum-secret-scan.log >&2
    rm -f /tmp/pulsum-secret-scan.log
    die "pattern '${pattern}' detected in source tree"
  fi
  rm -f /tmp/pulsum-secret-scan.log
done

APP_INPUT="${1:-${PULSUM_APP_PATH:-}}"
TMPDIR_PATH=""
if [[ -n "$APP_INPUT" ]]; then
  if [[ -f "$APP_INPUT" && "$APP_INPUT" == *.ipa ]]; then
    TMPDIR_PATH="$(mktemp -d)"
    unzip -qq "$APP_INPUT" -d "$TMPDIR_PATH"
    APP_PATH="$(find "$TMPDIR_PATH" -name "*.app" -type d | head -n 1)"
  else
    APP_PATH="$APP_INPUT"
  fi

  if [[ ! -d "$APP_PATH" ]]; then
    die "provided app bundle '$APP_INPUT' does not exist"
  fi

  echo "[secret-scan] scanning app bundle: $APP_PATH"
  if rg --no-heading --line-number --color never --text --pcre2 \
    -e 'sk-[A-Za-z0-9_-]{10,}' \
    -e 'sk-proj-[A-Za-z0-9_-]{5,}' \
    -e 'OPENAI_API_KEY\s*=' \
    -e 'PULSUM_COACH_API_KEY\s*=' \
    -e 'INFOPLIST_KEY_OPENAI_API_KEY' \
    "$APP_PATH" >/tmp/pulsum-secret-scan.log; then
    cat /tmp/pulsum-secret-scan.log >&2
    rm -f /tmp/pulsum-secret-scan.log
    [[ -n "$TMPDIR_PATH" ]] && rm -rf "$TMPDIR_PATH"
    die "credential pattern detected inside app bundle"
  fi
  rm -f /tmp/pulsum-secret-scan.log
  [[ -n "$TMPDIR_PATH" ]] && rm -rf "$TMPDIR_PATH"
fi

echo "[secret-scan] ✅ no secrets detected"
```
<!-- END_FILE: scripts/ci/scan-secrets.sh -->

### scripts/ci/test-harness.sh
- bytes: 8145
- lines: 267
- sha256: e241348885e08db38cfdce9943c239bab9656d91cf47b57545a198b31445ec36
- trailing_newline: true

<!-- BEGIN_FILE: scripts/ci/test-harness.sh -->
```text
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT_DIR"

export COPYFILE_DISABLE=1

LOG_DIR="${TMPDIR:-/tmp}"
info() { printf '\033[36m%s\033[0m\n' "$1"; }
pass() { printf '\033[32m%s\033[0m\n' "$1"; }
fail() { printf '\033[31m%s\033[0m\n' "$1"; exit 1; }

select_simulator() {
  local desired_os="${PULSUM_SIM_OS:-26.0.1}"
  if ! command -v xcrun >/dev/null || ! command -v python3 >/dev/null; then
    printf "iPhone SE (3rd generation)\n%s\nplatform=iOS Simulator,name=iPhone SE (3rd generation),OS=%s\n" "$desired_os" "$desired_os"
    return
  fi

  local selection
  selection="$(python3 - <<'PY'
import json, os, re, subprocess, sys
preferred = [
    "iPhone SE (3rd generation)",
    "iPhone 16 Pro",
    "iPhone 16",
    "iPhone 16 Plus",
    "iPhone 15 Pro",
    "iPhone 15"
]
desired = os.environ.get("PULSUM_SIM_OS", "26.0.1")
major = desired.split(".")[0]
try:
    raw = subprocess.check_output(
        ["xcrun", "simctl", "list", "-j", "devices", "available"],
        text=True
    )
    data = json.loads(raw)
except (subprocess.CalledProcessError, json.JSONDecodeError):
    data = {}

entries = []
for runtime, devices in (data.get("devices") or {}).items():
    match = re.search(r"iOS[-\.](\d+)-(\d+)(?:-(\d+))?", runtime)
    if not match:
        continue
    parts = [match.group(1), match.group(2)]
    if match.group(3):
        parts.append(match.group(3))
    os_version = ".".join(parts)
    for device in devices or []:
        if device.get("isAvailable") and device.get("udid"):
            entries.append((device["name"], os_version, device["udid"]))

def pick(names, prefix=None):
    for name in names:
        for entry in entries:
            if entry[0] == name and (prefix is None or entry[1].startswith(prefix)):
                return entry
    return None

def pick_any(prefix):
    for entry in entries:
        if entry[1].startswith(prefix):
            return entry
    return None

selection = pick(preferred, prefix=desired)
if selection is None:
    selection = pick(preferred, prefix=major)
if selection is None:
    selection = pick_any(desired)
if selection is None:
    selection = pick_any(major)
if selection is None:
    selection = pick_any("26")
if selection is None:
    selection = pick_any("18")
if selection is None:
    selection = pick(preferred)
if selection is None and entries:
    selection = entries[0]

if selection:
    print(selection[0] or "")
    print(selection[1] or "")
    print(selection[2] or "")
PY)"

  local name os udid destination
  name="$(printf '%s' "$selection" | sed -n '1p')"
  os="$(printf '%s' "$selection" | sed -n '2p')"
  udid="$(printf '%s' "$selection" | sed -n '3p')"

  if [ -z "$name" ]; then
    name="iPhone SE (3rd generation)"
  fi
  if [ -z "$os" ]; then
    os="$desired_os"
  fi

  if [ -n "$udid" ]; then
    destination="id=$udid"
  else
    destination="platform=iOS Simulator,name=$name,OS=$os"
  fi

  printf "%s\n%s\n%s\n" "$name" "$os" "$destination"
}

check_podcast_dataset_uniqueness() {
  info "[gate-ci] Checking podcast dataset uniqueness"
  python3 - <<'PY' || fail "[gate-ci] Dataset hash check failed"
import hashlib, json, subprocess, sys
try:
    raw = subprocess.check_output([
        "git", "ls-files", "-z",
        "podcastrecommendations*.json", "json database/podcastrecommendations*.json"
    ], text=True)
except subprocess.CalledProcessError:
    raw = ""
paths = [p for p in raw.split("\x00") if p]
if not paths:
    print("[gate-ci] No podcast dataset JSON found")
    sys.exit(1)
hashes = {}
for path in paths:
    with open(path, "rb") as fh:
        digest = hashlib.sha256(fh.read()).hexdigest()
    hashes.setdefault(digest, []).append(path)
print("[gate-ci] dataset hashes:", json.dumps(hashes, indent=2))
if len(hashes) != 1:
    print(f"[gate-ci] Expected single canonical dataset hash, found {len(hashes)}")
    sys.exit(1)
PY
  pass "[gate-ci] dataset hash unique"
}

build_app_target() {
  if ! command -v xcodebuild >/dev/null; then
    info "[gate-ci] xcodebuild not available; skipping Pulsum app build"
    return
  fi

  local sim
  sim="$(select_simulator)"
  local sim_name sim_os destination
  sim_name="$(printf '%s' "$sim" | sed -n '1p')"
  sim_os="$(printf '%s' "$sim" | sed -n '2p')"
  destination="$(printf '%s' "$sim" | sed -n '3p')"

  info "[gate-ci] Building Pulsum app target (Debug) on ${sim_name} (${sim_os})"
  local build_cmd=(xcodebuild -scheme Pulsum -configuration Debug -destination "$destination" build)
  local log_file="$LOG_DIR/pulsum_app_build.log"
  if command -v xcpretty >/dev/null; then
    if ! "${build_cmd[@]}" | tee "$log_file" | xcpretty; then
      tail -n 50 "$log_file" || true
      fail "[gate-ci] Pulsum app build failed (see $log_file)"
    fi
  else
    if ! "${build_cmd[@]}" >"$log_file" 2>&1; then
      tail -n 50 "$log_file" || true
      fail "[gate-ci] Pulsum app build failed (see $log_file)"
    fi
  fi
  pass "[gate-ci] Pulsum app target built successfully"
}

discover_and_run_spm_gate_tests() {
  local package_dir="$1"
  local package_name
  package_name="$(basename "$package_dir")"
  local list_output

  if [ ! -d "$package_dir" ]; then
    info "[gate-ci] $package_dir not found; skipping"
    return
  fi

  info "[gate-ci] Enumerating Gate suites in $package_name"
  if ! list_output="$(cd "$package_dir" && swift test --list-tests -Xswiftc -strict-concurrency=complete 2>/dev/null)"; then
    fail "[gate-ci] swift test --list-tests failed for $package_name"
  fi

  local patterns
  patterns="$(printf "%s\n" "$list_output" | sed -En 's/.*(Gate[0-9]+_).*/\1/p' | sort -u)"
  if [ -z "$patterns" ]; then
    info "[gate-ci] No Gate suites found in $package_name — skipping"
    return
  fi

  local joined
  joined="$(printf "%s" "$patterns" | paste -sd'|' -)"
  local log_suffix
  log_suffix="$(printf "%s" "$package_name" | tr '[:upper:]' '[:lower:]')"
  local log_file="$LOG_DIR/pulsum_${log_suffix}_gate.log"

  info "[gate-ci] Building $package_name with strict concurrency"
  if ! (cd "$package_dir" && swift build -Xswiftc -strict-concurrency=complete) >"$log_file" 2>&1; then
    tail -n 50 "$log_file" || true
    fail "[gate-ci] swift build failed for $package_name (see $log_file)"
  fi

  info "[gate-ci] Running $package_name tests matching (${joined})"
  if (cd "$package_dir" && swift test -Xswiftc -strict-concurrency=complete --parallel --filter "(${joined})") >"$log_file" 2>&1; then
    pass "[gate-ci] $package_name Gate suites passed"
  else
    tail -n 50 "$log_file" || true
    fail "[gate-ci] $package_name Gate suites failed (see $log_file)"
  fi
}

run_xcode_ui_gate_tests() {
  local log_file="$LOG_DIR/pulsum_ui_gate.log"

  if [ "${SKIP_UI_GATES:-0}" = "1" ]; then
    info "[gate-ci] SKIP_UI_GATES=1 → skipping UI Gate tests"
    return
  fi

  if ! command -v xcodebuild >/dev/null; then
    info "[gate-ci] xcodebuild not available; skipping UI Gate tests"
    return
  fi

  if ! command -v xcrun >/dev/null; then
    info "[gate-ci] xcrun not available; skipping UI Gate tests"
    return
  fi

  local sim
  sim="$(select_simulator)"
  local dest_name dest_os destination
  dest_name="$(printf '%s' "$sim" | sed -n '1p')"
  dest_os="$(printf '%s' "$sim" | sed -n '2p')"
  destination="$(printf '%s' "$sim" | sed -n '3p')"

  info "[gate-ci] Running UI Gate tests on ${dest_name} (${dest_os})"
  if UITEST_FAKE_SPEECH=1 UITEST_AUTOGRANT=1 \
     xcodebuild -scheme Pulsum -destination "$destination" \
     -parallel-testing-enabled NO -maximum-concurrent-test-simulator-destinations 1 \
     -only-testing:PulsumUITests clean test >"$log_file" 2>&1; then
    pass "[gate-ci] UI Gate tests passed"
  else
    tail -n 100 "$log_file" || true
    fail "[gate-ci] UI Gate tests failed (see $log_file)"
  fi
}

PACKAGES=(
  "Packages/PulsumServices"
  "Packages/PulsumAgents"
  "Packages/PulsumML"
  "Packages/PulsumData"
)

check_podcast_dataset_uniqueness
build_app_target

for package in "${PACKAGES[@]}"; do
  discover_and_run_spm_gate_tests "$package"
done

run_xcode_ui_gate_tests

pass "[harness] ✅ Gate suites completed"
```
<!-- END_FILE: scripts/ci/test-harness.sh -->

### scripts/ci/ui-tests.sh
- bytes: 1376
- lines: 31
- sha256: 417d056df482def5926598771e81935aa4ea1c182330cc84ee7a42bb81117ae8
- trailing_newline: true

<!-- BEGIN_FILE: scripts/ci/ui-tests.sh -->
```text
#!/usr/bin/env bash
set -euo pipefail

SCHEME=${SCHEME:-Pulsum}
CONFIG=${CONFIG:-Debug}
DERIVED=${DERIVED:-Build}
DEVICE_NAME=${DEVICE_NAME:-"iPhone 17 Pro"}
OS_SPEC=${OS_SPEC:-26.1}

xc(){ if command -v xcbeautify >/dev/null 2>&1; then xcodebuild "$@" | xcbeautify; else xcodebuild "$@"; fi; }

SIM_UDID="$(xcrun simctl list devices | awk -v n="$DEVICE_NAME" -v os="$OS_SPEC" '$0 ~ n && $0 ~ os {print $2}' | tr -d "()" | head -n1 || true)"
if [[ -n "${SIM_UDID:-}" ]]; then
  DEST="id=$SIM_UDID"
  xcrun simctl bootstatus "$SIM_UDID" -b || xcrun simctl boot "$SIM_UDID" || true
else
  DEST="platform=iOS Simulator,name=${DEVICE_NAME},OS=${OS_SPEC}"
  xcrun simctl boot "$DEVICE_NAME" >/dev/null 2>&1 || true
  xcrun simctl bootstatus "$DEVICE_NAME" -b || true
fi

rm -rf "$DERIVED" && mkdir -p "$DERIVED"

TEST_CONCURRENCY_FLAGS=(-parallel-testing-enabled NO -maximum-concurrent-test-simulator-destinations 1)

xc -scheme "$SCHEME" -configuration "$CONFIG" -destination "$DEST" -destination-timeout 180 -derivedDataPath "$DERIVED" \
   CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO build-for-testing

UITEST_USE_STUB_LLM=1 UITEST_FAKE_SPEECH=1 UITEST_AUTOGRANT=1 \
xc -scheme "$SCHEME" -configuration "$CONFIG" -destination "$DEST" -destination-timeout 180 -derivedDataPath "$DERIVED" \
   "${TEST_CONCURRENCY_FLAGS[@]}" -only-testing:PulsumUITests test-without-building
```
<!-- END_FILE: scripts/ci/ui-tests.sh -->

## Verification
- Text blocks verified: 196
- Result: PASS
